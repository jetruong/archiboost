    1: from __future__ import annotations
       
    1: from collections.abc import Iterator, Mapping
    1: from typing import TYPE_CHECKING, Any, Callable, Generic, Literal, TypeVar, Union
       
    1: from pydantic_core import CoreSchema, SchemaSerializer, SchemaValidator
       
    1: from ..errors import PydanticErrorCodes, PydanticUserError
    1: from ..plugin._schema_validator import PluggableSchemaValidator
       
    1: if TYPE_CHECKING:
>>>>>>     from ..dataclasses import PydanticDataclass
>>>>>>     from ..main import BaseModel
>>>>>>     from ..type_adapter import TypeAdapter
       
       
    1: ValSer = TypeVar('ValSer', bound=Union[SchemaValidator, PluggableSchemaValidator, SchemaSerializer])
    1: T = TypeVar('T')
       
       
    2: class MockCoreSchema(Mapping[str, Any]):
    1:     """Mocker for `pydantic_core.CoreSchema` which optionally attempts to
           rebuild the thing it's mocking when one of its methods is accessed and raises an error if that fails.
           """
       
    1:     __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'
       
    5:     def __init__(
               self,
    1:         error_message: str,
               *,
    1:         code: PydanticErrorCodes,
    2:         attempt_rebuild: Callable[[], CoreSchema | None] | None = None,
    1:     ) -> None:
    7:         self._error_message = error_message
    7:         self._code: PydanticErrorCodes = code
    7:         self._attempt_rebuild = attempt_rebuild
    7:         self._built_memo: CoreSchema | None = None
       
    1:     def __getitem__(self, key: str) -> Any:
>>>>>>         return self._get_built().__getitem__(key)
       
    1:     def __len__(self) -> int:
>>>>>>         return self._get_built().__len__()
       
    1:     def __iter__(self) -> Iterator[str]:
>>>>>>         return self._get_built().__iter__()
       
    1:     def _get_built(self) -> CoreSchema:
>>>>>>         if self._built_memo is not None:
>>>>>>             return self._built_memo
       
>>>>>>         if self._attempt_rebuild:
>>>>>>             schema = self._attempt_rebuild()
>>>>>>             if schema is not None:
>>>>>>                 self._built_memo = schema
>>>>>>                 return schema
>>>>>>         raise PydanticUserError(self._error_message, code=self._code)
       
    1:     def rebuild(self) -> CoreSchema | None:
>>>>>>         self._built_memo = None
>>>>>>         if self._attempt_rebuild:
>>>>>>             schema = self._attempt_rebuild()
>>>>>>             if schema is not None:
>>>>>>                 return schema
                   else:
>>>>>>                 raise PydanticUserError(self._error_message, code=self._code)
>>>>>>         return None
       
       
    2: class MockValSer(Generic[ValSer]):
    1:     """Mocker for `pydantic_core.SchemaValidator` or `pydantic_core.SchemaSerializer` which optionally attempts to
           rebuild the thing it's mocking when one of its methods is accessed and raises an error if that fails.
           """
       
    1:     __slots__ = '_error_message', '_code', '_val_or_ser', '_attempt_rebuild'
       
    6:     def __init__(
               self,
    1:         error_message: str,
               *,
    1:         code: PydanticErrorCodes,
    1:         val_or_ser: Literal['validator', 'serializer'],
    2:         attempt_rebuild: Callable[[], ValSer | None] | None = None,
    1:     ) -> None:
   14:         self._error_message = error_message
   14:         self._val_or_ser = SchemaValidator if val_or_ser == 'validator' else SchemaSerializer
   14:         self._code: PydanticErrorCodes = code
   14:         self._attempt_rebuild = attempt_rebuild
       
    1:     def __getattr__(self, item: str) -> None:
    2:         __tracebackhide__ = True
    2:         if self._attempt_rebuild:
>>>>>>             val_ser = self._attempt_rebuild()
>>>>>>             if val_ser is not None:
>>>>>>                 return getattr(val_ser, item)
       
               # raise an AttributeError if `item` doesn't exist
    2:         getattr(self._val_or_ser, item)
>>>>>>         raise PydanticUserError(self._error_message, code=self._code)
       
    1:     def rebuild(self) -> ValSer | None:
>>>>>>         if self._attempt_rebuild:
>>>>>>             val_ser = self._attempt_rebuild()
>>>>>>             if val_ser is not None:
>>>>>>                 return val_ser
                   else:
>>>>>>                 raise PydanticUserError(self._error_message, code=self._code)
>>>>>>         return None
       
       
    1: def set_type_adapter_mocks(adapter: TypeAdapter) -> None:
           """Set `core_schema`, `validator` and `serializer` to mock core types on a type adapter instance.
       
           Args:
               adapter: The type adapter instance to set the mocks on
           """
>>>>>>     type_repr = str(adapter._type)
>>>>>>     undefined_type_error_message = (
>>>>>>         f'`TypeAdapter[{type_repr}]` is not fully defined; you should define `{type_repr}` and all referenced types,'
               f' then call `.rebuild()` on the instance.'
           )
       
>>>>>>     def attempt_rebuild_fn(attr_fn: Callable[[TypeAdapter], T]) -> Callable[[], T | None]:
>>>>>>         def handler() -> T | None:
>>>>>>             if adapter.rebuild(raise_errors=False, _parent_namespace_depth=5) is not False:
>>>>>>                 return attr_fn(adapter)
>>>>>>             return None
       
>>>>>>         return handler
       
>>>>>>     adapter.core_schema = MockCoreSchema(  # pyright: ignore[reportAttributeAccessIssue]
>>>>>>         undefined_type_error_message,
>>>>>>         code='class-not-fully-defined',
>>>>>>         attempt_rebuild=attempt_rebuild_fn(lambda ta: ta.core_schema),
           )
>>>>>>     adapter.validator = MockValSer(  # pyright: ignore[reportAttributeAccessIssue]
>>>>>>         undefined_type_error_message,
>>>>>>         code='class-not-fully-defined',
>>>>>>         val_or_ser='validator',
>>>>>>         attempt_rebuild=attempt_rebuild_fn(lambda ta: ta.validator),
           )
>>>>>>     adapter.serializer = MockValSer(  # pyright: ignore[reportAttributeAccessIssue]
>>>>>>         undefined_type_error_message,
>>>>>>         code='class-not-fully-defined',
>>>>>>         val_or_ser='serializer',
>>>>>>         attempt_rebuild=attempt_rebuild_fn(lambda ta: ta.serializer),
           )
       
       
    1: def set_model_mocks(cls: type[BaseModel], undefined_name: str = 'all referenced types') -> None:
           """Set `__pydantic_core_schema__`, `__pydantic_validator__` and `__pydantic_serializer__` to mock core types on a model.
       
           Args:
               cls: The model class to set the mocks on
               undefined_name: Name of the undefined thing, used in error messages
           """
    6:     undefined_type_error_message = (
   12:         f'`{cls.__name__}` is not fully defined; you should define {undefined_name},'
    6:         f' then call `{cls.__name__}.model_rebuild()`.'
           )
       
    6:     def attempt_rebuild_fn(attr_fn: Callable[[type[BaseModel]], T]) -> Callable[[], T | None]:
   18:         def handler() -> T | None:
>>>>>>             if cls.model_rebuild(raise_errors=False, _parent_namespace_depth=5) is not False:
>>>>>>                 return attr_fn(cls)
>>>>>>             return None
       
   18:         return handler
       
   12:     cls.__pydantic_core_schema__ = MockCoreSchema(  # pyright: ignore[reportAttributeAccessIssue]
    6:         undefined_type_error_message,
    6:         code='class-not-fully-defined',
    6:         attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_core_schema__),
           )
   12:     cls.__pydantic_validator__ = MockValSer(  # pyright: ignore[reportAttributeAccessIssue]
    6:         undefined_type_error_message,
    6:         code='class-not-fully-defined',
    6:         val_or_ser='validator',
    6:         attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_validator__),
           )
   12:     cls.__pydantic_serializer__ = MockValSer(  # pyright: ignore[reportAttributeAccessIssue]
    6:         undefined_type_error_message,
    6:         code='class-not-fully-defined',
    6:         val_or_ser='serializer',
    6:         attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_serializer__),
           )
       
       
    1: def set_dataclass_mocks(cls: type[PydanticDataclass], undefined_name: str = 'all referenced types') -> None:
           """Set `__pydantic_validator__` and `__pydantic_serializer__` to `MockValSer`s on a dataclass.
       
           Args:
               cls: The model class to set the mocks on
               undefined_name: Name of the undefined thing, used in error messages
           """
>>>>>>     from ..dataclasses import rebuild_dataclass
       
>>>>>>     undefined_type_error_message = (
>>>>>>         f'`{cls.__name__}` is not fully defined; you should define {undefined_name},'
>>>>>>         f' then call `pydantic.dataclasses.rebuild_dataclass({cls.__name__})`.'
           )
       
>>>>>>     def attempt_rebuild_fn(attr_fn: Callable[[type[PydanticDataclass]], T]) -> Callable[[], T | None]:
>>>>>>         def handler() -> T | None:
>>>>>>             if rebuild_dataclass(cls, raise_errors=False, _parent_namespace_depth=5) is not False:
>>>>>>                 return attr_fn(cls)
>>>>>>             return None
       
>>>>>>         return handler
       
>>>>>>     cls.__pydantic_core_schema__ = MockCoreSchema(  # pyright: ignore[reportAttributeAccessIssue]
>>>>>>         undefined_type_error_message,
>>>>>>         code='class-not-fully-defined',
>>>>>>         attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_core_schema__),
           )
>>>>>>     cls.__pydantic_validator__ = MockValSer(  # pyright: ignore[reportAttributeAccessIssue]
>>>>>>         undefined_type_error_message,
>>>>>>         code='class-not-fully-defined',
>>>>>>         val_or_ser='validator',
>>>>>>         attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_validator__),
           )
>>>>>>     cls.__pydantic_serializer__ = MockValSer(  # pyright: ignore[reportAttributeAccessIssue]
>>>>>>         undefined_type_error_message,
>>>>>>         code='class-not-fully-defined',
>>>>>>         val_or_ser='serializer',
>>>>>>         attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_serializer__),
           )
