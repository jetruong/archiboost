    1: from __future__ import annotations
       
    1: import errno
    1: import socket
    1: import sys
    1: from abc import abstractmethod
    1: from collections.abc import Callable, Collection, Mapping
    1: from contextlib import AsyncExitStack
    1: from io import IOBase
    1: from ipaddress import IPv4Address, IPv6Address
    1: from socket import AddressFamily
    1: from typing import Any, TypeVar, Union
       
    1: from .._core._eventloop import get_async_backend
    1: from .._core._typedattr import (
           TypedAttributeProvider,
           TypedAttributeSet,
           typed_attribute,
       )
    1: from ._streams import ByteStream, Listener, UnreliableObjectStream
    1: from ._tasks import TaskGroup
       
    1: if sys.version_info >= (3, 10):
    1:     from typing import TypeAlias
       else:
>>>>>>     from typing_extensions import TypeAlias
       
    1: IPAddressType: TypeAlias = Union[str, IPv4Address, IPv6Address]
    1: IPSockAddrType: TypeAlias = tuple[str, int]
    1: SockAddrType: TypeAlias = Union[IPSockAddrType, str]
    1: UDPPacketType: TypeAlias = tuple[bytes, IPSockAddrType]
    1: UNIXDatagramPacketType: TypeAlias = tuple[bytes, str]
    1: T_Retval = TypeVar("T_Retval")
       
       
    8: def _validate_socket(
    1:     sock_or_fd: socket.socket | int,
    1:     sock_type: socket.SocketKind,
    2:     addr_family: socket.AddressFamily = socket.AF_UNSPEC,
           *,
    2:     require_connected: bool = False,
    2:     require_bound: bool = False,
    1: ) -> socket.socket:
>>>>>>     if isinstance(sock_or_fd, int):
>>>>>>         try:
>>>>>>             sock = socket.socket(fileno=sock_or_fd)
>>>>>>         except OSError as exc:
>>>>>>             if exc.errno == errno.ENOTSOCK:
>>>>>>                 raise ValueError(
>>>>>>                     "the file descriptor does not refer to a socket"
>>>>>>                 ) from exc
>>>>>>             elif require_connected:
>>>>>>                 raise ValueError("the socket must be connected") from exc
>>>>>>             elif require_bound:
>>>>>>                 raise ValueError("the socket must be bound to a local address") from exc
                   else:
>>>>>>                 raise
>>>>>>     elif isinstance(sock_or_fd, socket.socket):
>>>>>>         sock = sock_or_fd
           else:
>>>>>>         raise TypeError(
>>>>>>             f"expected an int or socket, got {type(sock_or_fd).__qualname__} instead"
               )
       
>>>>>>     try:
>>>>>>         if require_connected:
>>>>>>             try:
>>>>>>                 sock.getpeername()
>>>>>>             except OSError as exc:
>>>>>>                 raise ValueError("the socket must be connected") from exc
       
>>>>>>         if require_bound:
>>>>>>             try:
>>>>>>                 if sock.family in (socket.AF_INET, socket.AF_INET6):
>>>>>>                     bound_addr = sock.getsockname()[1]
                       else:
>>>>>>                     bound_addr = sock.getsockname()
>>>>>>             except OSError:
>>>>>>                 bound_addr = None
       
>>>>>>             if not bound_addr:
>>>>>>                 raise ValueError("the socket must be bound to a local address")
       
>>>>>>         if addr_family != socket.AF_UNSPEC and sock.family != addr_family:
>>>>>>             raise ValueError(
>>>>>>                 f"address family mismatch: expected {addr_family.name}, got "
>>>>>>                 f"{sock.family.name}"
                   )
       
>>>>>>         if sock.type != sock_type:
>>>>>>             raise ValueError(
>>>>>>                 f"socket type mismatch: expected {sock_type.name}, got {sock.type.name}"
                   )
>>>>>>     except BaseException:
               # Avoid ResourceWarning from the locally constructed socket object
>>>>>>         if isinstance(sock_or_fd, int):
>>>>>>             sock.detach()
       
>>>>>>         raise
       
>>>>>>     sock.setblocking(False)
>>>>>>     return sock
       
       
    2: class SocketAttribute(TypedAttributeSet):
    1:     """
           .. attribute:: family
               :type: socket.AddressFamily
       
               the address family of the underlying socket
       
           .. attribute:: local_address
               :type: tuple[str, int] | str
       
               the local address the underlying socket is connected to
       
           .. attribute:: local_port
               :type: int
       
               for IP based sockets, the local port the underlying socket is bound to
       
           .. attribute:: raw_socket
               :type: socket.socket
       
               the underlying stdlib socket object
       
           .. attribute:: remote_address
               :type: tuple[str, int] | str
       
               the remote address the underlying socket is connected to
       
           .. attribute:: remote_port
               :type: int
       
               for IP based sockets, the remote port the underlying socket is connected to
           """
       
    1:     family: AddressFamily = typed_attribute()
    1:     local_address: SockAddrType = typed_attribute()
    1:     local_port: int = typed_attribute()
    1:     raw_socket: socket.socket = typed_attribute()
    1:     remote_address: SockAddrType = typed_attribute()
    1:     remote_port: int = typed_attribute()
       
       
    2: class _SocketProvider(TypedAttributeProvider):
    2:     @property
    2:     def extra_attributes(self) -> Mapping[Any, Callable[[], Any]]:
>>>>>>         from .._core._sockets import convert_ipv6_sockaddr as convert
       
>>>>>>         attributes: dict[Any, Callable[[], Any]] = {
>>>>>>             SocketAttribute.family: lambda: self._raw_socket.family,
>>>>>>             SocketAttribute.local_address: lambda: convert(
>>>>>>                 self._raw_socket.getsockname()
                   ),
>>>>>>             SocketAttribute.raw_socket: lambda: self._raw_socket,
               }
>>>>>>         try:
>>>>>>             peername: tuple[str, int] | None = convert(self._raw_socket.getpeername())
>>>>>>         except OSError:
>>>>>>             peername = None
       
               # Provide the remote address for connected sockets
>>>>>>         if peername is not None:
>>>>>>             attributes[SocketAttribute.remote_address] = lambda: peername
       
               # Provide local and remote ports for IP based sockets
>>>>>>         if self._raw_socket.family in (AddressFamily.AF_INET, AddressFamily.AF_INET6):
>>>>>>             attributes[SocketAttribute.local_port] = (
>>>>>>                 lambda: self._raw_socket.getsockname()[1]
                   )
>>>>>>             if peername is not None:
>>>>>>                 remote_port = peername[1]
>>>>>>                 attributes[SocketAttribute.remote_port] = lambda: remote_port
       
>>>>>>         return attributes
       
    2:     @property
    2:     @abstractmethod
    2:     def _raw_socket(self) -> socket.socket:
>>>>>>         pass
       
       
    2: class SocketStream(ByteStream, _SocketProvider):
    1:     """
           Transports bytes over a socket.
       
           Supports all relevant extra attributes from :class:`~SocketAttribute`.
           """
       
    2:     @classmethod
    2:     async def from_socket(cls, sock_or_fd: socket.socket | int) -> SocketStream:
               """
               Wrap an existing socket object or file descriptor as a socket stream.
       
               The newly created socket wrapper takes ownership of the socket being passed in.
               The existing socket must already be connected.
       
               :param sock_or_fd: a socket object or file descriptor
               :return: a socket stream
       
               """
>>>>>>         sock = _validate_socket(sock_or_fd, socket.SOCK_STREAM, require_connected=True)
>>>>>>         return await get_async_backend().wrap_stream_socket(sock)
       
       
    2: class UNIXSocketStream(SocketStream):
    2:     @classmethod
    2:     async def from_socket(cls, sock_or_fd: socket.socket | int) -> UNIXSocketStream:
               """
               Wrap an existing socket object or file descriptor as a UNIX socket stream.
       
               The newly created socket wrapper takes ownership of the socket being passed in.
               The existing socket must already be connected.
       
               :param sock_or_fd: a socket object or file descriptor
               :return: a UNIX socket stream
       
               """
>>>>>>         sock = _validate_socket(
>>>>>>             sock_or_fd, socket.SOCK_STREAM, socket.AF_UNIX, require_connected=True
               )
>>>>>>         return await get_async_backend().wrap_unix_stream_socket(sock)
       
    2:     @abstractmethod
    2:     async def send_fds(self, message: bytes, fds: Collection[int | IOBase]) -> None:
               """
               Send file descriptors along with a message to the peer.
       
               :param message: a non-empty bytestring
               :param fds: a collection of files (either numeric file descriptors or open file
                   or socket objects)
               """
       
    2:     @abstractmethod
    2:     async def receive_fds(self, msglen: int, maxfds: int) -> tuple[bytes, list[int]]:
               """
               Receive file descriptors along with a message from the peer.
       
               :param msglen: length of the message to expect from the peer
               :param maxfds: maximum number of file descriptors to expect from the peer
               :return: a tuple of (message, file descriptors)
               """
       
       
    2: class SocketListener(Listener[SocketStream], _SocketProvider):
    1:     """
           Listens to incoming socket connections.
       
           Supports all relevant extra attributes from :class:`~SocketAttribute`.
           """
       
    2:     @classmethod
    4:     async def from_socket(
               cls,
    1:         sock_or_fd: socket.socket | int,
    1:     ) -> SocketListener:
               """
               Wrap an existing socket object or file descriptor as a socket listener.
       
               The newly created listener takes ownership of the socket being passed in.
       
               :param sock_or_fd: a socket object or file descriptor
               :return: a socket listener
       
               """
>>>>>>         sock = _validate_socket(sock_or_fd, socket.SOCK_STREAM, require_bound=True)
>>>>>>         return await get_async_backend().wrap_listener_socket(sock)
       
    2:     @abstractmethod
    2:     async def accept(self) -> SocketStream:
               """Accept an incoming connection."""
       
    4:     async def serve(
               self,
    1:         handler: Callable[[SocketStream], Any],
    2:         task_group: TaskGroup | None = None,
    1:     ) -> None:
>>>>>>         from .. import create_task_group
       
>>>>>>         async with AsyncExitStack() as stack:
>>>>>>             if task_group is None:
>>>>>>                 task_group = await stack.enter_async_context(create_task_group())
       
>>>>>>             while True:
>>>>>>                 stream = await self.accept()
>>>>>>                 task_group.start_soon(handler, stream)
       
       
    2: class UDPSocket(UnreliableObjectStream[UDPPacketType], _SocketProvider):
    1:     """
           Represents an unconnected UDP socket.
       
           Supports all relevant extra attributes from :class:`~SocketAttribute`.
           """
       
    2:     @classmethod
    2:     async def from_socket(cls, sock_or_fd: socket.socket | int) -> UDPSocket:
               """
               Wrap an existing socket object or file descriptor as a UDP socket.
       
               The newly created socket wrapper takes ownership of the socket being passed in.
               The existing socket must be bound to a local address.
       
               :param sock_or_fd: a socket object or file descriptor
               :return: a UDP socket
       
               """
>>>>>>         sock = _validate_socket(sock_or_fd, socket.SOCK_DGRAM, require_bound=True)
>>>>>>         return await get_async_backend().wrap_udp_socket(sock)
       
    1:     async def sendto(self, data: bytes, host: str, port: int) -> None:
               """
               Alias for :meth:`~.UnreliableObjectSendStream.send` ((data, (host, port))).
       
               """
>>>>>>         return await self.send((data, (host, port)))
       
       
    2: class ConnectedUDPSocket(UnreliableObjectStream[bytes], _SocketProvider):
    1:     """
           Represents an connected UDP socket.
       
           Supports all relevant extra attributes from :class:`~SocketAttribute`.
           """
       
    2:     @classmethod
    2:     async def from_socket(cls, sock_or_fd: socket.socket | int) -> ConnectedUDPSocket:
               """
               Wrap an existing socket object or file descriptor as a connected UDP socket.
       
               The newly created socket wrapper takes ownership of the socket being passed in.
               The existing socket must already be connected.
       
               :param sock_or_fd: a socket object or file descriptor
               :return: a connected UDP socket
       
               """
>>>>>>         sock = _validate_socket(
>>>>>>             sock_or_fd,
>>>>>>             socket.SOCK_DGRAM,
>>>>>>             require_connected=True,
               )
>>>>>>         return await get_async_backend().wrap_connected_udp_socket(sock)
       
       
    3: class UNIXDatagramSocket(
    1:     UnreliableObjectStream[UNIXDatagramPacketType], _SocketProvider
       ):
    1:     """
           Represents an unconnected Unix datagram socket.
       
           Supports all relevant extra attributes from :class:`~SocketAttribute`.
           """
       
    2:     @classmethod
    4:     async def from_socket(
               cls,
    1:         sock_or_fd: socket.socket | int,
    1:     ) -> UNIXDatagramSocket:
               """
               Wrap an existing socket object or file descriptor as a UNIX datagram
               socket.
       
               The newly created socket wrapper takes ownership of the socket being passed in.
       
               :param sock_or_fd: a socket object or file descriptor
               :return: a UNIX datagram socket
       
               """
>>>>>>         sock = _validate_socket(sock_or_fd, socket.SOCK_DGRAM, socket.AF_UNIX)
>>>>>>         return await get_async_backend().wrap_unix_datagram_socket(sock)
       
    1:     async def sendto(self, data: bytes, path: str) -> None:
               """Alias for :meth:`~.UnreliableObjectSendStream.send` ((data, path))."""
>>>>>>         return await self.send((data, path))
       
       
    2: class ConnectedUNIXDatagramSocket(UnreliableObjectStream[bytes], _SocketProvider):
    1:     """
           Represents a connected Unix datagram socket.
       
           Supports all relevant extra attributes from :class:`~SocketAttribute`.
           """
       
    2:     @classmethod
    4:     async def from_socket(
               cls,
    1:         sock_or_fd: socket.socket | int,
    1:     ) -> ConnectedUNIXDatagramSocket:
               """
               Wrap an existing socket object or file descriptor as a connected UNIX datagram
               socket.
       
               The newly created socket wrapper takes ownership of the socket being passed in.
               The existing socket must already be connected.
       
               :param sock_or_fd: a socket object or file descriptor
               :return: a connected UNIX datagram socket
       
               """
>>>>>>         sock = _validate_socket(
>>>>>>             sock_or_fd, socket.SOCK_DGRAM, socket.AF_UNIX, require_connected=True
               )
>>>>>>         return await get_async_backend().wrap_connected_unix_datagram_socket(sock)
