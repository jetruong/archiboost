       # This file was automatically generated by SWIG (https://www.swig.org).
       # Version 4.3.1
       #
       # Do not make changes to this file unless you know what you are doing - modify
       # the SWIG interface file instead.
       
    1: from sys import version_info as _swig_python_version_info
       # Import the low-level C/C++ module
    1: if __package__ or "." in __name__:
    1:     from . import _mupdf
       else:
>>>>>>     import _mupdf
       
    1: try:
    1:     import builtins as __builtin__
>>>>>> except ImportError:
>>>>>>     import __builtin__
       
    1: def _swig_repr(self):
>>>>>>     try:
>>>>>>         strthis = "proxy of " + self.this.__repr__()
>>>>>>     except __builtin__.Exception:
>>>>>>         strthis = ""
>>>>>>     return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)
       
       
    1: def _swig_setattr_nondynamic_instance_variable(set):
>>>>>>     def set_instance_attr(self, name, value):
>>>>>>         if name == "this":
>>>>>>             set(self, name, value)
>>>>>>         elif name == "thisown":
>>>>>>             self.this.own(value)
>>>>>>         elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
>>>>>>             set(self, name, value)
               else:
>>>>>>             raise AttributeError("You cannot add instance attributes to %s" % self)
>>>>>>     return set_instance_attr
       
       
    1: def _swig_setattr_nondynamic_class_variable(set):
    1:     def set_class_attr(cls, name, value):
>>>>>>         if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
>>>>>>             set(cls, name, value)
               else:
>>>>>>             raise AttributeError("You cannot add class attributes to %s" % cls)
    1:     return set_class_attr
       
       
    1: def _swig_add_metaclass(metaclass):
           """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
>>>>>>     def wrapper(cls):
>>>>>>         return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
>>>>>>     return wrapper
       
       
    2: class _SwigNonDynamicMeta(type):
    1:     """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    1:     __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)
       
       
    1: import weakref
       
       
    1: def cdata(ptr, nelements=1):
>>>>>>     return _mupdf.cdata(ptr, nelements)
       
    1: def memmove(data, indata):
>>>>>>     return _mupdf.memmove(data, indata)
    2: class SwigPyIterator(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
       
    1:     def __init__(self, *args, **kwargs):
>>>>>>         raise AttributeError("No constructor defined - class is abstract")
    1:     __repr__ = _swig_repr
    1:     __swig_destroy__ = _mupdf.delete_SwigPyIterator
       
    1:     def value(self):
>>>>>>         return _mupdf.SwigPyIterator_value(self)
       
    1:     def incr(self, n=1):
>>>>>>         return _mupdf.SwigPyIterator_incr(self, n)
       
    1:     def decr(self, n=1):
>>>>>>         return _mupdf.SwigPyIterator_decr(self, n)
       
    1:     def distance(self, x):
>>>>>>         return _mupdf.SwigPyIterator_distance(self, x)
       
    1:     def equal(self, x):
>>>>>>         return _mupdf.SwigPyIterator_equal(self, x)
       
    1:     def copy(self):
>>>>>>         return _mupdf.SwigPyIterator_copy(self)
       
    1:     def next(self):
>>>>>>         return _mupdf.SwigPyIterator_next(self)
       
    1:     def __next__(self):
>>>>>>         return _mupdf.SwigPyIterator___next__(self)
       
    1:     def previous(self):
>>>>>>         return _mupdf.SwigPyIterator_previous(self)
       
    1:     def advance(self, n):
>>>>>>         return _mupdf.SwigPyIterator_advance(self, n)
       
    1:     def __eq__(self, x):
>>>>>>         return _mupdf.SwigPyIterator___eq__(self, x)
       
    1:     def __ne__(self, x):
>>>>>>         return _mupdf.SwigPyIterator___ne__(self, x)
       
    1:     def __iadd__(self, n):
>>>>>>         return _mupdf.SwigPyIterator___iadd__(self, n)
       
    1:     def __isub__(self, n):
>>>>>>         return _mupdf.SwigPyIterator___isub__(self, n)
       
    1:     def __add__(self, n):
>>>>>>         return _mupdf.SwigPyIterator___add__(self, n)
       
    1:     def __sub__(self, *args):
>>>>>>         return _mupdf.SwigPyIterator___sub__(self, *args)
    1:     def __iter__(self):
>>>>>>         return self
       
       # Register SwigPyIterator in _mupdf:
    1: _mupdf.SwigPyIterator_swigregister(SwigPyIterator)
    2: class uchar_array(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, nelements):
>>>>>>         _mupdf.uchar_array_swiginit(self, _mupdf.new_uchar_array(nelements))
    1:     __swig_destroy__ = _mupdf.delete_uchar_array
       
    1:     def __getitem__(self, index):
>>>>>>         return _mupdf.uchar_array___getitem__(self, index)
       
    1:     def __setitem__(self, index, value):
>>>>>>         return _mupdf.uchar_array___setitem__(self, index, value)
       
    1:     def cast(self):
>>>>>>         return _mupdf.uchar_array_cast(self)
       
    2:     @staticmethod
    2:     def frompointer(t):
>>>>>>         return _mupdf.uchar_array_frompointer(t)
       
       # Register uchar_array in _mupdf:
    1: _mupdf.uchar_array_swigregister(uchar_array)
    2: class vectoruc(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def iterator(self):
>>>>>>         return _mupdf.vectoruc_iterator(self)
    1:     def __iter__(self):
>>>>>>         return self.iterator()
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.vectoruc___nonzero__(self)
       
    1:     def __bool__(self):
>>>>>>         return _mupdf.vectoruc___bool__(self)
       
    1:     def __len__(self):
>>>>>>         return _mupdf.vectoruc___len__(self)
       
    1:     def __getslice__(self, i, j):
>>>>>>         return _mupdf.vectoruc___getslice__(self, i, j)
       
    1:     def __setslice__(self, *args):
>>>>>>         return _mupdf.vectoruc___setslice__(self, *args)
       
    1:     def __delslice__(self, i, j):
>>>>>>         return _mupdf.vectoruc___delslice__(self, i, j)
       
    1:     def __delitem__(self, *args):
>>>>>>         return _mupdf.vectoruc___delitem__(self, *args)
       
    1:     def __getitem__(self, *args):
>>>>>>         return _mupdf.vectoruc___getitem__(self, *args)
       
    1:     def __setitem__(self, *args):
>>>>>>         return _mupdf.vectoruc___setitem__(self, *args)
       
    1:     def pop(self):
>>>>>>         return _mupdf.vectoruc_pop(self)
       
    1:     def append(self, x):
>>>>>>         return _mupdf.vectoruc_append(self, x)
       
    1:     def empty(self):
>>>>>>         return _mupdf.vectoruc_empty(self)
       
    1:     def size(self):
>>>>>>         return _mupdf.vectoruc_size(self)
       
    1:     def swap(self, v):
>>>>>>         return _mupdf.vectoruc_swap(self, v)
       
    1:     def begin(self):
>>>>>>         return _mupdf.vectoruc_begin(self)
       
    1:     def end(self):
>>>>>>         return _mupdf.vectoruc_end(self)
       
    1:     def rbegin(self):
>>>>>>         return _mupdf.vectoruc_rbegin(self)
       
    1:     def rend(self):
>>>>>>         return _mupdf.vectoruc_rend(self)
       
    1:     def clear(self):
>>>>>>         return _mupdf.vectoruc_clear(self)
       
    1:     def get_allocator(self):
>>>>>>         return _mupdf.vectoruc_get_allocator(self)
       
    1:     def pop_back(self):
>>>>>>         return _mupdf.vectoruc_pop_back(self)
       
    1:     def erase(self, *args):
>>>>>>         return _mupdf.vectoruc_erase(self, *args)
       
    1:     def __init__(self, *args):
>>>>>>         _mupdf.vectoruc_swiginit(self, _mupdf.new_vectoruc(*args))
       
    1:     def push_back(self, x):
>>>>>>         return _mupdf.vectoruc_push_back(self, x)
       
    1:     def front(self):
>>>>>>         return _mupdf.vectoruc_front(self)
       
    1:     def back(self):
>>>>>>         return _mupdf.vectoruc_back(self)
       
    1:     def assign(self, n, x):
>>>>>>         return _mupdf.vectoruc_assign(self, n, x)
       
    1:     def resize(self, *args):
>>>>>>         return _mupdf.vectoruc_resize(self, *args)
       
    1:     def insert(self, *args):
>>>>>>         return _mupdf.vectoruc_insert(self, *args)
       
    1:     def reserve(self, n):
>>>>>>         return _mupdf.vectoruc_reserve(self, n)
       
    1:     def capacity(self):
>>>>>>         return _mupdf.vectoruc_capacity(self)
    1:     __swig_destroy__ = _mupdf.delete_vectoruc
       
       # Register vectoruc in _mupdf:
    1: _mupdf.vectoruc_swigregister(vectoruc)
    2: class vectori(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def iterator(self):
>>>>>>         return _mupdf.vectori_iterator(self)
    1:     def __iter__(self):
>>>>>>         return self.iterator()
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.vectori___nonzero__(self)
       
    1:     def __bool__(self):
>>>>>>         return _mupdf.vectori___bool__(self)
       
    1:     def __len__(self):
>>>>>>         return _mupdf.vectori___len__(self)
       
    1:     def __getslice__(self, i, j):
>>>>>>         return _mupdf.vectori___getslice__(self, i, j)
       
    1:     def __setslice__(self, *args):
>>>>>>         return _mupdf.vectori___setslice__(self, *args)
       
    1:     def __delslice__(self, i, j):
>>>>>>         return _mupdf.vectori___delslice__(self, i, j)
       
    1:     def __delitem__(self, *args):
>>>>>>         return _mupdf.vectori___delitem__(self, *args)
       
    1:     def __getitem__(self, *args):
>>>>>>         return _mupdf.vectori___getitem__(self, *args)
       
    1:     def __setitem__(self, *args):
>>>>>>         return _mupdf.vectori___setitem__(self, *args)
       
    1:     def pop(self):
>>>>>>         return _mupdf.vectori_pop(self)
       
    1:     def append(self, x):
>>>>>>         return _mupdf.vectori_append(self, x)
       
    1:     def empty(self):
>>>>>>         return _mupdf.vectori_empty(self)
       
    1:     def size(self):
>>>>>>         return _mupdf.vectori_size(self)
       
    1:     def swap(self, v):
>>>>>>         return _mupdf.vectori_swap(self, v)
       
    1:     def begin(self):
>>>>>>         return _mupdf.vectori_begin(self)
       
    1:     def end(self):
>>>>>>         return _mupdf.vectori_end(self)
       
    1:     def rbegin(self):
>>>>>>         return _mupdf.vectori_rbegin(self)
       
    1:     def rend(self):
>>>>>>         return _mupdf.vectori_rend(self)
       
    1:     def clear(self):
>>>>>>         return _mupdf.vectori_clear(self)
       
    1:     def get_allocator(self):
>>>>>>         return _mupdf.vectori_get_allocator(self)
       
    1:     def pop_back(self):
>>>>>>         return _mupdf.vectori_pop_back(self)
       
    1:     def erase(self, *args):
>>>>>>         return _mupdf.vectori_erase(self, *args)
       
    1:     def __init__(self, *args):
>>>>>>         _mupdf.vectori_swiginit(self, _mupdf.new_vectori(*args))
       
    1:     def push_back(self, x):
>>>>>>         return _mupdf.vectori_push_back(self, x)
       
    1:     def front(self):
>>>>>>         return _mupdf.vectori_front(self)
       
    1:     def back(self):
>>>>>>         return _mupdf.vectori_back(self)
       
    1:     def assign(self, n, x):
>>>>>>         return _mupdf.vectori_assign(self, n, x)
       
    1:     def resize(self, *args):
>>>>>>         return _mupdf.vectori_resize(self, *args)
       
    1:     def insert(self, *args):
>>>>>>         return _mupdf.vectori_insert(self, *args)
       
    1:     def reserve(self, n):
>>>>>>         return _mupdf.vectori_reserve(self, n)
       
    1:     def capacity(self):
>>>>>>         return _mupdf.vectori_capacity(self)
    1:     __swig_destroy__ = _mupdf.delete_vectori
       
       # Register vectori in _mupdf:
    1: _mupdf.vectori_swigregister(vectori)
    2: class vectorf(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def iterator(self):
>>>>>>         return _mupdf.vectorf_iterator(self)
    1:     def __iter__(self):
>>>>>>         return self.iterator()
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.vectorf___nonzero__(self)
       
    1:     def __bool__(self):
>>>>>>         return _mupdf.vectorf___bool__(self)
       
    1:     def __len__(self):
>>>>>>         return _mupdf.vectorf___len__(self)
       
    1:     def __getslice__(self, i, j):
>>>>>>         return _mupdf.vectorf___getslice__(self, i, j)
       
    1:     def __setslice__(self, *args):
>>>>>>         return _mupdf.vectorf___setslice__(self, *args)
       
    1:     def __delslice__(self, i, j):
>>>>>>         return _mupdf.vectorf___delslice__(self, i, j)
       
    1:     def __delitem__(self, *args):
>>>>>>         return _mupdf.vectorf___delitem__(self, *args)
       
    1:     def __getitem__(self, *args):
>>>>>>         return _mupdf.vectorf___getitem__(self, *args)
       
    1:     def __setitem__(self, *args):
>>>>>>         return _mupdf.vectorf___setitem__(self, *args)
       
    1:     def pop(self):
>>>>>>         return _mupdf.vectorf_pop(self)
       
    1:     def append(self, x):
>>>>>>         return _mupdf.vectorf_append(self, x)
       
    1:     def empty(self):
>>>>>>         return _mupdf.vectorf_empty(self)
       
    1:     def size(self):
>>>>>>         return _mupdf.vectorf_size(self)
       
    1:     def swap(self, v):
>>>>>>         return _mupdf.vectorf_swap(self, v)
       
    1:     def begin(self):
>>>>>>         return _mupdf.vectorf_begin(self)
       
    1:     def end(self):
>>>>>>         return _mupdf.vectorf_end(self)
       
    1:     def rbegin(self):
>>>>>>         return _mupdf.vectorf_rbegin(self)
       
    1:     def rend(self):
>>>>>>         return _mupdf.vectorf_rend(self)
       
    1:     def clear(self):
>>>>>>         return _mupdf.vectorf_clear(self)
       
    1:     def get_allocator(self):
>>>>>>         return _mupdf.vectorf_get_allocator(self)
       
    1:     def pop_back(self):
>>>>>>         return _mupdf.vectorf_pop_back(self)
       
    1:     def erase(self, *args):
>>>>>>         return _mupdf.vectorf_erase(self, *args)
       
    1:     def __init__(self, *args):
>>>>>>         _mupdf.vectorf_swiginit(self, _mupdf.new_vectorf(*args))
       
    1:     def push_back(self, x):
>>>>>>         return _mupdf.vectorf_push_back(self, x)
       
    1:     def front(self):
>>>>>>         return _mupdf.vectorf_front(self)
       
    1:     def back(self):
>>>>>>         return _mupdf.vectorf_back(self)
       
    1:     def assign(self, n, x):
>>>>>>         return _mupdf.vectorf_assign(self, n, x)
       
    1:     def resize(self, *args):
>>>>>>         return _mupdf.vectorf_resize(self, *args)
       
    1:     def insert(self, *args):
>>>>>>         return _mupdf.vectorf_insert(self, *args)
       
    1:     def reserve(self, n):
>>>>>>         return _mupdf.vectorf_reserve(self, n)
       
    1:     def capacity(self):
>>>>>>         return _mupdf.vectorf_capacity(self)
    1:     __swig_destroy__ = _mupdf.delete_vectorf
       
       # Register vectorf in _mupdf:
    1: _mupdf.vectorf_swigregister(vectorf)
    2: class vectord(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def iterator(self):
>>>>>>         return _mupdf.vectord_iterator(self)
    1:     def __iter__(self):
>>>>>>         return self.iterator()
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.vectord___nonzero__(self)
       
    1:     def __bool__(self):
>>>>>>         return _mupdf.vectord___bool__(self)
       
    1:     def __len__(self):
>>>>>>         return _mupdf.vectord___len__(self)
       
    1:     def __getslice__(self, i, j):
>>>>>>         return _mupdf.vectord___getslice__(self, i, j)
       
    1:     def __setslice__(self, *args):
>>>>>>         return _mupdf.vectord___setslice__(self, *args)
       
    1:     def __delslice__(self, i, j):
>>>>>>         return _mupdf.vectord___delslice__(self, i, j)
       
    1:     def __delitem__(self, *args):
>>>>>>         return _mupdf.vectord___delitem__(self, *args)
       
    1:     def __getitem__(self, *args):
>>>>>>         return _mupdf.vectord___getitem__(self, *args)
       
    1:     def __setitem__(self, *args):
>>>>>>         return _mupdf.vectord___setitem__(self, *args)
       
    1:     def pop(self):
>>>>>>         return _mupdf.vectord_pop(self)
       
    1:     def append(self, x):
>>>>>>         return _mupdf.vectord_append(self, x)
       
    1:     def empty(self):
>>>>>>         return _mupdf.vectord_empty(self)
       
    1:     def size(self):
>>>>>>         return _mupdf.vectord_size(self)
       
    1:     def swap(self, v):
>>>>>>         return _mupdf.vectord_swap(self, v)
       
    1:     def begin(self):
>>>>>>         return _mupdf.vectord_begin(self)
       
    1:     def end(self):
>>>>>>         return _mupdf.vectord_end(self)
       
    1:     def rbegin(self):
>>>>>>         return _mupdf.vectord_rbegin(self)
       
    1:     def rend(self):
>>>>>>         return _mupdf.vectord_rend(self)
       
    1:     def clear(self):
>>>>>>         return _mupdf.vectord_clear(self)
       
    1:     def get_allocator(self):
>>>>>>         return _mupdf.vectord_get_allocator(self)
       
    1:     def pop_back(self):
>>>>>>         return _mupdf.vectord_pop_back(self)
       
    1:     def erase(self, *args):
>>>>>>         return _mupdf.vectord_erase(self, *args)
       
    1:     def __init__(self, *args):
>>>>>>         _mupdf.vectord_swiginit(self, _mupdf.new_vectord(*args))
       
    1:     def push_back(self, x):
>>>>>>         return _mupdf.vectord_push_back(self, x)
       
    1:     def front(self):
>>>>>>         return _mupdf.vectord_front(self)
       
    1:     def back(self):
>>>>>>         return _mupdf.vectord_back(self)
       
    1:     def assign(self, n, x):
>>>>>>         return _mupdf.vectord_assign(self, n, x)
       
    1:     def resize(self, *args):
>>>>>>         return _mupdf.vectord_resize(self, *args)
       
    1:     def insert(self, *args):
>>>>>>         return _mupdf.vectord_insert(self, *args)
       
    1:     def reserve(self, n):
>>>>>>         return _mupdf.vectord_reserve(self, n)
       
    1:     def capacity(self):
>>>>>>         return _mupdf.vectord_capacity(self)
    1:     __swig_destroy__ = _mupdf.delete_vectord
       
       # Register vectord in _mupdf:
    1: _mupdf.vectord_swigregister(vectord)
    2: class vectors(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def iterator(self):
>>>>>>         return _mupdf.vectors_iterator(self)
    1:     def __iter__(self):
>>>>>>         return self.iterator()
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.vectors___nonzero__(self)
       
    1:     def __bool__(self):
>>>>>>         return _mupdf.vectors___bool__(self)
       
    1:     def __len__(self):
>>>>>>         return _mupdf.vectors___len__(self)
       
    1:     def __getslice__(self, i, j):
>>>>>>         return _mupdf.vectors___getslice__(self, i, j)
       
    1:     def __setslice__(self, *args):
>>>>>>         return _mupdf.vectors___setslice__(self, *args)
       
    1:     def __delslice__(self, i, j):
>>>>>>         return _mupdf.vectors___delslice__(self, i, j)
       
    1:     def __delitem__(self, *args):
>>>>>>         return _mupdf.vectors___delitem__(self, *args)
       
    1:     def __getitem__(self, *args):
>>>>>>         return _mupdf.vectors___getitem__(self, *args)
       
    1:     def __setitem__(self, *args):
>>>>>>         return _mupdf.vectors___setitem__(self, *args)
       
    1:     def pop(self):
>>>>>>         return _mupdf.vectors_pop(self)
       
    1:     def append(self, x):
>>>>>>         return _mupdf.vectors_append(self, x)
       
    1:     def empty(self):
>>>>>>         return _mupdf.vectors_empty(self)
       
    1:     def size(self):
>>>>>>         return _mupdf.vectors_size(self)
       
    1:     def swap(self, v):
>>>>>>         return _mupdf.vectors_swap(self, v)
       
    1:     def begin(self):
>>>>>>         return _mupdf.vectors_begin(self)
       
    1:     def end(self):
>>>>>>         return _mupdf.vectors_end(self)
       
    1:     def rbegin(self):
>>>>>>         return _mupdf.vectors_rbegin(self)
       
    1:     def rend(self):
>>>>>>         return _mupdf.vectors_rend(self)
       
    1:     def clear(self):
>>>>>>         return _mupdf.vectors_clear(self)
       
    1:     def get_allocator(self):
>>>>>>         return _mupdf.vectors_get_allocator(self)
       
    1:     def pop_back(self):
>>>>>>         return _mupdf.vectors_pop_back(self)
       
    1:     def erase(self, *args):
>>>>>>         return _mupdf.vectors_erase(self, *args)
       
    1:     def __init__(self, *args):
>>>>>>         _mupdf.vectors_swiginit(self, _mupdf.new_vectors(*args))
       
    1:     def push_back(self, x):
>>>>>>         return _mupdf.vectors_push_back(self, x)
       
    1:     def front(self):
>>>>>>         return _mupdf.vectors_front(self)
       
    1:     def back(self):
>>>>>>         return _mupdf.vectors_back(self)
       
    1:     def assign(self, n, x):
>>>>>>         return _mupdf.vectors_assign(self, n, x)
       
    1:     def resize(self, *args):
>>>>>>         return _mupdf.vectors_resize(self, *args)
       
    1:     def insert(self, *args):
>>>>>>         return _mupdf.vectors_insert(self, *args)
       
    1:     def reserve(self, n):
>>>>>>         return _mupdf.vectors_reserve(self, n)
       
    1:     def capacity(self):
>>>>>>         return _mupdf.vectors_capacity(self)
    1:     __swig_destroy__ = _mupdf.delete_vectors
       
       # Register vectors in _mupdf:
    1: _mupdf.vectors_swigregister(vectors)
    2: class map_string_int(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def iterator(self):
>>>>>>         return _mupdf.map_string_int_iterator(self)
    1:     def __iter__(self):
>>>>>>         return self.iterator()
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.map_string_int___nonzero__(self)
       
    1:     def __bool__(self):
>>>>>>         return _mupdf.map_string_int___bool__(self)
       
    1:     def __len__(self):
>>>>>>         return _mupdf.map_string_int___len__(self)
    1:     def __iter__(self):
>>>>>>         return self.key_iterator()
    1:     def iterkeys(self):
>>>>>>         return self.key_iterator()
    1:     def itervalues(self):
>>>>>>         return self.value_iterator()
    1:     def iteritems(self):
>>>>>>         return self.iterator()
       
    1:     def __getitem__(self, key):
>>>>>>         return _mupdf.map_string_int___getitem__(self, key)
       
    1:     def __delitem__(self, key):
>>>>>>         return _mupdf.map_string_int___delitem__(self, key)
       
    1:     def has_key(self, key):
>>>>>>         return _mupdf.map_string_int_has_key(self, key)
       
    1:     def keys(self):
>>>>>>         return _mupdf.map_string_int_keys(self)
       
    1:     def values(self):
>>>>>>         return _mupdf.map_string_int_values(self)
       
    1:     def items(self):
>>>>>>         return _mupdf.map_string_int_items(self)
       
    1:     def __contains__(self, key):
>>>>>>         return _mupdf.map_string_int___contains__(self, key)
       
    1:     def key_iterator(self):
>>>>>>         return _mupdf.map_string_int_key_iterator(self)
       
    1:     def value_iterator(self):
>>>>>>         return _mupdf.map_string_int_value_iterator(self)
       
    1:     def __setitem__(self, *args):
>>>>>>         return _mupdf.map_string_int___setitem__(self, *args)
       
    1:     def asdict(self):
>>>>>>         return _mupdf.map_string_int_asdict(self)
       
    1:     def __init__(self, *args):
>>>>>>         _mupdf.map_string_int_swiginit(self, _mupdf.new_map_string_int(*args))
       
    1:     def empty(self):
>>>>>>         return _mupdf.map_string_int_empty(self)
       
    1:     def size(self):
>>>>>>         return _mupdf.map_string_int_size(self)
       
    1:     def swap(self, v):
>>>>>>         return _mupdf.map_string_int_swap(self, v)
       
    1:     def begin(self):
>>>>>>         return _mupdf.map_string_int_begin(self)
       
    1:     def end(self):
>>>>>>         return _mupdf.map_string_int_end(self)
       
    1:     def rbegin(self):
>>>>>>         return _mupdf.map_string_int_rbegin(self)
       
    1:     def rend(self):
>>>>>>         return _mupdf.map_string_int_rend(self)
       
    1:     def clear(self):
>>>>>>         return _mupdf.map_string_int_clear(self)
       
    1:     def get_allocator(self):
>>>>>>         return _mupdf.map_string_int_get_allocator(self)
       
    1:     def count(self, x):
>>>>>>         return _mupdf.map_string_int_count(self, x)
       
    1:     def erase(self, *args):
>>>>>>         return _mupdf.map_string_int_erase(self, *args)
       
    1:     def find(self, x):
>>>>>>         return _mupdf.map_string_int_find(self, x)
       
    1:     def lower_bound(self, x):
>>>>>>         return _mupdf.map_string_int_lower_bound(self, x)
       
    1:     def upper_bound(self, x):
>>>>>>         return _mupdf.map_string_int_upper_bound(self, x)
    1:     __swig_destroy__ = _mupdf.delete_map_string_int
       
       # Register map_string_int in _mupdf:
    1: _mupdf.map_string_int_swigregister(map_string_int)
    2: class vectorq(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def iterator(self):
>>>>>>         return _mupdf.vectorq_iterator(self)
    1:     def __iter__(self):
>>>>>>         return self.iterator()
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.vectorq___nonzero__(self)
       
    1:     def __bool__(self):
>>>>>>         return _mupdf.vectorq___bool__(self)
       
    1:     def __len__(self):
>>>>>>         return _mupdf.vectorq___len__(self)
       
    1:     def __getslice__(self, i, j):
>>>>>>         return _mupdf.vectorq___getslice__(self, i, j)
       
    1:     def __setslice__(self, *args):
>>>>>>         return _mupdf.vectorq___setslice__(self, *args)
       
    1:     def __delslice__(self, i, j):
>>>>>>         return _mupdf.vectorq___delslice__(self, i, j)
       
    1:     def __delitem__(self, *args):
>>>>>>         return _mupdf.vectorq___delitem__(self, *args)
       
    1:     def __getitem__(self, *args):
>>>>>>         return _mupdf.vectorq___getitem__(self, *args)
       
    1:     def __setitem__(self, *args):
>>>>>>         return _mupdf.vectorq___setitem__(self, *args)
       
    1:     def pop(self):
>>>>>>         return _mupdf.vectorq_pop(self)
       
    1:     def append(self, x):
>>>>>>         return _mupdf.vectorq_append(self, x)
       
    1:     def empty(self):
>>>>>>         return _mupdf.vectorq_empty(self)
       
    1:     def size(self):
>>>>>>         return _mupdf.vectorq_size(self)
       
    1:     def swap(self, v):
>>>>>>         return _mupdf.vectorq_swap(self, v)
       
    1:     def begin(self):
>>>>>>         return _mupdf.vectorq_begin(self)
       
    1:     def end(self):
>>>>>>         return _mupdf.vectorq_end(self)
       
    1:     def rbegin(self):
>>>>>>         return _mupdf.vectorq_rbegin(self)
       
    1:     def rend(self):
>>>>>>         return _mupdf.vectorq_rend(self)
       
    1:     def clear(self):
>>>>>>         return _mupdf.vectorq_clear(self)
       
    1:     def get_allocator(self):
>>>>>>         return _mupdf.vectorq_get_allocator(self)
       
    1:     def pop_back(self):
>>>>>>         return _mupdf.vectorq_pop_back(self)
       
    1:     def erase(self, *args):
>>>>>>         return _mupdf.vectorq_erase(self, *args)
       
    1:     def __init__(self, *args):
>>>>>>         _mupdf.vectorq_swiginit(self, _mupdf.new_vectorq(*args))
       
    1:     def push_back(self, x):
>>>>>>         return _mupdf.vectorq_push_back(self, x)
       
    1:     def front(self):
>>>>>>         return _mupdf.vectorq_front(self)
       
    1:     def back(self):
>>>>>>         return _mupdf.vectorq_back(self)
       
    1:     def assign(self, n, x):
>>>>>>         return _mupdf.vectorq_assign(self, n, x)
       
    1:     def resize(self, *args):
>>>>>>         return _mupdf.vectorq_resize(self, *args)
       
    1:     def insert(self, *args):
>>>>>>         return _mupdf.vectorq_insert(self, *args)
       
    1:     def reserve(self, n):
>>>>>>         return _mupdf.vectorq_reserve(self, n)
       
    1:     def capacity(self):
>>>>>>         return _mupdf.vectorq_capacity(self)
    1:     __swig_destroy__ = _mupdf.delete_vectorq
       
       # Register vectorq in _mupdf:
    1: _mupdf.vectorq_swigregister(vectorq)
    2: class vector_search_page2_hit(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def iterator(self):
>>>>>>         return _mupdf.vector_search_page2_hit_iterator(self)
    1:     def __iter__(self):
>>>>>>         return self.iterator()
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.vector_search_page2_hit___nonzero__(self)
       
    1:     def __bool__(self):
>>>>>>         return _mupdf.vector_search_page2_hit___bool__(self)
       
    1:     def __len__(self):
>>>>>>         return _mupdf.vector_search_page2_hit___len__(self)
       
    1:     def __getslice__(self, i, j):
>>>>>>         return _mupdf.vector_search_page2_hit___getslice__(self, i, j)
       
    1:     def __setslice__(self, *args):
>>>>>>         return _mupdf.vector_search_page2_hit___setslice__(self, *args)
       
    1:     def __delslice__(self, i, j):
>>>>>>         return _mupdf.vector_search_page2_hit___delslice__(self, i, j)
       
    1:     def __delitem__(self, *args):
>>>>>>         return _mupdf.vector_search_page2_hit___delitem__(self, *args)
       
    1:     def __getitem__(self, *args):
>>>>>>         return _mupdf.vector_search_page2_hit___getitem__(self, *args)
       
    1:     def __setitem__(self, *args):
>>>>>>         return _mupdf.vector_search_page2_hit___setitem__(self, *args)
       
    1:     def pop(self):
>>>>>>         return _mupdf.vector_search_page2_hit_pop(self)
       
    1:     def append(self, x):
>>>>>>         return _mupdf.vector_search_page2_hit_append(self, x)
       
    1:     def empty(self):
>>>>>>         return _mupdf.vector_search_page2_hit_empty(self)
       
    1:     def size(self):
>>>>>>         return _mupdf.vector_search_page2_hit_size(self)
       
    1:     def swap(self, v):
>>>>>>         return _mupdf.vector_search_page2_hit_swap(self, v)
       
    1:     def begin(self):
>>>>>>         return _mupdf.vector_search_page2_hit_begin(self)
       
    1:     def end(self):
>>>>>>         return _mupdf.vector_search_page2_hit_end(self)
       
    1:     def rbegin(self):
>>>>>>         return _mupdf.vector_search_page2_hit_rbegin(self)
       
    1:     def rend(self):
>>>>>>         return _mupdf.vector_search_page2_hit_rend(self)
       
    1:     def clear(self):
>>>>>>         return _mupdf.vector_search_page2_hit_clear(self)
       
    1:     def get_allocator(self):
>>>>>>         return _mupdf.vector_search_page2_hit_get_allocator(self)
       
    1:     def pop_back(self):
>>>>>>         return _mupdf.vector_search_page2_hit_pop_back(self)
       
    1:     def erase(self, *args):
>>>>>>         return _mupdf.vector_search_page2_hit_erase(self, *args)
       
    1:     def __init__(self, *args):
>>>>>>         _mupdf.vector_search_page2_hit_swiginit(self, _mupdf.new_vector_search_page2_hit(*args))
       
    1:     def push_back(self, x):
>>>>>>         return _mupdf.vector_search_page2_hit_push_back(self, x)
       
    1:     def front(self):
>>>>>>         return _mupdf.vector_search_page2_hit_front(self)
       
    1:     def back(self):
>>>>>>         return _mupdf.vector_search_page2_hit_back(self)
       
    1:     def assign(self, n, x):
>>>>>>         return _mupdf.vector_search_page2_hit_assign(self, n, x)
       
    1:     def resize(self, *args):
>>>>>>         return _mupdf.vector_search_page2_hit_resize(self, *args)
       
    1:     def insert(self, *args):
>>>>>>         return _mupdf.vector_search_page2_hit_insert(self, *args)
       
    1:     def reserve(self, n):
>>>>>>         return _mupdf.vector_search_page2_hit_reserve(self, n)
       
    1:     def capacity(self):
>>>>>>         return _mupdf.vector_search_page2_hit_capacity(self)
    1:     __swig_destroy__ = _mupdf.delete_vector_search_page2_hit
       
       # Register vector_search_page2_hit in _mupdf:
    1: _mupdf.vector_search_page2_hit_swigregister(vector_search_page2_hit)
    2: class vector_fz_font_ucs_gid(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def iterator(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_iterator(self)
    1:     def __iter__(self):
>>>>>>         return self.iterator()
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid___nonzero__(self)
       
    1:     def __bool__(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid___bool__(self)
       
    1:     def __len__(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid___len__(self)
       
    1:     def __getslice__(self, i, j):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid___getslice__(self, i, j)
       
    1:     def __setslice__(self, *args):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid___setslice__(self, *args)
       
    1:     def __delslice__(self, i, j):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid___delslice__(self, i, j)
       
    1:     def __delitem__(self, *args):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid___delitem__(self, *args)
       
    1:     def __getitem__(self, *args):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid___getitem__(self, *args)
       
    1:     def __setitem__(self, *args):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid___setitem__(self, *args)
       
    1:     def pop(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_pop(self)
       
    1:     def append(self, x):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_append(self, x)
       
    1:     def empty(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_empty(self)
       
    1:     def size(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_size(self)
       
    1:     def swap(self, v):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_swap(self, v)
       
    1:     def begin(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_begin(self)
       
    1:     def end(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_end(self)
       
    1:     def rbegin(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_rbegin(self)
       
    1:     def rend(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_rend(self)
       
    1:     def clear(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_clear(self)
       
    1:     def get_allocator(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_get_allocator(self)
       
    1:     def pop_back(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_pop_back(self)
       
    1:     def erase(self, *args):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_erase(self, *args)
       
    1:     def __init__(self, *args):
>>>>>>         _mupdf.vector_fz_font_ucs_gid_swiginit(self, _mupdf.new_vector_fz_font_ucs_gid(*args))
       
    1:     def push_back(self, x):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_push_back(self, x)
       
    1:     def front(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_front(self)
       
    1:     def back(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_back(self)
       
    1:     def assign(self, n, x):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_assign(self, n, x)
       
    1:     def resize(self, *args):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_resize(self, *args)
       
    1:     def insert(self, *args):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_insert(self, *args)
       
    1:     def reserve(self, n):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_reserve(self, n)
       
    1:     def capacity(self):
>>>>>>         return _mupdf.vector_fz_font_ucs_gid_capacity(self)
    1:     __swig_destroy__ = _mupdf.delete_vector_fz_font_ucs_gid
       
       # Register vector_fz_font_ucs_gid in _mupdf:
    1: _mupdf.vector_fz_font_ucs_gid_swigregister(vector_fz_font_ucs_gid)
    2: class vector_fz_point(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def iterator(self):
>>>>>>         return _mupdf.vector_fz_point_iterator(self)
    1:     def __iter__(self):
>>>>>>         return self.iterator()
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.vector_fz_point___nonzero__(self)
       
    1:     def __bool__(self):
>>>>>>         return _mupdf.vector_fz_point___bool__(self)
       
    1:     def __len__(self):
>>>>>>         return _mupdf.vector_fz_point___len__(self)
       
    1:     def __getslice__(self, i, j):
>>>>>>         return _mupdf.vector_fz_point___getslice__(self, i, j)
       
    1:     def __setslice__(self, *args):
>>>>>>         return _mupdf.vector_fz_point___setslice__(self, *args)
       
    1:     def __delslice__(self, i, j):
>>>>>>         return _mupdf.vector_fz_point___delslice__(self, i, j)
       
    1:     def __delitem__(self, *args):
>>>>>>         return _mupdf.vector_fz_point___delitem__(self, *args)
       
    1:     def __getitem__(self, *args):
>>>>>>         return _mupdf.vector_fz_point___getitem__(self, *args)
       
    1:     def __setitem__(self, *args):
>>>>>>         return _mupdf.vector_fz_point___setitem__(self, *args)
       
    1:     def pop(self):
>>>>>>         return _mupdf.vector_fz_point_pop(self)
       
    1:     def append(self, x):
>>>>>>         return _mupdf.vector_fz_point_append(self, x)
       
    1:     def empty(self):
>>>>>>         return _mupdf.vector_fz_point_empty(self)
       
    1:     def size(self):
>>>>>>         return _mupdf.vector_fz_point_size(self)
       
    1:     def swap(self, v):
>>>>>>         return _mupdf.vector_fz_point_swap(self, v)
       
    1:     def begin(self):
>>>>>>         return _mupdf.vector_fz_point_begin(self)
       
    1:     def end(self):
>>>>>>         return _mupdf.vector_fz_point_end(self)
       
    1:     def rbegin(self):
>>>>>>         return _mupdf.vector_fz_point_rbegin(self)
       
    1:     def rend(self):
>>>>>>         return _mupdf.vector_fz_point_rend(self)
       
    1:     def clear(self):
>>>>>>         return _mupdf.vector_fz_point_clear(self)
       
    1:     def get_allocator(self):
>>>>>>         return _mupdf.vector_fz_point_get_allocator(self)
       
    1:     def pop_back(self):
>>>>>>         return _mupdf.vector_fz_point_pop_back(self)
       
    1:     def erase(self, *args):
>>>>>>         return _mupdf.vector_fz_point_erase(self, *args)
       
    1:     def __init__(self, *args):
>>>>>>         _mupdf.vector_fz_point_swiginit(self, _mupdf.new_vector_fz_point(*args))
       
    1:     def push_back(self, x):
>>>>>>         return _mupdf.vector_fz_point_push_back(self, x)
       
    1:     def front(self):
>>>>>>         return _mupdf.vector_fz_point_front(self)
       
    1:     def back(self):
>>>>>>         return _mupdf.vector_fz_point_back(self)
       
    1:     def assign(self, n, x):
>>>>>>         return _mupdf.vector_fz_point_assign(self, n, x)
       
    1:     def resize(self, *args):
>>>>>>         return _mupdf.vector_fz_point_resize(self, *args)
       
    1:     def insert(self, *args):
>>>>>>         return _mupdf.vector_fz_point_insert(self, *args)
       
    1:     def reserve(self, n):
>>>>>>         return _mupdf.vector_fz_point_reserve(self, n)
       
    1:     def capacity(self):
>>>>>>         return _mupdf.vector_fz_point_capacity(self)
    1:     __swig_destroy__ = _mupdf.delete_vector_fz_point
       
       # Register vector_fz_point in _mupdf:
    1: _mupdf.vector_fz_point_swigregister(vector_fz_point)
       
    1: def new_bytes(nelements):
>>>>>>     return _mupdf.new_bytes(nelements)
       
    1: def delete_bytes(ary):
>>>>>>     return _mupdf.delete_bytes(ary)
       
    1: def bytes_getitem(ary, index):
>>>>>>     return _mupdf.bytes_getitem(ary, index)
       
    1: def bytes_setitem(ary, index, value):
>>>>>>     return _mupdf.bytes_setitem(ary, index, value)
       
    1: def new_floats(nelements):
>>>>>>     return _mupdf.new_floats(nelements)
       
    1: def delete_floats(ary):
>>>>>>     return _mupdf.delete_floats(ary)
       
    1: def floats_getitem(ary, index):
>>>>>>     return _mupdf.floats_getitem(ary, index)
       
    1: def floats_setitem(ary, index, value):
>>>>>>     return _mupdf.floats_setitem(ary, index, value)
       
    1: def internal_set_error_classes(classes):
    1:     return _mupdf.internal_set_error_classes(classes)
    1: FZ_VERSION = _mupdf.FZ_VERSION
    1: r"""This file was auto-generated by mupdfwrap.py."""
    1: FZ_VERSION_MAJOR = _mupdf.FZ_VERSION_MAJOR
    1: FZ_VERSION_MINOR = _mupdf.FZ_VERSION_MINOR
    1: FZ_VERSION_PATCH = _mupdf.FZ_VERSION_PATCH
    1: FZ_ENABLE_SPOT_RENDERING = _mupdf.FZ_ENABLE_SPOT_RENDERING
    1: r"""
           Enable the following for spot (and hence overprint/overprint
           simulation) capable rendering. This forces FZ_PLOTTERS_N on.
       
           Choose which plotters we need.
           By default we build all the plotters in. To avoid building
           plotters in that aren't needed, define the unwanted
           FZ_PLOTTERS_... define to 0.
       
           Choose which document agents to include.
           By default all are enabled. To avoid building unwanted
           ones, define FZ_ENABLE_... to 0.
       
           Some of those document agents rely on the HTML
           engine. This will be enabled if required based upon
           those engines, but can be enabled independently of
           them so that other features (such as the fz_story
           mechanism or PDF Annotation rich content) can work.
       
           Choose which document writers to include.
           By default all are enabled. To avoid building unwanted
           ones, define FZ_ENABLE_..._OUTPUT to 0.
       
           Choose whether to enable ICC color profiles.
       
           Choose whether to enable JPEG2000 decoding.
           By default, it is enabled, but due to frequent security
           issues with the third party libraries we support disabling
           it with this flag.
       
           Choose whether to enable Brotli compression support.
           By default, it is enabled.
       
           Choose whether to enable JavaScript.
           By default JavaScript is enabled both for mutool and PDF
           interactivity.
       
           Choose whether to enable barcode functionality.
           It is enabled by default, unless disabled by the build
           system.
       
           Choose which fonts to include.
           By default we include the base 14 PDF fonts,
           DroidSansFallback from Android for CJK, and
           Charis SIL from SIL for epub/html.
           Enable the following defines to AVOID including
           unwanted fonts.
           """
    1: FZ_PLOTTERS_N = _mupdf.FZ_PLOTTERS_N
    1: FZ_PLOTTERS_G = _mupdf.FZ_PLOTTERS_G
    1: FZ_PLOTTERS_RGB = _mupdf.FZ_PLOTTERS_RGB
    1: FZ_PLOTTERS_CMYK = _mupdf.FZ_PLOTTERS_CMYK
    1: FZ_ENABLE_PDF = _mupdf.FZ_ENABLE_PDF
    1: FZ_ENABLE_XPS = _mupdf.FZ_ENABLE_XPS
    1: FZ_ENABLE_SVG = _mupdf.FZ_ENABLE_SVG
    1: FZ_ENABLE_CBZ = _mupdf.FZ_ENABLE_CBZ
    1: FZ_ENABLE_IMG = _mupdf.FZ_ENABLE_IMG
    1: FZ_ENABLE_HTML = _mupdf.FZ_ENABLE_HTML
    1: FZ_ENABLE_EPUB = _mupdf.FZ_ENABLE_EPUB
    1: FZ_ENABLE_FB2 = _mupdf.FZ_ENABLE_FB2
    1: FZ_ENABLE_MOBI = _mupdf.FZ_ENABLE_MOBI
    1: FZ_ENABLE_TXT = _mupdf.FZ_ENABLE_TXT
    1: FZ_ENABLE_OFFICE = _mupdf.FZ_ENABLE_OFFICE
    1: FZ_ENABLE_OCR_OUTPUT = _mupdf.FZ_ENABLE_OCR_OUTPUT
    1: FZ_ENABLE_ODT_OUTPUT = _mupdf.FZ_ENABLE_ODT_OUTPUT
    1: FZ_ENABLE_DOCX_OUTPUT = _mupdf.FZ_ENABLE_DOCX_OUTPUT
    1: FZ_ENABLE_JPX = _mupdf.FZ_ENABLE_JPX
    1: FZ_ENABLE_BROTLI = _mupdf.FZ_ENABLE_BROTLI
    1: FZ_ENABLE_JS = _mupdf.FZ_ENABLE_JS
    1: FZ_ENABLE_ICC = _mupdf.FZ_ENABLE_ICC
    1: FZ_ENABLE_HTML_ENGINE = _mupdf.FZ_ENABLE_HTML_ENGINE
    1: FZ_ENABLE_BARCODE = _mupdf.FZ_ENABLE_BARCODE
    1: FZ_FLEXIBLE_ARRAY = _mupdf.FZ_FLEXIBLE_ARRAY
    1: r"""Include the standard libc headers."""
    1: MEMENTO_PREFILL = _mupdf.MEMENTO_PREFILL
    1: MEMENTO_POSTFILL = _mupdf.MEMENTO_POSTFILL
    1: MEMENTO_ALLOCFILL = _mupdf.MEMENTO_ALLOCFILL
    1: MEMENTO_FREEFILL = _mupdf.MEMENTO_FREEFILL
       
    1: def Memento_checkBlock(arg1):
>>>>>>     return _mupdf.Memento_checkBlock(arg1)
       
    1: def Memento_checkAllMemory():
>>>>>>     return _mupdf.Memento_checkAllMemory()
       
    1: def Memento_check():
>>>>>>     return _mupdf.Memento_check()
       
    1: def Memento_setParanoia(arg1):
>>>>>>     return _mupdf.Memento_setParanoia(arg1)
       
    1: def Memento_paranoidAt(arg1):
>>>>>>     return _mupdf.Memento_paranoidAt(arg1)
       
    1: def Memento_breakAt(arg1):
>>>>>>     return _mupdf.Memento_breakAt(arg1)
       
    1: def Memento_breakOnFree(a):
>>>>>>     return _mupdf.Memento_breakOnFree(a)
       
    1: def Memento_breakOnRealloc(a):
>>>>>>     return _mupdf.Memento_breakOnRealloc(a)
       
    1: def Memento_getBlockNum(arg1):
>>>>>>     return _mupdf.Memento_getBlockNum(arg1)
       
    1: def Memento_find(a):
>>>>>>     return _mupdf.Memento_find(a)
       
    1: def Memento_breakpoint():
>>>>>>     return _mupdf.Memento_breakpoint()
       
    1: def Memento_failAt(arg1):
>>>>>>     return _mupdf.Memento_failAt(arg1)
       
    1: def Memento_failThisEvent():
>>>>>>     return _mupdf.Memento_failThisEvent()
       
    1: def Memento_listBlocks():
>>>>>>     return _mupdf.Memento_listBlocks()
       
    1: def Memento_listNewBlocks():
>>>>>>     return _mupdf.Memento_listNewBlocks()
       
    1: def Memento_listLargeBlocks():
>>>>>>     return _mupdf.Memento_listLargeBlocks()
       
    1: def Memento_listPhasedBlocks():
>>>>>>     return _mupdf.Memento_listPhasedBlocks()
       
    1: def Memento_setMax(arg1):
>>>>>>     return _mupdf.Memento_setMax(arg1)
       
    1: def Memento_stats():
>>>>>>     return _mupdf.Memento_stats()
       
    1: def Memento_label(arg1, arg2):
>>>>>>     return _mupdf.Memento_label(arg1, arg2)
       
    1: def Memento_tick():
>>>>>>     return _mupdf.Memento_tick()
       
    1: def Memento_setVerbose(arg1):
>>>>>>     return _mupdf.Memento_setVerbose(arg1)
       
    1: def Memento_addBacktraceLimitFnname(fnname):
>>>>>>     return _mupdf.Memento_addBacktraceLimitFnname(fnname)
       
    1: def Memento_setAtexitFin(atexitfin):
>>>>>>     return _mupdf.Memento_setAtexitFin(atexitfin)
       
    1: def Memento_setIgnoreNewDelete(ignore):
>>>>>>     return _mupdf.Memento_setIgnoreNewDelete(ignore)
       
    1: def Memento_malloc(s):
>>>>>>     return _mupdf.Memento_malloc(s)
       
    1: def Memento_realloc(arg1, s):
>>>>>>     return _mupdf.Memento_realloc(arg1, s)
       
    1: def Memento_free(arg1):
>>>>>>     return _mupdf.Memento_free(arg1)
       
    1: def Memento_calloc(arg1, arg2):
>>>>>>     return _mupdf.Memento_calloc(arg1, arg2)
       
    1: def Memento_strdup(arg1):
>>>>>>     return _mupdf.Memento_strdup(arg1)
       
    1: def Memento_info(addr):
>>>>>>     return _mupdf.Memento_info(addr)
       
    1: def Memento_listBlockInfo():
>>>>>>     return _mupdf.Memento_listBlockInfo()
       
    1: def Memento_blockInfo(blk):
>>>>>>     return _mupdf.Memento_blockInfo(blk)
       
    1: def Memento_takeByteRef(blk):
>>>>>>     return _mupdf.Memento_takeByteRef(blk)
       
    1: def Memento_dropByteRef(blk):
>>>>>>     return _mupdf.Memento_dropByteRef(blk)
       
    1: def Memento_takeShortRef(blk):
>>>>>>     return _mupdf.Memento_takeShortRef(blk)
       
    1: def Memento_dropShortRef(blk):
>>>>>>     return _mupdf.Memento_dropShortRef(blk)
       
    1: def Memento_takeIntRef(blk):
>>>>>>     return _mupdf.Memento_takeIntRef(blk)
       
    1: def Memento_dropIntRef(blk):
>>>>>>     return _mupdf.Memento_dropIntRef(blk)
       
    1: def Memento_takeRef(blk):
>>>>>>     return _mupdf.Memento_takeRef(blk)
       
    1: def Memento_dropRef(blk):
>>>>>>     return _mupdf.Memento_dropRef(blk)
       
    1: def Memento_adjustRef(blk, adjust):
>>>>>>     return _mupdf.Memento_adjustRef(blk, adjust)
       
    1: def Memento_reference(blk):
>>>>>>     return _mupdf.Memento_reference(blk)
       
    1: def Memento_checkPointerOrNull(blk):
>>>>>>     return _mupdf.Memento_checkPointerOrNull(blk)
       
    1: def Memento_checkBytePointerOrNull(blk):
>>>>>>     return _mupdf.Memento_checkBytePointerOrNull(blk)
       
    1: def Memento_checkShortPointerOrNull(blk):
>>>>>>     return _mupdf.Memento_checkShortPointerOrNull(blk)
       
    1: def Memento_checkIntPointerOrNull(blk):
>>>>>>     return _mupdf.Memento_checkIntPointerOrNull(blk)
       
    1: def Memento_startLeaking():
>>>>>>     return _mupdf.Memento_startLeaking()
       
    1: def Memento_stopLeaking():
>>>>>>     return _mupdf.Memento_stopLeaking()
       
    1: def Memento_sequence():
>>>>>>     return _mupdf.Memento_sequence()
       
    1: def Memento_squeezing():
>>>>>>     return _mupdf.Memento_squeezing()
       
    1: def Memento_fin():
>>>>>>     return _mupdf.Memento_fin()
       
    1: def Memento_bt():
>>>>>>     return _mupdf.Memento_bt()
    1: PATH_MAX = _mupdf.PATH_MAX
    1: FZ_PI = _mupdf.FZ_PI
    1: FZ_RADIAN = _mupdf.FZ_RADIAN
    1: FZ_DEGREE = _mupdf.FZ_DEGREE
    1: FZ_SQRT2 = _mupdf.FZ_SQRT2
    1: FZ_LN2 = _mupdf.FZ_LN2
    1: ARCH_HAS_NEON = _mupdf.ARCH_HAS_NEON
    1: r"""Spot architectures where we have optimisations."""
    1: ARCH_HAS_SSE = _mupdf.ARCH_HAS_SSE
    1: HAVE_SIGSETJMP = _mupdf.HAVE_SIGSETJMP
    1: r"""Some differences in libc can be smoothed over"""
    1: EOF = _mupdf.EOF
    1: SEEK_SET = _mupdf.SEEK_SET
    1: SEEK_CUR = _mupdf.SEEK_CUR
    1: SEEK_END = _mupdf.SEEK_END
    1: M_PI = _mupdf.M_PI
    2: class fz_point(object):
    1:     r"""fz_point is a point in a two-dimensional space."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     x = property(_mupdf.fz_point_x_get, _mupdf.fz_point_x_set)
    1:     y = property(_mupdf.fz_point_y_get, _mupdf.fz_point_y_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_point_swiginit(self, _mupdf.new_fz_point())
    1:     __swig_destroy__ = _mupdf.delete_fz_point
       
       # Register fz_point in _mupdf:
    1: _mupdf.fz_point_swigregister(fz_point)
    2: class fz_rect(object):
    1:     r"""
           fz_rect is a rectangle represented by two diagonally opposite
           corners at arbitrary coordinates.
       
           Rectangles are always axis-aligned with the X- and Y- axes. We
           wish to distinguish rectangles in 3 categories; infinite, finite,
           and invalid. Zero area rectangles are a sub-category of finite
           ones.
       
           For all valid rectangles, x0 <= x1 and y0 <= y1 in all cases.
           Infinite rectangles have x0 = y0 = FZ_MIN_INF_RECT,
           x1 = y1 = FZ_MAX_INF_RECT. For any non infinite valid rectangle,
           the area is defined as (x1 - x0) * (y1 - y0).
       
           To check for empty or infinite rectangles use fz_is_empty_rect
           and fz_is_infinite_rect. To check for valid rectangles use
           fz_is_valid_rect.
       
           We choose this representation, so that we can easily distinguish
           the difference between intersecting 2 valid rectangles and
           getting an invalid one, as opposed to getting a zero area one
           (which nonetheless has valid bounds within the plane).
       
           x0, y0: The top left corner.
       
           x1, y1: The bottom right corner.
       
           We choose FZ_{MIN,MAX}_INF_RECT to be the largest 32bit signed
           integer values that survive roundtripping to floats.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     x0 = property(_mupdf.fz_rect_x0_get, _mupdf.fz_rect_x0_set)
    1:     y0 = property(_mupdf.fz_rect_y0_get, _mupdf.fz_rect_y0_set)
    1:     x1 = property(_mupdf.fz_rect_x1_get, _mupdf.fz_rect_x1_set)
    1:     y1 = property(_mupdf.fz_rect_y1_get, _mupdf.fz_rect_y1_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_rect_swiginit(self, _mupdf.new_fz_rect())
    1:     __swig_destroy__ = _mupdf.delete_fz_rect
       
       # Register fz_rect in _mupdf:
    1: _mupdf.fz_rect_swigregister(fz_rect)
    2: class fz_irect(object):
    1:     r"""
           fz_irect is a rectangle using integers instead of floats.
       
           It's used in the draw device and for pixmap dimensions.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     x0 = property(_mupdf.fz_irect_x0_get, _mupdf.fz_irect_x0_set)
    1:     y0 = property(_mupdf.fz_irect_y0_get, _mupdf.fz_irect_y0_set)
    1:     x1 = property(_mupdf.fz_irect_x1_get, _mupdf.fz_irect_x1_set)
    1:     y1 = property(_mupdf.fz_irect_y1_get, _mupdf.fz_irect_y1_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_irect_swiginit(self, _mupdf.new_fz_irect())
    1:     __swig_destroy__ = _mupdf.delete_fz_irect
       
       # Register fz_irect in _mupdf:
    1: _mupdf.fz_irect_swigregister(fz_irect)
    2: class fz_matrix(object):
    1:     r"""
               fz_matrix is a row-major 3x3 matrix used for representing
               transformations of coordinates throughout MuPDF.
       
               Since all points reside in a two-dimensional space, one vector
               is always a constant unit vector; hence only some elements may
               vary in a matrix. Below is how the elements map between
               different representations.
       
           a b 0
               | c d 0 | normally represented as [ a b c d e f ].
               \ e f 1 /
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     a = property(_mupdf.fz_matrix_a_get, _mupdf.fz_matrix_a_set)
    1:     b = property(_mupdf.fz_matrix_b_get, _mupdf.fz_matrix_b_set)
    1:     c = property(_mupdf.fz_matrix_c_get, _mupdf.fz_matrix_c_set)
    1:     d = property(_mupdf.fz_matrix_d_get, _mupdf.fz_matrix_d_set)
    1:     e = property(_mupdf.fz_matrix_e_get, _mupdf.fz_matrix_e_set)
    1:     f = property(_mupdf.fz_matrix_f_get, _mupdf.fz_matrix_f_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_matrix_swiginit(self, _mupdf.new_fz_matrix())
    1:     __swig_destroy__ = _mupdf.delete_fz_matrix
       
       # Register fz_matrix in _mupdf:
    1: _mupdf.fz_matrix_swigregister(fz_matrix)
    1: cvar = _mupdf.cvar
    1: fz_unit_rect = cvar.fz_unit_rect
    1: fz_empty_rect = cvar.fz_empty_rect
    1: fz_empty_irect = cvar.fz_empty_irect
    1: fz_infinite_rect = cvar.fz_infinite_rect
    1: fz_infinite_irect = cvar.fz_infinite_irect
    1: fz_invalid_rect = cvar.fz_invalid_rect
    1: fz_invalid_irect = cvar.fz_invalid_irect
       
    2: class fz_quad(object):
    1:     r"""
           A representation for a region defined by 4 points.
       
           The significant difference between quads and rects is that
           the edges of quads are not axis aligned.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     ul = property(_mupdf.fz_quad_ul_get, _mupdf.fz_quad_ul_set)
    1:     ur = property(_mupdf.fz_quad_ur_get, _mupdf.fz_quad_ur_set)
    1:     ll = property(_mupdf.fz_quad_ll_get, _mupdf.fz_quad_ll_set)
    1:     lr = property(_mupdf.fz_quad_lr_get, _mupdf.fz_quad_lr_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_quad_swiginit(self, _mupdf.new_fz_quad())
    1:     __swig_destroy__ = _mupdf.delete_fz_quad
       
       # Register fz_quad in _mupdf:
    1: _mupdf.fz_quad_swigregister(fz_quad)
    1: fz_identity = cvar.fz_identity
       
    1: FZ_VERBOSE_EXCEPTIONS = _mupdf.FZ_VERBOSE_EXCEPTIONS
    2: class fz_alloc_context(object):
    1:     r"""Allocator structure; holds callbacks and private data pointer."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     user = property(_mupdf.fz_alloc_context_user_get, _mupdf.fz_alloc_context_user_set)
    1:     malloc = property(_mupdf.fz_alloc_context_malloc_get, _mupdf.fz_alloc_context_malloc_set)
    1:     realloc = property(_mupdf.fz_alloc_context_realloc_get, _mupdf.fz_alloc_context_realloc_set)
    1:     free = property(_mupdf.fz_alloc_context_free_get, _mupdf.fz_alloc_context_free_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_alloc_context_swiginit(self, _mupdf.new_fz_alloc_context())
    1:     __swig_destroy__ = _mupdf.delete_fz_alloc_context
       
       # Register fz_alloc_context in _mupdf:
    1: _mupdf.fz_alloc_context_swigregister(fz_alloc_context)
    1: fz_invalid_quad = cvar.fz_invalid_quad
    1: fz_infinite_quad = cvar.fz_infinite_quad
       
    1: FZ_ERROR_NONE = _mupdf.FZ_ERROR_NONE
    1: FZ_ERROR_GENERIC = _mupdf.FZ_ERROR_GENERIC
    1: FZ_ERROR_SYSTEM = _mupdf.FZ_ERROR_SYSTEM
    1: FZ_ERROR_LIBRARY = _mupdf.FZ_ERROR_LIBRARY
    1: FZ_ERROR_ARGUMENT = _mupdf.FZ_ERROR_ARGUMENT
    1: FZ_ERROR_LIMIT = _mupdf.FZ_ERROR_LIMIT
    1: FZ_ERROR_UNSUPPORTED = _mupdf.FZ_ERROR_UNSUPPORTED
    1: FZ_ERROR_FORMAT = _mupdf.FZ_ERROR_FORMAT
    1: FZ_ERROR_SYNTAX = _mupdf.FZ_ERROR_SYNTAX
    1: FZ_ERROR_TRYLATER = _mupdf.FZ_ERROR_TRYLATER
    1: FZ_ERROR_ABORT = _mupdf.FZ_ERROR_ABORT
    1: FZ_ERROR_REPAIRED = _mupdf.FZ_ERROR_REPAIRED
    2: class fz_locks_context(object):
    1:     r"""
           Locking functions
       
           MuPDF is kept deliberately free of any knowledge of particular
           threading systems. As such, in order for safe multi-threaded
           operation, we rely on callbacks to client provided functions.
       
           A client is expected to provide FZ_LOCK_MAX number of mutexes,
           and a function to lock/unlock each of them. These may be
           recursive mutexes, but do not have to be.
       
           If a client does not intend to use multiple threads, then it
           may pass NULL instead of a lock structure.
       
           In order to avoid deadlocks, we have one simple rule
           internally as to how we use locks: We can never take lock n
           when we already hold any lock i, where 0 <= i <= n. In order
           to verify this, we have some debugging code, that can be
           enabled by defining FITZ_DEBUG_LOCKING.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     user = property(_mupdf.fz_locks_context_user_get, _mupdf.fz_locks_context_user_set)
    1:     lock = property(_mupdf.fz_locks_context_lock_get, _mupdf.fz_locks_context_lock_set)
    1:     unlock = property(_mupdf.fz_locks_context_unlock_get, _mupdf.fz_locks_context_unlock_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_locks_context_swiginit(self, _mupdf.new_fz_locks_context())
    1:     __swig_destroy__ = _mupdf.delete_fz_locks_context
       
       # Register fz_locks_context in _mupdf:
    1: _mupdf.fz_locks_context_swigregister(fz_locks_context)
    1: FZ_LOCK_ALLOC = _mupdf.FZ_LOCK_ALLOC
    1: FZ_LOCK_FREETYPE = _mupdf.FZ_LOCK_FREETYPE
    1: FZ_LOCK_GLYPHCACHE = _mupdf.FZ_LOCK_GLYPHCACHE
    1: FZ_LOCK_MAX = _mupdf.FZ_LOCK_MAX
    1: FZ_STORE_UNLIMITED = _mupdf.FZ_STORE_UNLIMITED
    1: FZ_STORE_DEFAULT = _mupdf.FZ_STORE_DEFAULT
    2: class fz_string(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_string_refs_get, _mupdf.fz_string_refs_set)
    1:     str = property(_mupdf.fz_string_str_get, _mupdf.fz_string_str_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_string_swiginit(self, _mupdf.new_fz_string())
    1:     __swig_destroy__ = _mupdf.delete_fz_string
       
       # Register fz_string in _mupdf:
    1: _mupdf.fz_string_swigregister(fz_string)
    1: FZ_JMPBUF_ALIGN = _mupdf.FZ_JMPBUF_ALIGN
    2: class fz_error_context(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     top = property(_mupdf.fz_error_context_top_get, _mupdf.fz_error_context_top_set)
    1:     stack = property(_mupdf.fz_error_context_stack_get, _mupdf.fz_error_context_stack_set)
    1:     padding = property(_mupdf.fz_error_context_padding_get, _mupdf.fz_error_context_padding_set)
    1:     stack_base = property(_mupdf.fz_error_context_stack_base_get, _mupdf.fz_error_context_stack_base_set)
    1:     errcode = property(_mupdf.fz_error_context_errcode_get, _mupdf.fz_error_context_errcode_set)
    1:     errnum = property(_mupdf.fz_error_context_errnum_get, _mupdf.fz_error_context_errnum_set)
    1:     print_user = property(_mupdf.fz_error_context_print_user_get, _mupdf.fz_error_context_print_user_set)
    1:     _print = property(_mupdf.fz_error_context__print_get, _mupdf.fz_error_context__print_set)
    1:     message = property(_mupdf.fz_error_context_message_get, _mupdf.fz_error_context_message_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_error_context_swiginit(self, _mupdf.new_fz_error_context())
    1:     __swig_destroy__ = _mupdf.delete_fz_error_context
       
       # Register fz_error_context in _mupdf:
    1: _mupdf.fz_error_context_swigregister(fz_error_context)
    2: class fz_warn_context(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     print_user = property(_mupdf.fz_warn_context_print_user_get, _mupdf.fz_warn_context_print_user_set)
    1:     _print = property(_mupdf.fz_warn_context__print_get, _mupdf.fz_warn_context__print_set)
    1:     count = property(_mupdf.fz_warn_context_count_get, _mupdf.fz_warn_context_count_set)
    1:     message = property(_mupdf.fz_warn_context_message_get, _mupdf.fz_warn_context_message_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_warn_context_swiginit(self, _mupdf.new_fz_warn_context())
    1:     __swig_destroy__ = _mupdf.delete_fz_warn_context
       
       # Register fz_warn_context in _mupdf:
    1: _mupdf.fz_warn_context_swigregister(fz_warn_context)
    2: class fz_aa_context(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     hscale = property(_mupdf.fz_aa_context_hscale_get, _mupdf.fz_aa_context_hscale_set)
    1:     vscale = property(_mupdf.fz_aa_context_vscale_get, _mupdf.fz_aa_context_vscale_set)
    1:     scale = property(_mupdf.fz_aa_context_scale_get, _mupdf.fz_aa_context_scale_set)
    1:     bits = property(_mupdf.fz_aa_context_bits_get, _mupdf.fz_aa_context_bits_set)
    1:     text_bits = property(_mupdf.fz_aa_context_text_bits_get, _mupdf.fz_aa_context_text_bits_set)
    1:     min_line_width = property(_mupdf.fz_aa_context_min_line_width_get, _mupdf.fz_aa_context_min_line_width_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_aa_context_swiginit(self, _mupdf.new_fz_aa_context())
    1:     __swig_destroy__ = _mupdf.delete_fz_aa_context
       
       # Register fz_aa_context in _mupdf:
    1: _mupdf.fz_aa_context_swigregister(fz_aa_context)
    1: FZ_ACTIVITY_NEW_DOC = _mupdf.FZ_ACTIVITY_NEW_DOC
    1: FZ_ACTIVITY_SHUTDOWN = _mupdf.FZ_ACTIVITY_SHUTDOWN
    2: class fz_activity_context(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     opaque = property(_mupdf.fz_activity_context_opaque_get, _mupdf.fz_activity_context_opaque_set)
    1:     activity = property(_mupdf.fz_activity_context_activity_get, _mupdf.fz_activity_context_activity_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_activity_context_swiginit(self, _mupdf.new_fz_activity_context())
    1:     __swig_destroy__ = _mupdf.delete_fz_activity_context
       
       # Register fz_activity_context in _mupdf:
    1: _mupdf.fz_activity_context_swigregister(fz_activity_context)
    2: class fz_context(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     user = property(_mupdf.fz_context_user_get, _mupdf.fz_context_user_set)
    1:     master = property(_mupdf.fz_context_master_get, _mupdf.fz_context_master_set)
    1:     context_count = property(_mupdf.fz_context_context_count_get, _mupdf.fz_context_context_count_set)
    1:     next_document_id = property(_mupdf.fz_context_next_document_id_get, _mupdf.fz_context_next_document_id_set)
    1:     alloc = property(_mupdf.fz_context_alloc_get, _mupdf.fz_context_alloc_set)
    1:     locks = property(_mupdf.fz_context_locks_get, _mupdf.fz_context_locks_set)
    1:     error = property(_mupdf.fz_context_error_get, _mupdf.fz_context_error_set)
    1:     warn = property(_mupdf.fz_context_warn_get, _mupdf.fz_context_warn_set)
    1:     activity = property(_mupdf.fz_context_activity_get, _mupdf.fz_context_activity_set)
    1:     aa = property(_mupdf.fz_context_aa_get, _mupdf.fz_context_aa_set)
    1:     seed48 = property(_mupdf.fz_context_seed48_get, _mupdf.fz_context_seed48_set)
    1:     icc_enabled = property(_mupdf.fz_context_icc_enabled_get, _mupdf.fz_context_icc_enabled_set)
    1:     throw_on_repair = property(_mupdf.fz_context_throw_on_repair_get, _mupdf.fz_context_throw_on_repair_set)
    1:     handler = property(_mupdf.fz_context_handler_get, _mupdf.fz_context_handler_set)
    1:     archive = property(_mupdf.fz_context_archive_get, _mupdf.fz_context_archive_set)
    1:     style = property(_mupdf.fz_context_style_get, _mupdf.fz_context_style_set)
    1:     tuning = property(_mupdf.fz_context_tuning_get, _mupdf.fz_context_tuning_set)
    1:     stddbg = property(_mupdf.fz_context_stddbg_get, _mupdf.fz_context_stddbg_set)
    1:     font = property(_mupdf.fz_context_font_get, _mupdf.fz_context_font_set)
    1:     colorspace = property(_mupdf.fz_context_colorspace_get, _mupdf.fz_context_colorspace_set)
    1:     store = property(_mupdf.fz_context_store_get, _mupdf.fz_context_store_set)
    1:     glyph_cache = property(_mupdf.fz_context_glyph_cache_get, _mupdf.fz_context_glyph_cache_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_context_swiginit(self, _mupdf.new_fz_context())
    1:     __swig_destroy__ = _mupdf.delete_fz_context
       
       # Register fz_context in _mupdf:
    1: _mupdf.fz_context_swigregister(fz_context)
    2: class fz_buffer(object):
    1:     r"""
           fz_buffer is a wrapper around a dynamically allocated array of
           bytes.
       
           Buffers have a capacity (the number of bytes storage immediately
           available) and a current size.
       
           The contents of the structure are considered implementation
           details and are subject to change. Users should use the accessor
           functions in preference.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_buffer_refs_get, _mupdf.fz_buffer_refs_set)
    1:     data = property(_mupdf.fz_buffer_data_get, _mupdf.fz_buffer_data_set)
    1:     cap = property(_mupdf.fz_buffer_cap_get, _mupdf.fz_buffer_cap_set)
    1:     len = property(_mupdf.fz_buffer_len_get, _mupdf.fz_buffer_len_set)
    1:     unused_bits = property(_mupdf.fz_buffer_unused_bits_get, _mupdf.fz_buffer_unused_bits_set)
    1:     shared = property(_mupdf.fz_buffer_shared_get, _mupdf.fz_buffer_shared_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_buffer_swiginit(self, _mupdf.new_fz_buffer())
    1:     __swig_destroy__ = _mupdf.delete_fz_buffer
       
       # Register fz_buffer in _mupdf:
    1: _mupdf.fz_buffer_swigregister(fz_buffer)
    1: FZ_REPLACEMENT_CHARACTER = _mupdf.FZ_REPLACEMENT_CHARACTER
    1: FZ_UTFMAX = _mupdf.FZ_UTFMAX
    2: class fz_stream(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_stream_refs_get, _mupdf.fz_stream_refs_set)
    1:     error = property(_mupdf.fz_stream_error_get, _mupdf.fz_stream_error_set)
    1:     eof = property(_mupdf.fz_stream_eof_get, _mupdf.fz_stream_eof_set)
    1:     progressive = property(_mupdf.fz_stream_progressive_get, _mupdf.fz_stream_progressive_set)
    1:     pos = property(_mupdf.fz_stream_pos_get, _mupdf.fz_stream_pos_set)
    1:     avail = property(_mupdf.fz_stream_avail_get, _mupdf.fz_stream_avail_set)
    1:     bits = property(_mupdf.fz_stream_bits_get, _mupdf.fz_stream_bits_set)
    1:     rp = property(_mupdf.fz_stream_rp_get, _mupdf.fz_stream_rp_set)
    1:     wp = property(_mupdf.fz_stream_wp_get, _mupdf.fz_stream_wp_set)
    1:     state = property(_mupdf.fz_stream_state_get, _mupdf.fz_stream_state_set)
    1:     next = property(_mupdf.fz_stream_next_get, _mupdf.fz_stream_next_set)
    1:     drop = property(_mupdf.fz_stream_drop_get, _mupdf.fz_stream_drop_set)
    1:     seek = property(_mupdf.fz_stream_seek_get, _mupdf.fz_stream_seek_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_stream_swiginit(self, _mupdf.new_fz_stream())
    1:     __swig_destroy__ = _mupdf.delete_fz_stream
       
       # Register fz_stream in _mupdf:
    1: _mupdf.fz_stream_swigregister(fz_stream)
    2: class fz_output(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     state = property(_mupdf.fz_output_state_get, _mupdf.fz_output_state_set)
    1:     write = property(_mupdf.fz_output_write_get, _mupdf.fz_output_write_set)
    1:     seek = property(_mupdf.fz_output_seek_get, _mupdf.fz_output_seek_set)
    1:     tell = property(_mupdf.fz_output_tell_get, _mupdf.fz_output_tell_set)
    1:     close = property(_mupdf.fz_output_close_get, _mupdf.fz_output_close_set)
    1:     drop = property(_mupdf.fz_output_drop_get, _mupdf.fz_output_drop_set)
    1:     reset = property(_mupdf.fz_output_reset_get, _mupdf.fz_output_reset_set)
    1:     as_stream = property(_mupdf.fz_output_as_stream_get, _mupdf.fz_output_as_stream_set)
    1:     truncate = property(_mupdf.fz_output_truncate_get, _mupdf.fz_output_truncate_set)
    1:     closed = property(_mupdf.fz_output_closed_get, _mupdf.fz_output_closed_set)
    1:     bp = property(_mupdf.fz_output_bp_get, _mupdf.fz_output_bp_set)
    1:     wp = property(_mupdf.fz_output_wp_get, _mupdf.fz_output_wp_set)
    1:     ep = property(_mupdf.fz_output_ep_get, _mupdf.fz_output_ep_set)
    1:     buffered = property(_mupdf.fz_output_buffered_get, _mupdf.fz_output_buffered_set)
    1:     bits = property(_mupdf.fz_output_bits_get, _mupdf.fz_output_bits_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_output_swiginit(self, _mupdf.new_fz_output())
    1:     __swig_destroy__ = _mupdf.delete_fz_output
       
       # Register fz_output in _mupdf:
    1: _mupdf.fz_output_swigregister(fz_output)
    2: class fz_md5(object):
    1:     r"""
           Structure definition is public to enable stack
           based allocation. Do not access the members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     lo = property(_mupdf.fz_md5_lo_get, _mupdf.fz_md5_lo_set)
    1:     hi = property(_mupdf.fz_md5_hi_get, _mupdf.fz_md5_hi_set)
    1:     a = property(_mupdf.fz_md5_a_get, _mupdf.fz_md5_a_set)
    1:     b = property(_mupdf.fz_md5_b_get, _mupdf.fz_md5_b_set)
    1:     c = property(_mupdf.fz_md5_c_get, _mupdf.fz_md5_c_set)
    1:     d = property(_mupdf.fz_md5_d_get, _mupdf.fz_md5_d_set)
    1:     buffer = property(_mupdf.fz_md5_buffer_get, _mupdf.fz_md5_buffer_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_md5_swiginit(self, _mupdf.new_fz_md5())
    1:     __swig_destroy__ = _mupdf.delete_fz_md5
       
       # Register fz_md5 in _mupdf:
    1: _mupdf.fz_md5_swigregister(fz_md5)
    2: class fz_sha256(object):
    1:     r"""
           Structure definition is public to enable stack
           based allocation. Do not access the members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     state = property(_mupdf.fz_sha256_state_get, _mupdf.fz_sha256_state_set)
    1:     count = property(_mupdf.fz_sha256_count_get, _mupdf.fz_sha256_count_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_sha256_swiginit(self, _mupdf.new_fz_sha256())
    1:     __swig_destroy__ = _mupdf.delete_fz_sha256
       
       # Register fz_sha256 in _mupdf:
    1: _mupdf.fz_sha256_swigregister(fz_sha256)
    2: class fz_sha512(object):
    1:     r"""
           Structure definition is public to enable stack
           based allocation. Do not access the members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     state = property(_mupdf.fz_sha512_state_get, _mupdf.fz_sha512_state_set)
    1:     count = property(_mupdf.fz_sha512_count_get, _mupdf.fz_sha512_count_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_sha512_swiginit(self, _mupdf.new_fz_sha512())
    1:     __swig_destroy__ = _mupdf.delete_fz_sha512
       
       # Register fz_sha512 in _mupdf:
    1: _mupdf.fz_sha512_swigregister(fz_sha512)
    2: class fz_arc4(object):
    1:     r"""
           Structure definition is public to enable stack
           based allocation. Do not access the members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     x = property(_mupdf.fz_arc4_x_get, _mupdf.fz_arc4_x_set)
    1:     y = property(_mupdf.fz_arc4_y_get, _mupdf.fz_arc4_y_set)
    1:     state = property(_mupdf.fz_arc4_state_get, _mupdf.fz_arc4_state_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_arc4_swiginit(self, _mupdf.new_fz_arc4())
    1:     __swig_destroy__ = _mupdf.delete_fz_arc4
       
       # Register fz_arc4 in _mupdf:
    1: _mupdf.fz_arc4_swigregister(fz_arc4)
    2: class fz_aes(object):
    1:     r"""
           Structure definitions are public to enable stack
           based allocation. Do not access the members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     nr = property(_mupdf.fz_aes_nr_get, _mupdf.fz_aes_nr_set)
    1:     rk = property(_mupdf.fz_aes_rk_get, _mupdf.fz_aes_rk_set)
    1:     buf = property(_mupdf.fz_aes_buf_get, _mupdf.fz_aes_buf_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_aes_swiginit(self, _mupdf.new_fz_aes())
    1:     __swig_destroy__ = _mupdf.delete_fz_aes
       
       # Register fz_aes in _mupdf:
    1: _mupdf.fz_aes_swigregister(fz_aes)
    1: FZ_AES_DECRYPT = _mupdf.FZ_AES_DECRYPT
    1: FZ_AES_ENCRYPT = _mupdf.FZ_AES_ENCRYPT
    2: class fz_getopt_long_options(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     option = property(_mupdf.fz_getopt_long_options_option_get, _mupdf.fz_getopt_long_options_option_set)
    1:     flag = property(_mupdf.fz_getopt_long_options_flag_get, _mupdf.fz_getopt_long_options_flag_set)
    1:     opaque = property(_mupdf.fz_getopt_long_options_opaque_get, _mupdf.fz_getopt_long_options_opaque_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_getopt_long_options_swiginit(self, _mupdf.new_fz_getopt_long_options())
    1:     __swig_destroy__ = _mupdf.delete_fz_getopt_long_options
       
       # Register fz_getopt_long_options in _mupdf:
    1: _mupdf.fz_getopt_long_options_swigregister(fz_getopt_long_options)
    1: FZ_HASH_TABLE_KEY_LENGTH = _mupdf.FZ_HASH_TABLE_KEY_LENGTH
    1: FZ_BIDI_LTR = _mupdf.FZ_BIDI_LTR
    1: FZ_BIDI_RTL = _mupdf.FZ_BIDI_RTL
    1: FZ_BIDI_NEUTRAL = _mupdf.FZ_BIDI_NEUTRAL
    1: FZ_BIDI_CLASSIFY_WHITE_SPACE = _mupdf.FZ_BIDI_CLASSIFY_WHITE_SPACE
    1: FZ_BIDI_REPLACE_TAB = _mupdf.FZ_BIDI_REPLACE_TAB
    2: class fz_archive_handler(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     recognize = property(_mupdf.fz_archive_handler_recognize_get, _mupdf.fz_archive_handler_recognize_set)
    1:     open = property(_mupdf.fz_archive_handler_open_get, _mupdf.fz_archive_handler_open_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_archive_handler_swiginit(self, _mupdf.new_fz_archive_handler())
    1:     __swig_destroy__ = _mupdf.delete_fz_archive_handler
       
       # Register fz_archive_handler in _mupdf:
    1: _mupdf.fz_archive_handler_swigregister(fz_archive_handler)
    2: class fz_archive(object):
    1:     r"""Implementation details: Subject to change."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_archive_refs_get, _mupdf.fz_archive_refs_set)
    1:     file = property(_mupdf.fz_archive_file_get, _mupdf.fz_archive_file_set)
    1:     format = property(_mupdf.fz_archive_format_get, _mupdf.fz_archive_format_set)
    1:     drop_archive = property(_mupdf.fz_archive_drop_archive_get, _mupdf.fz_archive_drop_archive_set)
    1:     count_entries = property(_mupdf.fz_archive_count_entries_get, _mupdf.fz_archive_count_entries_set)
    1:     list_entry = property(_mupdf.fz_archive_list_entry_get, _mupdf.fz_archive_list_entry_set)
    1:     has_entry = property(_mupdf.fz_archive_has_entry_get, _mupdf.fz_archive_has_entry_set)
    1:     read_entry = property(_mupdf.fz_archive_read_entry_get, _mupdf.fz_archive_read_entry_set)
    1:     open_entry = property(_mupdf.fz_archive_open_entry_get, _mupdf.fz_archive_open_entry_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_archive_swiginit(self, _mupdf.new_fz_archive())
    1:     __swig_destroy__ = _mupdf.delete_fz_archive
       
       # Register fz_archive in _mupdf:
    1: _mupdf.fz_archive_swigregister(fz_archive)
    1: fz_libarchive_archive_handler = cvar.fz_libarchive_archive_handler
       
    1: FZ_JSON_NULL = _mupdf.FZ_JSON_NULL
    1: FZ_JSON_TRUE = _mupdf.FZ_JSON_TRUE
    1: FZ_JSON_FALSE = _mupdf.FZ_JSON_FALSE
    1: FZ_JSON_NUMBER = _mupdf.FZ_JSON_NUMBER
    1: FZ_JSON_STRING = _mupdf.FZ_JSON_STRING
    1: FZ_JSON_ARRAY = _mupdf.FZ_JSON_ARRAY
    1: FZ_JSON_OBJECT = _mupdf.FZ_JSON_OBJECT
    2: class fz_json(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     type = property(_mupdf.fz_json_type_get, _mupdf.fz_json_type_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_json_swiginit(self, _mupdf.new_fz_json())
    1:     __swig_destroy__ = _mupdf.delete_fz_json
       
       # Register fz_json in _mupdf:
    1: _mupdf.fz_json_swigregister(fz_json)
    2: class fz_json_array(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     value = property(_mupdf.fz_json_array_value_get, _mupdf.fz_json_array_value_set)
    1:     next = property(_mupdf.fz_json_array_next_get, _mupdf.fz_json_array_next_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_json_array_swiginit(self, _mupdf.new_fz_json_array())
    1:     __swig_destroy__ = _mupdf.delete_fz_json_array
       
       # Register fz_json_array in _mupdf:
    1: _mupdf.fz_json_array_swigregister(fz_json_array)
    2: class fz_json_object(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     key = property(_mupdf.fz_json_object_key_get, _mupdf.fz_json_object_key_set)
    1:     value = property(_mupdf.fz_json_object_value_get, _mupdf.fz_json_object_value_set)
    1:     next = property(_mupdf.fz_json_object_next_get, _mupdf.fz_json_object_next_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_json_object_swiginit(self, _mupdf.new_fz_json_object())
    1:     __swig_destroy__ = _mupdf.delete_fz_json_object
       
       # Register fz_json_object in _mupdf:
    1: _mupdf.fz_json_object_swigregister(fz_json_object)
    2: class fz_location(object):
    1:     r"""
           Locations within the document are referred to in terms of
           chapter and page, rather than just a page number. For some
           documents (such as epub documents with large numbers of pages
           broken into many chapters) this can make navigation much faster
           as only the required chapter needs to be decoded at a time.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     chapter = property(_mupdf.fz_location_chapter_get, _mupdf.fz_location_chapter_set)
    1:     page = property(_mupdf.fz_location_page_get, _mupdf.fz_location_page_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_location_swiginit(self, _mupdf.new_fz_location())
    1:     __swig_destroy__ = _mupdf.delete_fz_location
       
       # Register fz_location in _mupdf:
    1: _mupdf.fz_location_swigregister(fz_location)
    2: class fz_storable(object):
    1:     r"""
           Any storable object should include an fz_storable structure
           at the start (by convention at least) of their structure.
           (Unless it starts with an fz_key_storable, see below).
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_storable_refs_get, _mupdf.fz_storable_refs_set)
    1:     drop = property(_mupdf.fz_storable_drop_get, _mupdf.fz_storable_drop_set)
    1:     droppable = property(_mupdf.fz_storable_droppable_get, _mupdf.fz_storable_droppable_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_storable_swiginit(self, _mupdf.new_fz_storable())
    1:     __swig_destroy__ = _mupdf.delete_fz_storable
       
       # Register fz_storable in _mupdf:
    1: _mupdf.fz_storable_swigregister(fz_storable)
    2: class fz_key_storable(object):
    1:     r"""
           Any storable object that can appear in the key of another
           storable object should include an fz_key_storable structure
           at the start (by convention at least) of their structure.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     storable = property(_mupdf.fz_key_storable_storable_get, _mupdf.fz_key_storable_storable_set)
    1:     store_key_refs = property(_mupdf.fz_key_storable_store_key_refs_get, _mupdf.fz_key_storable_store_key_refs_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_key_storable_swiginit(self, _mupdf.new_fz_key_storable())
    1:     __swig_destroy__ = _mupdf.delete_fz_key_storable
       
       # Register fz_key_storable in _mupdf:
    1: _mupdf.fz_key_storable_swigregister(fz_key_storable)
    2: class fz_store_hash(object):
    1:     r"""
           The store can be seen as a dictionary that maps keys to
           fz_storable values. In order to allow keys of different types to
           be stored, we have a structure full of functions for each key
           'type'; this fz_store_type pointer is stored with each key, and
           tells the store how to perform certain operations (like taking/
           dropping a reference, comparing two keys, outputting details for
           debugging etc).
       
           The store uses a hash table internally for speed where possible.
           In order for this to work, we need a mechanism for turning a
           generic 'key' into 'a hashable string'. For this purpose the
           type structure contains a make_hash_key function pointer that
           maps from a void * to a fz_store_hash structure. If
           make_hash_key function returns 0, then the key is determined not
           to be hashable, and the value is not stored in the hash table.
       
           Some objects can be used both as values within the store, and as
           a component of keys within the store. We refer to these objects
           as "key storable" objects. In this case, we need to take
           additional care to ensure that we do not end up keeping an item
           within the store, purely because its value is referred to by
           another key in the store.
       
           An example of this are fz_images in PDF files. Each fz_image is
           placed into the     store to enable it to be easily reused. When the
           image is rendered, a pixmap is generated from the image, and the
           pixmap is placed into the store so it can be reused on
           subsequent renders. The image forms part of the key for the
           pixmap.
       
           When we close the pdf document (and any associated pages/display
           lists etc), we drop the images from the store. This may leave us
           in the position of the images having non-zero reference counts
           purely because they are used as part of the keys for the
           pixmaps.
       
           We therefore use special reference counting functions to keep
           track of these "key storable" items, and hence store the number
           of references to these items that are used in keys.
       
           When the number of references to an object == the number of
           references to an object from keys in the store, we know that we
           can remove all the items which have that object as part of the
           key. This is done by running a pass over the store, 'reaping'
           those items.
       
           Reap passes are slower than we would like as they touch every
           item in the store. We therefore provide a way to 'batch' such
           reap passes together, using fz_defer_reap_start/
           fz_defer_reap_end to bracket a region in which many may be
           triggered.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     drop = property(_mupdf.fz_store_hash_drop_get, _mupdf.fz_store_hash_drop_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_store_hash_swiginit(self, _mupdf.new_fz_store_hash())
    1:     __swig_destroy__ = _mupdf.delete_fz_store_hash
       
       # Register fz_store_hash in _mupdf:
    1: _mupdf.fz_store_hash_swigregister(fz_store_hash)
    2: class fz_store_type(object):
    1:     r"""
           Every type of object to be placed into the store defines an
           fz_store_type. This contains the pointers to functions to
           make hashes, manipulate keys, and check for needing reaping.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     name = property(_mupdf.fz_store_type_name_get, _mupdf.fz_store_type_name_set)
    1:     make_hash_key = property(_mupdf.fz_store_type_make_hash_key_get, _mupdf.fz_store_type_make_hash_key_set)
    1:     keep_key = property(_mupdf.fz_store_type_keep_key_get, _mupdf.fz_store_type_keep_key_set)
    1:     drop_key = property(_mupdf.fz_store_type_drop_key_get, _mupdf.fz_store_type_drop_key_set)
    1:     cmp_key = property(_mupdf.fz_store_type_cmp_key_get, _mupdf.fz_store_type_cmp_key_set)
    1:     format_key = property(_mupdf.fz_store_type_format_key_get, _mupdf.fz_store_type_format_key_set)
    1:     needs_reap = property(_mupdf.fz_store_type_needs_reap_get, _mupdf.fz_store_type_needs_reap_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_store_type_swiginit(self, _mupdf.new_fz_store_type())
    1:     __swig_destroy__ = _mupdf.delete_fz_store_type
       
       # Register fz_store_type in _mupdf:
    1: _mupdf.fz_store_type_swigregister(fz_store_type)
    1: FZ_RI_PERCEPTUAL = _mupdf.FZ_RI_PERCEPTUAL
    1: FZ_RI_RELATIVE_COLORIMETRIC = _mupdf.FZ_RI_RELATIVE_COLORIMETRIC
    1: FZ_RI_SATURATION = _mupdf.FZ_RI_SATURATION
    1: FZ_RI_ABSOLUTE_COLORIMETRIC = _mupdf.FZ_RI_ABSOLUTE_COLORIMETRIC
    2: class fz_color_params(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     ri = property(_mupdf.fz_color_params_ri_get, _mupdf.fz_color_params_ri_set)
    1:     bp = property(_mupdf.fz_color_params_bp_get, _mupdf.fz_color_params_bp_set)
    1:     op = property(_mupdf.fz_color_params_op_get, _mupdf.fz_color_params_op_set)
    1:     opm = property(_mupdf.fz_color_params_opm_get, _mupdf.fz_color_params_opm_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_color_params_swiginit(self, _mupdf.new_fz_color_params())
    1:     __swig_destroy__ = _mupdf.delete_fz_color_params
       
       # Register fz_color_params in _mupdf:
    1: _mupdf.fz_color_params_swigregister(fz_color_params)
    1: FZ_MAX_COLORS = _mupdf.FZ_MAX_COLORS
    1: FZ_COLORSPACE_IS_DEVICE = _mupdf.FZ_COLORSPACE_IS_DEVICE
    1: FZ_COLORSPACE_IS_ICC = _mupdf.FZ_COLORSPACE_IS_ICC
    1: FZ_COLORSPACE_HAS_CMYK = _mupdf.FZ_COLORSPACE_HAS_CMYK
    1: FZ_COLORSPACE_HAS_SPOTS = _mupdf.FZ_COLORSPACE_HAS_SPOTS
    1: FZ_COLORSPACE_HAS_CMYK_AND_SPOTS = _mupdf.FZ_COLORSPACE_HAS_CMYK_AND_SPOTS
    2: class fz_default_colorspaces(object):
    1:     r"""Structure to hold default colorspaces."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_default_colorspaces_refs_get, _mupdf.fz_default_colorspaces_refs_set)
    1:     gray = property(_mupdf.fz_default_colorspaces_gray_get, _mupdf.fz_default_colorspaces_gray_set)
    1:     rgb = property(_mupdf.fz_default_colorspaces_rgb_get, _mupdf.fz_default_colorspaces_rgb_set)
    1:     cmyk = property(_mupdf.fz_default_colorspaces_cmyk_get, _mupdf.fz_default_colorspaces_cmyk_set)
    1:     oi = property(_mupdf.fz_default_colorspaces_oi_get, _mupdf.fz_default_colorspaces_oi_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_default_colorspaces_swiginit(self, _mupdf.new_fz_default_colorspaces())
    1:     __swig_destroy__ = _mupdf.delete_fz_default_colorspaces
       
       # Register fz_default_colorspaces in _mupdf:
    1: _mupdf.fz_default_colorspaces_swigregister(fz_default_colorspaces)
    1: fz_default_color_params = cvar.fz_default_color_params
       
    2: class fz_colorspace(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     key_storable = property(_mupdf.fz_colorspace_key_storable_get, _mupdf.fz_colorspace_key_storable_set)
    1:     type = property(_mupdf.fz_colorspace_type_get, _mupdf.fz_colorspace_type_set)
    1:     flags = property(_mupdf.fz_colorspace_flags_get, _mupdf.fz_colorspace_flags_set)
    1:     n = property(_mupdf.fz_colorspace_n_get, _mupdf.fz_colorspace_n_set)
    1:     name = property(_mupdf.fz_colorspace_name_get, _mupdf.fz_colorspace_name_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_colorspace_swiginit(self, _mupdf.new_fz_colorspace())
    1:     __swig_destroy__ = _mupdf.delete_fz_colorspace
       
       # Register fz_colorspace in _mupdf:
    1: _mupdf.fz_colorspace_swigregister(fz_colorspace)
    1: FZ_MAX_SEPARATIONS = _mupdf.FZ_MAX_SEPARATIONS
    1: FZ_SEPARATION_COMPOSITE = _mupdf.FZ_SEPARATION_COMPOSITE
    1: FZ_SEPARATION_SPOT = _mupdf.FZ_SEPARATION_SPOT
    1: FZ_SEPARATION_DISABLED = _mupdf.FZ_SEPARATION_DISABLED
    2: class fz_pixmap(object):
    1:     r"""
           Pixmaps represent a set of pixels for a 2 dimensional region of
           a plane. Each pixel has n components per pixel. The components
           are in the order process-components, spot-colors, alpha, where
           there can be 0 of any of those types. The data is in
           premultiplied alpha when rendering, but non-premultiplied for
           colorspace conversions and rescaling.
       
           x, y: The minimum x and y coord of the region in pixels.
       
           w, h: The width and height of the region in pixels.
       
           n: The number of color components in the image.
               n = num composite colors + num spots + num alphas
       
           s: The number of spot channels in the image.
       
           alpha: 0 for no alpha, 1 for alpha present.
       
           flags: flag bits.
               Bit 0: If set, draw the image with linear interpolation.
               Bit 1: If set, free the samples buffer when the pixmap
               is destroyed.
       
           stride: The byte offset from the data for any given pixel
           to the data for the same pixel on the row below.
       
           seps: NULL, or a pointer to a separations structure. If NULL,
           s should be 0.
       
           xres, yres: Image resolution in dpi. Default is 96 dpi.
       
           colorspace: Pointer to a colorspace object describing the
           colorspace the pixmap is in. If NULL, the image is a mask.
       
           samples: Pointer to the first byte of the pixmap sample data.
           This is typically a simple block of memory w * h * n bytes of
           memory in which the components are stored linearly, but with the
           use of appropriate stride values, scanlines can be stored in
           different orders, and have different amounts of padding. The
           first n bytes are components 0 to n-1 for the pixel at (x,y).
           Each successive n bytes gives another pixel in scanline order
           as we move across the line. The start of each scanline is offset
           the start of the previous one by stride bytes.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     storable = property(_mupdf.fz_pixmap_storable_get, _mupdf.fz_pixmap_storable_set)
    1:     x = property(_mupdf.fz_pixmap_x_get, _mupdf.fz_pixmap_x_set)
    1:     y = property(_mupdf.fz_pixmap_y_get, _mupdf.fz_pixmap_y_set)
    1:     w = property(_mupdf.fz_pixmap_w_get, _mupdf.fz_pixmap_w_set)
    1:     h = property(_mupdf.fz_pixmap_h_get, _mupdf.fz_pixmap_h_set)
    1:     n = property(_mupdf.fz_pixmap_n_get, _mupdf.fz_pixmap_n_set)
    1:     s = property(_mupdf.fz_pixmap_s_get, _mupdf.fz_pixmap_s_set)
    1:     alpha = property(_mupdf.fz_pixmap_alpha_get, _mupdf.fz_pixmap_alpha_set)
    1:     flags = property(_mupdf.fz_pixmap_flags_get, _mupdf.fz_pixmap_flags_set)
    1:     stride = property(_mupdf.fz_pixmap_stride_get, _mupdf.fz_pixmap_stride_set)
    1:     seps = property(_mupdf.fz_pixmap_seps_get, _mupdf.fz_pixmap_seps_set)
    1:     xres = property(_mupdf.fz_pixmap_xres_get, _mupdf.fz_pixmap_xres_set)
    1:     yres = property(_mupdf.fz_pixmap_yres_get, _mupdf.fz_pixmap_yres_set)
    1:     colorspace = property(_mupdf.fz_pixmap_colorspace_get, _mupdf.fz_pixmap_colorspace_set)
    1:     samples = property(_mupdf.fz_pixmap_samples_get, _mupdf.fz_pixmap_samples_set)
    1:     underlying = property(_mupdf.fz_pixmap_underlying_get, _mupdf.fz_pixmap_underlying_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_pixmap_swiginit(self, _mupdf.new_fz_pixmap())
    1:     __swig_destroy__ = _mupdf.delete_fz_pixmap
       
       # Register fz_pixmap in _mupdf:
    1: _mupdf.fz_pixmap_swigregister(fz_pixmap)
    1: FZ_PIXMAP_FLAG_INTERPOLATE = _mupdf.FZ_PIXMAP_FLAG_INTERPOLATE
    1: FZ_PIXMAP_FLAG_FREE_SAMPLES = _mupdf.FZ_PIXMAP_FLAG_FREE_SAMPLES
    1: FZ_DEFLATE_NONE = _mupdf.FZ_DEFLATE_NONE
    1: FZ_DEFLATE_BEST_SPEED = _mupdf.FZ_DEFLATE_BEST_SPEED
    1: FZ_DEFLATE_BEST = _mupdf.FZ_DEFLATE_BEST
    1: FZ_DEFLATE_DEFAULT = _mupdf.FZ_DEFLATE_DEFAULT
    1: FZ_BROTLI_NONE = _mupdf.FZ_BROTLI_NONE
    1: FZ_BROTLI_BEST_SPEED = _mupdf.FZ_BROTLI_BEST_SPEED
    1: FZ_BROTLI_BEST = _mupdf.FZ_BROTLI_BEST
    1: FZ_BROTLI_DEFAULT = _mupdf.FZ_BROTLI_DEFAULT
    2: class fz_range(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     offset = property(_mupdf.fz_range_offset_get, _mupdf.fz_range_offset_set)
    1:     length = property(_mupdf.fz_range_length_get, _mupdf.fz_range_length_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_range_swiginit(self, _mupdf.new_fz_range())
    1:     __swig_destroy__ = _mupdf.delete_fz_range
       
       # Register fz_range in _mupdf:
    1: _mupdf.fz_range_swigregister(fz_range)
    2: class fz_compression_params(object):
    1:     r"""
           Compression parameters used for buffers of compressed data;
           typically for the source data for images.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     type = property(_mupdf.fz_compression_params_type_get, _mupdf.fz_compression_params_type_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_compression_params_swiginit(self, _mupdf.new_fz_compression_params())
    1:     __swig_destroy__ = _mupdf.delete_fz_compression_params
       
       # Register fz_compression_params in _mupdf:
    1: _mupdf.fz_compression_params_swigregister(fz_compression_params)
    2: class fz_compressed_buffer(object):
    1:     r"""
           Buffers of compressed data; typically for the source data
           for images.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_compressed_buffer_refs_get, _mupdf.fz_compressed_buffer_refs_set)
    1:     params = property(_mupdf.fz_compressed_buffer_params_get, _mupdf.fz_compressed_buffer_params_set)
    1:     buffer = property(_mupdf.fz_compressed_buffer_buffer_get, _mupdf.fz_compressed_buffer_buffer_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_compressed_buffer_swiginit(self, _mupdf.new_fz_compressed_buffer())
    1:     __swig_destroy__ = _mupdf.delete_fz_compressed_buffer
       
       # Register fz_compressed_buffer in _mupdf:
    1: _mupdf.fz_compressed_buffer_swigregister(fz_compressed_buffer)
    1: FZ_IMAGE_UNKNOWN = _mupdf.FZ_IMAGE_UNKNOWN
    1: FZ_IMAGE_RAW = _mupdf.FZ_IMAGE_RAW
    1: FZ_IMAGE_FAX = _mupdf.FZ_IMAGE_FAX
    1: FZ_IMAGE_FLATE = _mupdf.FZ_IMAGE_FLATE
    1: FZ_IMAGE_LZW = _mupdf.FZ_IMAGE_LZW
    1: FZ_IMAGE_RLD = _mupdf.FZ_IMAGE_RLD
    1: FZ_IMAGE_BROTLI = _mupdf.FZ_IMAGE_BROTLI
    1: FZ_IMAGE_BMP = _mupdf.FZ_IMAGE_BMP
    1: FZ_IMAGE_GIF = _mupdf.FZ_IMAGE_GIF
    1: FZ_IMAGE_JBIG2 = _mupdf.FZ_IMAGE_JBIG2
    1: FZ_IMAGE_JPEG = _mupdf.FZ_IMAGE_JPEG
    1: FZ_IMAGE_JPX = _mupdf.FZ_IMAGE_JPX
    1: FZ_IMAGE_JXR = _mupdf.FZ_IMAGE_JXR
    1: FZ_IMAGE_PNG = _mupdf.FZ_IMAGE_PNG
    1: FZ_IMAGE_PNM = _mupdf.FZ_IMAGE_PNM
    1: FZ_IMAGE_TIFF = _mupdf.FZ_IMAGE_TIFF
    1: FZ_IMAGE_PSD = _mupdf.FZ_IMAGE_PSD
    2: class fz_image(object):
    1:     r"""
           Structure is public to allow other structures to
           be derived from it. Do not access members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     key_storable = property(_mupdf.fz_image_key_storable_get, _mupdf.fz_image_key_storable_set)
    1:     w = property(_mupdf.fz_image_w_get, _mupdf.fz_image_w_set)
    1:     h = property(_mupdf.fz_image_h_get, _mupdf.fz_image_h_set)
    1:     n = property(_mupdf.fz_image_n_get, _mupdf.fz_image_n_set)
    1:     bpc = property(_mupdf.fz_image_bpc_get, _mupdf.fz_image_bpc_set)
    1:     imagemask = property(_mupdf.fz_image_imagemask_get, _mupdf.fz_image_imagemask_set)
    1:     interpolate = property(_mupdf.fz_image_interpolate_get, _mupdf.fz_image_interpolate_set)
    1:     use_colorkey = property(_mupdf.fz_image_use_colorkey_get, _mupdf.fz_image_use_colorkey_set)
    1:     use_decode = property(_mupdf.fz_image_use_decode_get, _mupdf.fz_image_use_decode_set)
    1:     decoded = property(_mupdf.fz_image_decoded_get, _mupdf.fz_image_decoded_set)
    1:     scalable = property(_mupdf.fz_image_scalable_get, _mupdf.fz_image_scalable_set)
    1:     intent = property(_mupdf.fz_image_intent_get, _mupdf.fz_image_intent_set)
    1:     has_intent = property(_mupdf.fz_image_has_intent_get, _mupdf.fz_image_has_intent_set)
    1:     orientation = property(_mupdf.fz_image_orientation_get, _mupdf.fz_image_orientation_set)
    1:     mask = property(_mupdf.fz_image_mask_get, _mupdf.fz_image_mask_set)
    1:     xres = property(_mupdf.fz_image_xres_get, _mupdf.fz_image_xres_set)
    1:     yres = property(_mupdf.fz_image_yres_get, _mupdf.fz_image_yres_set)
    1:     colorspace = property(_mupdf.fz_image_colorspace_get, _mupdf.fz_image_colorspace_set)
    1:     drop_image = property(_mupdf.fz_image_drop_image_get, _mupdf.fz_image_drop_image_set)
    1:     get_pixmap = property(_mupdf.fz_image_get_pixmap_get, _mupdf.fz_image_get_pixmap_set)
    1:     get_size = property(_mupdf.fz_image_get_size_get, _mupdf.fz_image_get_size_set)
    1:     colorkey = property(_mupdf.fz_image_colorkey_get, _mupdf.fz_image_colorkey_set)
    1:     decode = property(_mupdf.fz_image_decode_get, _mupdf.fz_image_decode_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_image_swiginit(self, _mupdf.new_fz_image())
    1:     __swig_destroy__ = _mupdf.delete_fz_image
       
       # Register fz_image in _mupdf:
    1: _mupdf.fz_image_swigregister(fz_image)
    2: class fz_bitmap(object):
    1:     r"""
           Bitmaps have 1 bit per component. Only used for creating
           halftoned versions of contone buffers, and saving out. Samples
           are stored msb first, akin to pbms.
       
           The internals of this struct are considered implementation
           details and subject to change. Where possible, accessor
           functions should be used in preference.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_bitmap_refs_get, _mupdf.fz_bitmap_refs_set)
    1:     w = property(_mupdf.fz_bitmap_w_get, _mupdf.fz_bitmap_w_set)
    1:     h = property(_mupdf.fz_bitmap_h_get, _mupdf.fz_bitmap_h_set)
    1:     stride = property(_mupdf.fz_bitmap_stride_get, _mupdf.fz_bitmap_stride_set)
    1:     n = property(_mupdf.fz_bitmap_n_get, _mupdf.fz_bitmap_n_set)
    1:     xres = property(_mupdf.fz_bitmap_xres_get, _mupdf.fz_bitmap_xres_set)
    1:     yres = property(_mupdf.fz_bitmap_yres_get, _mupdf.fz_bitmap_yres_set)
    1:     samples = property(_mupdf.fz_bitmap_samples_get, _mupdf.fz_bitmap_samples_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_bitmap_swiginit(self, _mupdf.new_fz_bitmap())
    1:     __swig_destroy__ = _mupdf.delete_fz_bitmap
       
       # Register fz_bitmap in _mupdf:
    1: _mupdf.fz_bitmap_swigregister(fz_bitmap)
    1: FZ_FUNCTION_BASED = _mupdf.FZ_FUNCTION_BASED
    1: FZ_LINEAR = _mupdf.FZ_LINEAR
    1: FZ_RADIAL = _mupdf.FZ_RADIAL
    1: FZ_MESH_TYPE4 = _mupdf.FZ_MESH_TYPE4
    1: FZ_MESH_TYPE5 = _mupdf.FZ_MESH_TYPE5
    1: FZ_MESH_TYPE6 = _mupdf.FZ_MESH_TYPE6
    1: FZ_MESH_TYPE7 = _mupdf.FZ_MESH_TYPE7
    2: class fz_shade(object):
    1:     r"""
           Structure is public to allow derived classes. Do not
           access the members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     storable = property(_mupdf.fz_shade_storable_get, _mupdf.fz_shade_storable_set)
    1:     bbox = property(_mupdf.fz_shade_bbox_get, _mupdf.fz_shade_bbox_set)
    1:     colorspace = property(_mupdf.fz_shade_colorspace_get, _mupdf.fz_shade_colorspace_set)
    1:     matrix = property(_mupdf.fz_shade_matrix_get, _mupdf.fz_shade_matrix_set)
    1:     use_background = property(_mupdf.fz_shade_use_background_get, _mupdf.fz_shade_use_background_set)
    1:     background = property(_mupdf.fz_shade_background_get, _mupdf.fz_shade_background_set)
    1:     function_stride = property(_mupdf.fz_shade_function_stride_get, _mupdf.fz_shade_function_stride_set)
    1:     function = property(_mupdf.fz_shade_function_get, _mupdf.fz_shade_function_set)
    1:     type = property(_mupdf.fz_shade_type_get, _mupdf.fz_shade_type_set)
    1:     buffer = property(_mupdf.fz_shade_buffer_get, _mupdf.fz_shade_buffer_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_shade_swiginit(self, _mupdf.new_fz_shade())
    1:     __swig_destroy__ = _mupdf.delete_fz_shade
       
       # Register fz_shade in _mupdf:
    1: _mupdf.fz_shade_swigregister(fz_shade)
    2: class fz_vertex(object):
    1:     r"""Handy routine for processing mesh based shades"""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     p = property(_mupdf.fz_vertex_p_get, _mupdf.fz_vertex_p_set)
    1:     c = property(_mupdf.fz_vertex_c_get, _mupdf.fz_vertex_c_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_vertex_swiginit(self, _mupdf.new_fz_vertex())
    1:     __swig_destroy__ = _mupdf.delete_fz_vertex
       
       # Register fz_vertex in _mupdf:
    1: _mupdf.fz_vertex_swigregister(fz_vertex)
    2: class fz_text_decoder(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     decode_bound = property(_mupdf.fz_text_decoder_decode_bound_get, _mupdf.fz_text_decoder_decode_bound_set)
    1:     decode_size = property(_mupdf.fz_text_decoder_decode_size_get, _mupdf.fz_text_decoder_decode_size_set)
    1:     decode = property(_mupdf.fz_text_decoder_decode_get, _mupdf.fz_text_decoder_decode_set)
    1:     table1 = property(_mupdf.fz_text_decoder_table1_get, _mupdf.fz_text_decoder_table1_set)
    1:     table2 = property(_mupdf.fz_text_decoder_table2_get, _mupdf.fz_text_decoder_table2_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_text_decoder_swiginit(self, _mupdf.new_fz_text_decoder())
    1:     __swig_destroy__ = _mupdf.delete_fz_text_decoder
       
       # Register fz_text_decoder in _mupdf:
    1: _mupdf.fz_text_decoder_swigregister(fz_text_decoder)
    1: fz_unicode_from_iso8859_1 = cvar.fz_unicode_from_iso8859_1
    1: fz_unicode_from_iso8859_7 = cvar.fz_unicode_from_iso8859_7
    1: fz_unicode_from_koi8u = cvar.fz_unicode_from_koi8u
    1: fz_unicode_from_pdf_doc_encoding = cvar.fz_unicode_from_pdf_doc_encoding
    1: fz_unicode_from_windows_1250 = cvar.fz_unicode_from_windows_1250
    1: fz_unicode_from_windows_1251 = cvar.fz_unicode_from_windows_1251
    1: fz_unicode_from_windows_1252 = cvar.fz_unicode_from_windows_1252
       
    1: FZ_ADOBE_CNS = _mupdf.FZ_ADOBE_CNS
    1: FZ_ADOBE_GB = _mupdf.FZ_ADOBE_GB
    1: FZ_ADOBE_JAPAN = _mupdf.FZ_ADOBE_JAPAN
    1: FZ_ADOBE_KOREA = _mupdf.FZ_ADOBE_KOREA
    2: class fz_font_flags_t(object):
    1:     r"""
           Every fz_font carries a set of flags
           within it, in a fz_font_flags_t structure.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     is_mono = property(_mupdf.fz_font_flags_t_is_mono_get, _mupdf.fz_font_flags_t_is_mono_set)
    1:     is_serif = property(_mupdf.fz_font_flags_t_is_serif_get, _mupdf.fz_font_flags_t_is_serif_set)
    1:     is_bold = property(_mupdf.fz_font_flags_t_is_bold_get, _mupdf.fz_font_flags_t_is_bold_set)
    1:     is_italic = property(_mupdf.fz_font_flags_t_is_italic_get, _mupdf.fz_font_flags_t_is_italic_set)
    1:     ft_substitute = property(_mupdf.fz_font_flags_t_ft_substitute_get, _mupdf.fz_font_flags_t_ft_substitute_set)
    1:     ft_stretch = property(_mupdf.fz_font_flags_t_ft_stretch_get, _mupdf.fz_font_flags_t_ft_stretch_set)
    1:     fake_bold = property(_mupdf.fz_font_flags_t_fake_bold_get, _mupdf.fz_font_flags_t_fake_bold_set)
    1:     fake_italic = property(_mupdf.fz_font_flags_t_fake_italic_get, _mupdf.fz_font_flags_t_fake_italic_set)
    1:     has_opentype = property(_mupdf.fz_font_flags_t_has_opentype_get, _mupdf.fz_font_flags_t_has_opentype_set)
    1:     invalid_bbox = property(_mupdf.fz_font_flags_t_invalid_bbox_get, _mupdf.fz_font_flags_t_invalid_bbox_set)
    1:     cjk = property(_mupdf.fz_font_flags_t_cjk_get, _mupdf.fz_font_flags_t_cjk_set)
    1:     cjk_lang = property(_mupdf.fz_font_flags_t_cjk_lang_get, _mupdf.fz_font_flags_t_cjk_lang_set)
    1:     embed = property(_mupdf.fz_font_flags_t_embed_get, _mupdf.fz_font_flags_t_embed_set)
    1:     never_embed = property(_mupdf.fz_font_flags_t_never_embed_get, _mupdf.fz_font_flags_t_never_embed_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_font_flags_t_swiginit(self, _mupdf.new_fz_font_flags_t())
    1:     __swig_destroy__ = _mupdf.delete_fz_font_flags_t
       
       # Register fz_font_flags_t in _mupdf:
    1: _mupdf.fz_font_flags_t_swigregister(fz_font_flags_t)
    2: class fz_shaper_data_t(object):
    1:     r"""
           In order to shape a given font, we need to
           declare it to a shaper library (harfbuzz, by default, but others
           are possible). To avoid redeclaring it every time we need to
           shape, we hold a shaper handle and the destructor for it within
           the font itself. The handle is initialised by the caller when
           first required and the destructor is called when the fz_font is
           destroyed.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     shaper_handle = property(_mupdf.fz_shaper_data_t_shaper_handle_get, _mupdf.fz_shaper_data_t_shaper_handle_set)
    1:     destroy = property(_mupdf.fz_shaper_data_t_destroy_get, _mupdf.fz_shaper_data_t_destroy_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_shaper_data_t_swiginit(self, _mupdf.new_fz_shaper_data_t())
    1:     __swig_destroy__ = _mupdf.delete_fz_shaper_data_t
       
       # Register fz_shaper_data_t in _mupdf:
    1: _mupdf.fz_shaper_data_t_swigregister(fz_shaper_data_t)
    1: FZ_ASCDESC_FROM_FONT = _mupdf.FZ_ASCDESC_FROM_FONT
    1: FZ_ASCDESC_DEFAULT = _mupdf.FZ_ASCDESC_DEFAULT
    1: FZ_ASCDESC_FROM_BOUNDS = _mupdf.FZ_ASCDESC_FROM_BOUNDS
    1: FZ_MAX_TRUSTWORTHY_ASCENT = _mupdf.FZ_MAX_TRUSTWORTHY_ASCENT
    1: FZ_MAX_TRUSTWORTHY_DESCENT = _mupdf.FZ_MAX_TRUSTWORTHY_DESCENT
    2: class fz_font(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_font_refs_get, _mupdf.fz_font_refs_set)
    1:     name = property(_mupdf.fz_font_name_get, _mupdf.fz_font_name_set)
    1:     buffer = property(_mupdf.fz_font_buffer_get, _mupdf.fz_font_buffer_set)
    1:     flags = property(_mupdf.fz_font_flags_get, _mupdf.fz_font_flags_set)
    1:     ft_face = property(_mupdf.fz_font_ft_face_get, _mupdf.fz_font_ft_face_set)
    1:     shaper_data = property(_mupdf.fz_font_shaper_data_get, _mupdf.fz_font_shaper_data_set)
    1:     t3matrix = property(_mupdf.fz_font_t3matrix_get, _mupdf.fz_font_t3matrix_set)
    1:     t3resources = property(_mupdf.fz_font_t3resources_get, _mupdf.fz_font_t3resources_set)
    1:     t3procs = property(_mupdf.fz_font_t3procs_get, _mupdf.fz_font_t3procs_set)
    1:     t3lists = property(_mupdf.fz_font_t3lists_get, _mupdf.fz_font_t3lists_set)
    1:     t3widths = property(_mupdf.fz_font_t3widths_get, _mupdf.fz_font_t3widths_set)
    1:     t3flags = property(_mupdf.fz_font_t3flags_get, _mupdf.fz_font_t3flags_set)
    1:     t3doc = property(_mupdf.fz_font_t3doc_get, _mupdf.fz_font_t3doc_set)
    1:     t3run = property(_mupdf.fz_font_t3run_get, _mupdf.fz_font_t3run_set)
    1:     t3freeres = property(_mupdf.fz_font_t3freeres_get, _mupdf.fz_font_t3freeres_set)
    1:     bbox = property(_mupdf.fz_font_bbox_get, _mupdf.fz_font_bbox_set)
    1:     ascender = property(_mupdf.fz_font_ascender_get, _mupdf.fz_font_ascender_set)
    1:     descender = property(_mupdf.fz_font_descender_get, _mupdf.fz_font_descender_set)
    1:     ascdesc_src = property(_mupdf.fz_font_ascdesc_src_get, _mupdf.fz_font_ascdesc_src_set)
    1:     glyph_count = property(_mupdf.fz_font_glyph_count_get, _mupdf.fz_font_glyph_count_set)
    1:     bbox_table = property(_mupdf.fz_font_bbox_table_get, _mupdf.fz_font_bbox_table_set)
    1:     use_glyph_bbox = property(_mupdf.fz_font_use_glyph_bbox_get, _mupdf.fz_font_use_glyph_bbox_set)
    1:     width_count = property(_mupdf.fz_font_width_count_get, _mupdf.fz_font_width_count_set)
    1:     width_default = property(_mupdf.fz_font_width_default_get, _mupdf.fz_font_width_default_set)
    1:     width_table = property(_mupdf.fz_font_width_table_get, _mupdf.fz_font_width_table_set)
    1:     advance_cache = property(_mupdf.fz_font_advance_cache_get, _mupdf.fz_font_advance_cache_set)
    1:     encoding_cache = property(_mupdf.fz_font_encoding_cache_get, _mupdf.fz_font_encoding_cache_set)
    1:     has_digest = property(_mupdf.fz_font_has_digest_get, _mupdf.fz_font_has_digest_set)
    1:     digest = property(_mupdf.fz_font_digest_get, _mupdf.fz_font_digest_set)
    1:     subfont = property(_mupdf.fz_font_subfont_get, _mupdf.fz_font_subfont_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_font_swiginit(self, _mupdf.new_fz_font())
    1:     __swig_destroy__ = _mupdf.delete_fz_font
       
       # Register fz_font in _mupdf:
    1: _mupdf.fz_font_swigregister(fz_font)
    1: FZ_LINECAP_BUTT = _mupdf.FZ_LINECAP_BUTT
    1: FZ_LINECAP_ROUND = _mupdf.FZ_LINECAP_ROUND
    1: FZ_LINECAP_SQUARE = _mupdf.FZ_LINECAP_SQUARE
    1: FZ_LINECAP_TRIANGLE = _mupdf.FZ_LINECAP_TRIANGLE
    1: FZ_LINEJOIN_MITER = _mupdf.FZ_LINEJOIN_MITER
    1: FZ_LINEJOIN_ROUND = _mupdf.FZ_LINEJOIN_ROUND
    1: FZ_LINEJOIN_BEVEL = _mupdf.FZ_LINEJOIN_BEVEL
    1: FZ_LINEJOIN_MITER_XPS = _mupdf.FZ_LINEJOIN_MITER_XPS
    2: class fz_stroke_state(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_stroke_state_refs_get, _mupdf.fz_stroke_state_refs_set)
    1:     start_cap = property(_mupdf.fz_stroke_state_start_cap_get, _mupdf.fz_stroke_state_start_cap_set)
    1:     dash_cap = property(_mupdf.fz_stroke_state_dash_cap_get, _mupdf.fz_stroke_state_dash_cap_set)
    1:     end_cap = property(_mupdf.fz_stroke_state_end_cap_get, _mupdf.fz_stroke_state_end_cap_set)
    1:     linejoin = property(_mupdf.fz_stroke_state_linejoin_get, _mupdf.fz_stroke_state_linejoin_set)
    1:     linewidth = property(_mupdf.fz_stroke_state_linewidth_get, _mupdf.fz_stroke_state_linewidth_set)
    1:     miterlimit = property(_mupdf.fz_stroke_state_miterlimit_get, _mupdf.fz_stroke_state_miterlimit_set)
    1:     dash_phase = property(_mupdf.fz_stroke_state_dash_phase_get, _mupdf.fz_stroke_state_dash_phase_set)
    1:     dash_len = property(_mupdf.fz_stroke_state_dash_len_get, _mupdf.fz_stroke_state_dash_len_set)
    1:     dash_list = property(_mupdf.fz_stroke_state_dash_list_get, _mupdf.fz_stroke_state_dash_list_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_stroke_state_swiginit(self, _mupdf.new_fz_stroke_state())
    1:     __swig_destroy__ = _mupdf.delete_fz_stroke_state
       
       # Register fz_stroke_state in _mupdf:
    1: _mupdf.fz_stroke_state_swigregister(fz_stroke_state)
    2: class fz_path_walker(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     moveto = property(_mupdf.fz_path_walker_moveto_get, _mupdf.fz_path_walker_moveto_set)
    1:     lineto = property(_mupdf.fz_path_walker_lineto_get, _mupdf.fz_path_walker_lineto_set)
    1:     curveto = property(_mupdf.fz_path_walker_curveto_get, _mupdf.fz_path_walker_curveto_set)
    1:     closepath = property(_mupdf.fz_path_walker_closepath_get, _mupdf.fz_path_walker_closepath_set)
    1:     quadto = property(_mupdf.fz_path_walker_quadto_get, _mupdf.fz_path_walker_quadto_set)
    1:     curvetov = property(_mupdf.fz_path_walker_curvetov_get, _mupdf.fz_path_walker_curvetov_set)
    1:     curvetoy = property(_mupdf.fz_path_walker_curvetoy_get, _mupdf.fz_path_walker_curvetoy_set)
    1:     rectto = property(_mupdf.fz_path_walker_rectto_get, _mupdf.fz_path_walker_rectto_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_path_walker_swiginit(self, _mupdf.new_fz_path_walker())
    1:     __swig_destroy__ = _mupdf.delete_fz_path_walker
       
       # Register fz_path_walker in _mupdf:
    1: _mupdf.fz_path_walker_swigregister(fz_path_walker)
    2: class fz_text_item(object):
    1:     r"""
           Text buffer.
       
           The trm field contains the a, b, c and d coefficients.
           The e and f coefficients come from the individual elements,
           together they form the transform matrix for the glyph.
       
           Glyphs are referenced by glyph ID.
           The Unicode text equivalent is kept in a separate array
           with indexes into the glyph array.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     x = property(_mupdf.fz_text_item_x_get, _mupdf.fz_text_item_x_set)
    1:     y = property(_mupdf.fz_text_item_y_get, _mupdf.fz_text_item_y_set)
    1:     adv = property(_mupdf.fz_text_item_adv_get, _mupdf.fz_text_item_adv_set)
    1:     gid = property(_mupdf.fz_text_item_gid_get, _mupdf.fz_text_item_gid_set)
    1:     ucs = property(_mupdf.fz_text_item_ucs_get, _mupdf.fz_text_item_ucs_set)
    1:     cid = property(_mupdf.fz_text_item_cid_get, _mupdf.fz_text_item_cid_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_text_item_swiginit(self, _mupdf.new_fz_text_item())
    1:     __swig_destroy__ = _mupdf.delete_fz_text_item
       
       # Register fz_text_item in _mupdf:
    1: _mupdf.fz_text_item_swigregister(fz_text_item)
    1: fz_default_stroke_state = cvar.fz_default_stroke_state
       
    1: FZ_LANG_UNSET = _mupdf.FZ_LANG_UNSET
    1: FZ_LANG_ur = _mupdf.FZ_LANG_ur
    1: FZ_LANG_urd = _mupdf.FZ_LANG_urd
    1: FZ_LANG_ko = _mupdf.FZ_LANG_ko
    1: FZ_LANG_ja = _mupdf.FZ_LANG_ja
    1: FZ_LANG_zh = _mupdf.FZ_LANG_zh
    1: FZ_LANG_zh_Hans = _mupdf.FZ_LANG_zh_Hans
    1: FZ_LANG_zh_Hant = _mupdf.FZ_LANG_zh_Hant
    2: class fz_text_span(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     font = property(_mupdf.fz_text_span_font_get, _mupdf.fz_text_span_font_set)
    1:     trm = property(_mupdf.fz_text_span_trm_get, _mupdf.fz_text_span_trm_set)
    1:     wmode = property(_mupdf.fz_text_span_wmode_get, _mupdf.fz_text_span_wmode_set)
    1:     bidi_level = property(_mupdf.fz_text_span_bidi_level_get, _mupdf.fz_text_span_bidi_level_set)
    1:     markup_dir = property(_mupdf.fz_text_span_markup_dir_get, _mupdf.fz_text_span_markup_dir_set)
    1:     language = property(_mupdf.fz_text_span_language_get, _mupdf.fz_text_span_language_set)
    1:     len = property(_mupdf.fz_text_span_len_get, _mupdf.fz_text_span_len_set)
    1:     cap = property(_mupdf.fz_text_span_cap_get, _mupdf.fz_text_span_cap_set)
    1:     items = property(_mupdf.fz_text_span_items_get, _mupdf.fz_text_span_items_set)
    1:     next = property(_mupdf.fz_text_span_next_get, _mupdf.fz_text_span_next_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_text_span_swiginit(self, _mupdf.new_fz_text_span())
    1:     __swig_destroy__ = _mupdf.delete_fz_text_span
       
       # Register fz_text_span in _mupdf:
    1: _mupdf.fz_text_span_swigregister(fz_text_span)
    2: class fz_text(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_text_refs_get, _mupdf.fz_text_refs_set)
    1:     head = property(_mupdf.fz_text_head_get, _mupdf.fz_text_head_set)
    1:     tail = property(_mupdf.fz_text_tail_get, _mupdf.fz_text_tail_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_text_swiginit(self, _mupdf.new_fz_text())
    1:     __swig_destroy__ = _mupdf.delete_fz_text
       
       # Register fz_text in _mupdf:
    1: _mupdf.fz_text_swigregister(fz_text)
    1: FZ_DEVFLAG_MASK = _mupdf.FZ_DEVFLAG_MASK
    1: FZ_DEVFLAG_COLOR = _mupdf.FZ_DEVFLAG_COLOR
    1: FZ_DEVFLAG_UNCACHEABLE = _mupdf.FZ_DEVFLAG_UNCACHEABLE
    1: FZ_DEVFLAG_FILLCOLOR_UNDEFINED = _mupdf.FZ_DEVFLAG_FILLCOLOR_UNDEFINED
    1: FZ_DEVFLAG_STROKECOLOR_UNDEFINED = _mupdf.FZ_DEVFLAG_STROKECOLOR_UNDEFINED
    1: FZ_DEVFLAG_STARTCAP_UNDEFINED = _mupdf.FZ_DEVFLAG_STARTCAP_UNDEFINED
    1: FZ_DEVFLAG_DASHCAP_UNDEFINED = _mupdf.FZ_DEVFLAG_DASHCAP_UNDEFINED
    1: FZ_DEVFLAG_ENDCAP_UNDEFINED = _mupdf.FZ_DEVFLAG_ENDCAP_UNDEFINED
    1: FZ_DEVFLAG_LINEJOIN_UNDEFINED = _mupdf.FZ_DEVFLAG_LINEJOIN_UNDEFINED
    1: FZ_DEVFLAG_MITERLIMIT_UNDEFINED = _mupdf.FZ_DEVFLAG_MITERLIMIT_UNDEFINED
    1: FZ_DEVFLAG_LINEWIDTH_UNDEFINED = _mupdf.FZ_DEVFLAG_LINEWIDTH_UNDEFINED
    1: FZ_DEVFLAG_BBOX_DEFINED = _mupdf.FZ_DEVFLAG_BBOX_DEFINED
    1: FZ_DEVFLAG_GRIDFIT_AS_TILED = _mupdf.FZ_DEVFLAG_GRIDFIT_AS_TILED
    1: FZ_DEVFLAG_DASH_PATTERN_UNDEFINED = _mupdf.FZ_DEVFLAG_DASH_PATTERN_UNDEFINED
    1: FZ_BLEND_NORMAL = _mupdf.FZ_BLEND_NORMAL
    1: FZ_BLEND_MULTIPLY = _mupdf.FZ_BLEND_MULTIPLY
    1: FZ_BLEND_SCREEN = _mupdf.FZ_BLEND_SCREEN
    1: FZ_BLEND_OVERLAY = _mupdf.FZ_BLEND_OVERLAY
    1: FZ_BLEND_DARKEN = _mupdf.FZ_BLEND_DARKEN
    1: FZ_BLEND_LIGHTEN = _mupdf.FZ_BLEND_LIGHTEN
    1: FZ_BLEND_COLOR_DODGE = _mupdf.FZ_BLEND_COLOR_DODGE
    1: FZ_BLEND_COLOR_BURN = _mupdf.FZ_BLEND_COLOR_BURN
    1: FZ_BLEND_HARD_LIGHT = _mupdf.FZ_BLEND_HARD_LIGHT
    1: FZ_BLEND_SOFT_LIGHT = _mupdf.FZ_BLEND_SOFT_LIGHT
    1: FZ_BLEND_DIFFERENCE = _mupdf.FZ_BLEND_DIFFERENCE
    1: FZ_BLEND_EXCLUSION = _mupdf.FZ_BLEND_EXCLUSION
    1: FZ_BLEND_HUE = _mupdf.FZ_BLEND_HUE
    1: FZ_BLEND_SATURATION = _mupdf.FZ_BLEND_SATURATION
    1: FZ_BLEND_COLOR = _mupdf.FZ_BLEND_COLOR
    1: FZ_BLEND_LUMINOSITY = _mupdf.FZ_BLEND_LUMINOSITY
    1: FZ_BLEND_MODEMASK = _mupdf.FZ_BLEND_MODEMASK
    1: FZ_BLEND_ISOLATED = _mupdf.FZ_BLEND_ISOLATED
    1: FZ_BLEND_KNOCKOUT = _mupdf.FZ_BLEND_KNOCKOUT
    1: FZ_FUNCTION_MAX_N = _mupdf.FZ_FUNCTION_MAX_N
    1: FZ_FUNCTION_MAX_M = _mupdf.FZ_FUNCTION_MAX_M
    2: class fz_function(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     storable = property(_mupdf.fz_function_storable_get, _mupdf.fz_function_storable_set)
    1:     size = property(_mupdf.fz_function_size_get, _mupdf.fz_function_size_set)
    1:     m = property(_mupdf.fz_function_m_get, _mupdf.fz_function_m_set)
    1:     n = property(_mupdf.fz_function_n_get, _mupdf.fz_function_n_set)
    1:     eval = property(_mupdf.fz_function_eval_get, _mupdf.fz_function_eval_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_function_swiginit(self, _mupdf.new_fz_function())
    1:     __swig_destroy__ = _mupdf.delete_fz_function
       
       # Register fz_function in _mupdf:
    1: _mupdf.fz_function_swigregister(fz_function)
    2: class fz_device_container_stack(object):
    1:     r"""
           The device structure is public to allow devices to be
           implemented outside of fitz.
       
           Device methods should always be called using e.g.
           fz_fill_path(ctx, dev, ...) rather than
           dev->fill_path(ctx, dev, ...)
       
           Devices can keep track of containers (clips/masks/groups/tiles)
           as they go to save callers having to do it.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     scissor = property(_mupdf.fz_device_container_stack_scissor_get, _mupdf.fz_device_container_stack_scissor_set)
    1:     type = property(_mupdf.fz_device_container_stack_type_get, _mupdf.fz_device_container_stack_type_set)
    1:     user = property(_mupdf.fz_device_container_stack_user_get, _mupdf.fz_device_container_stack_user_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_device_container_stack_swiginit(self, _mupdf.new_fz_device_container_stack())
    1:     __swig_destroy__ = _mupdf.delete_fz_device_container_stack
       
       # Register fz_device_container_stack in _mupdf:
    1: _mupdf.fz_device_container_stack_swigregister(fz_device_container_stack)
    1: fz_device_container_stack_is_clip = _mupdf.fz_device_container_stack_is_clip
    1: fz_device_container_stack_is_mask = _mupdf.fz_device_container_stack_is_mask
    1: fz_device_container_stack_is_group = _mupdf.fz_device_container_stack_is_group
    1: fz_device_container_stack_is_tile = _mupdf.fz_device_container_stack_is_tile
    1: FZ_STRUCTURE_INVALID = _mupdf.FZ_STRUCTURE_INVALID
    1: FZ_STRUCTURE_DOCUMENT = _mupdf.FZ_STRUCTURE_DOCUMENT
    1: FZ_STRUCTURE_PART = _mupdf.FZ_STRUCTURE_PART
    1: FZ_STRUCTURE_ART = _mupdf.FZ_STRUCTURE_ART
    1: FZ_STRUCTURE_SECT = _mupdf.FZ_STRUCTURE_SECT
    1: FZ_STRUCTURE_DIV = _mupdf.FZ_STRUCTURE_DIV
    1: FZ_STRUCTURE_BLOCKQUOTE = _mupdf.FZ_STRUCTURE_BLOCKQUOTE
    1: FZ_STRUCTURE_CAPTION = _mupdf.FZ_STRUCTURE_CAPTION
    1: FZ_STRUCTURE_TOC = _mupdf.FZ_STRUCTURE_TOC
    1: FZ_STRUCTURE_TOCI = _mupdf.FZ_STRUCTURE_TOCI
    1: FZ_STRUCTURE_INDEX = _mupdf.FZ_STRUCTURE_INDEX
    1: FZ_STRUCTURE_NONSTRUCT = _mupdf.FZ_STRUCTURE_NONSTRUCT
    1: FZ_STRUCTURE_PRIVATE = _mupdf.FZ_STRUCTURE_PRIVATE
    1: FZ_STRUCTURE_DOCUMENTFRAGMENT = _mupdf.FZ_STRUCTURE_DOCUMENTFRAGMENT
    1: FZ_STRUCTURE_ASIDE = _mupdf.FZ_STRUCTURE_ASIDE
    1: FZ_STRUCTURE_TITLE = _mupdf.FZ_STRUCTURE_TITLE
    1: FZ_STRUCTURE_FENOTE = _mupdf.FZ_STRUCTURE_FENOTE
    1: FZ_STRUCTURE_SUB = _mupdf.FZ_STRUCTURE_SUB
    1: FZ_STRUCTURE_P = _mupdf.FZ_STRUCTURE_P
    1: FZ_STRUCTURE_H = _mupdf.FZ_STRUCTURE_H
    1: FZ_STRUCTURE_H1 = _mupdf.FZ_STRUCTURE_H1
    1: FZ_STRUCTURE_H2 = _mupdf.FZ_STRUCTURE_H2
    1: FZ_STRUCTURE_H3 = _mupdf.FZ_STRUCTURE_H3
    1: FZ_STRUCTURE_H4 = _mupdf.FZ_STRUCTURE_H4
    1: FZ_STRUCTURE_H5 = _mupdf.FZ_STRUCTURE_H5
    1: FZ_STRUCTURE_H6 = _mupdf.FZ_STRUCTURE_H6
    1: FZ_STRUCTURE_LIST = _mupdf.FZ_STRUCTURE_LIST
    1: FZ_STRUCTURE_LISTITEM = _mupdf.FZ_STRUCTURE_LISTITEM
    1: FZ_STRUCTURE_LABEL = _mupdf.FZ_STRUCTURE_LABEL
    1: FZ_STRUCTURE_LISTBODY = _mupdf.FZ_STRUCTURE_LISTBODY
    1: FZ_STRUCTURE_TABLE = _mupdf.FZ_STRUCTURE_TABLE
    1: FZ_STRUCTURE_TR = _mupdf.FZ_STRUCTURE_TR
    1: FZ_STRUCTURE_TH = _mupdf.FZ_STRUCTURE_TH
    1: FZ_STRUCTURE_TD = _mupdf.FZ_STRUCTURE_TD
    1: FZ_STRUCTURE_THEAD = _mupdf.FZ_STRUCTURE_THEAD
    1: FZ_STRUCTURE_TBODY = _mupdf.FZ_STRUCTURE_TBODY
    1: FZ_STRUCTURE_TFOOT = _mupdf.FZ_STRUCTURE_TFOOT
    1: FZ_STRUCTURE_SPAN = _mupdf.FZ_STRUCTURE_SPAN
    1: FZ_STRUCTURE_QUOTE = _mupdf.FZ_STRUCTURE_QUOTE
    1: FZ_STRUCTURE_NOTE = _mupdf.FZ_STRUCTURE_NOTE
    1: FZ_STRUCTURE_REFERENCE = _mupdf.FZ_STRUCTURE_REFERENCE
    1: FZ_STRUCTURE_BIBENTRY = _mupdf.FZ_STRUCTURE_BIBENTRY
    1: FZ_STRUCTURE_CODE = _mupdf.FZ_STRUCTURE_CODE
    1: FZ_STRUCTURE_LINK = _mupdf.FZ_STRUCTURE_LINK
    1: FZ_STRUCTURE_ANNOT = _mupdf.FZ_STRUCTURE_ANNOT
    1: FZ_STRUCTURE_EM = _mupdf.FZ_STRUCTURE_EM
    1: FZ_STRUCTURE_STRONG = _mupdf.FZ_STRUCTURE_STRONG
    1: FZ_STRUCTURE_RUBY = _mupdf.FZ_STRUCTURE_RUBY
    1: FZ_STRUCTURE_RB = _mupdf.FZ_STRUCTURE_RB
    1: FZ_STRUCTURE_RT = _mupdf.FZ_STRUCTURE_RT
    1: FZ_STRUCTURE_RP = _mupdf.FZ_STRUCTURE_RP
    1: FZ_STRUCTURE_WARICHU = _mupdf.FZ_STRUCTURE_WARICHU
    1: FZ_STRUCTURE_WT = _mupdf.FZ_STRUCTURE_WT
    1: FZ_STRUCTURE_WP = _mupdf.FZ_STRUCTURE_WP
    1: FZ_STRUCTURE_FIGURE = _mupdf.FZ_STRUCTURE_FIGURE
    1: FZ_STRUCTURE_FORMULA = _mupdf.FZ_STRUCTURE_FORMULA
    1: FZ_STRUCTURE_FORM = _mupdf.FZ_STRUCTURE_FORM
    1: FZ_STRUCTURE_ARTIFACT = _mupdf.FZ_STRUCTURE_ARTIFACT
    1: FZ_METATEXT_ACTUALTEXT = _mupdf.FZ_METATEXT_ACTUALTEXT
    1: FZ_METATEXT_ALT = _mupdf.FZ_METATEXT_ALT
    1: FZ_METATEXT_ABBREVIATION = _mupdf.FZ_METATEXT_ABBREVIATION
    1: FZ_METATEXT_TITLE = _mupdf.FZ_METATEXT_TITLE
    2: class fz_device(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_device_refs_get, _mupdf.fz_device_refs_set)
    1:     hints = property(_mupdf.fz_device_hints_get, _mupdf.fz_device_hints_set)
    1:     flags = property(_mupdf.fz_device_flags_get, _mupdf.fz_device_flags_set)
    1:     close_device = property(_mupdf.fz_device_close_device_get, _mupdf.fz_device_close_device_set)
    1:     drop_device = property(_mupdf.fz_device_drop_device_get, _mupdf.fz_device_drop_device_set)
    1:     fill_path = property(_mupdf.fz_device_fill_path_get, _mupdf.fz_device_fill_path_set)
    1:     stroke_path = property(_mupdf.fz_device_stroke_path_get, _mupdf.fz_device_stroke_path_set)
    1:     clip_path = property(_mupdf.fz_device_clip_path_get, _mupdf.fz_device_clip_path_set)
    1:     clip_stroke_path = property(_mupdf.fz_device_clip_stroke_path_get, _mupdf.fz_device_clip_stroke_path_set)
    1:     fill_text = property(_mupdf.fz_device_fill_text_get, _mupdf.fz_device_fill_text_set)
    1:     stroke_text = property(_mupdf.fz_device_stroke_text_get, _mupdf.fz_device_stroke_text_set)
    1:     clip_text = property(_mupdf.fz_device_clip_text_get, _mupdf.fz_device_clip_text_set)
    1:     clip_stroke_text = property(_mupdf.fz_device_clip_stroke_text_get, _mupdf.fz_device_clip_stroke_text_set)
    1:     ignore_text = property(_mupdf.fz_device_ignore_text_get, _mupdf.fz_device_ignore_text_set)
    1:     fill_shade = property(_mupdf.fz_device_fill_shade_get, _mupdf.fz_device_fill_shade_set)
    1:     fill_image = property(_mupdf.fz_device_fill_image_get, _mupdf.fz_device_fill_image_set)
    1:     fill_image_mask = property(_mupdf.fz_device_fill_image_mask_get, _mupdf.fz_device_fill_image_mask_set)
    1:     clip_image_mask = property(_mupdf.fz_device_clip_image_mask_get, _mupdf.fz_device_clip_image_mask_set)
    1:     pop_clip = property(_mupdf.fz_device_pop_clip_get, _mupdf.fz_device_pop_clip_set)
    1:     begin_mask = property(_mupdf.fz_device_begin_mask_get, _mupdf.fz_device_begin_mask_set)
    1:     end_mask = property(_mupdf.fz_device_end_mask_get, _mupdf.fz_device_end_mask_set)
    1:     begin_group = property(_mupdf.fz_device_begin_group_get, _mupdf.fz_device_begin_group_set)
    1:     end_group = property(_mupdf.fz_device_end_group_get, _mupdf.fz_device_end_group_set)
    1:     begin_tile = property(_mupdf.fz_device_begin_tile_get, _mupdf.fz_device_begin_tile_set)
    1:     end_tile = property(_mupdf.fz_device_end_tile_get, _mupdf.fz_device_end_tile_set)
    1:     render_flags = property(_mupdf.fz_device_render_flags_get, _mupdf.fz_device_render_flags_set)
    1:     set_default_colorspaces = property(_mupdf.fz_device_set_default_colorspaces_get, _mupdf.fz_device_set_default_colorspaces_set)
    1:     begin_layer = property(_mupdf.fz_device_begin_layer_get, _mupdf.fz_device_begin_layer_set)
    1:     end_layer = property(_mupdf.fz_device_end_layer_get, _mupdf.fz_device_end_layer_set)
    1:     begin_structure = property(_mupdf.fz_device_begin_structure_get, _mupdf.fz_device_begin_structure_set)
    1:     end_structure = property(_mupdf.fz_device_end_structure_get, _mupdf.fz_device_end_structure_set)
    1:     begin_metatext = property(_mupdf.fz_device_begin_metatext_get, _mupdf.fz_device_begin_metatext_set)
    1:     end_metatext = property(_mupdf.fz_device_end_metatext_get, _mupdf.fz_device_end_metatext_set)
    1:     d1_rect = property(_mupdf.fz_device_d1_rect_get, _mupdf.fz_device_d1_rect_set)
    1:     container_len = property(_mupdf.fz_device_container_len_get, _mupdf.fz_device_container_len_set)
    1:     container_cap = property(_mupdf.fz_device_container_cap_get, _mupdf.fz_device_container_cap_set)
    1:     container = property(_mupdf.fz_device_container_get, _mupdf.fz_device_container_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_device_swiginit(self, _mupdf.new_fz_device())
    1:     __swig_destroy__ = _mupdf.delete_fz_device
       
       # Register fz_device in _mupdf:
    1: _mupdf.fz_device_swigregister(fz_device)
    1: FZ_DONT_INTERPOLATE_IMAGES = _mupdf.FZ_DONT_INTERPOLATE_IMAGES
    1: FZ_NO_CACHE = _mupdf.FZ_NO_CACHE
    1: FZ_DONT_DECODE_IMAGES = _mupdf.FZ_DONT_DECODE_IMAGES
    2: class fz_cookie(object):
    1:     r"""
           Cookie support - simple communication channel between app/library.
       
           Provide two-way communication between application and library.
           Intended for multi-threaded applications where one thread is
           rendering pages and another thread wants to read progress
           feedback or abort a job that takes a long time to finish. The
           communication is unsynchronized without locking.
       
           abort: The application should set this field to 0 before
           calling fz_run_page to render a page. At any point when the
           page is being rendered the application my set this field to 1
           which will cause the rendering to finish soon. This field is
           checked periodically when the page is rendered, but exactly
           when is not known, therefore there is no upper bound on
           exactly when the rendering will abort. If the application
           did not provide a set of locks to fz_new_context, it must also
           await the completion of fz_run_page before issuing another
           call to fz_run_page. Note that once the application has set
           this field to 1 after it called fz_run_page it may not change
           the value again.
       
           progress: Communicates rendering progress back to the
           application and is read only. Increments as a page is being
           rendered. The value starts out at 0 and is limited to less
           than or equal to progress_max, unless progress_max is -1.
       
           progress_max: Communicates the known upper bound of rendering
           back to the application and is read only. The maximum value
           that the progress field may take. If there is no known upper
           bound on how long the rendering may take this value is -1 and
           progress is not limited. Note that the value of progress_max
           may change from -1 to a positive value once an upper bound is
           known, so take this into consideration when comparing the
           value of progress to that of progress_max.
       
           errors: count of errors during current rendering.
       
           incomplete: Initially should be set to 0. Will be set to
           non-zero if a TRYLATER error is thrown during rendering.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     abort = property(_mupdf.fz_cookie_abort_get, _mupdf.fz_cookie_abort_set)
    1:     progress = property(_mupdf.fz_cookie_progress_get, _mupdf.fz_cookie_progress_set)
    1:     progress_max = property(_mupdf.fz_cookie_progress_max_get, _mupdf.fz_cookie_progress_max_set)
    1:     errors = property(_mupdf.fz_cookie_errors_get, _mupdf.fz_cookie_errors_set)
    1:     incomplete = property(_mupdf.fz_cookie_incomplete_get, _mupdf.fz_cookie_incomplete_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_cookie_swiginit(self, _mupdf.new_fz_cookie())
    1:     __swig_destroy__ = _mupdf.delete_fz_cookie
       
       # Register fz_cookie in _mupdf:
    1: _mupdf.fz_cookie_swigregister(fz_cookie)
    1: FZ_TEST_OPT_IMAGES = _mupdf.FZ_TEST_OPT_IMAGES
    1: FZ_TEST_OPT_SHADINGS = _mupdf.FZ_TEST_OPT_SHADINGS
    2: class fz_draw_options(object):
    1:     r"""
           struct fz_draw_options: Options for creating a pixmap and draw
           device.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     rotate = property(_mupdf.fz_draw_options_rotate_get, _mupdf.fz_draw_options_rotate_set)
    1:     x_resolution = property(_mupdf.fz_draw_options_x_resolution_get, _mupdf.fz_draw_options_x_resolution_set)
    1:     y_resolution = property(_mupdf.fz_draw_options_y_resolution_get, _mupdf.fz_draw_options_y_resolution_set)
    1:     width = property(_mupdf.fz_draw_options_width_get, _mupdf.fz_draw_options_width_set)
    1:     height = property(_mupdf.fz_draw_options_height_get, _mupdf.fz_draw_options_height_set)
    1:     colorspace = property(_mupdf.fz_draw_options_colorspace_get, _mupdf.fz_draw_options_colorspace_set)
    1:     alpha = property(_mupdf.fz_draw_options_alpha_get, _mupdf.fz_draw_options_alpha_set)
    1:     graphics = property(_mupdf.fz_draw_options_graphics_get, _mupdf.fz_draw_options_graphics_set)
    1:     text = property(_mupdf.fz_draw_options_text_get, _mupdf.fz_draw_options_text_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_draw_options_swiginit(self, _mupdf.new_fz_draw_options())
    1:     __swig_destroy__ = _mupdf.delete_fz_draw_options
       
       # Register fz_draw_options in _mupdf:
    1: _mupdf.fz_draw_options_swigregister(fz_draw_options)
    2: class fz_layout_char(object):
    1:     r"""Simple text layout (for use with annotation editing primarily)."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     x = property(_mupdf.fz_layout_char_x_get, _mupdf.fz_layout_char_x_set)
    1:     advance = property(_mupdf.fz_layout_char_advance_get, _mupdf.fz_layout_char_advance_set)
    1:     p = property(_mupdf.fz_layout_char_p_get, _mupdf.fz_layout_char_p_set)
    1:     next = property(_mupdf.fz_layout_char_next_get, _mupdf.fz_layout_char_next_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_layout_char_swiginit(self, _mupdf.new_fz_layout_char())
    1:     __swig_destroy__ = _mupdf.delete_fz_layout_char
       
       # Register fz_layout_char in _mupdf:
    1: _mupdf.fz_layout_char_swigregister(fz_layout_char)
    2: class fz_layout_line(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     x = property(_mupdf.fz_layout_line_x_get, _mupdf.fz_layout_line_x_set)
    1:     y = property(_mupdf.fz_layout_line_y_get, _mupdf.fz_layout_line_y_set)
    1:     font_size = property(_mupdf.fz_layout_line_font_size_get, _mupdf.fz_layout_line_font_size_set)
    1:     p = property(_mupdf.fz_layout_line_p_get, _mupdf.fz_layout_line_p_set)
    1:     text = property(_mupdf.fz_layout_line_text_get, _mupdf.fz_layout_line_text_set)
    1:     next = property(_mupdf.fz_layout_line_next_get, _mupdf.fz_layout_line_next_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_layout_line_swiginit(self, _mupdf.new_fz_layout_line())
    1:     __swig_destroy__ = _mupdf.delete_fz_layout_line
       
       # Register fz_layout_line in _mupdf:
    1: _mupdf.fz_layout_line_swigregister(fz_layout_line)
    2: class fz_layout_block(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     pool = property(_mupdf.fz_layout_block_pool_get, _mupdf.fz_layout_block_pool_set)
    1:     matrix = property(_mupdf.fz_layout_block_matrix_get, _mupdf.fz_layout_block_matrix_set)
    1:     inv_matrix = property(_mupdf.fz_layout_block_inv_matrix_get, _mupdf.fz_layout_block_inv_matrix_set)
    1:     head = property(_mupdf.fz_layout_block_head_get, _mupdf.fz_layout_block_head_set)
    1:     tailp = property(_mupdf.fz_layout_block_tailp_get, _mupdf.fz_layout_block_tailp_set)
    1:     text_tailp = property(_mupdf.fz_layout_block_text_tailp_get, _mupdf.fz_layout_block_text_tailp_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_layout_block_swiginit(self, _mupdf.new_fz_layout_block())
    1:     __swig_destroy__ = _mupdf.delete_fz_layout_block
       
       # Register fz_layout_block in _mupdf:
    1: _mupdf.fz_layout_block_swigregister(fz_layout_block)
    1: FZ_STEXT_PRESERVE_LIGATURES = _mupdf.FZ_STEXT_PRESERVE_LIGATURES
    1: FZ_STEXT_PRESERVE_WHITESPACE = _mupdf.FZ_STEXT_PRESERVE_WHITESPACE
    1: FZ_STEXT_PRESERVE_IMAGES = _mupdf.FZ_STEXT_PRESERVE_IMAGES
    1: FZ_STEXT_INHIBIT_SPACES = _mupdf.FZ_STEXT_INHIBIT_SPACES
    1: FZ_STEXT_DEHYPHENATE = _mupdf.FZ_STEXT_DEHYPHENATE
    1: FZ_STEXT_PRESERVE_SPANS = _mupdf.FZ_STEXT_PRESERVE_SPANS
    1: FZ_STEXT_CLIP = _mupdf.FZ_STEXT_CLIP
    1: FZ_STEXT_USE_CID_FOR_UNKNOWN_UNICODE = _mupdf.FZ_STEXT_USE_CID_FOR_UNKNOWN_UNICODE
    1: FZ_STEXT_COLLECT_STRUCTURE = _mupdf.FZ_STEXT_COLLECT_STRUCTURE
    1: FZ_STEXT_ACCURATE_BBOXES = _mupdf.FZ_STEXT_ACCURATE_BBOXES
    1: FZ_STEXT_COLLECT_VECTORS = _mupdf.FZ_STEXT_COLLECT_VECTORS
    1: FZ_STEXT_IGNORE_ACTUALTEXT = _mupdf.FZ_STEXT_IGNORE_ACTUALTEXT
    1: FZ_STEXT_SEGMENT = _mupdf.FZ_STEXT_SEGMENT
    1: FZ_STEXT_PARAGRAPH_BREAK = _mupdf.FZ_STEXT_PARAGRAPH_BREAK
    1: FZ_STEXT_TABLE_HUNT = _mupdf.FZ_STEXT_TABLE_HUNT
    1: FZ_STEXT_COLLECT_STYLES = _mupdf.FZ_STEXT_COLLECT_STYLES
    1: FZ_STEXT_USE_GID_FOR_UNKNOWN_UNICODE = _mupdf.FZ_STEXT_USE_GID_FOR_UNKNOWN_UNICODE
    1: FZ_STEXT_CLIP_RECT = _mupdf.FZ_STEXT_CLIP_RECT
    1: FZ_STEXT_ACCURATE_ASCENDERS = _mupdf.FZ_STEXT_ACCURATE_ASCENDERS
    1: FZ_STEXT_ACCURATE_SIDE_BEARINGS = _mupdf.FZ_STEXT_ACCURATE_SIDE_BEARINGS
    1: FZ_STEXT_MEDIABOX_CLIP = _mupdf.FZ_STEXT_MEDIABOX_CLIP
    2: class fz_stext_page_details(object):
    1:     r"""
           A note on stext's handling of structure.
       
           A PDF document can contain a structure tree. This gives the
           structure of a document in its entirety as a tree. e.g.
       
           Tree                        MCID    INDEX
           -------------------------------------
           DOC                 0       0
            TOC                        1       0
             TOC_ITEM          2       0
             TOC_ITEM          3       1
             TOC_ITEM          4       2
             ...
            STORY                      100     1
             SECTION           101     0
              HEADING          102     0
              SUBSECTION               103     1
               PARAGRAPH               104     0
               PARAGRAPH               105     1
               PARAGRAPH               106     2
              SUBSECTION               107     2
               PARAGRAPH               108     0
               PARAGRAPH               109     1
               PARAGRAPH               110     2
              ...
             SECTION           200     1
               ...
       
           Each different section of the tree is identified as part of an
           MCID by a number (this is a slight simplification, but makes the
           explanation easier).
       
           The PDF document contains markings that say "Entering MCID 0"
           and "Leaving MCID 0". Any content within that region is therefore
           identified as appearing in that particular structural region.
       
           This means that content can be sent in the document in a different
           order to which it appears 'logically' in the tree.
       
           MuPDF converts this tree form into a nested series of calls to
           begin_structure and end_structure.
       
           For instance, if the document started out with MCID 100, then
           we'd send:
               begin_structure("DOC")
               begin_structure("STORY")
       
           The problem with this is that if we send:
               begin_structure("DOC")
               begin_structure("STORY")
               begin_structure("SECTION")
               begin_structure("SUBSECTION")
       
           or
               begin_structure("DOC")
               begin_structure("STORY")
               begin_structure("SECTION")
               begin_structure("HEADING")
       
           How do I know what order the SECTION and HEADING should appear in?
           Are they even in the same STORY? Or the same DOC?
       
           Accordingly, every begin_structure is accompanied not only with the
           node type, but with an index. The index is the number of this node
           within this level of the tree. Hence:
       
               begin_structure("DOC", 0)
               begin_structure("STORY", 0)
               begin_structure("SECTION", 0)
               begin_structure("HEADING", 0)
           and
               begin_structure("DOC", 0)
               begin_structure("STORY", 0)
               begin_structure("SECTION", 0)
               begin_structure("SUBSECTION", 1)
       
           are now unambiguous in their describing of the tree.
       
           MuPDF automatically sends the minimal end_structure/begin_structure
           pairs to move us between nodes in the tree.
       
           In order to accommodate this information within the structured text
           data structures an additional block type is used. Previously a
           "page" was just a list of blocks, either text or images. e.g.
       
           [BLOCK:TEXT] <-> [BLOCK:IMG] <-> [BLOCK:TEXT] <-> [BLOCK:TEXT] ...
       
           We now introduce a new type of block, STRUCT, that turns this into
           a tree:
       
           [BLOCK:TEXT] <-> [BLOCK:STRUCT(IDX=0)] <-> [BLOCK:TEXT] <-> ...
                                 /|
           [STRUCT:TYPE=DOC] <----
               |
           [BLOCK:TEXT] <-> [BLOCK:STRUCT(IDX=0)] <-> [BLOCK:TEXT] <-> ...
                                 /|
           [STRUCT:TYPE=STORY] <--
               |
              ...
       
           Rather than doing a simple linear traversal of the list to extract
           the logical data, a caller now has to do a depth-first traversal.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     mediabox = property(_mupdf.fz_stext_page_details_mediabox_get, _mupdf.fz_stext_page_details_mediabox_set)
    1:     chapter = property(_mupdf.fz_stext_page_details_chapter_get, _mupdf.fz_stext_page_details_chapter_set)
    1:     page = property(_mupdf.fz_stext_page_details_page_get, _mupdf.fz_stext_page_details_page_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_stext_page_details_swiginit(self, _mupdf.new_fz_stext_page_details())
    1:     __swig_destroy__ = _mupdf.delete_fz_stext_page_details
       
       # Register fz_stext_page_details in _mupdf:
    1: _mupdf.fz_stext_page_details_swigregister(fz_stext_page_details)
    2: class fz_stext_page(object):
    1:     r"""
           A text page is a list of blocks, together with an overall
           bounding box.
       
           The name of this structure is now slightly out of date. It
           should really be fz_stext_document, cos it can contain
           content from multiple pages.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_stext_page_refs_get, _mupdf.fz_stext_page_refs_set)
    1:     pool = property(_mupdf.fz_stext_page_pool_get, _mupdf.fz_stext_page_pool_set)
    1:     mediabox = property(_mupdf.fz_stext_page_mediabox_get, _mupdf.fz_stext_page_mediabox_set)
    1:     first_block = property(_mupdf.fz_stext_page_first_block_get, _mupdf.fz_stext_page_first_block_set)
    1:     last_block = property(_mupdf.fz_stext_page_last_block_get, _mupdf.fz_stext_page_last_block_set)
    1:     last_struct = property(_mupdf.fz_stext_page_last_struct_get, _mupdf.fz_stext_page_last_struct_set)
    1:     id_list = property(_mupdf.fz_stext_page_id_list_get, _mupdf.fz_stext_page_id_list_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_stext_page_swiginit(self, _mupdf.new_fz_stext_page())
    1:     __swig_destroy__ = _mupdf.delete_fz_stext_page
       
       # Register fz_stext_page in _mupdf:
    1: _mupdf.fz_stext_page_swigregister(fz_stext_page)
    1: FZ_STEXT_BLOCK_TEXT = _mupdf.FZ_STEXT_BLOCK_TEXT
    1: FZ_STEXT_BLOCK_IMAGE = _mupdf.FZ_STEXT_BLOCK_IMAGE
    1: FZ_STEXT_BLOCK_STRUCT = _mupdf.FZ_STEXT_BLOCK_STRUCT
    1: FZ_STEXT_BLOCK_VECTOR = _mupdf.FZ_STEXT_BLOCK_VECTOR
    1: FZ_STEXT_BLOCK_GRID = _mupdf.FZ_STEXT_BLOCK_GRID
    1: FZ_STEXT_TEXT_JUSTIFY_UNKNOWN = _mupdf.FZ_STEXT_TEXT_JUSTIFY_UNKNOWN
    1: FZ_STEXT_TEXT_JUSTIFY_LEFT = _mupdf.FZ_STEXT_TEXT_JUSTIFY_LEFT
    1: FZ_STEXT_TEXT_JUSTIFY_CENTRE = _mupdf.FZ_STEXT_TEXT_JUSTIFY_CENTRE
    1: FZ_STEXT_TEXT_JUSTIFY_RIGHT = _mupdf.FZ_STEXT_TEXT_JUSTIFY_RIGHT
    1: FZ_STEXT_TEXT_JUSTIFY_FULL = _mupdf.FZ_STEXT_TEXT_JUSTIFY_FULL
    1: FZ_STEXT_VECTOR_IS_STROKED = _mupdf.FZ_STEXT_VECTOR_IS_STROKED
    1: FZ_STEXT_VECTOR_IS_RECTANGLE = _mupdf.FZ_STEXT_VECTOR_IS_RECTANGLE
    1: FZ_STEXT_VECTOR_CONTINUES = _mupdf.FZ_STEXT_VECTOR_CONTINUES
    2: class fz_stext_block(object):
    1:     r"""
           A text block is a list of lines of text (typically a paragraph),
           or an image.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     type = property(_mupdf.fz_stext_block_type_get, _mupdf.fz_stext_block_type_set)
    1:     id = property(_mupdf.fz_stext_block_id_get, _mupdf.fz_stext_block_id_set)
    1:     bbox = property(_mupdf.fz_stext_block_bbox_get, _mupdf.fz_stext_block_bbox_set)
    1:     prev = property(_mupdf.fz_stext_block_prev_get, _mupdf.fz_stext_block_prev_set)
    1:     next = property(_mupdf.fz_stext_block_next_get, _mupdf.fz_stext_block_next_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_stext_block_swiginit(self, _mupdf.new_fz_stext_block())
    1:     __swig_destroy__ = _mupdf.delete_fz_stext_block
       
       # Register fz_stext_block in _mupdf:
    1: _mupdf.fz_stext_block_swigregister(fz_stext_block)
    2: class fz_stext_line(object):
    1:     r"""A text line is a list of characters that share a common baseline."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     wmode = property(_mupdf.fz_stext_line_wmode_get, _mupdf.fz_stext_line_wmode_set)
    1:     dir = property(_mupdf.fz_stext_line_dir_get, _mupdf.fz_stext_line_dir_set)
    1:     bbox = property(_mupdf.fz_stext_line_bbox_get, _mupdf.fz_stext_line_bbox_set)
    1:     first_char = property(_mupdf.fz_stext_line_first_char_get, _mupdf.fz_stext_line_first_char_set)
    1:     last_char = property(_mupdf.fz_stext_line_last_char_get, _mupdf.fz_stext_line_last_char_set)
    1:     prev = property(_mupdf.fz_stext_line_prev_get, _mupdf.fz_stext_line_prev_set)
    1:     next = property(_mupdf.fz_stext_line_next_get, _mupdf.fz_stext_line_next_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_stext_line_swiginit(self, _mupdf.new_fz_stext_line())
    1:     __swig_destroy__ = _mupdf.delete_fz_stext_line
       
       # Register fz_stext_line in _mupdf:
    1: _mupdf.fz_stext_line_swigregister(fz_stext_line)
    2: class fz_stext_char(object):
    1:     r"""
           A text char is a unicode character, the style in which is
           appears, and the point at which it is positioned.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     c = property(_mupdf.fz_stext_char_c_get, _mupdf.fz_stext_char_c_set)
    1:     bidi = property(_mupdf.fz_stext_char_bidi_get, _mupdf.fz_stext_char_bidi_set)
    1:     flags = property(_mupdf.fz_stext_char_flags_get, _mupdf.fz_stext_char_flags_set)
    1:     argb = property(_mupdf.fz_stext_char_argb_get, _mupdf.fz_stext_char_argb_set)
    1:     origin = property(_mupdf.fz_stext_char_origin_get, _mupdf.fz_stext_char_origin_set)
    1:     quad = property(_mupdf.fz_stext_char_quad_get, _mupdf.fz_stext_char_quad_set)
    1:     size = property(_mupdf.fz_stext_char_size_get, _mupdf.fz_stext_char_size_set)
    1:     font = property(_mupdf.fz_stext_char_font_get, _mupdf.fz_stext_char_font_set)
    1:     next = property(_mupdf.fz_stext_char_next_get, _mupdf.fz_stext_char_next_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_stext_char_swiginit(self, _mupdf.new_fz_stext_char())
    1:     __swig_destroy__ = _mupdf.delete_fz_stext_char
       
       # Register fz_stext_char in _mupdf:
    1: _mupdf.fz_stext_char_swigregister(fz_stext_char)
    1: FZ_STEXT_STRIKEOUT = _mupdf.FZ_STEXT_STRIKEOUT
    1: FZ_STEXT_UNDERLINE = _mupdf.FZ_STEXT_UNDERLINE
    1: FZ_STEXT_SYNTHETIC = _mupdf.FZ_STEXT_SYNTHETIC
    1: FZ_STEXT_BOLD = _mupdf.FZ_STEXT_BOLD
    1: FZ_STEXT_FILLED = _mupdf.FZ_STEXT_FILLED
    1: FZ_STEXT_STROKED = _mupdf.FZ_STEXT_STROKED
    1: FZ_STEXT_CLIPPED = _mupdf.FZ_STEXT_CLIPPED
    1: FZ_STEXT_UNICODE_IS_CID = _mupdf.FZ_STEXT_UNICODE_IS_CID
    1: FZ_STEXT_UNICODE_IS_GID = _mupdf.FZ_STEXT_UNICODE_IS_GID
    2: class fz_stext_struct(object):
    1:     r"""
           When we are collecting the structure information from
           PDF structure trees/tags, we end up with a tree of
           nodes. The structure should be walked in depth-first
           traversal order to extract the content.
       
           An fz_stext_struct pointer can be NULL to indicate that
           we know there is a child there within the complete tree,
           but we don't know what it is yet.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     up = property(_mupdf.fz_stext_struct_up_get, _mupdf.fz_stext_struct_up_set)
    1:     parent = property(_mupdf.fz_stext_struct_parent_get, _mupdf.fz_stext_struct_parent_set)
    1:     first_block = property(_mupdf.fz_stext_struct_first_block_get, _mupdf.fz_stext_struct_first_block_set)
    1:     last_block = property(_mupdf.fz_stext_struct_last_block_get, _mupdf.fz_stext_struct_last_block_set)
    1:     standard = property(_mupdf.fz_stext_struct_standard_get, _mupdf.fz_stext_struct_standard_set)
    1:     raw = property(_mupdf.fz_stext_struct_raw_get, _mupdf.fz_stext_struct_raw_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_stext_struct_swiginit(self, _mupdf.new_fz_stext_struct())
    1:     __swig_destroy__ = _mupdf.delete_fz_stext_struct
       
       # Register fz_stext_struct in _mupdf:
    1: _mupdf.fz_stext_struct_swigregister(fz_stext_struct)
    2: class fz_stext_grid_positions(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.fz_stext_grid_positions_len_get, _mupdf.fz_stext_grid_positions_len_set)
    1:     max_uncertainty = property(_mupdf.fz_stext_grid_positions_max_uncertainty_get, _mupdf.fz_stext_grid_positions_max_uncertainty_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_stext_grid_positions_swiginit(self, _mupdf.new_fz_stext_grid_positions())
    1:     __swig_destroy__ = _mupdf.delete_fz_stext_grid_positions
       
       # Register fz_stext_grid_positions in _mupdf:
    1: _mupdf.fz_stext_grid_positions_swigregister(fz_stext_grid_positions)
    1: FZ_SELECT_CHARS = _mupdf.FZ_SELECT_CHARS
    1: FZ_SELECT_WORDS = _mupdf.FZ_SELECT_WORDS
    1: FZ_SELECT_LINES = _mupdf.FZ_SELECT_LINES
    2: class fz_stext_options(object):
    1:     r"""Options for creating structured text."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     flags = property(_mupdf.fz_stext_options_flags_get, _mupdf.fz_stext_options_flags_set)
    1:     scale = property(_mupdf.fz_stext_options_scale_get, _mupdf.fz_stext_options_scale_set)
    1:     clip = property(_mupdf.fz_stext_options_clip_get, _mupdf.fz_stext_options_clip_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_stext_options_swiginit(self, _mupdf.new_fz_stext_options())
    1:     __swig_destroy__ = _mupdf.delete_fz_stext_options
       
       # Register fz_stext_options in _mupdf:
    1: _mupdf.fz_stext_options_swigregister(fz_stext_options)
    2: class fz_stext_page_block_iterator(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     page = property(_mupdf.fz_stext_page_block_iterator_page_get, _mupdf.fz_stext_page_block_iterator_page_set)
    1:     pos = property(_mupdf.fz_stext_page_block_iterator_pos_get, _mupdf.fz_stext_page_block_iterator_pos_set)
    1:     parent = property(_mupdf.fz_stext_page_block_iterator_parent_get, _mupdf.fz_stext_page_block_iterator_parent_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_stext_page_block_iterator_swiginit(self, _mupdf.new_fz_stext_page_block_iterator())
    1:     __swig_destroy__ = _mupdf.delete_fz_stext_page_block_iterator
       
       # Register fz_stext_page_block_iterator in _mupdf:
    1: _mupdf.fz_stext_page_block_iterator_swigregister(fz_stext_page_block_iterator)
    1: FZ_TRANSITION_NONE = _mupdf.FZ_TRANSITION_NONE
    1: FZ_TRANSITION_SPLIT = _mupdf.FZ_TRANSITION_SPLIT
    1: FZ_TRANSITION_BLINDS = _mupdf.FZ_TRANSITION_BLINDS
    1: FZ_TRANSITION_BOX = _mupdf.FZ_TRANSITION_BOX
    1: FZ_TRANSITION_WIPE = _mupdf.FZ_TRANSITION_WIPE
    1: FZ_TRANSITION_DISSOLVE = _mupdf.FZ_TRANSITION_DISSOLVE
    1: FZ_TRANSITION_GLITTER = _mupdf.FZ_TRANSITION_GLITTER
    1: FZ_TRANSITION_FLY = _mupdf.FZ_TRANSITION_FLY
    1: FZ_TRANSITION_PUSH = _mupdf.FZ_TRANSITION_PUSH
    1: FZ_TRANSITION_COVER = _mupdf.FZ_TRANSITION_COVER
    1: FZ_TRANSITION_UNCOVER = _mupdf.FZ_TRANSITION_UNCOVER
    1: FZ_TRANSITION_FADE = _mupdf.FZ_TRANSITION_FADE
    2: class fz_transition(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     type = property(_mupdf.fz_transition_type_get, _mupdf.fz_transition_type_set)
    1:     duration = property(_mupdf.fz_transition_duration_get, _mupdf.fz_transition_duration_set)
    1:     vertical = property(_mupdf.fz_transition_vertical_get, _mupdf.fz_transition_vertical_set)
    1:     outwards = property(_mupdf.fz_transition_outwards_get, _mupdf.fz_transition_outwards_set)
    1:     direction = property(_mupdf.fz_transition_direction_get, _mupdf.fz_transition_direction_set)
    1:     state0 = property(_mupdf.fz_transition_state0_get, _mupdf.fz_transition_state0_set)
    1:     state1 = property(_mupdf.fz_transition_state1_get, _mupdf.fz_transition_state1_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_transition_swiginit(self, _mupdf.new_fz_transition())
    1:     __swig_destroy__ = _mupdf.delete_fz_transition
       
       # Register fz_transition in _mupdf:
    1: _mupdf.fz_transition_swigregister(fz_transition)
    2: class fz_link(object):
    1:     r"""
           fz_link is a list of interactive links on a page.
       
           There is no relation between the order of the links in the
           list and the order they appear on the page. The list of links
           for a given page can be obtained from fz_load_links.
       
           A link is reference counted. Dropping a reference to a link is
           done by calling fz_drop_link.
       
           rect: The hot zone. The area that can be clicked in
           untransformed coordinates.
       
           uri: Link destinations come in two forms: internal and external.
           Internal links refer to other pages in the same document.
           External links are URLs to other documents.
       
           next: A pointer to the next link on the same page.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_link_refs_get, _mupdf.fz_link_refs_set)
    1:     next = property(_mupdf.fz_link_next_get, _mupdf.fz_link_next_set)
    1:     rect = property(_mupdf.fz_link_rect_get, _mupdf.fz_link_rect_set)
    1:     uri = property(_mupdf.fz_link_uri_get, _mupdf.fz_link_uri_set)
    1:     set_rect_fn = property(_mupdf.fz_link_set_rect_fn_get, _mupdf.fz_link_set_rect_fn_set)
    1:     set_uri_fn = property(_mupdf.fz_link_set_uri_fn_get, _mupdf.fz_link_set_uri_fn_set)
    1:     drop = property(_mupdf.fz_link_drop_get, _mupdf.fz_link_drop_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_link_swiginit(self, _mupdf.new_fz_link())
    1:     __swig_destroy__ = _mupdf.delete_fz_link
       
       # Register fz_link in _mupdf:
    1: _mupdf.fz_link_swigregister(fz_link)
    1: FZ_LINK_DEST_FIT = _mupdf.FZ_LINK_DEST_FIT
    1: FZ_LINK_DEST_FIT_B = _mupdf.FZ_LINK_DEST_FIT_B
    1: FZ_LINK_DEST_FIT_H = _mupdf.FZ_LINK_DEST_FIT_H
    1: FZ_LINK_DEST_FIT_BH = _mupdf.FZ_LINK_DEST_FIT_BH
    1: FZ_LINK_DEST_FIT_V = _mupdf.FZ_LINK_DEST_FIT_V
    1: FZ_LINK_DEST_FIT_BV = _mupdf.FZ_LINK_DEST_FIT_BV
    1: FZ_LINK_DEST_FIT_R = _mupdf.FZ_LINK_DEST_FIT_R
    1: FZ_LINK_DEST_XYZ = _mupdf.FZ_LINK_DEST_XYZ
    2: class fz_link_dest(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     loc = property(_mupdf.fz_link_dest_loc_get, _mupdf.fz_link_dest_loc_set)
    1:     type = property(_mupdf.fz_link_dest_type_get, _mupdf.fz_link_dest_type_set)
    1:     x = property(_mupdf.fz_link_dest_x_get, _mupdf.fz_link_dest_x_set)
    1:     y = property(_mupdf.fz_link_dest_y_get, _mupdf.fz_link_dest_y_set)
    1:     w = property(_mupdf.fz_link_dest_w_get, _mupdf.fz_link_dest_w_set)
    1:     h = property(_mupdf.fz_link_dest_h_get, _mupdf.fz_link_dest_h_set)
    1:     zoom = property(_mupdf.fz_link_dest_zoom_get, _mupdf.fz_link_dest_zoom_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_link_dest_swiginit(self, _mupdf.new_fz_link_dest())
    1:     __swig_destroy__ = _mupdf.delete_fz_link_dest
       
       # Register fz_link_dest in _mupdf:
    1: _mupdf.fz_link_dest_swigregister(fz_link_dest)
    2: class fz_outline_item(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     title = property(_mupdf.fz_outline_item_title_get, _mupdf.fz_outline_item_title_set)
    1:     uri = property(_mupdf.fz_outline_item_uri_get, _mupdf.fz_outline_item_uri_set)
    1:     is_open = property(_mupdf.fz_outline_item_is_open_get, _mupdf.fz_outline_item_is_open_set)
    1:     flags = property(_mupdf.fz_outline_item_flags_get, _mupdf.fz_outline_item_flags_set)
    1:     r = property(_mupdf.fz_outline_item_r_get, _mupdf.fz_outline_item_r_set)
    1:     g = property(_mupdf.fz_outline_item_g_get, _mupdf.fz_outline_item_g_set)
    1:     b = property(_mupdf.fz_outline_item_b_get, _mupdf.fz_outline_item_b_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_outline_item_swiginit(self, _mupdf.new_fz_outline_item())
    1:     __swig_destroy__ = _mupdf.delete_fz_outline_item
       
       # Register fz_outline_item in _mupdf:
    1: _mupdf.fz_outline_item_swigregister(fz_outline_item)
    1: FZ_OUTLINE_FLAG_BOLD = _mupdf.FZ_OUTLINE_FLAG_BOLD
    1: FZ_OUTLINE_FLAG_ITALIC = _mupdf.FZ_OUTLINE_FLAG_ITALIC
    2: class fz_outline(object):
    1:     r"""
           Structure based API
           fz_outline is a tree of the outline of a document (also known
           as table of contents).
       
           title: Title of outline item using UTF-8 encoding. May be NULL
           if the outline item has no text string.
       
           uri: Destination in the document to be displayed when this
           outline item is activated. May be an internal or external
           link, or NULL if the outline item does not have a destination.
       
           page: The page number of an internal link, or -1 for external
           links or links with no destination.
       
           next: The next outline item at the same level as this outline
           item. May be NULL if no more outline items exist at this level.
       
           down: The outline items immediate children in the hierarchy.
           May be NULL if no children exist.
       
           is_open: If zero, the outline element is closed in the UI. If
           1, it should be open, showing any child elements.
       
           flags: Bit 0 set -> Bold, Bit 1 set -> Italic. All other bits
           reserved.
       
           r, g, b: The RGB components of the color of this entry.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_outline_refs_get, _mupdf.fz_outline_refs_set)
    1:     title = property(_mupdf.fz_outline_title_get, _mupdf.fz_outline_title_set)
    1:     uri = property(_mupdf.fz_outline_uri_get, _mupdf.fz_outline_uri_set)
    1:     page = property(_mupdf.fz_outline_page_get, _mupdf.fz_outline_page_set)
    1:     x = property(_mupdf.fz_outline_x_get, _mupdf.fz_outline_x_set)
    1:     y = property(_mupdf.fz_outline_y_get, _mupdf.fz_outline_y_set)
    1:     next = property(_mupdf.fz_outline_next_get, _mupdf.fz_outline_next_set)
    1:     down = property(_mupdf.fz_outline_down_get, _mupdf.fz_outline_down_set)
    1:     is_open = property(_mupdf.fz_outline_is_open_get, _mupdf.fz_outline_is_open_set)
    1:     flags = property(_mupdf.fz_outline_flags_get, _mupdf.fz_outline_flags_set)
    1:     r = property(_mupdf.fz_outline_r_get, _mupdf.fz_outline_r_set)
    1:     g = property(_mupdf.fz_outline_g_get, _mupdf.fz_outline_g_set)
    1:     b = property(_mupdf.fz_outline_b_get, _mupdf.fz_outline_b_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_outline_swiginit(self, _mupdf.new_fz_outline())
    1:     __swig_destroy__ = _mupdf.delete_fz_outline
       
       # Register fz_outline in _mupdf:
    1: _mupdf.fz_outline_swigregister(fz_outline)
    2: class fz_outline_iterator(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     drop = property(_mupdf.fz_outline_iterator_drop_get, _mupdf.fz_outline_iterator_drop_set)
    1:     item = property(_mupdf.fz_outline_iterator_item_get, _mupdf.fz_outline_iterator_item_set)
    1:     next = property(_mupdf.fz_outline_iterator_next_get, _mupdf.fz_outline_iterator_next_set)
    1:     prev = property(_mupdf.fz_outline_iterator_prev_get, _mupdf.fz_outline_iterator_prev_set)
    1:     up = property(_mupdf.fz_outline_iterator_up_get, _mupdf.fz_outline_iterator_up_set)
    1:     down = property(_mupdf.fz_outline_iterator_down_get, _mupdf.fz_outline_iterator_down_set)
    1:     insert = property(_mupdf.fz_outline_iterator_insert_get, _mupdf.fz_outline_iterator_insert_set)
    1:     update = property(_mupdf.fz_outline_iterator_update_get, _mupdf.fz_outline_iterator_update_set)
    1:     _del = property(_mupdf.fz_outline_iterator__del_get, _mupdf.fz_outline_iterator__del_set)
    1:     doc = property(_mupdf.fz_outline_iterator_doc_get, _mupdf.fz_outline_iterator_doc_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_outline_iterator_swiginit(self, _mupdf.new_fz_outline_iterator())
    1:     __swig_destroy__ = _mupdf.delete_fz_outline_iterator
       
       # Register fz_outline_iterator in _mupdf:
    1: _mupdf.fz_outline_iterator_swigregister(fz_outline_iterator)
    1: FZ_MEDIA_BOX = _mupdf.FZ_MEDIA_BOX
    1: FZ_CROP_BOX = _mupdf.FZ_CROP_BOX
    1: FZ_BLEED_BOX = _mupdf.FZ_BLEED_BOX
    1: FZ_TRIM_BOX = _mupdf.FZ_TRIM_BOX
    1: FZ_ART_BOX = _mupdf.FZ_ART_BOX
    1: FZ_UNKNOWN_BOX = _mupdf.FZ_UNKNOWN_BOX
    1: FZ_LAYOUT_KINDLE_W = _mupdf.FZ_LAYOUT_KINDLE_W
    1: FZ_LAYOUT_KINDLE_H = _mupdf.FZ_LAYOUT_KINDLE_H
    1: FZ_LAYOUT_KINDLE_EM = _mupdf.FZ_LAYOUT_KINDLE_EM
    1: FZ_LAYOUT_US_POCKET_W = _mupdf.FZ_LAYOUT_US_POCKET_W
    1: FZ_LAYOUT_US_POCKET_H = _mupdf.FZ_LAYOUT_US_POCKET_H
    1: FZ_LAYOUT_US_POCKET_EM = _mupdf.FZ_LAYOUT_US_POCKET_EM
    1: FZ_LAYOUT_US_TRADE_W = _mupdf.FZ_LAYOUT_US_TRADE_W
    1: FZ_LAYOUT_US_TRADE_H = _mupdf.FZ_LAYOUT_US_TRADE_H
    1: FZ_LAYOUT_US_TRADE_EM = _mupdf.FZ_LAYOUT_US_TRADE_EM
    1: FZ_LAYOUT_UK_A_FORMAT_W = _mupdf.FZ_LAYOUT_UK_A_FORMAT_W
    1: FZ_LAYOUT_UK_A_FORMAT_H = _mupdf.FZ_LAYOUT_UK_A_FORMAT_H
    1: FZ_LAYOUT_UK_A_FORMAT_EM = _mupdf.FZ_LAYOUT_UK_A_FORMAT_EM
    1: FZ_LAYOUT_UK_B_FORMAT_W = _mupdf.FZ_LAYOUT_UK_B_FORMAT_W
    1: FZ_LAYOUT_UK_B_FORMAT_H = _mupdf.FZ_LAYOUT_UK_B_FORMAT_H
    1: FZ_LAYOUT_UK_B_FORMAT_EM = _mupdf.FZ_LAYOUT_UK_B_FORMAT_EM
    1: FZ_LAYOUT_UK_C_FORMAT_W = _mupdf.FZ_LAYOUT_UK_C_FORMAT_W
    1: FZ_LAYOUT_UK_C_FORMAT_H = _mupdf.FZ_LAYOUT_UK_C_FORMAT_H
    1: FZ_LAYOUT_UK_C_FORMAT_EM = _mupdf.FZ_LAYOUT_UK_C_FORMAT_EM
    1: FZ_LAYOUT_A5_W = _mupdf.FZ_LAYOUT_A5_W
    1: FZ_LAYOUT_A5_H = _mupdf.FZ_LAYOUT_A5_H
    1: FZ_LAYOUT_A5_EM = _mupdf.FZ_LAYOUT_A5_EM
    1: FZ_DEFAULT_LAYOUT_W = _mupdf.FZ_DEFAULT_LAYOUT_W
    1: FZ_DEFAULT_LAYOUT_H = _mupdf.FZ_DEFAULT_LAYOUT_H
    1: FZ_DEFAULT_LAYOUT_EM = _mupdf.FZ_DEFAULT_LAYOUT_EM
    1: FZ_PERMISSION_PRINT = _mupdf.FZ_PERMISSION_PRINT
    1: FZ_PERMISSION_COPY = _mupdf.FZ_PERMISSION_COPY
    1: FZ_PERMISSION_EDIT = _mupdf.FZ_PERMISSION_EDIT
    1: FZ_PERMISSION_ANNOTATE = _mupdf.FZ_PERMISSION_ANNOTATE
    1: FZ_PERMISSION_FORM = _mupdf.FZ_PERMISSION_FORM
    1: FZ_PERMISSION_ACCESSIBILITY = _mupdf.FZ_PERMISSION_ACCESSIBILITY
    1: FZ_PERMISSION_ASSEMBLE = _mupdf.FZ_PERMISSION_ASSEMBLE
    1: FZ_PERMISSION_PRINT_HQ = _mupdf.FZ_PERMISSION_PRINT_HQ
    1: FZ_META_FORMAT = _mupdf.FZ_META_FORMAT
    1: FZ_META_ENCRYPTION = _mupdf.FZ_META_ENCRYPTION
    1: FZ_META_INFO = _mupdf.FZ_META_INFO
    1: FZ_META_INFO_TITLE = _mupdf.FZ_META_INFO_TITLE
    1: FZ_META_INFO_AUTHOR = _mupdf.FZ_META_INFO_AUTHOR
    1: FZ_META_INFO_SUBJECT = _mupdf.FZ_META_INFO_SUBJECT
    1: FZ_META_INFO_KEYWORDS = _mupdf.FZ_META_INFO_KEYWORDS
    1: FZ_META_INFO_CREATOR = _mupdf.FZ_META_INFO_CREATOR
    1: FZ_META_INFO_PRODUCER = _mupdf.FZ_META_INFO_PRODUCER
    1: FZ_META_INFO_CREATIONDATE = _mupdf.FZ_META_INFO_CREATIONDATE
    1: FZ_META_INFO_MODIFICATIONDATE = _mupdf.FZ_META_INFO_MODIFICATIONDATE
    2: class fz_page(object):
    1:     r"""
           Structure definition is public so other classes can
           derive from it. Do not access the members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_page_refs_get, _mupdf.fz_page_refs_set)
    1:     doc = property(_mupdf.fz_page_doc_get, _mupdf.fz_page_doc_set)
    1:     chapter = property(_mupdf.fz_page_chapter_get, _mupdf.fz_page_chapter_set)
    1:     number = property(_mupdf.fz_page_number_get, _mupdf.fz_page_number_set)
    1:     incomplete = property(_mupdf.fz_page_incomplete_get, _mupdf.fz_page_incomplete_set)
    1:     in_doc = property(_mupdf.fz_page_in_doc_get, _mupdf.fz_page_in_doc_set)
    1:     drop_page = property(_mupdf.fz_page_drop_page_get, _mupdf.fz_page_drop_page_set)
    1:     bound_page = property(_mupdf.fz_page_bound_page_get, _mupdf.fz_page_bound_page_set)
    1:     run_page_contents = property(_mupdf.fz_page_run_page_contents_get, _mupdf.fz_page_run_page_contents_set)
    1:     run_page_annots = property(_mupdf.fz_page_run_page_annots_get, _mupdf.fz_page_run_page_annots_set)
    1:     run_page_widgets = property(_mupdf.fz_page_run_page_widgets_get, _mupdf.fz_page_run_page_widgets_set)
    1:     load_links = property(_mupdf.fz_page_load_links_get, _mupdf.fz_page_load_links_set)
    1:     page_presentation = property(_mupdf.fz_page_page_presentation_get, _mupdf.fz_page_page_presentation_set)
    1:     control_separation = property(_mupdf.fz_page_control_separation_get, _mupdf.fz_page_control_separation_set)
    1:     separation_disabled = property(_mupdf.fz_page_separation_disabled_get, _mupdf.fz_page_separation_disabled_set)
    1:     separations = property(_mupdf.fz_page_separations_get, _mupdf.fz_page_separations_set)
    1:     overprint = property(_mupdf.fz_page_overprint_get, _mupdf.fz_page_overprint_set)
    1:     create_link = property(_mupdf.fz_page_create_link_get, _mupdf.fz_page_create_link_set)
    1:     delete_link = property(_mupdf.fz_page_delete_link_get, _mupdf.fz_page_delete_link_set)
    1:     prev = property(_mupdf.fz_page_prev_get, _mupdf.fz_page_prev_set)
    1:     next = property(_mupdf.fz_page_next_get, _mupdf.fz_page_next_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_page_swiginit(self, _mupdf.new_fz_page())
    1:     __swig_destroy__ = _mupdf.delete_fz_page
       
       # Register fz_page in _mupdf:
    1: _mupdf.fz_page_swigregister(fz_page)
    2: class fz_document(object):
    1:     r"""
           Structure definition is public so other classes can
           derive from it. Callers should not access the members
           directly, though implementations will need initialize
           functions directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.fz_document_refs_get, _mupdf.fz_document_refs_set)
    1:     drop_document = property(_mupdf.fz_document_drop_document_get, _mupdf.fz_document_drop_document_set)
    1:     needs_password = property(_mupdf.fz_document_needs_password_get, _mupdf.fz_document_needs_password_set)
    1:     authenticate_password = property(_mupdf.fz_document_authenticate_password_get, _mupdf.fz_document_authenticate_password_set)
    1:     has_permission = property(_mupdf.fz_document_has_permission_get, _mupdf.fz_document_has_permission_set)
    1:     load_outline = property(_mupdf.fz_document_load_outline_get, _mupdf.fz_document_load_outline_set)
    1:     outline_iterator = property(_mupdf.fz_document_outline_iterator_get, _mupdf.fz_document_outline_iterator_set)
    1:     layout = property(_mupdf.fz_document_layout_get, _mupdf.fz_document_layout_set)
    1:     make_bookmark = property(_mupdf.fz_document_make_bookmark_get, _mupdf.fz_document_make_bookmark_set)
    1:     lookup_bookmark = property(_mupdf.fz_document_lookup_bookmark_get, _mupdf.fz_document_lookup_bookmark_set)
    1:     resolve_link_dest = property(_mupdf.fz_document_resolve_link_dest_get, _mupdf.fz_document_resolve_link_dest_set)
    1:     format_link_uri = property(_mupdf.fz_document_format_link_uri_get, _mupdf.fz_document_format_link_uri_set)
    1:     count_chapters = property(_mupdf.fz_document_count_chapters_get, _mupdf.fz_document_count_chapters_set)
    1:     count_pages = property(_mupdf.fz_document_count_pages_get, _mupdf.fz_document_count_pages_set)
    1:     load_page = property(_mupdf.fz_document_load_page_get, _mupdf.fz_document_load_page_set)
    1:     page_label = property(_mupdf.fz_document_page_label_get, _mupdf.fz_document_page_label_set)
    1:     lookup_metadata = property(_mupdf.fz_document_lookup_metadata_get, _mupdf.fz_document_lookup_metadata_set)
    1:     set_metadata = property(_mupdf.fz_document_set_metadata_get, _mupdf.fz_document_set_metadata_set)
    1:     get_output_intent = property(_mupdf.fz_document_get_output_intent_get, _mupdf.fz_document_get_output_intent_set)
    1:     output_accelerator = property(_mupdf.fz_document_output_accelerator_get, _mupdf.fz_document_output_accelerator_set)
    1:     run_structure = property(_mupdf.fz_document_run_structure_get, _mupdf.fz_document_run_structure_set)
    1:     as_pdf = property(_mupdf.fz_document_as_pdf_get, _mupdf.fz_document_as_pdf_set)
    1:     did_layout = property(_mupdf.fz_document_did_layout_get, _mupdf.fz_document_did_layout_set)
    1:     is_reflowable = property(_mupdf.fz_document_is_reflowable_get, _mupdf.fz_document_is_reflowable_set)
    1:     id = property(_mupdf.fz_document_id_get, _mupdf.fz_document_id_set)
    1:     open = property(_mupdf.fz_document_open_get, _mupdf.fz_document_open_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_document_swiginit(self, _mupdf.new_fz_document())
    1:     __swig_destroy__ = _mupdf.delete_fz_document
       
       # Register fz_document in _mupdf:
    1: _mupdf.fz_document_swigregister(fz_document)
    2: class fz_document_handler(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     recognize = property(_mupdf.fz_document_handler_recognize_get, _mupdf.fz_document_handler_recognize_set)
    1:     open = property(_mupdf.fz_document_handler_open_get, _mupdf.fz_document_handler_open_set)
    1:     extensions = property(_mupdf.fz_document_handler_extensions_get, _mupdf.fz_document_handler_extensions_set)
    1:     mimetypes = property(_mupdf.fz_document_handler_mimetypes_get, _mupdf.fz_document_handler_mimetypes_set)
    1:     recognize_content = property(_mupdf.fz_document_handler_recognize_content_get, _mupdf.fz_document_handler_recognize_content_set)
    1:     wants_dir = property(_mupdf.fz_document_handler_wants_dir_get, _mupdf.fz_document_handler_wants_dir_set)
    1:     wants_file = property(_mupdf.fz_document_handler_wants_file_get, _mupdf.fz_document_handler_wants_file_set)
    1:     fin = property(_mupdf.fz_document_handler_fin_get, _mupdf.fz_document_handler_fin_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_document_handler_swiginit(self, _mupdf.new_fz_document_handler())
    1:     __swig_destroy__ = _mupdf.delete_fz_document_handler
       
       # Register fz_document_handler in _mupdf:
    1: _mupdf.fz_document_handler_swigregister(fz_document_handler)
    2: class fz_document_writer(object):
    1:     r"""
           Structure is public to allow other structures to
           be derived from it. Do not access members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     begin_page = property(_mupdf.fz_document_writer_begin_page_get, _mupdf.fz_document_writer_begin_page_set)
    1:     end_page = property(_mupdf.fz_document_writer_end_page_get, _mupdf.fz_document_writer_end_page_set)
    1:     close_writer = property(_mupdf.fz_document_writer_close_writer_get, _mupdf.fz_document_writer_close_writer_set)
    1:     drop_writer = property(_mupdf.fz_document_writer_drop_writer_get, _mupdf.fz_document_writer_drop_writer_set)
    1:     dev = property(_mupdf.fz_document_writer_dev_get, _mupdf.fz_document_writer_dev_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_document_writer_swiginit(self, _mupdf.new_fz_document_writer())
    1:     __swig_destroy__ = _mupdf.delete_fz_document_writer
       
       # Register fz_document_writer in _mupdf:
    1: _mupdf.fz_document_writer_swigregister(fz_document_writer)
    2: class fz_band_writer(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     drop = property(_mupdf.fz_band_writer_drop_get, _mupdf.fz_band_writer_drop_set)
    1:     close = property(_mupdf.fz_band_writer_close_get, _mupdf.fz_band_writer_close_set)
    1:     header = property(_mupdf.fz_band_writer_header_get, _mupdf.fz_band_writer_header_set)
    1:     band = property(_mupdf.fz_band_writer_band_get, _mupdf.fz_band_writer_band_set)
    1:     trailer = property(_mupdf.fz_band_writer_trailer_get, _mupdf.fz_band_writer_trailer_set)
    1:     out = property(_mupdf.fz_band_writer_out_get, _mupdf.fz_band_writer_out_set)
    1:     w = property(_mupdf.fz_band_writer_w_get, _mupdf.fz_band_writer_w_set)
    1:     h = property(_mupdf.fz_band_writer_h_get, _mupdf.fz_band_writer_h_set)
    1:     n = property(_mupdf.fz_band_writer_n_get, _mupdf.fz_band_writer_n_set)
    1:     s = property(_mupdf.fz_band_writer_s_get, _mupdf.fz_band_writer_s_set)
    1:     alpha = property(_mupdf.fz_band_writer_alpha_get, _mupdf.fz_band_writer_alpha_set)
    1:     xres = property(_mupdf.fz_band_writer_xres_get, _mupdf.fz_band_writer_xres_set)
    1:     yres = property(_mupdf.fz_band_writer_yres_get, _mupdf.fz_band_writer_yres_set)
    1:     pagenum = property(_mupdf.fz_band_writer_pagenum_get, _mupdf.fz_band_writer_pagenum_set)
    1:     line = property(_mupdf.fz_band_writer_line_get, _mupdf.fz_band_writer_line_set)
    1:     seps = property(_mupdf.fz_band_writer_seps_get, _mupdf.fz_band_writer_seps_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_band_writer_swiginit(self, _mupdf.new_fz_band_writer())
    1:     __swig_destroy__ = _mupdf.delete_fz_band_writer
       
       # Register fz_band_writer in _mupdf:
    1: _mupdf.fz_band_writer_swigregister(fz_band_writer)
    2: class fz_pcl_options(object):
    1:     r"""PCL output"""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     features = property(_mupdf.fz_pcl_options_features_get, _mupdf.fz_pcl_options_features_set)
    1:     odd_page_init = property(_mupdf.fz_pcl_options_odd_page_init_get, _mupdf.fz_pcl_options_odd_page_init_set)
    1:     even_page_init = property(_mupdf.fz_pcl_options_even_page_init_get, _mupdf.fz_pcl_options_even_page_init_set)
    1:     tumble = property(_mupdf.fz_pcl_options_tumble_get, _mupdf.fz_pcl_options_tumble_set)
    1:     duplex_set = property(_mupdf.fz_pcl_options_duplex_set_get, _mupdf.fz_pcl_options_duplex_set_set)
    1:     duplex = property(_mupdf.fz_pcl_options_duplex_get, _mupdf.fz_pcl_options_duplex_set)
    1:     paper_size = property(_mupdf.fz_pcl_options_paper_size_get, _mupdf.fz_pcl_options_paper_size_set)
    1:     manual_feed_set = property(_mupdf.fz_pcl_options_manual_feed_set_get, _mupdf.fz_pcl_options_manual_feed_set_set)
    1:     manual_feed = property(_mupdf.fz_pcl_options_manual_feed_get, _mupdf.fz_pcl_options_manual_feed_set)
    1:     media_position_set = property(_mupdf.fz_pcl_options_media_position_set_get, _mupdf.fz_pcl_options_media_position_set_set)
    1:     media_position = property(_mupdf.fz_pcl_options_media_position_get, _mupdf.fz_pcl_options_media_position_set)
    1:     orientation = property(_mupdf.fz_pcl_options_orientation_get, _mupdf.fz_pcl_options_orientation_set)
    1:     page_count = property(_mupdf.fz_pcl_options_page_count_get, _mupdf.fz_pcl_options_page_count_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_pcl_options_swiginit(self, _mupdf.new_fz_pcl_options())
    1:     __swig_destroy__ = _mupdf.delete_fz_pcl_options
       
       # Register fz_pcl_options in _mupdf:
    1: _mupdf.fz_pcl_options_swigregister(fz_pcl_options)
    2: class fz_pclm_options(object):
    1:     r"""PCLm output"""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     compress = property(_mupdf.fz_pclm_options_compress_get, _mupdf.fz_pclm_options_compress_set)
    1:     strip_height = property(_mupdf.fz_pclm_options_strip_height_get, _mupdf.fz_pclm_options_strip_height_set)
    1:     page_count = property(_mupdf.fz_pclm_options_page_count_get, _mupdf.fz_pclm_options_page_count_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_pclm_options_swiginit(self, _mupdf.new_fz_pclm_options())
    1:     __swig_destroy__ = _mupdf.delete_fz_pclm_options
       
       # Register fz_pclm_options in _mupdf:
    1: _mupdf.fz_pclm_options_swigregister(fz_pclm_options)
    2: class fz_pdfocr_options(object):
    1:     r"""PDFOCR output"""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     compress = property(_mupdf.fz_pdfocr_options_compress_get, _mupdf.fz_pdfocr_options_compress_set)
    1:     strip_height = property(_mupdf.fz_pdfocr_options_strip_height_get, _mupdf.fz_pdfocr_options_strip_height_set)
    1:     language = property(_mupdf.fz_pdfocr_options_language_get, _mupdf.fz_pdfocr_options_language_set)
    1:     datadir = property(_mupdf.fz_pdfocr_options_datadir_get, _mupdf.fz_pdfocr_options_datadir_set)
    1:     skew_correct = property(_mupdf.fz_pdfocr_options_skew_correct_get, _mupdf.fz_pdfocr_options_skew_correct_set)
    1:     skew_angle = property(_mupdf.fz_pdfocr_options_skew_angle_get, _mupdf.fz_pdfocr_options_skew_angle_set)
    1:     skew_border = property(_mupdf.fz_pdfocr_options_skew_border_get, _mupdf.fz_pdfocr_options_skew_border_set)
    1:     page_count = property(_mupdf.fz_pdfocr_options_page_count_get, _mupdf.fz_pdfocr_options_page_count_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_pdfocr_options_swiginit(self, _mupdf.new_fz_pdfocr_options())
    1:     __swig_destroy__ = _mupdf.delete_fz_pdfocr_options
       
       # Register fz_pdfocr_options in _mupdf:
    1: _mupdf.fz_pdfocr_options_swigregister(fz_pdfocr_options)
    2: class fz_pwg_options(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     media_class = property(_mupdf.fz_pwg_options_media_class_get, _mupdf.fz_pwg_options_media_class_set)
    1:     media_color = property(_mupdf.fz_pwg_options_media_color_get, _mupdf.fz_pwg_options_media_color_set)
    1:     media_type = property(_mupdf.fz_pwg_options_media_type_get, _mupdf.fz_pwg_options_media_type_set)
    1:     output_type = property(_mupdf.fz_pwg_options_output_type_get, _mupdf.fz_pwg_options_output_type_set)
    1:     advance_distance = property(_mupdf.fz_pwg_options_advance_distance_get, _mupdf.fz_pwg_options_advance_distance_set)
    1:     advance_media = property(_mupdf.fz_pwg_options_advance_media_get, _mupdf.fz_pwg_options_advance_media_set)
    1:     collate = property(_mupdf.fz_pwg_options_collate_get, _mupdf.fz_pwg_options_collate_set)
    1:     cut_media = property(_mupdf.fz_pwg_options_cut_media_get, _mupdf.fz_pwg_options_cut_media_set)
    1:     duplex = property(_mupdf.fz_pwg_options_duplex_get, _mupdf.fz_pwg_options_duplex_set)
    1:     insert_sheet = property(_mupdf.fz_pwg_options_insert_sheet_get, _mupdf.fz_pwg_options_insert_sheet_set)
    1:     jog = property(_mupdf.fz_pwg_options_jog_get, _mupdf.fz_pwg_options_jog_set)
    1:     leading_edge = property(_mupdf.fz_pwg_options_leading_edge_get, _mupdf.fz_pwg_options_leading_edge_set)
    1:     manual_feed = property(_mupdf.fz_pwg_options_manual_feed_get, _mupdf.fz_pwg_options_manual_feed_set)
    1:     media_position = property(_mupdf.fz_pwg_options_media_position_get, _mupdf.fz_pwg_options_media_position_set)
    1:     media_weight = property(_mupdf.fz_pwg_options_media_weight_get, _mupdf.fz_pwg_options_media_weight_set)
    1:     mirror_print = property(_mupdf.fz_pwg_options_mirror_print_get, _mupdf.fz_pwg_options_mirror_print_set)
    1:     negative_print = property(_mupdf.fz_pwg_options_negative_print_get, _mupdf.fz_pwg_options_negative_print_set)
    1:     num_copies = property(_mupdf.fz_pwg_options_num_copies_get, _mupdf.fz_pwg_options_num_copies_set)
    1:     orientation = property(_mupdf.fz_pwg_options_orientation_get, _mupdf.fz_pwg_options_orientation_set)
    1:     output_face_up = property(_mupdf.fz_pwg_options_output_face_up_get, _mupdf.fz_pwg_options_output_face_up_set)
    1:     PageSize = property(_mupdf.fz_pwg_options_PageSize_get, _mupdf.fz_pwg_options_PageSize_set)
    1:     separations = property(_mupdf.fz_pwg_options_separations_get, _mupdf.fz_pwg_options_separations_set)
    1:     tray_switch = property(_mupdf.fz_pwg_options_tray_switch_get, _mupdf.fz_pwg_options_tray_switch_set)
    1:     tumble = property(_mupdf.fz_pwg_options_tumble_get, _mupdf.fz_pwg_options_tumble_set)
    1:     media_type_num = property(_mupdf.fz_pwg_options_media_type_num_get, _mupdf.fz_pwg_options_media_type_num_set)
    1:     compression = property(_mupdf.fz_pwg_options_compression_get, _mupdf.fz_pwg_options_compression_set)
    1:     row_count = property(_mupdf.fz_pwg_options_row_count_get, _mupdf.fz_pwg_options_row_count_set)
    1:     row_feed = property(_mupdf.fz_pwg_options_row_feed_get, _mupdf.fz_pwg_options_row_feed_set)
    1:     row_step = property(_mupdf.fz_pwg_options_row_step_get, _mupdf.fz_pwg_options_row_step_set)
    1:     rendering_intent = property(_mupdf.fz_pwg_options_rendering_intent_get, _mupdf.fz_pwg_options_rendering_intent_set)
    1:     page_size_name = property(_mupdf.fz_pwg_options_page_size_name_get, _mupdf.fz_pwg_options_page_size_name_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_pwg_options_swiginit(self, _mupdf.new_fz_pwg_options())
    1:     __swig_destroy__ = _mupdf.delete_fz_pwg_options
       
       # Register fz_pwg_options in _mupdf:
    1: _mupdf.fz_pwg_options_swigregister(fz_pwg_options)
    1: FZ_SVG_TEXT_AS_PATH = _mupdf.FZ_SVG_TEXT_AS_PATH
    1: FZ_SVG_TEXT_AS_TEXT = _mupdf.FZ_SVG_TEXT_AS_TEXT
    1: FZ_PLACE_STORY_FLAG_NO_OVERFLOW = _mupdf.FZ_PLACE_STORY_FLAG_NO_OVERFLOW
    1: FZ_PLACE_STORY_RETURN_ALL_FITTED = _mupdf.FZ_PLACE_STORY_RETURN_ALL_FITTED
    1: FZ_PLACE_STORY_RETURN_OVERFLOW_WIDTH = _mupdf.FZ_PLACE_STORY_RETURN_OVERFLOW_WIDTH
    2: class fz_story_element_position(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     depth = property(_mupdf.fz_story_element_position_depth_get, _mupdf.fz_story_element_position_depth_set)
    1:     heading = property(_mupdf.fz_story_element_position_heading_get, _mupdf.fz_story_element_position_heading_set)
    1:     id = property(_mupdf.fz_story_element_position_id_get, _mupdf.fz_story_element_position_id_set)
    1:     href = property(_mupdf.fz_story_element_position_href_get, _mupdf.fz_story_element_position_href_set)
    1:     rect = property(_mupdf.fz_story_element_position_rect_get, _mupdf.fz_story_element_position_rect_set)
    1:     text = property(_mupdf.fz_story_element_position_text_get, _mupdf.fz_story_element_position_text_set)
    1:     open_close = property(_mupdf.fz_story_element_position_open_close_get, _mupdf.fz_story_element_position_open_close_set)
    1:     rectangle_num = property(_mupdf.fz_story_element_position_rectangle_num_get, _mupdf.fz_story_element_position_rectangle_num_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_story_element_position_swiginit(self, _mupdf.new_fz_story_element_position())
    1:     __swig_destroy__ = _mupdf.delete_fz_story_element_position
       
       # Register fz_story_element_position in _mupdf:
    1: _mupdf.fz_story_element_position_swigregister(fz_story_element_position)
    2: class fz_write_story_position(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     element = property(_mupdf.fz_write_story_position_element_get, _mupdf.fz_write_story_position_element_set)
    1:     page_num = property(_mupdf.fz_write_story_position_page_num_get, _mupdf.fz_write_story_position_page_num_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_write_story_position_swiginit(self, _mupdf.new_fz_write_story_position())
    1:     __swig_destroy__ = _mupdf.delete_fz_write_story_position
       
       # Register fz_write_story_position in _mupdf:
    1: _mupdf.fz_write_story_position_swigregister(fz_write_story_position)
    2: class fz_write_story_positions(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     positions = property(_mupdf.fz_write_story_positions_positions_get, _mupdf.fz_write_story_positions_positions_set)
    1:     num = property(_mupdf.fz_write_story_positions_num_get, _mupdf.fz_write_story_positions_num_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_write_story_positions_swiginit(self, _mupdf.new_fz_write_story_positions())
    1:     __swig_destroy__ = _mupdf.delete_fz_write_story_positions
       
       # Register fz_write_story_positions in _mupdf:
    1: _mupdf.fz_write_story_positions_swigregister(fz_write_story_positions)
    1: FZ_DESKEW_BORDER_INCREASE = _mupdf.FZ_DESKEW_BORDER_INCREASE
    1: FZ_DESKEW_BORDER_MAINTAIN = _mupdf.FZ_DESKEW_BORDER_MAINTAIN
    1: FZ_DESKEW_BORDER_DECREASE = _mupdf.FZ_DESKEW_BORDER_DECREASE
    1: FZ_BARCODE_NONE = _mupdf.FZ_BARCODE_NONE
    1: FZ_BARCODE_AZTEC = _mupdf.FZ_BARCODE_AZTEC
    1: FZ_BARCODE_CODABAR = _mupdf.FZ_BARCODE_CODABAR
    1: FZ_BARCODE_CODE39 = _mupdf.FZ_BARCODE_CODE39
    1: FZ_BARCODE_CODE93 = _mupdf.FZ_BARCODE_CODE93
    1: FZ_BARCODE_CODE128 = _mupdf.FZ_BARCODE_CODE128
    1: FZ_BARCODE_DATABAR = _mupdf.FZ_BARCODE_DATABAR
    1: FZ_BARCODE_DATABAREXPANDED = _mupdf.FZ_BARCODE_DATABAREXPANDED
    1: FZ_BARCODE_DATAMATRIX = _mupdf.FZ_BARCODE_DATAMATRIX
    1: FZ_BARCODE_EAN8 = _mupdf.FZ_BARCODE_EAN8
    1: FZ_BARCODE_EAN13 = _mupdf.FZ_BARCODE_EAN13
    1: FZ_BARCODE_ITF = _mupdf.FZ_BARCODE_ITF
    1: FZ_BARCODE_MAXICODE = _mupdf.FZ_BARCODE_MAXICODE
    1: FZ_BARCODE_PDF417 = _mupdf.FZ_BARCODE_PDF417
    1: FZ_BARCODE_QRCODE = _mupdf.FZ_BARCODE_QRCODE
    1: FZ_BARCODE_UPCA = _mupdf.FZ_BARCODE_UPCA
    1: FZ_BARCODE_UPCE = _mupdf.FZ_BARCODE_UPCE
    1: FZ_BARCODE_MICROQRCODE = _mupdf.FZ_BARCODE_MICROQRCODE
    1: FZ_BARCODE_RMQRCODE = _mupdf.FZ_BARCODE_RMQRCODE
    1: FZ_BARCODE_DXFILMEDGE = _mupdf.FZ_BARCODE_DXFILMEDGE
    1: FZ_BARCODE_DATABARLIMITED = _mupdf.FZ_BARCODE_DATABARLIMITED
    1: FZ_BARCODE__LIMIT = _mupdf.FZ_BARCODE__LIMIT
    1: PDF_MAX_OBJECT_NUMBER = _mupdf.PDF_MAX_OBJECT_NUMBER
    1: PDF_MAX_GEN_NUMBER = _mupdf.PDF_MAX_GEN_NUMBER
    2: class pdf_cycle_list(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     up = property(_mupdf.pdf_cycle_list_up_get, _mupdf.pdf_cycle_list_up_set)
    1:     num = property(_mupdf.pdf_cycle_list_num_get, _mupdf.pdf_cycle_list_num_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_cycle_list_swiginit(self, _mupdf.new_pdf_cycle_list())
    1:     __swig_destroy__ = _mupdf.delete_pdf_cycle_list
       
       # Register pdf_cycle_list in _mupdf:
    1: _mupdf.pdf_cycle_list_swigregister(pdf_cycle_list)
    2: class pdf_mark_bits(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.pdf_mark_bits_len_get, _mupdf.pdf_mark_bits_len_set)
    1:     bits = property(_mupdf.pdf_mark_bits_bits_get, _mupdf.pdf_mark_bits_bits_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_mark_bits_swiginit(self, _mupdf.new_pdf_mark_bits())
    1:     __swig_destroy__ = _mupdf.delete_pdf_mark_bits
       
       # Register pdf_mark_bits in _mupdf:
    1: _mupdf.pdf_mark_bits_swigregister(pdf_mark_bits)
    2: class pdf_mark_list(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.pdf_mark_list_len_get, _mupdf.pdf_mark_list_len_set)
    1:     max = property(_mupdf.pdf_mark_list_max_get, _mupdf.pdf_mark_list_max_set)
    1:     list = property(_mupdf.pdf_mark_list_list_get, _mupdf.pdf_mark_list_list_set)
    1:     local_list = property(_mupdf.pdf_mark_list_local_list_get, _mupdf.pdf_mark_list_local_list_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_mark_list_swiginit(self, _mupdf.new_pdf_mark_list())
    1:     __swig_destroy__ = _mupdf.delete_pdf_mark_list
       
       # Register pdf_mark_list in _mupdf:
    1: _mupdf.pdf_mark_list_swigregister(pdf_mark_list)
    1: PDF_ENUM_NULL = _mupdf.PDF_ENUM_NULL
    1: PDF_ENUM_TRUE = _mupdf.PDF_ENUM_TRUE
    1: PDF_ENUM_FALSE = _mupdf.PDF_ENUM_FALSE
    1: PDF_ENUM_NAME_1_2 = _mupdf.PDF_ENUM_NAME_1_2
    1: PDF_ENUM_NAME_1_5 = _mupdf.PDF_ENUM_NAME_1_5
    1: PDF_ENUM_NAME_3D = _mupdf.PDF_ENUM_NAME_3D
    1: PDF_ENUM_NAME_A = _mupdf.PDF_ENUM_NAME_A
    1: PDF_ENUM_NAME_A85 = _mupdf.PDF_ENUM_NAME_A85
    1: PDF_ENUM_NAME_AA = _mupdf.PDF_ENUM_NAME_AA
    1: PDF_ENUM_NAME_AC = _mupdf.PDF_ENUM_NAME_AC
    1: PDF_ENUM_NAME_AESV2 = _mupdf.PDF_ENUM_NAME_AESV2
    1: PDF_ENUM_NAME_AESV3 = _mupdf.PDF_ENUM_NAME_AESV3
    1: PDF_ENUM_NAME_AF = _mupdf.PDF_ENUM_NAME_AF
    1: PDF_ENUM_NAME_AFRelationship = _mupdf.PDF_ENUM_NAME_AFRelationship
    1: PDF_ENUM_NAME_AHx = _mupdf.PDF_ENUM_NAME_AHx
    1: PDF_ENUM_NAME_AP = _mupdf.PDF_ENUM_NAME_AP
    1: PDF_ENUM_NAME_AS = _mupdf.PDF_ENUM_NAME_AS
    1: PDF_ENUM_NAME_ASCII85Decode = _mupdf.PDF_ENUM_NAME_ASCII85Decode
    1: PDF_ENUM_NAME_ASCIIHexDecode = _mupdf.PDF_ENUM_NAME_ASCIIHexDecode
    1: PDF_ENUM_NAME_AbsoluteColorimetric = _mupdf.PDF_ENUM_NAME_AbsoluteColorimetric
    1: PDF_ENUM_NAME_AcroForm = _mupdf.PDF_ENUM_NAME_AcroForm
    1: PDF_ENUM_NAME_Action = _mupdf.PDF_ENUM_NAME_Action
    1: PDF_ENUM_NAME_ActualText = _mupdf.PDF_ENUM_NAME_ActualText
    1: PDF_ENUM_NAME_Adobe_PPKLite = _mupdf.PDF_ENUM_NAME_Adobe_PPKLite
    1: PDF_ENUM_NAME_All = _mupdf.PDF_ENUM_NAME_All
    1: PDF_ENUM_NAME_AllOff = _mupdf.PDF_ENUM_NAME_AllOff
    1: PDF_ENUM_NAME_AllOn = _mupdf.PDF_ENUM_NAME_AllOn
    1: PDF_ENUM_NAME_Alpha = _mupdf.PDF_ENUM_NAME_Alpha
    1: PDF_ENUM_NAME_Alt = _mupdf.PDF_ENUM_NAME_Alt
    1: PDF_ENUM_NAME_Alternate = _mupdf.PDF_ENUM_NAME_Alternate
    1: PDF_ENUM_NAME_Alternative = _mupdf.PDF_ENUM_NAME_Alternative
    1: PDF_ENUM_NAME_Annot = _mupdf.PDF_ENUM_NAME_Annot
    1: PDF_ENUM_NAME_Annots = _mupdf.PDF_ENUM_NAME_Annots
    1: PDF_ENUM_NAME_AnyOff = _mupdf.PDF_ENUM_NAME_AnyOff
    1: PDF_ENUM_NAME_App = _mupdf.PDF_ENUM_NAME_App
    1: PDF_ENUM_NAME_Approved = _mupdf.PDF_ENUM_NAME_Approved
    1: PDF_ENUM_NAME_Art = _mupdf.PDF_ENUM_NAME_Art
    1: PDF_ENUM_NAME_ArtBox = _mupdf.PDF_ENUM_NAME_ArtBox
    1: PDF_ENUM_NAME_Artifact = _mupdf.PDF_ENUM_NAME_Artifact
    1: PDF_ENUM_NAME_AsIs = _mupdf.PDF_ENUM_NAME_AsIs
    1: PDF_ENUM_NAME_Ascent = _mupdf.PDF_ENUM_NAME_Ascent
    1: PDF_ENUM_NAME_Aside = _mupdf.PDF_ENUM_NAME_Aside
    1: PDF_ENUM_NAME_AuthEvent = _mupdf.PDF_ENUM_NAME_AuthEvent
    1: PDF_ENUM_NAME_Author = _mupdf.PDF_ENUM_NAME_Author
    1: PDF_ENUM_NAME_B = _mupdf.PDF_ENUM_NAME_B
    1: PDF_ENUM_NAME_BBox = _mupdf.PDF_ENUM_NAME_BBox
    1: PDF_ENUM_NAME_BC = _mupdf.PDF_ENUM_NAME_BC
    1: PDF_ENUM_NAME_BE = _mupdf.PDF_ENUM_NAME_BE
    1: PDF_ENUM_NAME_BG = _mupdf.PDF_ENUM_NAME_BG
    1: PDF_ENUM_NAME_BM = _mupdf.PDF_ENUM_NAME_BM
    1: PDF_ENUM_NAME_BPC = _mupdf.PDF_ENUM_NAME_BPC
    1: PDF_ENUM_NAME_BS = _mupdf.PDF_ENUM_NAME_BS
    1: PDF_ENUM_NAME_Background = _mupdf.PDF_ENUM_NAME_Background
    1: PDF_ENUM_NAME_BaseEncoding = _mupdf.PDF_ENUM_NAME_BaseEncoding
    1: PDF_ENUM_NAME_BaseFont = _mupdf.PDF_ENUM_NAME_BaseFont
    1: PDF_ENUM_NAME_BaseState = _mupdf.PDF_ENUM_NAME_BaseState
    1: PDF_ENUM_NAME_BibEntry = _mupdf.PDF_ENUM_NAME_BibEntry
    1: PDF_ENUM_NAME_BitsPerComponent = _mupdf.PDF_ENUM_NAME_BitsPerComponent
    1: PDF_ENUM_NAME_BitsPerCoordinate = _mupdf.PDF_ENUM_NAME_BitsPerCoordinate
    1: PDF_ENUM_NAME_BitsPerFlag = _mupdf.PDF_ENUM_NAME_BitsPerFlag
    1: PDF_ENUM_NAME_BitsPerSample = _mupdf.PDF_ENUM_NAME_BitsPerSample
    1: PDF_ENUM_NAME_BlackIs1 = _mupdf.PDF_ENUM_NAME_BlackIs1
    1: PDF_ENUM_NAME_BlackPoint = _mupdf.PDF_ENUM_NAME_BlackPoint
    1: PDF_ENUM_NAME_BleedBox = _mupdf.PDF_ENUM_NAME_BleedBox
    1: PDF_ENUM_NAME_Blinds = _mupdf.PDF_ENUM_NAME_Blinds
    1: PDF_ENUM_NAME_BlockQuote = _mupdf.PDF_ENUM_NAME_BlockQuote
    1: PDF_ENUM_NAME_Border = _mupdf.PDF_ENUM_NAME_Border
    1: PDF_ENUM_NAME_Bounds = _mupdf.PDF_ENUM_NAME_Bounds
    1: PDF_ENUM_NAME_Box = _mupdf.PDF_ENUM_NAME_Box
    1: PDF_ENUM_NAME_Br = _mupdf.PDF_ENUM_NAME_Br
    1: PDF_ENUM_NAME_BrotliDecode = _mupdf.PDF_ENUM_NAME_BrotliDecode
    1: PDF_ENUM_NAME_Bt = _mupdf.PDF_ENUM_NAME_Bt
    1: PDF_ENUM_NAME_Btn = _mupdf.PDF_ENUM_NAME_Btn
    1: PDF_ENUM_NAME_Butt = _mupdf.PDF_ENUM_NAME_Butt
    1: PDF_ENUM_NAME_ByteRange = _mupdf.PDF_ENUM_NAME_ByteRange
    1: PDF_ENUM_NAME_C = _mupdf.PDF_ENUM_NAME_C
    1: PDF_ENUM_NAME_C0 = _mupdf.PDF_ENUM_NAME_C0
    1: PDF_ENUM_NAME_C1 = _mupdf.PDF_ENUM_NAME_C1
    1: PDF_ENUM_NAME_CA = _mupdf.PDF_ENUM_NAME_CA
    1: PDF_ENUM_NAME_CCF = _mupdf.PDF_ENUM_NAME_CCF
    1: PDF_ENUM_NAME_CCITTFaxDecode = _mupdf.PDF_ENUM_NAME_CCITTFaxDecode
    1: PDF_ENUM_NAME_CF = _mupdf.PDF_ENUM_NAME_CF
    1: PDF_ENUM_NAME_CFM = _mupdf.PDF_ENUM_NAME_CFM
    1: PDF_ENUM_NAME_CI = _mupdf.PDF_ENUM_NAME_CI
    1: PDF_ENUM_NAME_CIDFontType0 = _mupdf.PDF_ENUM_NAME_CIDFontType0
    1: PDF_ENUM_NAME_CIDFontType0C = _mupdf.PDF_ENUM_NAME_CIDFontType0C
    1: PDF_ENUM_NAME_CIDFontType2 = _mupdf.PDF_ENUM_NAME_CIDFontType2
    1: PDF_ENUM_NAME_CIDSystemInfo = _mupdf.PDF_ENUM_NAME_CIDSystemInfo
    1: PDF_ENUM_NAME_CIDToGIDMap = _mupdf.PDF_ENUM_NAME_CIDToGIDMap
    1: PDF_ENUM_NAME_CL = _mupdf.PDF_ENUM_NAME_CL
    1: PDF_ENUM_NAME_CMYK = _mupdf.PDF_ENUM_NAME_CMYK
    1: PDF_ENUM_NAME_CO = _mupdf.PDF_ENUM_NAME_CO
    1: PDF_ENUM_NAME_CP = _mupdf.PDF_ENUM_NAME_CP
    1: PDF_ENUM_NAME_CS = _mupdf.PDF_ENUM_NAME_CS
    1: PDF_ENUM_NAME_CalCMYK = _mupdf.PDF_ENUM_NAME_CalCMYK
    1: PDF_ENUM_NAME_CalGray = _mupdf.PDF_ENUM_NAME_CalGray
    1: PDF_ENUM_NAME_CalRGB = _mupdf.PDF_ENUM_NAME_CalRGB
    1: PDF_ENUM_NAME_Cap = _mupdf.PDF_ENUM_NAME_Cap
    1: PDF_ENUM_NAME_CapHeight = _mupdf.PDF_ENUM_NAME_CapHeight
    1: PDF_ENUM_NAME_Caption = _mupdf.PDF_ENUM_NAME_Caption
    1: PDF_ENUM_NAME_Caret = _mupdf.PDF_ENUM_NAME_Caret
    1: PDF_ENUM_NAME_Catalog = _mupdf.PDF_ENUM_NAME_Catalog
    1: PDF_ENUM_NAME_Cert = _mupdf.PDF_ENUM_NAME_Cert
    1: PDF_ENUM_NAME_Ch = _mupdf.PDF_ENUM_NAME_Ch
    1: PDF_ENUM_NAME_Changes = _mupdf.PDF_ENUM_NAME_Changes
    1: PDF_ENUM_NAME_CharProcs = _mupdf.PDF_ENUM_NAME_CharProcs
    1: PDF_ENUM_NAME_CheckSum = _mupdf.PDF_ENUM_NAME_CheckSum
    1: PDF_ENUM_NAME_Circle = _mupdf.PDF_ENUM_NAME_Circle
    1: PDF_ENUM_NAME_ClosedArrow = _mupdf.PDF_ENUM_NAME_ClosedArrow
    1: PDF_ENUM_NAME_Code = _mupdf.PDF_ENUM_NAME_Code
    1: PDF_ENUM_NAME_Collection = _mupdf.PDF_ENUM_NAME_Collection
    1: PDF_ENUM_NAME_ColorSpace = _mupdf.PDF_ENUM_NAME_ColorSpace
    1: PDF_ENUM_NAME_ColorTransform = _mupdf.PDF_ENUM_NAME_ColorTransform
    1: PDF_ENUM_NAME_Colorants = _mupdf.PDF_ENUM_NAME_Colorants
    1: PDF_ENUM_NAME_Colors = _mupdf.PDF_ENUM_NAME_Colors
    1: PDF_ENUM_NAME_Columns = _mupdf.PDF_ENUM_NAME_Columns
    1: PDF_ENUM_NAME_Confidential = _mupdf.PDF_ENUM_NAME_Confidential
    1: PDF_ENUM_NAME_Configs = _mupdf.PDF_ENUM_NAME_Configs
    1: PDF_ENUM_NAME_ContactInfo = _mupdf.PDF_ENUM_NAME_ContactInfo
    1: PDF_ENUM_NAME_Contents = _mupdf.PDF_ENUM_NAME_Contents
    1: PDF_ENUM_NAME_Coords = _mupdf.PDF_ENUM_NAME_Coords
    1: PDF_ENUM_NAME_Count = _mupdf.PDF_ENUM_NAME_Count
    1: PDF_ENUM_NAME_Cover = _mupdf.PDF_ENUM_NAME_Cover
    1: PDF_ENUM_NAME_CreationDate = _mupdf.PDF_ENUM_NAME_CreationDate
    1: PDF_ENUM_NAME_Creator = _mupdf.PDF_ENUM_NAME_Creator
    1: PDF_ENUM_NAME_CropBox = _mupdf.PDF_ENUM_NAME_CropBox
    1: PDF_ENUM_NAME_Crypt = _mupdf.PDF_ENUM_NAME_Crypt
    1: PDF_ENUM_NAME_D = _mupdf.PDF_ENUM_NAME_D
    1: PDF_ENUM_NAME_DA = _mupdf.PDF_ENUM_NAME_DA
    1: PDF_ENUM_NAME_DC = _mupdf.PDF_ENUM_NAME_DC
    1: PDF_ENUM_NAME_DCT = _mupdf.PDF_ENUM_NAME_DCT
    1: PDF_ENUM_NAME_DCTDecode = _mupdf.PDF_ENUM_NAME_DCTDecode
    1: PDF_ENUM_NAME_DL = _mupdf.PDF_ENUM_NAME_DL
    1: PDF_ENUM_NAME_DOS = _mupdf.PDF_ENUM_NAME_DOS
    1: PDF_ENUM_NAME_DP = _mupdf.PDF_ENUM_NAME_DP
    1: PDF_ENUM_NAME_DR = _mupdf.PDF_ENUM_NAME_DR
    1: PDF_ENUM_NAME_DS = _mupdf.PDF_ENUM_NAME_DS
    1: PDF_ENUM_NAME_DV = _mupdf.PDF_ENUM_NAME_DV
    1: PDF_ENUM_NAME_DW = _mupdf.PDF_ENUM_NAME_DW
    1: PDF_ENUM_NAME_DW2 = _mupdf.PDF_ENUM_NAME_DW2
    1: PDF_ENUM_NAME_DamagedRowsBeforeError = _mupdf.PDF_ENUM_NAME_DamagedRowsBeforeError
    1: PDF_ENUM_NAME_Data = _mupdf.PDF_ENUM_NAME_Data
    1: PDF_ENUM_NAME_Date = _mupdf.PDF_ENUM_NAME_Date
    1: PDF_ENUM_NAME_Decode = _mupdf.PDF_ENUM_NAME_Decode
    1: PDF_ENUM_NAME_DecodeParms = _mupdf.PDF_ENUM_NAME_DecodeParms
    1: PDF_ENUM_NAME_Default = _mupdf.PDF_ENUM_NAME_Default
    1: PDF_ENUM_NAME_DefaultCMYK = _mupdf.PDF_ENUM_NAME_DefaultCMYK
    1: PDF_ENUM_NAME_DefaultGray = _mupdf.PDF_ENUM_NAME_DefaultGray
    1: PDF_ENUM_NAME_DefaultRGB = _mupdf.PDF_ENUM_NAME_DefaultRGB
    1: PDF_ENUM_NAME_Departmental = _mupdf.PDF_ENUM_NAME_Departmental
    1: PDF_ENUM_NAME_Desc = _mupdf.PDF_ENUM_NAME_Desc
    1: PDF_ENUM_NAME_DescendantFonts = _mupdf.PDF_ENUM_NAME_DescendantFonts
    1: PDF_ENUM_NAME_Descent = _mupdf.PDF_ENUM_NAME_Descent
    1: PDF_ENUM_NAME_Design = _mupdf.PDF_ENUM_NAME_Design
    1: PDF_ENUM_NAME_Dest = _mupdf.PDF_ENUM_NAME_Dest
    1: PDF_ENUM_NAME_DestOutputProfile = _mupdf.PDF_ENUM_NAME_DestOutputProfile
    1: PDF_ENUM_NAME_Dests = _mupdf.PDF_ENUM_NAME_Dests
    1: PDF_ENUM_NAME_DeviceCMYK = _mupdf.PDF_ENUM_NAME_DeviceCMYK
    1: PDF_ENUM_NAME_DeviceGray = _mupdf.PDF_ENUM_NAME_DeviceGray
    1: PDF_ENUM_NAME_DeviceN = _mupdf.PDF_ENUM_NAME_DeviceN
    1: PDF_ENUM_NAME_DeviceRGB = _mupdf.PDF_ENUM_NAME_DeviceRGB
    1: PDF_ENUM_NAME_Di = _mupdf.PDF_ENUM_NAME_Di
    1: PDF_ENUM_NAME_Diamond = _mupdf.PDF_ENUM_NAME_Diamond
    1: PDF_ENUM_NAME_Differences = _mupdf.PDF_ENUM_NAME_Differences
    1: PDF_ENUM_NAME_DigestLocation = _mupdf.PDF_ENUM_NAME_DigestLocation
    1: PDF_ENUM_NAME_DigestMethod = _mupdf.PDF_ENUM_NAME_DigestMethod
    1: PDF_ENUM_NAME_DigestValue = _mupdf.PDF_ENUM_NAME_DigestValue
    1: PDF_ENUM_NAME_Dissolve = _mupdf.PDF_ENUM_NAME_Dissolve
    1: PDF_ENUM_NAME_Div = _mupdf.PDF_ENUM_NAME_Div
    1: PDF_ENUM_NAME_Dm = _mupdf.PDF_ENUM_NAME_Dm
    1: PDF_ENUM_NAME_DocMDP = _mupdf.PDF_ENUM_NAME_DocMDP
    1: PDF_ENUM_NAME_Document = _mupdf.PDF_ENUM_NAME_Document
    1: PDF_ENUM_NAME_DocumentFragment = _mupdf.PDF_ENUM_NAME_DocumentFragment
    1: PDF_ENUM_NAME_Domain = _mupdf.PDF_ENUM_NAME_Domain
    1: PDF_ENUM_NAME_Draft = _mupdf.PDF_ENUM_NAME_Draft
    1: PDF_ENUM_NAME_Dur = _mupdf.PDF_ENUM_NAME_Dur
    1: PDF_ENUM_NAME_E = _mupdf.PDF_ENUM_NAME_E
    1: PDF_ENUM_NAME_EF = _mupdf.PDF_ENUM_NAME_EF
    1: PDF_ENUM_NAME_EarlyChange = _mupdf.PDF_ENUM_NAME_EarlyChange
    1: PDF_ENUM_NAME_Em = _mupdf.PDF_ENUM_NAME_Em
    1: PDF_ENUM_NAME_EmbeddedFile = _mupdf.PDF_ENUM_NAME_EmbeddedFile
    1: PDF_ENUM_NAME_EmbeddedFiles = _mupdf.PDF_ENUM_NAME_EmbeddedFiles
    1: PDF_ENUM_NAME_Encode = _mupdf.PDF_ENUM_NAME_Encode
    1: PDF_ENUM_NAME_EncodedByteAlign = _mupdf.PDF_ENUM_NAME_EncodedByteAlign
    1: PDF_ENUM_NAME_Encoding = _mupdf.PDF_ENUM_NAME_Encoding
    1: PDF_ENUM_NAME_Encrypt = _mupdf.PDF_ENUM_NAME_Encrypt
    1: PDF_ENUM_NAME_EncryptMetadata = _mupdf.PDF_ENUM_NAME_EncryptMetadata
    1: PDF_ENUM_NAME_EncryptedPayload = _mupdf.PDF_ENUM_NAME_EncryptedPayload
    1: PDF_ENUM_NAME_EndOfBlock = _mupdf.PDF_ENUM_NAME_EndOfBlock
    1: PDF_ENUM_NAME_EndOfLine = _mupdf.PDF_ENUM_NAME_EndOfLine
    1: PDF_ENUM_NAME_Exclude = _mupdf.PDF_ENUM_NAME_Exclude
    1: PDF_ENUM_NAME_Experimental = _mupdf.PDF_ENUM_NAME_Experimental
    1: PDF_ENUM_NAME_Expired = _mupdf.PDF_ENUM_NAME_Expired
    1: PDF_ENUM_NAME_ExtGState = _mupdf.PDF_ENUM_NAME_ExtGState
    1: PDF_ENUM_NAME_Extend = _mupdf.PDF_ENUM_NAME_Extend
    1: PDF_ENUM_NAME_F = _mupdf.PDF_ENUM_NAME_F
    1: PDF_ENUM_NAME_FENote = _mupdf.PDF_ENUM_NAME_FENote
    1: PDF_ENUM_NAME_FL = _mupdf.PDF_ENUM_NAME_FL
    1: PDF_ENUM_NAME_FRM = _mupdf.PDF_ENUM_NAME_FRM
    1: PDF_ENUM_NAME_FS = _mupdf.PDF_ENUM_NAME_FS
    1: PDF_ENUM_NAME_FT = _mupdf.PDF_ENUM_NAME_FT
    1: PDF_ENUM_NAME_Fade = _mupdf.PDF_ENUM_NAME_Fade
    1: PDF_ENUM_NAME_Ff = _mupdf.PDF_ENUM_NAME_Ff
    1: PDF_ENUM_NAME_FieldMDP = _mupdf.PDF_ENUM_NAME_FieldMDP
    1: PDF_ENUM_NAME_Fields = _mupdf.PDF_ENUM_NAME_Fields
    1: PDF_ENUM_NAME_Figure = _mupdf.PDF_ENUM_NAME_Figure
    1: PDF_ENUM_NAME_FileAttachment = _mupdf.PDF_ENUM_NAME_FileAttachment
    1: PDF_ENUM_NAME_FileSize = _mupdf.PDF_ENUM_NAME_FileSize
    1: PDF_ENUM_NAME_Filespec = _mupdf.PDF_ENUM_NAME_Filespec
    1: PDF_ENUM_NAME_Filter = _mupdf.PDF_ENUM_NAME_Filter
    1: PDF_ENUM_NAME_Final = _mupdf.PDF_ENUM_NAME_Final
    1: PDF_ENUM_NAME_Fingerprint = _mupdf.PDF_ENUM_NAME_Fingerprint
    1: PDF_ENUM_NAME_First = _mupdf.PDF_ENUM_NAME_First
    1: PDF_ENUM_NAME_FirstChar = _mupdf.PDF_ENUM_NAME_FirstChar
    1: PDF_ENUM_NAME_FirstPage = _mupdf.PDF_ENUM_NAME_FirstPage
    1: PDF_ENUM_NAME_Fit = _mupdf.PDF_ENUM_NAME_Fit
    1: PDF_ENUM_NAME_FitB = _mupdf.PDF_ENUM_NAME_FitB
    1: PDF_ENUM_NAME_FitBH = _mupdf.PDF_ENUM_NAME_FitBH
    1: PDF_ENUM_NAME_FitBV = _mupdf.PDF_ENUM_NAME_FitBV
    1: PDF_ENUM_NAME_FitH = _mupdf.PDF_ENUM_NAME_FitH
    1: PDF_ENUM_NAME_FitR = _mupdf.PDF_ENUM_NAME_FitR
    1: PDF_ENUM_NAME_FitV = _mupdf.PDF_ENUM_NAME_FitV
    1: PDF_ENUM_NAME_Fl = _mupdf.PDF_ENUM_NAME_Fl
    1: PDF_ENUM_NAME_Flags = _mupdf.PDF_ENUM_NAME_Flags
    1: PDF_ENUM_NAME_FlateDecode = _mupdf.PDF_ENUM_NAME_FlateDecode
    1: PDF_ENUM_NAME_Fly = _mupdf.PDF_ENUM_NAME_Fly
    1: PDF_ENUM_NAME_Font = _mupdf.PDF_ENUM_NAME_Font
    1: PDF_ENUM_NAME_FontBBox = _mupdf.PDF_ENUM_NAME_FontBBox
    1: PDF_ENUM_NAME_FontDescriptor = _mupdf.PDF_ENUM_NAME_FontDescriptor
    1: PDF_ENUM_NAME_FontFile = _mupdf.PDF_ENUM_NAME_FontFile
    1: PDF_ENUM_NAME_FontFile2 = _mupdf.PDF_ENUM_NAME_FontFile2
    1: PDF_ENUM_NAME_FontFile3 = _mupdf.PDF_ENUM_NAME_FontFile3
    1: PDF_ENUM_NAME_FontMatrix = _mupdf.PDF_ENUM_NAME_FontMatrix
    1: PDF_ENUM_NAME_FontName = _mupdf.PDF_ENUM_NAME_FontName
    1: PDF_ENUM_NAME_ForComment = _mupdf.PDF_ENUM_NAME_ForComment
    1: PDF_ENUM_NAME_ForPublicRelease = _mupdf.PDF_ENUM_NAME_ForPublicRelease
    1: PDF_ENUM_NAME_Form = _mupdf.PDF_ENUM_NAME_Form
    1: PDF_ENUM_NAME_FormData = _mupdf.PDF_ENUM_NAME_FormData
    1: PDF_ENUM_NAME_FormEx = _mupdf.PDF_ENUM_NAME_FormEx
    1: PDF_ENUM_NAME_FormType = _mupdf.PDF_ENUM_NAME_FormType
    1: PDF_ENUM_NAME_Formula = _mupdf.PDF_ENUM_NAME_Formula
    1: PDF_ENUM_NAME_FreeText = _mupdf.PDF_ENUM_NAME_FreeText
    1: PDF_ENUM_NAME_FreeTextCallout = _mupdf.PDF_ENUM_NAME_FreeTextCallout
    1: PDF_ENUM_NAME_FreeTextTypeWriter = _mupdf.PDF_ENUM_NAME_FreeTextTypeWriter
    1: PDF_ENUM_NAME_Function = _mupdf.PDF_ENUM_NAME_Function
    1: PDF_ENUM_NAME_FunctionType = _mupdf.PDF_ENUM_NAME_FunctionType
    1: PDF_ENUM_NAME_Functions = _mupdf.PDF_ENUM_NAME_Functions
    1: PDF_ENUM_NAME_G = _mupdf.PDF_ENUM_NAME_G
    1: PDF_ENUM_NAME_GTS_PDFX = _mupdf.PDF_ENUM_NAME_GTS_PDFX
    1: PDF_ENUM_NAME_Gamma = _mupdf.PDF_ENUM_NAME_Gamma
    1: PDF_ENUM_NAME_Glitter = _mupdf.PDF_ENUM_NAME_Glitter
    1: PDF_ENUM_NAME_GoTo = _mupdf.PDF_ENUM_NAME_GoTo
    1: PDF_ENUM_NAME_GoToR = _mupdf.PDF_ENUM_NAME_GoToR
    1: PDF_ENUM_NAME_Group = _mupdf.PDF_ENUM_NAME_Group
    1: PDF_ENUM_NAME_H = _mupdf.PDF_ENUM_NAME_H
    1: PDF_ENUM_NAME_H1 = _mupdf.PDF_ENUM_NAME_H1
    1: PDF_ENUM_NAME_H2 = _mupdf.PDF_ENUM_NAME_H2
    1: PDF_ENUM_NAME_H3 = _mupdf.PDF_ENUM_NAME_H3
    1: PDF_ENUM_NAME_H4 = _mupdf.PDF_ENUM_NAME_H4
    1: PDF_ENUM_NAME_H5 = _mupdf.PDF_ENUM_NAME_H5
    1: PDF_ENUM_NAME_H6 = _mupdf.PDF_ENUM_NAME_H6
    1: PDF_ENUM_NAME_Height = _mupdf.PDF_ENUM_NAME_Height
    1: PDF_ENUM_NAME_Helv = _mupdf.PDF_ENUM_NAME_Helv
    1: PDF_ENUM_NAME_Highlight = _mupdf.PDF_ENUM_NAME_Highlight
    1: PDF_ENUM_NAME_HistoryPos = _mupdf.PDF_ENUM_NAME_HistoryPos
    1: PDF_ENUM_NAME_I = _mupdf.PDF_ENUM_NAME_I
    1: PDF_ENUM_NAME_IC = _mupdf.PDF_ENUM_NAME_IC
    1: PDF_ENUM_NAME_ICCBased = _mupdf.PDF_ENUM_NAME_ICCBased
    1: PDF_ENUM_NAME_ID = _mupdf.PDF_ENUM_NAME_ID
    1: PDF_ENUM_NAME_IM = _mupdf.PDF_ENUM_NAME_IM
    1: PDF_ENUM_NAME_IRT = _mupdf.PDF_ENUM_NAME_IRT
    1: PDF_ENUM_NAME_IT = _mupdf.PDF_ENUM_NAME_IT
    1: PDF_ENUM_NAME_Identity = _mupdf.PDF_ENUM_NAME_Identity
    1: PDF_ENUM_NAME_Identity_H = _mupdf.PDF_ENUM_NAME_Identity_H
    1: PDF_ENUM_NAME_Identity_V = _mupdf.PDF_ENUM_NAME_Identity_V
    1: PDF_ENUM_NAME_Image = _mupdf.PDF_ENUM_NAME_Image
    1: PDF_ENUM_NAME_ImageB = _mupdf.PDF_ENUM_NAME_ImageB
    1: PDF_ENUM_NAME_ImageC = _mupdf.PDF_ENUM_NAME_ImageC
    1: PDF_ENUM_NAME_ImageI = _mupdf.PDF_ENUM_NAME_ImageI
    1: PDF_ENUM_NAME_ImageMask = _mupdf.PDF_ENUM_NAME_ImageMask
    1: PDF_ENUM_NAME_Include = _mupdf.PDF_ENUM_NAME_Include
    1: PDF_ENUM_NAME_Index = _mupdf.PDF_ENUM_NAME_Index
    1: PDF_ENUM_NAME_Indexed = _mupdf.PDF_ENUM_NAME_Indexed
    1: PDF_ENUM_NAME_Info = _mupdf.PDF_ENUM_NAME_Info
    1: PDF_ENUM_NAME_Ink = _mupdf.PDF_ENUM_NAME_Ink
    1: PDF_ENUM_NAME_InkList = _mupdf.PDF_ENUM_NAME_InkList
    1: PDF_ENUM_NAME_Intent = _mupdf.PDF_ENUM_NAME_Intent
    1: PDF_ENUM_NAME_Interpolate = _mupdf.PDF_ENUM_NAME_Interpolate
    1: PDF_ENUM_NAME_IsMap = _mupdf.PDF_ENUM_NAME_IsMap
    1: PDF_ENUM_NAME_ItalicAngle = _mupdf.PDF_ENUM_NAME_ItalicAngle
    1: PDF_ENUM_NAME_JBIG2Decode = _mupdf.PDF_ENUM_NAME_JBIG2Decode
    1: PDF_ENUM_NAME_JBIG2Globals = _mupdf.PDF_ENUM_NAME_JBIG2Globals
    1: PDF_ENUM_NAME_JPXDecode = _mupdf.PDF_ENUM_NAME_JPXDecode
    1: PDF_ENUM_NAME_JS = _mupdf.PDF_ENUM_NAME_JS
    1: PDF_ENUM_NAME_JavaScript = _mupdf.PDF_ENUM_NAME_JavaScript
    1: PDF_ENUM_NAME_K = _mupdf.PDF_ENUM_NAME_K
    1: PDF_ENUM_NAME_Keywords = _mupdf.PDF_ENUM_NAME_Keywords
    1: PDF_ENUM_NAME_Kids = _mupdf.PDF_ENUM_NAME_Kids
    1: PDF_ENUM_NAME_L = _mupdf.PDF_ENUM_NAME_L
    1: PDF_ENUM_NAME_LBody = _mupdf.PDF_ENUM_NAME_LBody
    1: PDF_ENUM_NAME_LC = _mupdf.PDF_ENUM_NAME_LC
    1: PDF_ENUM_NAME_LE = _mupdf.PDF_ENUM_NAME_LE
    1: PDF_ENUM_NAME_LI = _mupdf.PDF_ENUM_NAME_LI
    1: PDF_ENUM_NAME_LJ = _mupdf.PDF_ENUM_NAME_LJ
    1: PDF_ENUM_NAME_LL = _mupdf.PDF_ENUM_NAME_LL
    1: PDF_ENUM_NAME_LLE = _mupdf.PDF_ENUM_NAME_LLE
    1: PDF_ENUM_NAME_LLO = _mupdf.PDF_ENUM_NAME_LLO
    1: PDF_ENUM_NAME_LW = _mupdf.PDF_ENUM_NAME_LW
    1: PDF_ENUM_NAME_LZ = _mupdf.PDF_ENUM_NAME_LZ
    1: PDF_ENUM_NAME_LZW = _mupdf.PDF_ENUM_NAME_LZW
    1: PDF_ENUM_NAME_LZWDecode = _mupdf.PDF_ENUM_NAME_LZWDecode
    1: PDF_ENUM_NAME_Lab = _mupdf.PDF_ENUM_NAME_Lab
    1: PDF_ENUM_NAME_Label = _mupdf.PDF_ENUM_NAME_Label
    1: PDF_ENUM_NAME_Lang = _mupdf.PDF_ENUM_NAME_Lang
    1: PDF_ENUM_NAME_Last = _mupdf.PDF_ENUM_NAME_Last
    1: PDF_ENUM_NAME_LastChar = _mupdf.PDF_ENUM_NAME_LastChar
    1: PDF_ENUM_NAME_LastPage = _mupdf.PDF_ENUM_NAME_LastPage
    1: PDF_ENUM_NAME_Launch = _mupdf.PDF_ENUM_NAME_Launch
    1: PDF_ENUM_NAME_Layer = _mupdf.PDF_ENUM_NAME_Layer
    1: PDF_ENUM_NAME_Lbl = _mupdf.PDF_ENUM_NAME_Lbl
    1: PDF_ENUM_NAME_Length = _mupdf.PDF_ENUM_NAME_Length
    1: PDF_ENUM_NAME_Length1 = _mupdf.PDF_ENUM_NAME_Length1
    1: PDF_ENUM_NAME_Length2 = _mupdf.PDF_ENUM_NAME_Length2
    1: PDF_ENUM_NAME_Length3 = _mupdf.PDF_ENUM_NAME_Length3
    1: PDF_ENUM_NAME_Limits = _mupdf.PDF_ENUM_NAME_Limits
    1: PDF_ENUM_NAME_Line = _mupdf.PDF_ENUM_NAME_Line
    1: PDF_ENUM_NAME_LineArrow = _mupdf.PDF_ENUM_NAME_LineArrow
    1: PDF_ENUM_NAME_LineDimension = _mupdf.PDF_ENUM_NAME_LineDimension
    1: PDF_ENUM_NAME_Linearized = _mupdf.PDF_ENUM_NAME_Linearized
    1: PDF_ENUM_NAME_Link = _mupdf.PDF_ENUM_NAME_Link
    1: PDF_ENUM_NAME_List = _mupdf.PDF_ENUM_NAME_List
    1: PDF_ENUM_NAME_Location = _mupdf.PDF_ENUM_NAME_Location
    1: PDF_ENUM_NAME_Lock = _mupdf.PDF_ENUM_NAME_Lock
    1: PDF_ENUM_NAME_Locked = _mupdf.PDF_ENUM_NAME_Locked
    1: PDF_ENUM_NAME_Luminosity = _mupdf.PDF_ENUM_NAME_Luminosity
    1: PDF_ENUM_NAME_M = _mupdf.PDF_ENUM_NAME_M
    1: PDF_ENUM_NAME_MCID = _mupdf.PDF_ENUM_NAME_MCID
    1: PDF_ENUM_NAME_MK = _mupdf.PDF_ENUM_NAME_MK
    1: PDF_ENUM_NAME_ML = _mupdf.PDF_ENUM_NAME_ML
    1: PDF_ENUM_NAME_MMType1 = _mupdf.PDF_ENUM_NAME_MMType1
    1: PDF_ENUM_NAME_Mac = _mupdf.PDF_ENUM_NAME_Mac
    1: PDF_ENUM_NAME_Mask = _mupdf.PDF_ENUM_NAME_Mask
    1: PDF_ENUM_NAME_Matrix = _mupdf.PDF_ENUM_NAME_Matrix
    1: PDF_ENUM_NAME_Matte = _mupdf.PDF_ENUM_NAME_Matte
    1: PDF_ENUM_NAME_MaxLen = _mupdf.PDF_ENUM_NAME_MaxLen
    1: PDF_ENUM_NAME_MediaBox = _mupdf.PDF_ENUM_NAME_MediaBox
    1: PDF_ENUM_NAME_Metadata = _mupdf.PDF_ENUM_NAME_Metadata
    1: PDF_ENUM_NAME_MissingWidth = _mupdf.PDF_ENUM_NAME_MissingWidth
    1: PDF_ENUM_NAME_ModDate = _mupdf.PDF_ENUM_NAME_ModDate
    1: PDF_ENUM_NAME_Movie = _mupdf.PDF_ENUM_NAME_Movie
    1: PDF_ENUM_NAME_Msg = _mupdf.PDF_ENUM_NAME_Msg
    1: PDF_ENUM_NAME_Multiply = _mupdf.PDF_ENUM_NAME_Multiply
    1: PDF_ENUM_NAME_N = _mupdf.PDF_ENUM_NAME_N
    1: PDF_ENUM_NAME_Name = _mupdf.PDF_ENUM_NAME_Name
    1: PDF_ENUM_NAME_Named = _mupdf.PDF_ENUM_NAME_Named
    1: PDF_ENUM_NAME_Names = _mupdf.PDF_ENUM_NAME_Names
    1: PDF_ENUM_NAME_NewWindow = _mupdf.PDF_ENUM_NAME_NewWindow
    1: PDF_ENUM_NAME_Next = _mupdf.PDF_ENUM_NAME_Next
    1: PDF_ENUM_NAME_NextPage = _mupdf.PDF_ENUM_NAME_NextPage
    1: PDF_ENUM_NAME_NonEFontNoWarn = _mupdf.PDF_ENUM_NAME_NonEFontNoWarn
    1: PDF_ENUM_NAME_NonStruct = _mupdf.PDF_ENUM_NAME_NonStruct
    1: PDF_ENUM_NAME_None = _mupdf.PDF_ENUM_NAME_None
    1: PDF_ENUM_NAME_Normal = _mupdf.PDF_ENUM_NAME_Normal
    1: PDF_ENUM_NAME_NotApproved = _mupdf.PDF_ENUM_NAME_NotApproved
    1: PDF_ENUM_NAME_NotForPublicRelease = _mupdf.PDF_ENUM_NAME_NotForPublicRelease
    1: PDF_ENUM_NAME_Note = _mupdf.PDF_ENUM_NAME_Note
    1: PDF_ENUM_NAME_NumSections = _mupdf.PDF_ENUM_NAME_NumSections
    1: PDF_ENUM_NAME_Nums = _mupdf.PDF_ENUM_NAME_Nums
    1: PDF_ENUM_NAME_O = _mupdf.PDF_ENUM_NAME_O
    1: PDF_ENUM_NAME_OC = _mupdf.PDF_ENUM_NAME_OC
    1: PDF_ENUM_NAME_OCG = _mupdf.PDF_ENUM_NAME_OCG
    1: PDF_ENUM_NAME_OCGs = _mupdf.PDF_ENUM_NAME_OCGs
    1: PDF_ENUM_NAME_OCMD = _mupdf.PDF_ENUM_NAME_OCMD
    1: PDF_ENUM_NAME_OCProperties = _mupdf.PDF_ENUM_NAME_OCProperties
    1: PDF_ENUM_NAME_OE = _mupdf.PDF_ENUM_NAME_OE
    1: PDF_ENUM_NAME_OFF = _mupdf.PDF_ENUM_NAME_OFF
    1: PDF_ENUM_NAME_ON = _mupdf.PDF_ENUM_NAME_ON
    1: PDF_ENUM_NAME_OP = _mupdf.PDF_ENUM_NAME_OP
    1: PDF_ENUM_NAME_OPM = _mupdf.PDF_ENUM_NAME_OPM
    1: PDF_ENUM_NAME_OS = _mupdf.PDF_ENUM_NAME_OS
    1: PDF_ENUM_NAME_ObjStm = _mupdf.PDF_ENUM_NAME_ObjStm
    1: PDF_ENUM_NAME_Of = _mupdf.PDF_ENUM_NAME_Of
    1: PDF_ENUM_NAME_Off = _mupdf.PDF_ENUM_NAME_Off
    1: PDF_ENUM_NAME_Open = _mupdf.PDF_ENUM_NAME_Open
    1: PDF_ENUM_NAME_OpenArrow = _mupdf.PDF_ENUM_NAME_OpenArrow
    1: PDF_ENUM_NAME_OpenType = _mupdf.PDF_ENUM_NAME_OpenType
    1: PDF_ENUM_NAME_Opt = _mupdf.PDF_ENUM_NAME_Opt
    1: PDF_ENUM_NAME_Order = _mupdf.PDF_ENUM_NAME_Order
    1: PDF_ENUM_NAME_Ordering = _mupdf.PDF_ENUM_NAME_Ordering
    1: PDF_ENUM_NAME_Outlines = _mupdf.PDF_ENUM_NAME_Outlines
    1: PDF_ENUM_NAME_OutputCondition = _mupdf.PDF_ENUM_NAME_OutputCondition
    1: PDF_ENUM_NAME_OutputConditionIdentifier = _mupdf.PDF_ENUM_NAME_OutputConditionIdentifier
    1: PDF_ENUM_NAME_OutputIntent = _mupdf.PDF_ENUM_NAME_OutputIntent
    1: PDF_ENUM_NAME_OutputIntents = _mupdf.PDF_ENUM_NAME_OutputIntents
    1: PDF_ENUM_NAME_P = _mupdf.PDF_ENUM_NAME_P
    1: PDF_ENUM_NAME_PDF = _mupdf.PDF_ENUM_NAME_PDF
    1: PDF_ENUM_NAME_PS = _mupdf.PDF_ENUM_NAME_PS
    1: PDF_ENUM_NAME_Page = _mupdf.PDF_ENUM_NAME_Page
    1: PDF_ENUM_NAME_PageLabels = _mupdf.PDF_ENUM_NAME_PageLabels
    1: PDF_ENUM_NAME_PageMode = _mupdf.PDF_ENUM_NAME_PageMode
    1: PDF_ENUM_NAME_Pages = _mupdf.PDF_ENUM_NAME_Pages
    1: PDF_ENUM_NAME_PaintType = _mupdf.PDF_ENUM_NAME_PaintType
    1: PDF_ENUM_NAME_Params = _mupdf.PDF_ENUM_NAME_Params
    1: PDF_ENUM_NAME_Parent = _mupdf.PDF_ENUM_NAME_Parent
    1: PDF_ENUM_NAME_ParentTree = _mupdf.PDF_ENUM_NAME_ParentTree
    1: PDF_ENUM_NAME_Part = _mupdf.PDF_ENUM_NAME_Part
    1: PDF_ENUM_NAME_Pattern = _mupdf.PDF_ENUM_NAME_Pattern
    1: PDF_ENUM_NAME_PatternType = _mupdf.PDF_ENUM_NAME_PatternType
    1: PDF_ENUM_NAME_Perceptual = _mupdf.PDF_ENUM_NAME_Perceptual
    1: PDF_ENUM_NAME_Perms = _mupdf.PDF_ENUM_NAME_Perms
    1: PDF_ENUM_NAME_PieceInfo = _mupdf.PDF_ENUM_NAME_PieceInfo
    1: PDF_ENUM_NAME_PolyLine = _mupdf.PDF_ENUM_NAME_PolyLine
    1: PDF_ENUM_NAME_PolyLineDimension = _mupdf.PDF_ENUM_NAME_PolyLineDimension
    1: PDF_ENUM_NAME_Polygon = _mupdf.PDF_ENUM_NAME_Polygon
    1: PDF_ENUM_NAME_PolygonCloud = _mupdf.PDF_ENUM_NAME_PolygonCloud
    1: PDF_ENUM_NAME_PolygonDimension = _mupdf.PDF_ENUM_NAME_PolygonDimension
    1: PDF_ENUM_NAME_Popup = _mupdf.PDF_ENUM_NAME_Popup
    1: PDF_ENUM_NAME_PreRelease = _mupdf.PDF_ENUM_NAME_PreRelease
    1: PDF_ENUM_NAME_Predictor = _mupdf.PDF_ENUM_NAME_Predictor
    1: PDF_ENUM_NAME_Prev = _mupdf.PDF_ENUM_NAME_Prev
    1: PDF_ENUM_NAME_PrevPage = _mupdf.PDF_ENUM_NAME_PrevPage
    1: PDF_ENUM_NAME_Preview = _mupdf.PDF_ENUM_NAME_Preview
    1: PDF_ENUM_NAME_Print = _mupdf.PDF_ENUM_NAME_Print
    1: PDF_ENUM_NAME_PrinterMark = _mupdf.PDF_ENUM_NAME_PrinterMark
    1: PDF_ENUM_NAME_Private = _mupdf.PDF_ENUM_NAME_Private
    1: PDF_ENUM_NAME_ProcSet = _mupdf.PDF_ENUM_NAME_ProcSet
    1: PDF_ENUM_NAME_Producer = _mupdf.PDF_ENUM_NAME_Producer
    1: PDF_ENUM_NAME_Prop_AuthTime = _mupdf.PDF_ENUM_NAME_Prop_AuthTime
    1: PDF_ENUM_NAME_Prop_AuthType = _mupdf.PDF_ENUM_NAME_Prop_AuthType
    1: PDF_ENUM_NAME_Prop_Build = _mupdf.PDF_ENUM_NAME_Prop_Build
    1: PDF_ENUM_NAME_Properties = _mupdf.PDF_ENUM_NAME_Properties
    1: PDF_ENUM_NAME_PubSec = _mupdf.PDF_ENUM_NAME_PubSec
    1: PDF_ENUM_NAME_Push = _mupdf.PDF_ENUM_NAME_Push
    1: PDF_ENUM_NAME_Q = _mupdf.PDF_ENUM_NAME_Q
    1: PDF_ENUM_NAME_QuadPoints = _mupdf.PDF_ENUM_NAME_QuadPoints
    1: PDF_ENUM_NAME_Quote = _mupdf.PDF_ENUM_NAME_Quote
    1: PDF_ENUM_NAME_R = _mupdf.PDF_ENUM_NAME_R
    1: PDF_ENUM_NAME_RB = _mupdf.PDF_ENUM_NAME_RB
    1: PDF_ENUM_NAME_RBGroups = _mupdf.PDF_ENUM_NAME_RBGroups
    1: PDF_ENUM_NAME_RC = _mupdf.PDF_ENUM_NAME_RC
    1: PDF_ENUM_NAME_RClosedArrow = _mupdf.PDF_ENUM_NAME_RClosedArrow
    1: PDF_ENUM_NAME_RD = _mupdf.PDF_ENUM_NAME_RD
    1: PDF_ENUM_NAME_REx = _mupdf.PDF_ENUM_NAME_REx
    1: PDF_ENUM_NAME_RGB = _mupdf.PDF_ENUM_NAME_RGB
    1: PDF_ENUM_NAME_RI = _mupdf.PDF_ENUM_NAME_RI
    1: PDF_ENUM_NAME_RL = _mupdf.PDF_ENUM_NAME_RL
    1: PDF_ENUM_NAME_RO = _mupdf.PDF_ENUM_NAME_RO
    1: PDF_ENUM_NAME_ROpenArrow = _mupdf.PDF_ENUM_NAME_ROpenArrow
    1: PDF_ENUM_NAME_RP = _mupdf.PDF_ENUM_NAME_RP
    1: PDF_ENUM_NAME_RT = _mupdf.PDF_ENUM_NAME_RT
    1: PDF_ENUM_NAME_RV = _mupdf.PDF_ENUM_NAME_RV
    1: PDF_ENUM_NAME_Range = _mupdf.PDF_ENUM_NAME_Range
    1: PDF_ENUM_NAME_Reason = _mupdf.PDF_ENUM_NAME_Reason
    1: PDF_ENUM_NAME_Rect = _mupdf.PDF_ENUM_NAME_Rect
    1: PDF_ENUM_NAME_Redact = _mupdf.PDF_ENUM_NAME_Redact
    1: PDF_ENUM_NAME_Ref = _mupdf.PDF_ENUM_NAME_Ref
    1: PDF_ENUM_NAME_Reference = _mupdf.PDF_ENUM_NAME_Reference
    1: PDF_ENUM_NAME_Registry = _mupdf.PDF_ENUM_NAME_Registry
    1: PDF_ENUM_NAME_RelativeColorimetric = _mupdf.PDF_ENUM_NAME_RelativeColorimetric
    1: PDF_ENUM_NAME_ResetForm = _mupdf.PDF_ENUM_NAME_ResetForm
    1: PDF_ENUM_NAME_Resources = _mupdf.PDF_ENUM_NAME_Resources
    1: PDF_ENUM_NAME_RoleMap = _mupdf.PDF_ENUM_NAME_RoleMap
    1: PDF_ENUM_NAME_Root = _mupdf.PDF_ENUM_NAME_Root
    1: PDF_ENUM_NAME_Rotate = _mupdf.PDF_ENUM_NAME_Rotate
    1: PDF_ENUM_NAME_Rows = _mupdf.PDF_ENUM_NAME_Rows
    1: PDF_ENUM_NAME_Ruby = _mupdf.PDF_ENUM_NAME_Ruby
    1: PDF_ENUM_NAME_RunLengthDecode = _mupdf.PDF_ENUM_NAME_RunLengthDecode
    1: PDF_ENUM_NAME_S = _mupdf.PDF_ENUM_NAME_S
    1: PDF_ENUM_NAME_SMask = _mupdf.PDF_ENUM_NAME_SMask
    1: PDF_ENUM_NAME_SMaskInData = _mupdf.PDF_ENUM_NAME_SMaskInData
    1: PDF_ENUM_NAME_Saturation = _mupdf.PDF_ENUM_NAME_Saturation
    1: PDF_ENUM_NAME_Schema = _mupdf.PDF_ENUM_NAME_Schema
    1: PDF_ENUM_NAME_Screen = _mupdf.PDF_ENUM_NAME_Screen
    1: PDF_ENUM_NAME_Sect = _mupdf.PDF_ENUM_NAME_Sect
    1: PDF_ENUM_NAME_Separation = _mupdf.PDF_ENUM_NAME_Separation
    1: PDF_ENUM_NAME_Shading = _mupdf.PDF_ENUM_NAME_Shading
    1: PDF_ENUM_NAME_ShadingType = _mupdf.PDF_ENUM_NAME_ShadingType
    1: PDF_ENUM_NAME_Si = _mupdf.PDF_ENUM_NAME_Si
    1: PDF_ENUM_NAME_Sig = _mupdf.PDF_ENUM_NAME_Sig
    1: PDF_ENUM_NAME_SigFlags = _mupdf.PDF_ENUM_NAME_SigFlags
    1: PDF_ENUM_NAME_SigQ = _mupdf.PDF_ENUM_NAME_SigQ
    1: PDF_ENUM_NAME_SigRef = _mupdf.PDF_ENUM_NAME_SigRef
    1: PDF_ENUM_NAME_Size = _mupdf.PDF_ENUM_NAME_Size
    1: PDF_ENUM_NAME_Slash = _mupdf.PDF_ENUM_NAME_Slash
    1: PDF_ENUM_NAME_Sold = _mupdf.PDF_ENUM_NAME_Sold
    1: PDF_ENUM_NAME_Sound = _mupdf.PDF_ENUM_NAME_Sound
    1: PDF_ENUM_NAME_Source = _mupdf.PDF_ENUM_NAME_Source
    1: PDF_ENUM_NAME_Span = _mupdf.PDF_ENUM_NAME_Span
    1: PDF_ENUM_NAME_Split = _mupdf.PDF_ENUM_NAME_Split
    1: PDF_ENUM_NAME_Square = _mupdf.PDF_ENUM_NAME_Square
    1: PDF_ENUM_NAME_Squiggly = _mupdf.PDF_ENUM_NAME_Squiggly
    1: PDF_ENUM_NAME_St = _mupdf.PDF_ENUM_NAME_St
    1: PDF_ENUM_NAME_Stamp = _mupdf.PDF_ENUM_NAME_Stamp
    1: PDF_ENUM_NAME_StampImage = _mupdf.PDF_ENUM_NAME_StampImage
    1: PDF_ENUM_NAME_StampSnapshot = _mupdf.PDF_ENUM_NAME_StampSnapshot
    1: PDF_ENUM_NAME_Standard = _mupdf.PDF_ENUM_NAME_Standard
    1: PDF_ENUM_NAME_StdCF = _mupdf.PDF_ENUM_NAME_StdCF
    1: PDF_ENUM_NAME_StemV = _mupdf.PDF_ENUM_NAME_StemV
    1: PDF_ENUM_NAME_StmF = _mupdf.PDF_ENUM_NAME_StmF
    1: PDF_ENUM_NAME_StrF = _mupdf.PDF_ENUM_NAME_StrF
    1: PDF_ENUM_NAME_StrikeOut = _mupdf.PDF_ENUM_NAME_StrikeOut
    1: PDF_ENUM_NAME_Strong = _mupdf.PDF_ENUM_NAME_Strong
    1: PDF_ENUM_NAME_StructParent = _mupdf.PDF_ENUM_NAME_StructParent
    1: PDF_ENUM_NAME_StructParents = _mupdf.PDF_ENUM_NAME_StructParents
    1: PDF_ENUM_NAME_StructTreeRoot = _mupdf.PDF_ENUM_NAME_StructTreeRoot
    1: PDF_ENUM_NAME_Sub = _mupdf.PDF_ENUM_NAME_Sub
    1: PDF_ENUM_NAME_SubFilter = _mupdf.PDF_ENUM_NAME_SubFilter
    1: PDF_ENUM_NAME_Subject = _mupdf.PDF_ENUM_NAME_Subject
    1: PDF_ENUM_NAME_Subtype = _mupdf.PDF_ENUM_NAME_Subtype
    1: PDF_ENUM_NAME_Subtype2 = _mupdf.PDF_ENUM_NAME_Subtype2
    1: PDF_ENUM_NAME_Supplement = _mupdf.PDF_ENUM_NAME_Supplement
    1: PDF_ENUM_NAME_Symb = _mupdf.PDF_ENUM_NAME_Symb
    1: PDF_ENUM_NAME_T = _mupdf.PDF_ENUM_NAME_T
    1: PDF_ENUM_NAME_TBody = _mupdf.PDF_ENUM_NAME_TBody
    1: PDF_ENUM_NAME_TD = _mupdf.PDF_ENUM_NAME_TD
    1: PDF_ENUM_NAME_TFoot = _mupdf.PDF_ENUM_NAME_TFoot
    1: PDF_ENUM_NAME_TH = _mupdf.PDF_ENUM_NAME_TH
    1: PDF_ENUM_NAME_THead = _mupdf.PDF_ENUM_NAME_THead
    1: PDF_ENUM_NAME_TI = _mupdf.PDF_ENUM_NAME_TI
    1: PDF_ENUM_NAME_TOC = _mupdf.PDF_ENUM_NAME_TOC
    1: PDF_ENUM_NAME_TOCI = _mupdf.PDF_ENUM_NAME_TOCI
    1: PDF_ENUM_NAME_TR = _mupdf.PDF_ENUM_NAME_TR
    1: PDF_ENUM_NAME_TR2 = _mupdf.PDF_ENUM_NAME_TR2
    1: PDF_ENUM_NAME_TU = _mupdf.PDF_ENUM_NAME_TU
    1: PDF_ENUM_NAME_Table = _mupdf.PDF_ENUM_NAME_Table
    1: PDF_ENUM_NAME_Text = _mupdf.PDF_ENUM_NAME_Text
    1: PDF_ENUM_NAME_Thumb = _mupdf.PDF_ENUM_NAME_Thumb
    1: PDF_ENUM_NAME_TilingType = _mupdf.PDF_ENUM_NAME_TilingType
    1: PDF_ENUM_NAME_Times = _mupdf.PDF_ENUM_NAME_Times
    1: PDF_ENUM_NAME_Title = _mupdf.PDF_ENUM_NAME_Title
    1: PDF_ENUM_NAME_ToUnicode = _mupdf.PDF_ENUM_NAME_ToUnicode
    1: PDF_ENUM_NAME_Top = _mupdf.PDF_ENUM_NAME_Top
    1: PDF_ENUM_NAME_TopSecret = _mupdf.PDF_ENUM_NAME_TopSecret
    1: PDF_ENUM_NAME_Trans = _mupdf.PDF_ENUM_NAME_Trans
    1: PDF_ENUM_NAME_TransformMethod = _mupdf.PDF_ENUM_NAME_TransformMethod
    1: PDF_ENUM_NAME_TransformParams = _mupdf.PDF_ENUM_NAME_TransformParams
    1: PDF_ENUM_NAME_Transparency = _mupdf.PDF_ENUM_NAME_Transparency
    1: PDF_ENUM_NAME_TrapNet = _mupdf.PDF_ENUM_NAME_TrapNet
    1: PDF_ENUM_NAME_TrimBox = _mupdf.PDF_ENUM_NAME_TrimBox
    1: PDF_ENUM_NAME_TrueType = _mupdf.PDF_ENUM_NAME_TrueType
    1: PDF_ENUM_NAME_TrustedMode = _mupdf.PDF_ENUM_NAME_TrustedMode
    1: PDF_ENUM_NAME_Tx = _mupdf.PDF_ENUM_NAME_Tx
    1: PDF_ENUM_NAME_Type = _mupdf.PDF_ENUM_NAME_Type
    1: PDF_ENUM_NAME_Type0 = _mupdf.PDF_ENUM_NAME_Type0
    1: PDF_ENUM_NAME_Type1 = _mupdf.PDF_ENUM_NAME_Type1
    1: PDF_ENUM_NAME_Type1C = _mupdf.PDF_ENUM_NAME_Type1C
    1: PDF_ENUM_NAME_Type3 = _mupdf.PDF_ENUM_NAME_Type3
    1: PDF_ENUM_NAME_U = _mupdf.PDF_ENUM_NAME_U
    1: PDF_ENUM_NAME_UE = _mupdf.PDF_ENUM_NAME_UE
    1: PDF_ENUM_NAME_UF = _mupdf.PDF_ENUM_NAME_UF
    1: PDF_ENUM_NAME_URI = _mupdf.PDF_ENUM_NAME_URI
    1: PDF_ENUM_NAME_URL = _mupdf.PDF_ENUM_NAME_URL
    1: PDF_ENUM_NAME_Unchanged = _mupdf.PDF_ENUM_NAME_Unchanged
    1: PDF_ENUM_NAME_Uncover = _mupdf.PDF_ENUM_NAME_Uncover
    1: PDF_ENUM_NAME_Underline = _mupdf.PDF_ENUM_NAME_Underline
    1: PDF_ENUM_NAME_Unix = _mupdf.PDF_ENUM_NAME_Unix
    1: PDF_ENUM_NAME_Unspecified = _mupdf.PDF_ENUM_NAME_Unspecified
    1: PDF_ENUM_NAME_Usage = _mupdf.PDF_ENUM_NAME_Usage
    1: PDF_ENUM_NAME_UseBlackPtComp = _mupdf.PDF_ENUM_NAME_UseBlackPtComp
    1: PDF_ENUM_NAME_UseCMap = _mupdf.PDF_ENUM_NAME_UseCMap
    1: PDF_ENUM_NAME_UseOutlines = _mupdf.PDF_ENUM_NAME_UseOutlines
    1: PDF_ENUM_NAME_UserUnit = _mupdf.PDF_ENUM_NAME_UserUnit
    1: PDF_ENUM_NAME_V = _mupdf.PDF_ENUM_NAME_V
    1: PDF_ENUM_NAME_V2 = _mupdf.PDF_ENUM_NAME_V2
    1: PDF_ENUM_NAME_VE = _mupdf.PDF_ENUM_NAME_VE
    1: PDF_ENUM_NAME_Version = _mupdf.PDF_ENUM_NAME_Version
    1: PDF_ENUM_NAME_Vertices = _mupdf.PDF_ENUM_NAME_Vertices
    1: PDF_ENUM_NAME_VerticesPerRow = _mupdf.PDF_ENUM_NAME_VerticesPerRow
    1: PDF_ENUM_NAME_View = _mupdf.PDF_ENUM_NAME_View
    1: PDF_ENUM_NAME_W = _mupdf.PDF_ENUM_NAME_W
    1: PDF_ENUM_NAME_W2 = _mupdf.PDF_ENUM_NAME_W2
    1: PDF_ENUM_NAME_WMode = _mupdf.PDF_ENUM_NAME_WMode
    1: PDF_ENUM_NAME_WP = _mupdf.PDF_ENUM_NAME_WP
    1: PDF_ENUM_NAME_WT = _mupdf.PDF_ENUM_NAME_WT
    1: PDF_ENUM_NAME_Warichu = _mupdf.PDF_ENUM_NAME_Warichu
    1: PDF_ENUM_NAME_Watermark = _mupdf.PDF_ENUM_NAME_Watermark
    1: PDF_ENUM_NAME_WhitePoint = _mupdf.PDF_ENUM_NAME_WhitePoint
    1: PDF_ENUM_NAME_Widget = _mupdf.PDF_ENUM_NAME_Widget
    1: PDF_ENUM_NAME_Width = _mupdf.PDF_ENUM_NAME_Width
    1: PDF_ENUM_NAME_Widths = _mupdf.PDF_ENUM_NAME_Widths
    1: PDF_ENUM_NAME_WinAnsiEncoding = _mupdf.PDF_ENUM_NAME_WinAnsiEncoding
    1: PDF_ENUM_NAME_Wipe = _mupdf.PDF_ENUM_NAME_Wipe
    1: PDF_ENUM_NAME_XFA = _mupdf.PDF_ENUM_NAME_XFA
    1: PDF_ENUM_NAME_XHeight = _mupdf.PDF_ENUM_NAME_XHeight
    1: PDF_ENUM_NAME_XML = _mupdf.PDF_ENUM_NAME_XML
    1: PDF_ENUM_NAME_XObject = _mupdf.PDF_ENUM_NAME_XObject
    1: PDF_ENUM_NAME_XRef = _mupdf.PDF_ENUM_NAME_XRef
    1: PDF_ENUM_NAME_XRefStm = _mupdf.PDF_ENUM_NAME_XRefStm
    1: PDF_ENUM_NAME_XStep = _mupdf.PDF_ENUM_NAME_XStep
    1: PDF_ENUM_NAME_XYZ = _mupdf.PDF_ENUM_NAME_XYZ
    1: PDF_ENUM_NAME_YStep = _mupdf.PDF_ENUM_NAME_YStep
    1: PDF_ENUM_NAME_Yes = _mupdf.PDF_ENUM_NAME_Yes
    1: PDF_ENUM_NAME_ZaDb = _mupdf.PDF_ENUM_NAME_ZaDb
    1: PDF_ENUM_NAME_a = _mupdf.PDF_ENUM_NAME_a
    1: PDF_ENUM_NAME_adbe_pkcs7_detached = _mupdf.PDF_ENUM_NAME_adbe_pkcs7_detached
    1: PDF_ENUM_NAME_ca = _mupdf.PDF_ENUM_NAME_ca
    1: PDF_ENUM_NAME_n0 = _mupdf.PDF_ENUM_NAME_n0
    1: PDF_ENUM_NAME_n1 = _mupdf.PDF_ENUM_NAME_n1
    1: PDF_ENUM_NAME_n2 = _mupdf.PDF_ENUM_NAME_n2
    1: PDF_ENUM_NAME_op = _mupdf.PDF_ENUM_NAME_op
    1: PDF_ENUM_NAME_r = _mupdf.PDF_ENUM_NAME_r
    1: PDF_ENUM_LIMIT = _mupdf.PDF_ENUM_LIMIT
    1: PDF_LEXBUF_SMALL = _mupdf.PDF_LEXBUF_SMALL
    1: PDF_LEXBUF_LARGE = _mupdf.PDF_LEXBUF_LARGE
    2: class pdf_lexbuf(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     size = property(_mupdf.pdf_lexbuf_size_get, _mupdf.pdf_lexbuf_size_set)
    1:     base_size = property(_mupdf.pdf_lexbuf_base_size_get, _mupdf.pdf_lexbuf_base_size_set)
    1:     len = property(_mupdf.pdf_lexbuf_len_get, _mupdf.pdf_lexbuf_len_set)
    1:     i = property(_mupdf.pdf_lexbuf_i_get, _mupdf.pdf_lexbuf_i_set)
    1:     f = property(_mupdf.pdf_lexbuf_f_get, _mupdf.pdf_lexbuf_f_set)
    1:     scratch = property(_mupdf.pdf_lexbuf_scratch_get, _mupdf.pdf_lexbuf_scratch_set)
    1:     buffer = property(_mupdf.pdf_lexbuf_buffer_get, _mupdf.pdf_lexbuf_buffer_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_lexbuf_swiginit(self, _mupdf.new_pdf_lexbuf())
    1:     __swig_destroy__ = _mupdf.delete_pdf_lexbuf
       
       # Register pdf_lexbuf in _mupdf:
    1: _mupdf.pdf_lexbuf_swigregister(pdf_lexbuf)
    2: class pdf_lexbuf_large(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     base = property(_mupdf.pdf_lexbuf_large_base_get, _mupdf.pdf_lexbuf_large_base_set)
    1:     buffer = property(_mupdf.pdf_lexbuf_large_buffer_get, _mupdf.pdf_lexbuf_large_buffer_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_lexbuf_large_swiginit(self, _mupdf.new_pdf_lexbuf_large())
    1:     __swig_destroy__ = _mupdf.delete_pdf_lexbuf_large
       
       # Register pdf_lexbuf_large in _mupdf:
    1: _mupdf.pdf_lexbuf_large_swigregister(pdf_lexbuf_large)
    2: class pdf_js_console(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     drop = property(_mupdf.pdf_js_console_drop_get, _mupdf.pdf_js_console_drop_set)
    1:     show = property(_mupdf.pdf_js_console_show_get, _mupdf.pdf_js_console_show_set)
    1:     hide = property(_mupdf.pdf_js_console_hide_get, _mupdf.pdf_js_console_hide_set)
    1:     clear = property(_mupdf.pdf_js_console_clear_get, _mupdf.pdf_js_console_clear_set)
    1:     write = property(_mupdf.pdf_js_console_write_get, _mupdf.pdf_js_console_write_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_js_console_swiginit(self, _mupdf.new_pdf_js_console())
    1:     __swig_destroy__ = _mupdf.delete_pdf_js_console
       
       # Register pdf_js_console in _mupdf:
    1: _mupdf.pdf_js_console_swigregister(pdf_js_console)
    2: class pdf_layer_config(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     name = property(_mupdf.pdf_layer_config_name_get, _mupdf.pdf_layer_config_name_set)
    1:     creator = property(_mupdf.pdf_layer_config_creator_get, _mupdf.pdf_layer_config_creator_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_layer_config_swiginit(self, _mupdf.new_pdf_layer_config())
    1:     __swig_destroy__ = _mupdf.delete_pdf_layer_config
       
       # Register pdf_layer_config in _mupdf:
    1: _mupdf.pdf_layer_config_swigregister(pdf_layer_config)
    1: PDF_LAYER_UI_LABEL = _mupdf.PDF_LAYER_UI_LABEL
    1: PDF_LAYER_UI_CHECKBOX = _mupdf.PDF_LAYER_UI_CHECKBOX
    1: PDF_LAYER_UI_RADIOBOX = _mupdf.PDF_LAYER_UI_RADIOBOX
    2: class pdf_layer_config_ui(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     text = property(_mupdf.pdf_layer_config_ui_text_get, _mupdf.pdf_layer_config_ui_text_set)
    1:     depth = property(_mupdf.pdf_layer_config_ui_depth_get, _mupdf.pdf_layer_config_ui_depth_set)
    1:     type = property(_mupdf.pdf_layer_config_ui_type_get, _mupdf.pdf_layer_config_ui_type_set)
    1:     selected = property(_mupdf.pdf_layer_config_ui_selected_get, _mupdf.pdf_layer_config_ui_selected_set)
    1:     locked = property(_mupdf.pdf_layer_config_ui_locked_get, _mupdf.pdf_layer_config_ui_locked_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_layer_config_ui_swiginit(self, _mupdf.new_pdf_layer_config_ui())
    1:     __swig_destroy__ = _mupdf.delete_pdf_layer_config_ui
       
       # Register pdf_layer_config_ui in _mupdf:
    1: _mupdf.pdf_layer_config_ui_swigregister(pdf_layer_config_ui)
    2: class pdf_unsaved_sig(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     field = property(_mupdf.pdf_unsaved_sig_field_get, _mupdf.pdf_unsaved_sig_field_set)
    1:     byte_range_start = property(_mupdf.pdf_unsaved_sig_byte_range_start_get, _mupdf.pdf_unsaved_sig_byte_range_start_set)
    1:     byte_range_end = property(_mupdf.pdf_unsaved_sig_byte_range_end_get, _mupdf.pdf_unsaved_sig_byte_range_end_set)
    1:     contents_start = property(_mupdf.pdf_unsaved_sig_contents_start_get, _mupdf.pdf_unsaved_sig_contents_start_set)
    1:     contents_end = property(_mupdf.pdf_unsaved_sig_contents_end_get, _mupdf.pdf_unsaved_sig_contents_end_set)
    1:     signer = property(_mupdf.pdf_unsaved_sig_signer_get, _mupdf.pdf_unsaved_sig_signer_set)
    1:     next = property(_mupdf.pdf_unsaved_sig_next_get, _mupdf.pdf_unsaved_sig_next_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_unsaved_sig_swiginit(self, _mupdf.new_pdf_unsaved_sig())
    1:     __swig_destroy__ = _mupdf.delete_pdf_unsaved_sig
       
       # Register pdf_unsaved_sig in _mupdf:
    1: _mupdf.pdf_unsaved_sig_swigregister(pdf_unsaved_sig)
    2: class pdf_rev_page_map(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     page = property(_mupdf.pdf_rev_page_map_page_get, _mupdf.pdf_rev_page_map_page_set)
    1:     object = property(_mupdf.pdf_rev_page_map_object_get, _mupdf.pdf_rev_page_map_object_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_rev_page_map_swiginit(self, _mupdf.new_pdf_rev_page_map())
    1:     __swig_destroy__ = _mupdf.delete_pdf_rev_page_map
       
       # Register pdf_rev_page_map in _mupdf:
    1: _mupdf.pdf_rev_page_map_swigregister(pdf_rev_page_map)
    2: class pdf_hint_page(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     number = property(_mupdf.pdf_hint_page_number_get, _mupdf.pdf_hint_page_number_set)
    1:     offset = property(_mupdf.pdf_hint_page_offset_get, _mupdf.pdf_hint_page_offset_set)
    1:     index = property(_mupdf.pdf_hint_page_index_get, _mupdf.pdf_hint_page_index_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_hint_page_swiginit(self, _mupdf.new_pdf_hint_page())
    1:     __swig_destroy__ = _mupdf.delete_pdf_hint_page
       
       # Register pdf_hint_page in _mupdf:
    1: _mupdf.pdf_hint_page_swigregister(pdf_hint_page)
    2: class pdf_hint_shared(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     number = property(_mupdf.pdf_hint_shared_number_get, _mupdf.pdf_hint_shared_number_set)
    1:     offset = property(_mupdf.pdf_hint_shared_offset_get, _mupdf.pdf_hint_shared_offset_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_hint_shared_swiginit(self, _mupdf.new_pdf_hint_shared())
    1:     __swig_destroy__ = _mupdf.delete_pdf_hint_shared
       
       # Register pdf_hint_shared in _mupdf:
    1: _mupdf.pdf_hint_shared_swigregister(pdf_hint_shared)
    2: class pdf_document(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     super = property(_mupdf.pdf_document_super_get, _mupdf.pdf_document_super_set)
    1:     file = property(_mupdf.pdf_document_file_get, _mupdf.pdf_document_file_set)
    1:     version = property(_mupdf.pdf_document_version_get, _mupdf.pdf_document_version_set)
    1:     is_fdf = property(_mupdf.pdf_document_is_fdf_get, _mupdf.pdf_document_is_fdf_set)
    1:     bias = property(_mupdf.pdf_document_bias_get, _mupdf.pdf_document_bias_set)
    1:     startxref = property(_mupdf.pdf_document_startxref_get, _mupdf.pdf_document_startxref_set)
    1:     file_size = property(_mupdf.pdf_document_file_size_get, _mupdf.pdf_document_file_size_set)
    1:     crypt = property(_mupdf.pdf_document_crypt_get, _mupdf.pdf_document_crypt_set)
    1:     ocg = property(_mupdf.pdf_document_ocg_get, _mupdf.pdf_document_ocg_set)
    1:     oi = property(_mupdf.pdf_document_oi_get, _mupdf.pdf_document_oi_set)
    1:     max_xref_len = property(_mupdf.pdf_document_max_xref_len_get, _mupdf.pdf_document_max_xref_len_set)
    1:     num_xref_sections = property(_mupdf.pdf_document_num_xref_sections_get, _mupdf.pdf_document_num_xref_sections_set)
    1:     saved_num_xref_sections = property(_mupdf.pdf_document_saved_num_xref_sections_get, _mupdf.pdf_document_saved_num_xref_sections_set)
    1:     num_incremental_sections = property(_mupdf.pdf_document_num_incremental_sections_get, _mupdf.pdf_document_num_incremental_sections_set)
    1:     xref_base = property(_mupdf.pdf_document_xref_base_get, _mupdf.pdf_document_xref_base_set)
    1:     disallow_new_increments = property(_mupdf.pdf_document_disallow_new_increments_get, _mupdf.pdf_document_disallow_new_increments_set)
    1:     local_xref = property(_mupdf.pdf_document_local_xref_get, _mupdf.pdf_document_local_xref_set)
    1:     local_xref_nesting = property(_mupdf.pdf_document_local_xref_nesting_get, _mupdf.pdf_document_local_xref_nesting_set)
    1:     xref_sections = property(_mupdf.pdf_document_xref_sections_get, _mupdf.pdf_document_xref_sections_set)
    1:     saved_xref_sections = property(_mupdf.pdf_document_saved_xref_sections_get, _mupdf.pdf_document_saved_xref_sections_set)
    1:     xref_index = property(_mupdf.pdf_document_xref_index_get, _mupdf.pdf_document_xref_index_set)
    1:     save_in_progress = property(_mupdf.pdf_document_save_in_progress_get, _mupdf.pdf_document_save_in_progress_set)
    1:     last_xref_was_old_style = property(_mupdf.pdf_document_last_xref_was_old_style_get, _mupdf.pdf_document_last_xref_was_old_style_set)
    1:     has_linearization_object = property(_mupdf.pdf_document_has_linearization_object_get, _mupdf.pdf_document_has_linearization_object_set)
    1:     map_page_count = property(_mupdf.pdf_document_map_page_count_get, _mupdf.pdf_document_map_page_count_set)
    1:     rev_page_map = property(_mupdf.pdf_document_rev_page_map_get, _mupdf.pdf_document_rev_page_map_set)
    1:     fwd_page_map = property(_mupdf.pdf_document_fwd_page_map_get, _mupdf.pdf_document_fwd_page_map_set)
    1:     page_tree_broken = property(_mupdf.pdf_document_page_tree_broken_get, _mupdf.pdf_document_page_tree_broken_set)
    1:     repair_attempted = property(_mupdf.pdf_document_repair_attempted_get, _mupdf.pdf_document_repair_attempted_set)
    1:     repair_in_progress = property(_mupdf.pdf_document_repair_in_progress_get, _mupdf.pdf_document_repair_in_progress_set)
    1:     non_structural_change = property(_mupdf.pdf_document_non_structural_change_get, _mupdf.pdf_document_non_structural_change_set)
    1:     file_reading_linearly = property(_mupdf.pdf_document_file_reading_linearly_get, _mupdf.pdf_document_file_reading_linearly_set)
    1:     file_length = property(_mupdf.pdf_document_file_length_get, _mupdf.pdf_document_file_length_set)
    1:     linear_page_count = property(_mupdf.pdf_document_linear_page_count_get, _mupdf.pdf_document_linear_page_count_set)
    1:     linear_obj = property(_mupdf.pdf_document_linear_obj_get, _mupdf.pdf_document_linear_obj_set)
    1:     linear_page_refs = property(_mupdf.pdf_document_linear_page_refs_get, _mupdf.pdf_document_linear_page_refs_set)
    1:     linear_page1_obj_num = property(_mupdf.pdf_document_linear_page1_obj_num_get, _mupdf.pdf_document_linear_page1_obj_num_set)
    1:     linear_pos = property(_mupdf.pdf_document_linear_pos_get, _mupdf.pdf_document_linear_pos_set)
    1:     linear_page_num = property(_mupdf.pdf_document_linear_page_num_get, _mupdf.pdf_document_linear_page_num_set)
    1:     hint_object_offset = property(_mupdf.pdf_document_hint_object_offset_get, _mupdf.pdf_document_hint_object_offset_set)
    1:     hint_object_length = property(_mupdf.pdf_document_hint_object_length_get, _mupdf.pdf_document_hint_object_length_set)
    1:     hints_loaded = property(_mupdf.pdf_document_hints_loaded_get, _mupdf.pdf_document_hints_loaded_set)
    1:     hint_page = property(_mupdf.pdf_document_hint_page_get, _mupdf.pdf_document_hint_page_set)
    1:     hint_shared_ref = property(_mupdf.pdf_document_hint_shared_ref_get, _mupdf.pdf_document_hint_shared_ref_set)
    1:     hint_shared = property(_mupdf.pdf_document_hint_shared_get, _mupdf.pdf_document_hint_shared_set)
    1:     hint_obj_offsets_max = property(_mupdf.pdf_document_hint_obj_offsets_max_get, _mupdf.pdf_document_hint_obj_offsets_max_set)
    1:     hint_obj_offsets = property(_mupdf.pdf_document_hint_obj_offsets_get, _mupdf.pdf_document_hint_obj_offsets_set)
    1:     lexbuf = property(_mupdf.pdf_document_lexbuf_get, _mupdf.pdf_document_lexbuf_set)
    1:     js = property(_mupdf.pdf_document_js_get, _mupdf.pdf_document_js_set)
    1:     recalculate = property(_mupdf.pdf_document_recalculate_get, _mupdf.pdf_document_recalculate_set)
    1:     redacted = property(_mupdf.pdf_document_redacted_get, _mupdf.pdf_document_redacted_set)
    1:     resynth_required = property(_mupdf.pdf_document_resynth_required_get, _mupdf.pdf_document_resynth_required_set)
    1:     event_cb = property(_mupdf.pdf_document_event_cb_get, _mupdf.pdf_document_event_cb_set)
    1:     free_event_data_cb = property(_mupdf.pdf_document_free_event_data_cb_get, _mupdf.pdf_document_free_event_data_cb_set)
    1:     event_cb_data = property(_mupdf.pdf_document_event_cb_data_get, _mupdf.pdf_document_event_cb_data_set)
    1:     num_type3_fonts = property(_mupdf.pdf_document_num_type3_fonts_get, _mupdf.pdf_document_num_type3_fonts_set)
    1:     max_type3_fonts = property(_mupdf.pdf_document_max_type3_fonts_get, _mupdf.pdf_document_max_type3_fonts_set)
    1:     type3_fonts = property(_mupdf.pdf_document_type3_fonts_get, _mupdf.pdf_document_type3_fonts_set)
    1:     orphans_max = property(_mupdf.pdf_document_orphans_max_get, _mupdf.pdf_document_orphans_max_set)
    1:     orphans_count = property(_mupdf.pdf_document_orphans_count_get, _mupdf.pdf_document_orphans_count_set)
    1:     orphans = property(_mupdf.pdf_document_orphans_get, _mupdf.pdf_document_orphans_set)
    1:     xfa = property(_mupdf.pdf_document_xfa_get, _mupdf.pdf_document_xfa_set)
    1:     journal = property(_mupdf.pdf_document_journal_get, _mupdf.pdf_document_journal_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_document_swiginit(self, _mupdf.new_pdf_document())
    1:     __swig_destroy__ = _mupdf.delete_pdf_document
       
       # Register pdf_document in _mupdf:
    1: _mupdf.pdf_document_swigregister(pdf_document)
    1: PDF_PAGE_LABEL_NONE = _mupdf.PDF_PAGE_LABEL_NONE
    1: PDF_PAGE_LABEL_DECIMAL = _mupdf.PDF_PAGE_LABEL_DECIMAL
    1: PDF_PAGE_LABEL_ROMAN_UC = _mupdf.PDF_PAGE_LABEL_ROMAN_UC
    1: PDF_PAGE_LABEL_ROMAN_LC = _mupdf.PDF_PAGE_LABEL_ROMAN_LC
    1: PDF_PAGE_LABEL_ALPHA_UC = _mupdf.PDF_PAGE_LABEL_ALPHA_UC
    1: PDF_PAGE_LABEL_ALPHA_LC = _mupdf.PDF_PAGE_LABEL_ALPHA_LC
    2: class pdf_write_options(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     do_incremental = property(_mupdf.pdf_write_options_do_incremental_get, _mupdf.pdf_write_options_do_incremental_set)
    1:     do_pretty = property(_mupdf.pdf_write_options_do_pretty_get, _mupdf.pdf_write_options_do_pretty_set)
    1:     do_ascii = property(_mupdf.pdf_write_options_do_ascii_get, _mupdf.pdf_write_options_do_ascii_set)
    1:     do_compress = property(_mupdf.pdf_write_options_do_compress_get, _mupdf.pdf_write_options_do_compress_set)
    1:     do_compress_images = property(_mupdf.pdf_write_options_do_compress_images_get, _mupdf.pdf_write_options_do_compress_images_set)
    1:     do_compress_fonts = property(_mupdf.pdf_write_options_do_compress_fonts_get, _mupdf.pdf_write_options_do_compress_fonts_set)
    1:     do_decompress = property(_mupdf.pdf_write_options_do_decompress_get, _mupdf.pdf_write_options_do_decompress_set)
    1:     do_garbage = property(_mupdf.pdf_write_options_do_garbage_get, _mupdf.pdf_write_options_do_garbage_set)
    1:     do_linear = property(_mupdf.pdf_write_options_do_linear_get, _mupdf.pdf_write_options_do_linear_set)
    1:     do_clean = property(_mupdf.pdf_write_options_do_clean_get, _mupdf.pdf_write_options_do_clean_set)
    1:     do_sanitize = property(_mupdf.pdf_write_options_do_sanitize_get, _mupdf.pdf_write_options_do_sanitize_set)
    1:     do_appearance = property(_mupdf.pdf_write_options_do_appearance_get, _mupdf.pdf_write_options_do_appearance_set)
    1:     do_encrypt = property(_mupdf.pdf_write_options_do_encrypt_get, _mupdf.pdf_write_options_do_encrypt_set)
    1:     dont_regenerate_id = property(_mupdf.pdf_write_options_dont_regenerate_id_get, _mupdf.pdf_write_options_dont_regenerate_id_set)
    1:     permissions = property(_mupdf.pdf_write_options_permissions_get, _mupdf.pdf_write_options_permissions_set)
    1:     opwd_utf8 = property(_mupdf.pdf_write_options_opwd_utf8_get, _mupdf.pdf_write_options_opwd_utf8_set)
    1:     upwd_utf8 = property(_mupdf.pdf_write_options_upwd_utf8_get, _mupdf.pdf_write_options_upwd_utf8_set)
    1:     do_snapshot = property(_mupdf.pdf_write_options_do_snapshot_get, _mupdf.pdf_write_options_do_snapshot_set)
    1:     do_preserve_metadata = property(_mupdf.pdf_write_options_do_preserve_metadata_get, _mupdf.pdf_write_options_do_preserve_metadata_set)
    1:     do_use_objstms = property(_mupdf.pdf_write_options_do_use_objstms_get, _mupdf.pdf_write_options_do_use_objstms_set)
    1:     compression_effort = property(_mupdf.pdf_write_options_compression_effort_get, _mupdf.pdf_write_options_compression_effort_set)
    1:     do_labels = property(_mupdf.pdf_write_options_do_labels_get, _mupdf.pdf_write_options_do_labels_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_write_options_swiginit(self, _mupdf.new_pdf_write_options())
    1:     __swig_destroy__ = _mupdf.delete_pdf_write_options
       
       # Register pdf_write_options in _mupdf:
    1: _mupdf.pdf_write_options_swigregister(pdf_write_options)
    1: PDF_TOK_ERROR = _mupdf.PDF_TOK_ERROR
    1: PDF_TOK_EOF = _mupdf.PDF_TOK_EOF
    1: PDF_TOK_OPEN_ARRAY = _mupdf.PDF_TOK_OPEN_ARRAY
    1: PDF_TOK_CLOSE_ARRAY = _mupdf.PDF_TOK_CLOSE_ARRAY
    1: PDF_TOK_OPEN_DICT = _mupdf.PDF_TOK_OPEN_DICT
    1: PDF_TOK_CLOSE_DICT = _mupdf.PDF_TOK_CLOSE_DICT
    1: PDF_TOK_OPEN_BRACE = _mupdf.PDF_TOK_OPEN_BRACE
    1: PDF_TOK_CLOSE_BRACE = _mupdf.PDF_TOK_CLOSE_BRACE
    1: PDF_TOK_NAME = _mupdf.PDF_TOK_NAME
    1: PDF_TOK_INT = _mupdf.PDF_TOK_INT
    1: PDF_TOK_REAL = _mupdf.PDF_TOK_REAL
    1: PDF_TOK_STRING = _mupdf.PDF_TOK_STRING
    1: PDF_TOK_KEYWORD = _mupdf.PDF_TOK_KEYWORD
    1: PDF_TOK_R = _mupdf.PDF_TOK_R
    1: PDF_TOK_TRUE = _mupdf.PDF_TOK_TRUE
    1: PDF_TOK_FALSE = _mupdf.PDF_TOK_FALSE
    1: PDF_TOK_NULL = _mupdf.PDF_TOK_NULL
    1: PDF_TOK_OBJ = _mupdf.PDF_TOK_OBJ
    1: PDF_TOK_ENDOBJ = _mupdf.PDF_TOK_ENDOBJ
    1: PDF_TOK_STREAM = _mupdf.PDF_TOK_STREAM
    1: PDF_TOK_ENDSTREAM = _mupdf.PDF_TOK_ENDSTREAM
    1: PDF_TOK_XREF = _mupdf.PDF_TOK_XREF
    1: PDF_TOK_TRAILER = _mupdf.PDF_TOK_TRAILER
    1: PDF_TOK_STARTXREF = _mupdf.PDF_TOK_STARTXREF
    1: PDF_TOK_NEWOBJ = _mupdf.PDF_TOK_NEWOBJ
    1: PDF_NUM_TOKENS = _mupdf.PDF_NUM_TOKENS
    2: class pdf_xref_entry(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     type = property(_mupdf.pdf_xref_entry_type_get, _mupdf.pdf_xref_entry_type_set)
    1:     marked = property(_mupdf.pdf_xref_entry_marked_get, _mupdf.pdf_xref_entry_marked_set)
    1:     gen = property(_mupdf.pdf_xref_entry_gen_get, _mupdf.pdf_xref_entry_gen_set)
    1:     num = property(_mupdf.pdf_xref_entry_num_get, _mupdf.pdf_xref_entry_num_set)
    1:     ofs = property(_mupdf.pdf_xref_entry_ofs_get, _mupdf.pdf_xref_entry_ofs_set)
    1:     stm_ofs = property(_mupdf.pdf_xref_entry_stm_ofs_get, _mupdf.pdf_xref_entry_stm_ofs_set)
    1:     stm_buf = property(_mupdf.pdf_xref_entry_stm_buf_get, _mupdf.pdf_xref_entry_stm_buf_set)
    1:     obj = property(_mupdf.pdf_xref_entry_obj_get, _mupdf.pdf_xref_entry_obj_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_xref_entry_swiginit(self, _mupdf.new_pdf_xref_entry())
    1:     __swig_destroy__ = _mupdf.delete_pdf_xref_entry
       
       # Register pdf_xref_entry in _mupdf:
    1: _mupdf.pdf_xref_entry_swigregister(pdf_xref_entry)
    1: pdf_default_write_options = cvar.pdf_default_write_options
       
    2: class pdf_xref_subsec(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     next = property(_mupdf.pdf_xref_subsec_next_get, _mupdf.pdf_xref_subsec_next_set)
    1:     len = property(_mupdf.pdf_xref_subsec_len_get, _mupdf.pdf_xref_subsec_len_set)
    1:     start = property(_mupdf.pdf_xref_subsec_start_get, _mupdf.pdf_xref_subsec_start_set)
    1:     table = property(_mupdf.pdf_xref_subsec_table_get, _mupdf.pdf_xref_subsec_table_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_xref_subsec_swiginit(self, _mupdf.new_pdf_xref_subsec())
    1:     __swig_destroy__ = _mupdf.delete_pdf_xref_subsec
       
       # Register pdf_xref_subsec in _mupdf:
    1: _mupdf.pdf_xref_subsec_swigregister(pdf_xref_subsec)
    2: class pdf_xref(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     num_objects = property(_mupdf.pdf_xref_num_objects_get, _mupdf.pdf_xref_num_objects_set)
    1:     subsec = property(_mupdf.pdf_xref_subsec_get, _mupdf.pdf_xref_subsec_set)
    1:     trailer = property(_mupdf.pdf_xref_trailer_get, _mupdf.pdf_xref_trailer_set)
    1:     pre_repair_trailer = property(_mupdf.pdf_xref_pre_repair_trailer_get, _mupdf.pdf_xref_pre_repair_trailer_set)
    1:     unsaved_sigs = property(_mupdf.pdf_xref_unsaved_sigs_get, _mupdf.pdf_xref_unsaved_sigs_set)
    1:     unsaved_sigs_end = property(_mupdf.pdf_xref_unsaved_sigs_end_get, _mupdf.pdf_xref_unsaved_sigs_end_set)
    1:     end_ofs = property(_mupdf.pdf_xref_end_ofs_get, _mupdf.pdf_xref_end_ofs_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_xref_swiginit(self, _mupdf.new_pdf_xref())
    1:     __swig_destroy__ = _mupdf.delete_pdf_xref
       
       # Register pdf_xref in _mupdf:
    1: _mupdf.pdf_xref_swigregister(pdf_xref)
    1: PDF_ENCRYPT_KEEP = _mupdf.PDF_ENCRYPT_KEEP
    1: PDF_ENCRYPT_NONE = _mupdf.PDF_ENCRYPT_NONE
    1: PDF_ENCRYPT_RC4_40 = _mupdf.PDF_ENCRYPT_RC4_40
    1: PDF_ENCRYPT_RC4_128 = _mupdf.PDF_ENCRYPT_RC4_128
    1: PDF_ENCRYPT_AES_128 = _mupdf.PDF_ENCRYPT_AES_128
    1: PDF_ENCRYPT_AES_256 = _mupdf.PDF_ENCRYPT_AES_256
    1: PDF_ENCRYPT_UNKNOWN = _mupdf.PDF_ENCRYPT_UNKNOWN
    1: PDF_PERM_PRINT = _mupdf.PDF_PERM_PRINT
    1: PDF_PERM_MODIFY = _mupdf.PDF_PERM_MODIFY
    1: PDF_PERM_COPY = _mupdf.PDF_PERM_COPY
    1: PDF_PERM_ANNOTATE = _mupdf.PDF_PERM_ANNOTATE
    1: PDF_PERM_FORM = _mupdf.PDF_PERM_FORM
    1: PDF_PERM_ACCESSIBILITY = _mupdf.PDF_PERM_ACCESSIBILITY
    1: PDF_PERM_ASSEMBLE = _mupdf.PDF_PERM_ASSEMBLE
    1: PDF_PERM_PRINT_HQ = _mupdf.PDF_PERM_PRINT_HQ
    1: PDF_MRANGE_CAP = _mupdf.PDF_MRANGE_CAP
    2: class pdf_range(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     low = property(_mupdf.pdf_range_low_get, _mupdf.pdf_range_low_set)
    1:     high = property(_mupdf.pdf_range_high_get, _mupdf.pdf_range_high_set)
    1:     out = property(_mupdf.pdf_range_out_get, _mupdf.pdf_range_out_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_range_swiginit(self, _mupdf.new_pdf_range())
    1:     __swig_destroy__ = _mupdf.delete_pdf_range
       
       # Register pdf_range in _mupdf:
    1: _mupdf.pdf_range_swigregister(pdf_range)
    2: class pdf_xrange(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     low = property(_mupdf.pdf_xrange_low_get, _mupdf.pdf_xrange_low_set)
    1:     high = property(_mupdf.pdf_xrange_high_get, _mupdf.pdf_xrange_high_set)
    1:     out = property(_mupdf.pdf_xrange_out_get, _mupdf.pdf_xrange_out_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_xrange_swiginit(self, _mupdf.new_pdf_xrange())
    1:     __swig_destroy__ = _mupdf.delete_pdf_xrange
       
       # Register pdf_xrange in _mupdf:
    1: _mupdf.pdf_xrange_swigregister(pdf_xrange)
    2: class pdf_mrange(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     low = property(_mupdf.pdf_mrange_low_get, _mupdf.pdf_mrange_low_set)
    1:     out = property(_mupdf.pdf_mrange_out_get, _mupdf.pdf_mrange_out_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_mrange_swiginit(self, _mupdf.new_pdf_mrange())
    1:     __swig_destroy__ = _mupdf.delete_pdf_mrange
       
       # Register pdf_mrange in _mupdf:
    1: _mupdf.pdf_mrange_swigregister(pdf_mrange)
    2: class pdf_cmap(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     storable = property(_mupdf.pdf_cmap_storable_get, _mupdf.pdf_cmap_storable_set)
    1:     cmap_name = property(_mupdf.pdf_cmap_cmap_name_get, _mupdf.pdf_cmap_cmap_name_set)
    1:     usecmap_name = property(_mupdf.pdf_cmap_usecmap_name_get, _mupdf.pdf_cmap_usecmap_name_set)
    1:     usecmap = property(_mupdf.pdf_cmap_usecmap_get, _mupdf.pdf_cmap_usecmap_set)
    1:     wmode = property(_mupdf.pdf_cmap_wmode_get, _mupdf.pdf_cmap_wmode_set)
    1:     codespace_len = property(_mupdf.pdf_cmap_codespace_len_get, _mupdf.pdf_cmap_codespace_len_set)
    1:     rlen = property(_mupdf.pdf_cmap_rlen_get, _mupdf.pdf_cmap_rlen_set)
    1:     rcap = property(_mupdf.pdf_cmap_rcap_get, _mupdf.pdf_cmap_rcap_set)
    1:     ranges = property(_mupdf.pdf_cmap_ranges_get, _mupdf.pdf_cmap_ranges_set)
    1:     xlen = property(_mupdf.pdf_cmap_xlen_get, _mupdf.pdf_cmap_xlen_set)
    1:     xcap = property(_mupdf.pdf_cmap_xcap_get, _mupdf.pdf_cmap_xcap_set)
    1:     xranges = property(_mupdf.pdf_cmap_xranges_get, _mupdf.pdf_cmap_xranges_set)
    1:     mlen = property(_mupdf.pdf_cmap_mlen_get, _mupdf.pdf_cmap_mlen_set)
    1:     mcap = property(_mupdf.pdf_cmap_mcap_get, _mupdf.pdf_cmap_mcap_set)
    1:     mranges = property(_mupdf.pdf_cmap_mranges_get, _mupdf.pdf_cmap_mranges_set)
    1:     dlen = property(_mupdf.pdf_cmap_dlen_get, _mupdf.pdf_cmap_dlen_set)
    1:     dcap = property(_mupdf.pdf_cmap_dcap_get, _mupdf.pdf_cmap_dcap_set)
    1:     dict = property(_mupdf.pdf_cmap_dict_get, _mupdf.pdf_cmap_dict_set)
    1:     tlen = property(_mupdf.pdf_cmap_tlen_get, _mupdf.pdf_cmap_tlen_set)
    1:     tcap = property(_mupdf.pdf_cmap_tcap_get, _mupdf.pdf_cmap_tcap_set)
    1:     ttop = property(_mupdf.pdf_cmap_ttop_get, _mupdf.pdf_cmap_ttop_set)
    1:     tree = property(_mupdf.pdf_cmap_tree_get, _mupdf.pdf_cmap_tree_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_cmap_swiginit(self, _mupdf.new_pdf_cmap())
    1:     __swig_destroy__ = _mupdf.delete_pdf_cmap
       
       # Register pdf_cmap in _mupdf:
    1: _mupdf.pdf_cmap_swigregister(pdf_cmap)
    1: PDF_FD_FIXED_PITCH = _mupdf.PDF_FD_FIXED_PITCH
    1: PDF_FD_SERIF = _mupdf.PDF_FD_SERIF
    1: PDF_FD_SYMBOLIC = _mupdf.PDF_FD_SYMBOLIC
    1: PDF_FD_SCRIPT = _mupdf.PDF_FD_SCRIPT
    1: PDF_FD_NONSYMBOLIC = _mupdf.PDF_FD_NONSYMBOLIC
    1: PDF_FD_ITALIC = _mupdf.PDF_FD_ITALIC
    1: PDF_FD_ALL_CAP = _mupdf.PDF_FD_ALL_CAP
    1: PDF_FD_SMALL_CAP = _mupdf.PDF_FD_SMALL_CAP
    1: PDF_FD_FORCE_BOLD = _mupdf.PDF_FD_FORCE_BOLD
    2: class pdf_hmtx(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     lo = property(_mupdf.pdf_hmtx_lo_get, _mupdf.pdf_hmtx_lo_set)
    1:     hi = property(_mupdf.pdf_hmtx_hi_get, _mupdf.pdf_hmtx_hi_set)
    1:     w = property(_mupdf.pdf_hmtx_w_get, _mupdf.pdf_hmtx_w_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_hmtx_swiginit(self, _mupdf.new_pdf_hmtx())
    1:     __swig_destroy__ = _mupdf.delete_pdf_hmtx
       
       # Register pdf_hmtx in _mupdf:
    1: _mupdf.pdf_hmtx_swigregister(pdf_hmtx)
    2: class pdf_vmtx(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     lo = property(_mupdf.pdf_vmtx_lo_get, _mupdf.pdf_vmtx_lo_set)
    1:     hi = property(_mupdf.pdf_vmtx_hi_get, _mupdf.pdf_vmtx_hi_set)
    1:     x = property(_mupdf.pdf_vmtx_x_get, _mupdf.pdf_vmtx_x_set)
    1:     y = property(_mupdf.pdf_vmtx_y_get, _mupdf.pdf_vmtx_y_set)
    1:     w = property(_mupdf.pdf_vmtx_w_get, _mupdf.pdf_vmtx_w_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_vmtx_swiginit(self, _mupdf.new_pdf_vmtx())
    1:     __swig_destroy__ = _mupdf.delete_pdf_vmtx
       
       # Register pdf_vmtx in _mupdf:
    1: _mupdf.pdf_vmtx_swigregister(pdf_vmtx)
    2: class pdf_font_desc(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     storable = property(_mupdf.pdf_font_desc_storable_get, _mupdf.pdf_font_desc_storable_set)
    1:     size = property(_mupdf.pdf_font_desc_size_get, _mupdf.pdf_font_desc_size_set)
    1:     font = property(_mupdf.pdf_font_desc_font_get, _mupdf.pdf_font_desc_font_set)
    1:     flags = property(_mupdf.pdf_font_desc_flags_get, _mupdf.pdf_font_desc_flags_set)
    1:     italic_angle = property(_mupdf.pdf_font_desc_italic_angle_get, _mupdf.pdf_font_desc_italic_angle_set)
    1:     ascent = property(_mupdf.pdf_font_desc_ascent_get, _mupdf.pdf_font_desc_ascent_set)
    1:     descent = property(_mupdf.pdf_font_desc_descent_get, _mupdf.pdf_font_desc_descent_set)
    1:     cap_height = property(_mupdf.pdf_font_desc_cap_height_get, _mupdf.pdf_font_desc_cap_height_set)
    1:     x_height = property(_mupdf.pdf_font_desc_x_height_get, _mupdf.pdf_font_desc_x_height_set)
    1:     missing_width = property(_mupdf.pdf_font_desc_missing_width_get, _mupdf.pdf_font_desc_missing_width_set)
    1:     encoding = property(_mupdf.pdf_font_desc_encoding_get, _mupdf.pdf_font_desc_encoding_set)
    1:     to_ttf_cmap = property(_mupdf.pdf_font_desc_to_ttf_cmap_get, _mupdf.pdf_font_desc_to_ttf_cmap_set)
    1:     cid_to_gid_len = property(_mupdf.pdf_font_desc_cid_to_gid_len_get, _mupdf.pdf_font_desc_cid_to_gid_len_set)
    1:     cid_to_gid = property(_mupdf.pdf_font_desc_cid_to_gid_get, _mupdf.pdf_font_desc_cid_to_gid_set)
    1:     to_unicode = property(_mupdf.pdf_font_desc_to_unicode_get, _mupdf.pdf_font_desc_to_unicode_set)
    1:     cid_to_ucs_len = property(_mupdf.pdf_font_desc_cid_to_ucs_len_get, _mupdf.pdf_font_desc_cid_to_ucs_len_set)
    1:     cid_to_ucs = property(_mupdf.pdf_font_desc_cid_to_ucs_get, _mupdf.pdf_font_desc_cid_to_ucs_set)
    1:     wmode = property(_mupdf.pdf_font_desc_wmode_get, _mupdf.pdf_font_desc_wmode_set)
    1:     hmtx_len = property(_mupdf.pdf_font_desc_hmtx_len_get, _mupdf.pdf_font_desc_hmtx_len_set)
    1:     hmtx_cap = property(_mupdf.pdf_font_desc_hmtx_cap_get, _mupdf.pdf_font_desc_hmtx_cap_set)
    1:     dhmtx = property(_mupdf.pdf_font_desc_dhmtx_get, _mupdf.pdf_font_desc_dhmtx_set)
    1:     hmtx = property(_mupdf.pdf_font_desc_hmtx_get, _mupdf.pdf_font_desc_hmtx_set)
    1:     vmtx_len = property(_mupdf.pdf_font_desc_vmtx_len_get, _mupdf.pdf_font_desc_vmtx_len_set)
    1:     vmtx_cap = property(_mupdf.pdf_font_desc_vmtx_cap_get, _mupdf.pdf_font_desc_vmtx_cap_set)
    1:     dvmtx = property(_mupdf.pdf_font_desc_dvmtx_get, _mupdf.pdf_font_desc_dvmtx_set)
    1:     vmtx = property(_mupdf.pdf_font_desc_vmtx_get, _mupdf.pdf_font_desc_vmtx_set)
    1:     is_embedded = property(_mupdf.pdf_font_desc_is_embedded_get, _mupdf.pdf_font_desc_is_embedded_set)
    1:     t3loading = property(_mupdf.pdf_font_desc_t3loading_get, _mupdf.pdf_font_desc_t3loading_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_font_desc_swiginit(self, _mupdf.new_pdf_font_desc())
    1:     __swig_destroy__ = _mupdf.delete_pdf_font_desc
       
       # Register pdf_font_desc in _mupdf:
    1: _mupdf.pdf_font_desc_swigregister(pdf_font_desc)
    1: PDF_SIMPLE_FONT_RESOURCE = _mupdf.PDF_SIMPLE_FONT_RESOURCE
    1: PDF_CID_FONT_RESOURCE = _mupdf.PDF_CID_FONT_RESOURCE
    1: PDF_CJK_FONT_RESOURCE = _mupdf.PDF_CJK_FONT_RESOURCE
    1: PDF_SIMPLE_ENCODING_LATIN = _mupdf.PDF_SIMPLE_ENCODING_LATIN
    1: PDF_SIMPLE_ENCODING_GREEK = _mupdf.PDF_SIMPLE_ENCODING_GREEK
    1: PDF_SIMPLE_ENCODING_CYRILLIC = _mupdf.PDF_SIMPLE_ENCODING_CYRILLIC
    2: class pdf_font_resource_key(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     digest = property(_mupdf.pdf_font_resource_key_digest_get, _mupdf.pdf_font_resource_key_digest_set)
    1:     type = property(_mupdf.pdf_font_resource_key_type_get, _mupdf.pdf_font_resource_key_type_set)
    1:     encoding = property(_mupdf.pdf_font_resource_key_encoding_get, _mupdf.pdf_font_resource_key_encoding_set)
    1:     local_xref = property(_mupdf.pdf_font_resource_key_local_xref_get, _mupdf.pdf_font_resource_key_local_xref_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_font_resource_key_swiginit(self, _mupdf.new_pdf_font_resource_key())
    1:     __swig_destroy__ = _mupdf.delete_pdf_font_resource_key
       
       # Register pdf_font_resource_key in _mupdf:
    1: _mupdf.pdf_font_resource_key_swigregister(pdf_font_resource_key)
    2: class pdf_colorspace_resource_key(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     digest = property(_mupdf.pdf_colorspace_resource_key_digest_get, _mupdf.pdf_colorspace_resource_key_digest_set)
    1:     local_xref = property(_mupdf.pdf_colorspace_resource_key_local_xref_get, _mupdf.pdf_colorspace_resource_key_local_xref_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_colorspace_resource_key_swiginit(self, _mupdf.new_pdf_colorspace_resource_key())
    1:     __swig_destroy__ = _mupdf.delete_pdf_colorspace_resource_key
       
       # Register pdf_colorspace_resource_key in _mupdf:
    1: _mupdf.pdf_colorspace_resource_key_swigregister(pdf_colorspace_resource_key)
    2: class pdf_pattern(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     storable = property(_mupdf.pdf_pattern_storable_get, _mupdf.pdf_pattern_storable_set)
    1:     ismask = property(_mupdf.pdf_pattern_ismask_get, _mupdf.pdf_pattern_ismask_set)
    1:     xstep = property(_mupdf.pdf_pattern_xstep_get, _mupdf.pdf_pattern_xstep_set)
    1:     ystep = property(_mupdf.pdf_pattern_ystep_get, _mupdf.pdf_pattern_ystep_set)
    1:     matrix = property(_mupdf.pdf_pattern_matrix_get, _mupdf.pdf_pattern_matrix_set)
    1:     bbox = property(_mupdf.pdf_pattern_bbox_get, _mupdf.pdf_pattern_bbox_set)
    1:     document = property(_mupdf.pdf_pattern_document_get, _mupdf.pdf_pattern_document_set)
    1:     resources = property(_mupdf.pdf_pattern_resources_get, _mupdf.pdf_pattern_resources_set)
    1:     contents = property(_mupdf.pdf_pattern_contents_get, _mupdf.pdf_pattern_contents_set)
    1:     id = property(_mupdf.pdf_pattern_id_get, _mupdf.pdf_pattern_id_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_pattern_swiginit(self, _mupdf.new_pdf_pattern())
    1:     __swig_destroy__ = _mupdf.delete_pdf_pattern
       
       # Register pdf_pattern in _mupdf:
    1: _mupdf.pdf_pattern_swigregister(pdf_pattern)
    2: class pdf_resource_stack(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     next = property(_mupdf.pdf_resource_stack_next_get, _mupdf.pdf_resource_stack_next_set)
    1:     resources = property(_mupdf.pdf_resource_stack_resources_get, _mupdf.pdf_resource_stack_resources_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_resource_stack_swiginit(self, _mupdf.new_pdf_resource_stack())
    1:     __swig_destroy__ = _mupdf.delete_pdf_resource_stack
       
       # Register pdf_resource_stack in _mupdf:
    1: _mupdf.pdf_resource_stack_swigregister(pdf_resource_stack)
    1: PDF_PROCESSOR_REQUIRES_DECODED_IMAGES = _mupdf.PDF_PROCESSOR_REQUIRES_DECODED_IMAGES
    2: class pdf_processor(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.pdf_processor_refs_get, _mupdf.pdf_processor_refs_set)
    1:     closed = property(_mupdf.pdf_processor_closed_get, _mupdf.pdf_processor_closed_set)
    1:     close_processor = property(_mupdf.pdf_processor_close_processor_get, _mupdf.pdf_processor_close_processor_set)
    1:     drop_processor = property(_mupdf.pdf_processor_drop_processor_get, _mupdf.pdf_processor_drop_processor_set)
    1:     reset_processor = property(_mupdf.pdf_processor_reset_processor_get, _mupdf.pdf_processor_reset_processor_set)
    1:     push_resources = property(_mupdf.pdf_processor_push_resources_get, _mupdf.pdf_processor_push_resources_set)
    1:     pop_resources = property(_mupdf.pdf_processor_pop_resources_get, _mupdf.pdf_processor_pop_resources_set)
    1:     op_w = property(_mupdf.pdf_processor_op_w_get, _mupdf.pdf_processor_op_w_set)
    1:     op_j = property(_mupdf.pdf_processor_op_j_get, _mupdf.pdf_processor_op_j_set)
    1:     op_J = property(_mupdf.pdf_processor_op_J_get, _mupdf.pdf_processor_op_J_set)
    1:     op_M = property(_mupdf.pdf_processor_op_M_get, _mupdf.pdf_processor_op_M_set)
    1:     op_d = property(_mupdf.pdf_processor_op_d_get, _mupdf.pdf_processor_op_d_set)
    1:     op_ri = property(_mupdf.pdf_processor_op_ri_get, _mupdf.pdf_processor_op_ri_set)
    1:     op_i = property(_mupdf.pdf_processor_op_i_get, _mupdf.pdf_processor_op_i_set)
    1:     op_gs_begin = property(_mupdf.pdf_processor_op_gs_begin_get, _mupdf.pdf_processor_op_gs_begin_set)
    1:     op_gs_BM = property(_mupdf.pdf_processor_op_gs_BM_get, _mupdf.pdf_processor_op_gs_BM_set)
    1:     op_gs_ca = property(_mupdf.pdf_processor_op_gs_ca_get, _mupdf.pdf_processor_op_gs_ca_set)
    1:     op_gs_CA = property(_mupdf.pdf_processor_op_gs_CA_get, _mupdf.pdf_processor_op_gs_CA_set)
    1:     op_gs_SMask = property(_mupdf.pdf_processor_op_gs_SMask_get, _mupdf.pdf_processor_op_gs_SMask_set)
    1:     op_gs_end = property(_mupdf.pdf_processor_op_gs_end_get, _mupdf.pdf_processor_op_gs_end_set)
    1:     op_q = property(_mupdf.pdf_processor_op_q_get, _mupdf.pdf_processor_op_q_set)
    1:     op_Q = property(_mupdf.pdf_processor_op_Q_get, _mupdf.pdf_processor_op_Q_set)
    1:     op_cm = property(_mupdf.pdf_processor_op_cm_get, _mupdf.pdf_processor_op_cm_set)
    1:     op_m = property(_mupdf.pdf_processor_op_m_get, _mupdf.pdf_processor_op_m_set)
    1:     op_l = property(_mupdf.pdf_processor_op_l_get, _mupdf.pdf_processor_op_l_set)
    1:     op_c = property(_mupdf.pdf_processor_op_c_get, _mupdf.pdf_processor_op_c_set)
    1:     op_v = property(_mupdf.pdf_processor_op_v_get, _mupdf.pdf_processor_op_v_set)
    1:     op_y = property(_mupdf.pdf_processor_op_y_get, _mupdf.pdf_processor_op_y_set)
    1:     op_h = property(_mupdf.pdf_processor_op_h_get, _mupdf.pdf_processor_op_h_set)
    1:     op_re = property(_mupdf.pdf_processor_op_re_get, _mupdf.pdf_processor_op_re_set)
    1:     op_S = property(_mupdf.pdf_processor_op_S_get, _mupdf.pdf_processor_op_S_set)
    1:     op_s = property(_mupdf.pdf_processor_op_s_get, _mupdf.pdf_processor_op_s_set)
    1:     op_F = property(_mupdf.pdf_processor_op_F_get, _mupdf.pdf_processor_op_F_set)
    1:     op_f = property(_mupdf.pdf_processor_op_f_get, _mupdf.pdf_processor_op_f_set)
    1:     op_fstar = property(_mupdf.pdf_processor_op_fstar_get, _mupdf.pdf_processor_op_fstar_set)
    1:     op_B = property(_mupdf.pdf_processor_op_B_get, _mupdf.pdf_processor_op_B_set)
    1:     op_Bstar = property(_mupdf.pdf_processor_op_Bstar_get, _mupdf.pdf_processor_op_Bstar_set)
    1:     op_b = property(_mupdf.pdf_processor_op_b_get, _mupdf.pdf_processor_op_b_set)
    1:     op_bstar = property(_mupdf.pdf_processor_op_bstar_get, _mupdf.pdf_processor_op_bstar_set)
    1:     op_n = property(_mupdf.pdf_processor_op_n_get, _mupdf.pdf_processor_op_n_set)
    1:     op_W = property(_mupdf.pdf_processor_op_W_get, _mupdf.pdf_processor_op_W_set)
    1:     op_Wstar = property(_mupdf.pdf_processor_op_Wstar_get, _mupdf.pdf_processor_op_Wstar_set)
    1:     op_BT = property(_mupdf.pdf_processor_op_BT_get, _mupdf.pdf_processor_op_BT_set)
    1:     op_ET = property(_mupdf.pdf_processor_op_ET_get, _mupdf.pdf_processor_op_ET_set)
    1:     op_Tc = property(_mupdf.pdf_processor_op_Tc_get, _mupdf.pdf_processor_op_Tc_set)
    1:     op_Tw = property(_mupdf.pdf_processor_op_Tw_get, _mupdf.pdf_processor_op_Tw_set)
    1:     op_Tz = property(_mupdf.pdf_processor_op_Tz_get, _mupdf.pdf_processor_op_Tz_set)
    1:     op_TL = property(_mupdf.pdf_processor_op_TL_get, _mupdf.pdf_processor_op_TL_set)
    1:     op_Tf = property(_mupdf.pdf_processor_op_Tf_get, _mupdf.pdf_processor_op_Tf_set)
    1:     op_Tr = property(_mupdf.pdf_processor_op_Tr_get, _mupdf.pdf_processor_op_Tr_set)
    1:     op_Ts = property(_mupdf.pdf_processor_op_Ts_get, _mupdf.pdf_processor_op_Ts_set)
    1:     op_Td = property(_mupdf.pdf_processor_op_Td_get, _mupdf.pdf_processor_op_Td_set)
    1:     op_TD = property(_mupdf.pdf_processor_op_TD_get, _mupdf.pdf_processor_op_TD_set)
    1:     op_Tm = property(_mupdf.pdf_processor_op_Tm_get, _mupdf.pdf_processor_op_Tm_set)
    1:     op_Tstar = property(_mupdf.pdf_processor_op_Tstar_get, _mupdf.pdf_processor_op_Tstar_set)
    1:     op_TJ = property(_mupdf.pdf_processor_op_TJ_get, _mupdf.pdf_processor_op_TJ_set)
    1:     op_Tj = property(_mupdf.pdf_processor_op_Tj_get, _mupdf.pdf_processor_op_Tj_set)
    1:     op_squote = property(_mupdf.pdf_processor_op_squote_get, _mupdf.pdf_processor_op_squote_set)
    1:     op_dquote = property(_mupdf.pdf_processor_op_dquote_get, _mupdf.pdf_processor_op_dquote_set)
    1:     op_d0 = property(_mupdf.pdf_processor_op_d0_get, _mupdf.pdf_processor_op_d0_set)
    1:     op_d1 = property(_mupdf.pdf_processor_op_d1_get, _mupdf.pdf_processor_op_d1_set)
    1:     op_CS = property(_mupdf.pdf_processor_op_CS_get, _mupdf.pdf_processor_op_CS_set)
    1:     op_cs = property(_mupdf.pdf_processor_op_cs_get, _mupdf.pdf_processor_op_cs_set)
    1:     op_SC_pattern = property(_mupdf.pdf_processor_op_SC_pattern_get, _mupdf.pdf_processor_op_SC_pattern_set)
    1:     op_sc_pattern = property(_mupdf.pdf_processor_op_sc_pattern_get, _mupdf.pdf_processor_op_sc_pattern_set)
    1:     op_SC_shade = property(_mupdf.pdf_processor_op_SC_shade_get, _mupdf.pdf_processor_op_SC_shade_set)
    1:     op_sc_shade = property(_mupdf.pdf_processor_op_sc_shade_get, _mupdf.pdf_processor_op_sc_shade_set)
    1:     op_SC_color = property(_mupdf.pdf_processor_op_SC_color_get, _mupdf.pdf_processor_op_SC_color_set)
    1:     op_sc_color = property(_mupdf.pdf_processor_op_sc_color_get, _mupdf.pdf_processor_op_sc_color_set)
    1:     op_G = property(_mupdf.pdf_processor_op_G_get, _mupdf.pdf_processor_op_G_set)
    1:     op_g = property(_mupdf.pdf_processor_op_g_get, _mupdf.pdf_processor_op_g_set)
    1:     op_RG = property(_mupdf.pdf_processor_op_RG_get, _mupdf.pdf_processor_op_RG_set)
    1:     op_rg = property(_mupdf.pdf_processor_op_rg_get, _mupdf.pdf_processor_op_rg_set)
    1:     op_K = property(_mupdf.pdf_processor_op_K_get, _mupdf.pdf_processor_op_K_set)
    1:     op_k = property(_mupdf.pdf_processor_op_k_get, _mupdf.pdf_processor_op_k_set)
    1:     op_BI = property(_mupdf.pdf_processor_op_BI_get, _mupdf.pdf_processor_op_BI_set)
    1:     op_sh = property(_mupdf.pdf_processor_op_sh_get, _mupdf.pdf_processor_op_sh_set)
    1:     op_Do_image = property(_mupdf.pdf_processor_op_Do_image_get, _mupdf.pdf_processor_op_Do_image_set)
    1:     op_Do_form = property(_mupdf.pdf_processor_op_Do_form_get, _mupdf.pdf_processor_op_Do_form_set)
    1:     op_MP = property(_mupdf.pdf_processor_op_MP_get, _mupdf.pdf_processor_op_MP_set)
    1:     op_DP = property(_mupdf.pdf_processor_op_DP_get, _mupdf.pdf_processor_op_DP_set)
    1:     op_BMC = property(_mupdf.pdf_processor_op_BMC_get, _mupdf.pdf_processor_op_BMC_set)
    1:     op_BDC = property(_mupdf.pdf_processor_op_BDC_get, _mupdf.pdf_processor_op_BDC_set)
    1:     op_EMC = property(_mupdf.pdf_processor_op_EMC_get, _mupdf.pdf_processor_op_EMC_set)
    1:     op_BX = property(_mupdf.pdf_processor_op_BX_get, _mupdf.pdf_processor_op_BX_set)
    1:     op_EX = property(_mupdf.pdf_processor_op_EX_get, _mupdf.pdf_processor_op_EX_set)
    1:     op_gs_OP = property(_mupdf.pdf_processor_op_gs_OP_get, _mupdf.pdf_processor_op_gs_OP_set)
    1:     op_gs_op = property(_mupdf.pdf_processor_op_gs_op_get, _mupdf.pdf_processor_op_gs_op_set)
    1:     op_gs_OPM = property(_mupdf.pdf_processor_op_gs_OPM_get, _mupdf.pdf_processor_op_gs_OPM_set)
    1:     op_gs_UseBlackPtComp = property(_mupdf.pdf_processor_op_gs_UseBlackPtComp_get, _mupdf.pdf_processor_op_gs_UseBlackPtComp_set)
    1:     op_EOD = property(_mupdf.pdf_processor_op_EOD_get, _mupdf.pdf_processor_op_EOD_set)
    1:     op_END = property(_mupdf.pdf_processor_op_END_get, _mupdf.pdf_processor_op_END_set)
    1:     usage = property(_mupdf.pdf_processor_usage_get, _mupdf.pdf_processor_usage_set)
    1:     hidden = property(_mupdf.pdf_processor_hidden_get, _mupdf.pdf_processor_hidden_set)
    1:     requirements = property(_mupdf.pdf_processor_requirements_get, _mupdf.pdf_processor_requirements_set)
    1:     rstack = property(_mupdf.pdf_processor_rstack_get, _mupdf.pdf_processor_rstack_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_processor_swiginit(self, _mupdf.new_pdf_processor())
    1:     __swig_destroy__ = _mupdf.delete_pdf_processor
       
       # Register pdf_processor in _mupdf:
    1: _mupdf.pdf_processor_swigregister(pdf_processor)
    2: class pdf_csi(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     doc = property(_mupdf.pdf_csi_doc_get, _mupdf.pdf_csi_doc_set)
    1:     buf = property(_mupdf.pdf_csi_buf_get, _mupdf.pdf_csi_buf_set)
    1:     cookie = property(_mupdf.pdf_csi_cookie_get, _mupdf.pdf_csi_cookie_set)
    1:     gstate = property(_mupdf.pdf_csi_gstate_get, _mupdf.pdf_csi_gstate_set)
    1:     xbalance = property(_mupdf.pdf_csi_xbalance_get, _mupdf.pdf_csi_xbalance_set)
    1:     in_text = property(_mupdf.pdf_csi_in_text_get, _mupdf.pdf_csi_in_text_set)
    1:     d1_rect = property(_mupdf.pdf_csi_d1_rect_get, _mupdf.pdf_csi_d1_rect_set)
    1:     obj = property(_mupdf.pdf_csi_obj_get, _mupdf.pdf_csi_obj_set)
    1:     name = property(_mupdf.pdf_csi_name_get, _mupdf.pdf_csi_name_set)
    1:     string = property(_mupdf.pdf_csi_string_get, _mupdf.pdf_csi_string_set)
    1:     string_len = property(_mupdf.pdf_csi_string_len_get, _mupdf.pdf_csi_string_len_set)
    1:     top = property(_mupdf.pdf_csi_top_get, _mupdf.pdf_csi_top_set)
    1:     stack = property(_mupdf.pdf_csi_stack_get, _mupdf.pdf_csi_stack_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_csi_swiginit(self, _mupdf.new_pdf_csi())
    1:     __swig_destroy__ = _mupdf.delete_pdf_csi
       
       # Register pdf_csi in _mupdf:
    1: _mupdf.pdf_csi_swigregister(pdf_csi)
    2: class pdf_filter_factory(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     filter = property(_mupdf.pdf_filter_factory_filter_get, _mupdf.pdf_filter_factory_filter_set)
    1:     options = property(_mupdf.pdf_filter_factory_options_get, _mupdf.pdf_filter_factory_options_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_filter_factory_swiginit(self, _mupdf.new_pdf_filter_factory())
    1:     __swig_destroy__ = _mupdf.delete_pdf_filter_factory
       
       # Register pdf_filter_factory in _mupdf:
    1: _mupdf.pdf_filter_factory_swigregister(pdf_filter_factory)
    2: class pdf_filter_options(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     recurse = property(_mupdf.pdf_filter_options_recurse_get, _mupdf.pdf_filter_options_recurse_set)
    1:     instance_forms = property(_mupdf.pdf_filter_options_instance_forms_get, _mupdf.pdf_filter_options_instance_forms_set)
    1:     ascii = property(_mupdf.pdf_filter_options_ascii_get, _mupdf.pdf_filter_options_ascii_set)
    1:     no_update = property(_mupdf.pdf_filter_options_no_update_get, _mupdf.pdf_filter_options_no_update_set)
    1:     opaque = property(_mupdf.pdf_filter_options_opaque_get, _mupdf.pdf_filter_options_opaque_set)
    1:     complete = property(_mupdf.pdf_filter_options_complete_get, _mupdf.pdf_filter_options_complete_set)
    1:     filters = property(_mupdf.pdf_filter_options_filters_get, _mupdf.pdf_filter_options_filters_set)
    1:     newlines = property(_mupdf.pdf_filter_options_newlines_get, _mupdf.pdf_filter_options_newlines_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_filter_options_swiginit(self, _mupdf.new_pdf_filter_options())
    1:     __swig_destroy__ = _mupdf.delete_pdf_filter_options
       
       # Register pdf_filter_options in _mupdf:
    1: _mupdf.pdf_filter_options_swigregister(pdf_filter_options)
    1: FZ_CULL_PATH_DROP = _mupdf.FZ_CULL_PATH_DROP
    1: FZ_CULL_PATH_FILL = _mupdf.FZ_CULL_PATH_FILL
    1: FZ_CULL_PATH_STROKE = _mupdf.FZ_CULL_PATH_STROKE
    1: FZ_CULL_PATH_FILL_STROKE = _mupdf.FZ_CULL_PATH_FILL_STROKE
    1: FZ_CULL_CLIP_PATH_DROP = _mupdf.FZ_CULL_CLIP_PATH_DROP
    1: FZ_CULL_CLIP_PATH_FILL = _mupdf.FZ_CULL_CLIP_PATH_FILL
    1: FZ_CULL_CLIP_PATH_STROKE = _mupdf.FZ_CULL_CLIP_PATH_STROKE
    1: FZ_CULL_CLIP_PATH_FILL_STROKE = _mupdf.FZ_CULL_CLIP_PATH_FILL_STROKE
    1: FZ_CULL_GLYPH = _mupdf.FZ_CULL_GLYPH
    1: FZ_CULL_IMAGE = _mupdf.FZ_CULL_IMAGE
    1: FZ_CULL_SHADING = _mupdf.FZ_CULL_SHADING
    2: class pdf_sanitize_filter_options(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     opaque = property(_mupdf.pdf_sanitize_filter_options_opaque_get, _mupdf.pdf_sanitize_filter_options_opaque_set)
    1:     image_filter = property(_mupdf.pdf_sanitize_filter_options_image_filter_get, _mupdf.pdf_sanitize_filter_options_image_filter_set)
    1:     text_filter = property(_mupdf.pdf_sanitize_filter_options_text_filter_get, _mupdf.pdf_sanitize_filter_options_text_filter_set)
    1:     after_text_object = property(_mupdf.pdf_sanitize_filter_options_after_text_object_get, _mupdf.pdf_sanitize_filter_options_after_text_object_set)
    1:     culler = property(_mupdf.pdf_sanitize_filter_options_culler_get, _mupdf.pdf_sanitize_filter_options_culler_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_sanitize_filter_options_swiginit(self, _mupdf.new_pdf_sanitize_filter_options())
    1:     __swig_destroy__ = _mupdf.delete_pdf_sanitize_filter_options
       
       # Register pdf_sanitize_filter_options in _mupdf:
    1: _mupdf.pdf_sanitize_filter_options_swigregister(pdf_sanitize_filter_options)
    2: class pdf_color_filter_options(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     opaque = property(_mupdf.pdf_color_filter_options_opaque_get, _mupdf.pdf_color_filter_options_opaque_set)
    1:     color_rewrite = property(_mupdf.pdf_color_filter_options_color_rewrite_get, _mupdf.pdf_color_filter_options_color_rewrite_set)
    1:     image_rewrite = property(_mupdf.pdf_color_filter_options_image_rewrite_get, _mupdf.pdf_color_filter_options_image_rewrite_set)
    1:     shade_rewrite = property(_mupdf.pdf_color_filter_options_shade_rewrite_get, _mupdf.pdf_color_filter_options_shade_rewrite_set)
    1:     repeated_image_rewrite = property(_mupdf.pdf_color_filter_options_repeated_image_rewrite_get, _mupdf.pdf_color_filter_options_repeated_image_rewrite_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_color_filter_options_swiginit(self, _mupdf.new_pdf_color_filter_options())
    1:     __swig_destroy__ = _mupdf.delete_pdf_color_filter_options
       
       # Register pdf_color_filter_options in _mupdf:
    1: _mupdf.pdf_color_filter_options_swigregister(pdf_color_filter_options)
    2: class pdf_text_state(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     char_space = property(_mupdf.pdf_text_state_char_space_get, _mupdf.pdf_text_state_char_space_set)
    1:     word_space = property(_mupdf.pdf_text_state_word_space_get, _mupdf.pdf_text_state_word_space_set)
    1:     scale = property(_mupdf.pdf_text_state_scale_get, _mupdf.pdf_text_state_scale_set)
    1:     leading = property(_mupdf.pdf_text_state_leading_get, _mupdf.pdf_text_state_leading_set)
    1:     font = property(_mupdf.pdf_text_state_font_get, _mupdf.pdf_text_state_font_set)
    1:     fontname = property(_mupdf.pdf_text_state_fontname_get, _mupdf.pdf_text_state_fontname_set)
    1:     size = property(_mupdf.pdf_text_state_size_get, _mupdf.pdf_text_state_size_set)
    1:     render = property(_mupdf.pdf_text_state_render_get, _mupdf.pdf_text_state_render_set)
    1:     rise = property(_mupdf.pdf_text_state_rise_get, _mupdf.pdf_text_state_rise_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_text_state_swiginit(self, _mupdf.new_pdf_text_state())
    1:     __swig_destroy__ = _mupdf.delete_pdf_text_state
       
       # Register pdf_text_state in _mupdf:
    1: _mupdf.pdf_text_state_swigregister(pdf_text_state)
    2: class pdf_text_object_state(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     text = property(_mupdf.pdf_text_object_state_text_get, _mupdf.pdf_text_object_state_text_set)
    1:     text_bbox = property(_mupdf.pdf_text_object_state_text_bbox_get, _mupdf.pdf_text_object_state_text_bbox_set)
    1:     tlm = property(_mupdf.pdf_text_object_state_tlm_get, _mupdf.pdf_text_object_state_tlm_set)
    1:     tm = property(_mupdf.pdf_text_object_state_tm_get, _mupdf.pdf_text_object_state_tm_set)
    1:     text_mode = property(_mupdf.pdf_text_object_state_text_mode_get, _mupdf.pdf_text_object_state_text_mode_set)
    1:     cid = property(_mupdf.pdf_text_object_state_cid_get, _mupdf.pdf_text_object_state_cid_set)
    1:     gid = property(_mupdf.pdf_text_object_state_gid_get, _mupdf.pdf_text_object_state_gid_set)
    1:     char_bbox = property(_mupdf.pdf_text_object_state_char_bbox_get, _mupdf.pdf_text_object_state_char_bbox_set)
    1:     fontdesc = property(_mupdf.pdf_text_object_state_fontdesc_get, _mupdf.pdf_text_object_state_fontdesc_set)
    1:     char_tx = property(_mupdf.pdf_text_object_state_char_tx_get, _mupdf.pdf_text_object_state_char_tx_set)
    1:     char_ty = property(_mupdf.pdf_text_object_state_char_ty_get, _mupdf.pdf_text_object_state_char_ty_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_text_object_state_swiginit(self, _mupdf.new_pdf_text_object_state())
    1:     __swig_destroy__ = _mupdf.delete_pdf_text_object_state
       
       # Register pdf_text_object_state in _mupdf:
    1: _mupdf.pdf_text_object_state_swigregister(pdf_text_object_state)
    1: PDF_REDACT_IMAGE_NONE = _mupdf.PDF_REDACT_IMAGE_NONE
    1: PDF_REDACT_IMAGE_REMOVE = _mupdf.PDF_REDACT_IMAGE_REMOVE
    1: PDF_REDACT_IMAGE_PIXELS = _mupdf.PDF_REDACT_IMAGE_PIXELS
    1: PDF_REDACT_IMAGE_REMOVE_UNLESS_INVISIBLE = _mupdf.PDF_REDACT_IMAGE_REMOVE_UNLESS_INVISIBLE
    1: PDF_REDACT_LINE_ART_NONE = _mupdf.PDF_REDACT_LINE_ART_NONE
    1: PDF_REDACT_LINE_ART_REMOVE_IF_COVERED = _mupdf.PDF_REDACT_LINE_ART_REMOVE_IF_COVERED
    1: PDF_REDACT_LINE_ART_REMOVE_IF_TOUCHED = _mupdf.PDF_REDACT_LINE_ART_REMOVE_IF_TOUCHED
    1: PDF_REDACT_TEXT_REMOVE = _mupdf.PDF_REDACT_TEXT_REMOVE
    1: PDF_REDACT_TEXT_NONE = _mupdf.PDF_REDACT_TEXT_NONE
    2: class pdf_redact_options(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     black_boxes = property(_mupdf.pdf_redact_options_black_boxes_get, _mupdf.pdf_redact_options_black_boxes_set)
    1:     image_method = property(_mupdf.pdf_redact_options_image_method_get, _mupdf.pdf_redact_options_image_method_set)
    1:     line_art = property(_mupdf.pdf_redact_options_line_art_get, _mupdf.pdf_redact_options_line_art_set)
    1:     text = property(_mupdf.pdf_redact_options_text_get, _mupdf.pdf_redact_options_text_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_redact_options_swiginit(self, _mupdf.new_pdf_redact_options())
    1:     __swig_destroy__ = _mupdf.delete_pdf_redact_options
       
       # Register pdf_redact_options in _mupdf:
    1: _mupdf.pdf_redact_options_swigregister(pdf_redact_options)
    2: class pdf_page(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     super = property(_mupdf.pdf_page_super_get, _mupdf.pdf_page_super_set)
    1:     doc = property(_mupdf.pdf_page_doc_get, _mupdf.pdf_page_doc_set)
    1:     obj = property(_mupdf.pdf_page_obj_get, _mupdf.pdf_page_obj_set)
    1:     transparency = property(_mupdf.pdf_page_transparency_get, _mupdf.pdf_page_transparency_set)
    1:     overprint = property(_mupdf.pdf_page_overprint_get, _mupdf.pdf_page_overprint_set)
    1:     links = property(_mupdf.pdf_page_links_get, _mupdf.pdf_page_links_set)
    1:     annots = property(_mupdf.pdf_page_annots_get, _mupdf.pdf_page_annots_set)
    1:     annot_tailp = property(_mupdf.pdf_page_annot_tailp_get, _mupdf.pdf_page_annot_tailp_set)
    1:     widgets = property(_mupdf.pdf_page_widgets_get, _mupdf.pdf_page_widgets_set)
    1:     widget_tailp = property(_mupdf.pdf_page_widget_tailp_get, _mupdf.pdf_page_widget_tailp_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_page_swiginit(self, _mupdf.new_pdf_page())
    1:     __swig_destroy__ = _mupdf.delete_pdf_page
       
       # Register pdf_page in _mupdf:
    1: _mupdf.pdf_page_swigregister(pdf_page)
    1: PDF_ANNOT_TEXT = _mupdf.PDF_ANNOT_TEXT
    1: PDF_ANNOT_LINK = _mupdf.PDF_ANNOT_LINK
    1: PDF_ANNOT_FREE_TEXT = _mupdf.PDF_ANNOT_FREE_TEXT
    1: PDF_ANNOT_LINE = _mupdf.PDF_ANNOT_LINE
    1: PDF_ANNOT_SQUARE = _mupdf.PDF_ANNOT_SQUARE
    1: PDF_ANNOT_CIRCLE = _mupdf.PDF_ANNOT_CIRCLE
    1: PDF_ANNOT_POLYGON = _mupdf.PDF_ANNOT_POLYGON
    1: PDF_ANNOT_POLY_LINE = _mupdf.PDF_ANNOT_POLY_LINE
    1: PDF_ANNOT_HIGHLIGHT = _mupdf.PDF_ANNOT_HIGHLIGHT
    1: PDF_ANNOT_UNDERLINE = _mupdf.PDF_ANNOT_UNDERLINE
    1: PDF_ANNOT_SQUIGGLY = _mupdf.PDF_ANNOT_SQUIGGLY
    1: PDF_ANNOT_STRIKE_OUT = _mupdf.PDF_ANNOT_STRIKE_OUT
    1: PDF_ANNOT_REDACT = _mupdf.PDF_ANNOT_REDACT
    1: PDF_ANNOT_STAMP = _mupdf.PDF_ANNOT_STAMP
    1: PDF_ANNOT_CARET = _mupdf.PDF_ANNOT_CARET
    1: PDF_ANNOT_INK = _mupdf.PDF_ANNOT_INK
    1: PDF_ANNOT_POPUP = _mupdf.PDF_ANNOT_POPUP
    1: PDF_ANNOT_FILE_ATTACHMENT = _mupdf.PDF_ANNOT_FILE_ATTACHMENT
    1: PDF_ANNOT_SOUND = _mupdf.PDF_ANNOT_SOUND
    1: PDF_ANNOT_MOVIE = _mupdf.PDF_ANNOT_MOVIE
    1: PDF_ANNOT_RICH_MEDIA = _mupdf.PDF_ANNOT_RICH_MEDIA
    1: PDF_ANNOT_WIDGET = _mupdf.PDF_ANNOT_WIDGET
    1: PDF_ANNOT_SCREEN = _mupdf.PDF_ANNOT_SCREEN
    1: PDF_ANNOT_PRINTER_MARK = _mupdf.PDF_ANNOT_PRINTER_MARK
    1: PDF_ANNOT_TRAP_NET = _mupdf.PDF_ANNOT_TRAP_NET
    1: PDF_ANNOT_WATERMARK = _mupdf.PDF_ANNOT_WATERMARK
    1: PDF_ANNOT_3D = _mupdf.PDF_ANNOT_3D
    1: PDF_ANNOT_PROJECTION = _mupdf.PDF_ANNOT_PROJECTION
    1: PDF_ANNOT_UNKNOWN = _mupdf.PDF_ANNOT_UNKNOWN
    1: PDF_ANNOT_IS_INVISIBLE = _mupdf.PDF_ANNOT_IS_INVISIBLE
    1: PDF_ANNOT_IS_HIDDEN = _mupdf.PDF_ANNOT_IS_HIDDEN
    1: PDF_ANNOT_IS_PRINT = _mupdf.PDF_ANNOT_IS_PRINT
    1: PDF_ANNOT_IS_NO_ZOOM = _mupdf.PDF_ANNOT_IS_NO_ZOOM
    1: PDF_ANNOT_IS_NO_ROTATE = _mupdf.PDF_ANNOT_IS_NO_ROTATE
    1: PDF_ANNOT_IS_NO_VIEW = _mupdf.PDF_ANNOT_IS_NO_VIEW
    1: PDF_ANNOT_IS_READ_ONLY = _mupdf.PDF_ANNOT_IS_READ_ONLY
    1: PDF_ANNOT_IS_LOCKED = _mupdf.PDF_ANNOT_IS_LOCKED
    1: PDF_ANNOT_IS_TOGGLE_NO_VIEW = _mupdf.PDF_ANNOT_IS_TOGGLE_NO_VIEW
    1: PDF_ANNOT_IS_LOCKED_CONTENTS = _mupdf.PDF_ANNOT_IS_LOCKED_CONTENTS
    1: PDF_ANNOT_LE_NONE = _mupdf.PDF_ANNOT_LE_NONE
    1: PDF_ANNOT_LE_SQUARE = _mupdf.PDF_ANNOT_LE_SQUARE
    1: PDF_ANNOT_LE_CIRCLE = _mupdf.PDF_ANNOT_LE_CIRCLE
    1: PDF_ANNOT_LE_DIAMOND = _mupdf.PDF_ANNOT_LE_DIAMOND
    1: PDF_ANNOT_LE_OPEN_ARROW = _mupdf.PDF_ANNOT_LE_OPEN_ARROW
    1: PDF_ANNOT_LE_CLOSED_ARROW = _mupdf.PDF_ANNOT_LE_CLOSED_ARROW
    1: PDF_ANNOT_LE_BUTT = _mupdf.PDF_ANNOT_LE_BUTT
    1: PDF_ANNOT_LE_R_OPEN_ARROW = _mupdf.PDF_ANNOT_LE_R_OPEN_ARROW
    1: PDF_ANNOT_LE_R_CLOSED_ARROW = _mupdf.PDF_ANNOT_LE_R_CLOSED_ARROW
    1: PDF_ANNOT_LE_SLASH = _mupdf.PDF_ANNOT_LE_SLASH
    1: PDF_ANNOT_Q_LEFT = _mupdf.PDF_ANNOT_Q_LEFT
    1: PDF_ANNOT_Q_CENTER = _mupdf.PDF_ANNOT_Q_CENTER
    1: PDF_ANNOT_Q_RIGHT = _mupdf.PDF_ANNOT_Q_RIGHT
    1: PDF_ANNOT_IT_DEFAULT = _mupdf.PDF_ANNOT_IT_DEFAULT
    1: PDF_ANNOT_IT_FREETEXT_CALLOUT = _mupdf.PDF_ANNOT_IT_FREETEXT_CALLOUT
    1: PDF_ANNOT_IT_FREETEXT_TYPEWRITER = _mupdf.PDF_ANNOT_IT_FREETEXT_TYPEWRITER
    1: PDF_ANNOT_IT_LINE_ARROW = _mupdf.PDF_ANNOT_IT_LINE_ARROW
    1: PDF_ANNOT_IT_LINE_DIMENSION = _mupdf.PDF_ANNOT_IT_LINE_DIMENSION
    1: PDF_ANNOT_IT_POLYLINE_DIMENSION = _mupdf.PDF_ANNOT_IT_POLYLINE_DIMENSION
    1: PDF_ANNOT_IT_POLYGON_CLOUD = _mupdf.PDF_ANNOT_IT_POLYGON_CLOUD
    1: PDF_ANNOT_IT_POLYGON_DIMENSION = _mupdf.PDF_ANNOT_IT_POLYGON_DIMENSION
    1: PDF_ANNOT_IT_STAMP_IMAGE = _mupdf.PDF_ANNOT_IT_STAMP_IMAGE
    1: PDF_ANNOT_IT_STAMP_SNAPSHOT = _mupdf.PDF_ANNOT_IT_STAMP_SNAPSHOT
    1: PDF_ANNOT_IT_UNKNOWN = _mupdf.PDF_ANNOT_IT_UNKNOWN
    1: PDF_BORDER_STYLE_SOLID = _mupdf.PDF_BORDER_STYLE_SOLID
    1: PDF_BORDER_STYLE_DASHED = _mupdf.PDF_BORDER_STYLE_DASHED
    1: PDF_BORDER_STYLE_BEVELED = _mupdf.PDF_BORDER_STYLE_BEVELED
    1: PDF_BORDER_STYLE_INSET = _mupdf.PDF_BORDER_STYLE_INSET
    1: PDF_BORDER_STYLE_UNDERLINE = _mupdf.PDF_BORDER_STYLE_UNDERLINE
    1: PDF_BORDER_EFFECT_NONE = _mupdf.PDF_BORDER_EFFECT_NONE
    1: PDF_BORDER_EFFECT_CLOUDY = _mupdf.PDF_BORDER_EFFECT_CLOUDY
    2: class pdf_filespec_params(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     filename = property(_mupdf.pdf_filespec_params_filename_get, _mupdf.pdf_filespec_params_filename_set)
    1:     mimetype = property(_mupdf.pdf_filespec_params_mimetype_get, _mupdf.pdf_filespec_params_mimetype_set)
    1:     size = property(_mupdf.pdf_filespec_params_size_get, _mupdf.pdf_filespec_params_size_set)
    1:     created = property(_mupdf.pdf_filespec_params_created_get, _mupdf.pdf_filespec_params_created_set)
    1:     modified = property(_mupdf.pdf_filespec_params_modified_get, _mupdf.pdf_filespec_params_modified_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_filespec_params_swiginit(self, _mupdf.new_pdf_filespec_params())
    1:     __swig_destroy__ = _mupdf.delete_pdf_filespec_params
       
       # Register pdf_filespec_params in _mupdf:
    1: _mupdf.pdf_filespec_params_swigregister(pdf_filespec_params)
    1: PDF_WIDGET_TYPE_UNKNOWN = _mupdf.PDF_WIDGET_TYPE_UNKNOWN
    1: PDF_WIDGET_TYPE_BUTTON = _mupdf.PDF_WIDGET_TYPE_BUTTON
    1: PDF_WIDGET_TYPE_CHECKBOX = _mupdf.PDF_WIDGET_TYPE_CHECKBOX
    1: PDF_WIDGET_TYPE_COMBOBOX = _mupdf.PDF_WIDGET_TYPE_COMBOBOX
    1: PDF_WIDGET_TYPE_LISTBOX = _mupdf.PDF_WIDGET_TYPE_LISTBOX
    1: PDF_WIDGET_TYPE_RADIOBUTTON = _mupdf.PDF_WIDGET_TYPE_RADIOBUTTON
    1: PDF_WIDGET_TYPE_SIGNATURE = _mupdf.PDF_WIDGET_TYPE_SIGNATURE
    1: PDF_WIDGET_TYPE_TEXT = _mupdf.PDF_WIDGET_TYPE_TEXT
    1: PDF_WIDGET_TX_FORMAT_NONE = _mupdf.PDF_WIDGET_TX_FORMAT_NONE
    1: PDF_WIDGET_TX_FORMAT_NUMBER = _mupdf.PDF_WIDGET_TX_FORMAT_NUMBER
    1: PDF_WIDGET_TX_FORMAT_SPECIAL = _mupdf.PDF_WIDGET_TX_FORMAT_SPECIAL
    1: PDF_WIDGET_TX_FORMAT_DATE = _mupdf.PDF_WIDGET_TX_FORMAT_DATE
    1: PDF_WIDGET_TX_FORMAT_TIME = _mupdf.PDF_WIDGET_TX_FORMAT_TIME
    1: PDF_FIELD_IS_READ_ONLY = _mupdf.PDF_FIELD_IS_READ_ONLY
    1: PDF_FIELD_IS_REQUIRED = _mupdf.PDF_FIELD_IS_REQUIRED
    1: PDF_FIELD_IS_NO_EXPORT = _mupdf.PDF_FIELD_IS_NO_EXPORT
    1: PDF_TX_FIELD_IS_MULTILINE = _mupdf.PDF_TX_FIELD_IS_MULTILINE
    1: PDF_TX_FIELD_IS_PASSWORD = _mupdf.PDF_TX_FIELD_IS_PASSWORD
    1: PDF_TX_FIELD_IS_FILE_SELECT = _mupdf.PDF_TX_FIELD_IS_FILE_SELECT
    1: PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK = _mupdf.PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK
    1: PDF_TX_FIELD_IS_DO_NOT_SCROLL = _mupdf.PDF_TX_FIELD_IS_DO_NOT_SCROLL
    1: PDF_TX_FIELD_IS_COMB = _mupdf.PDF_TX_FIELD_IS_COMB
    1: PDF_TX_FIELD_IS_RICH_TEXT = _mupdf.PDF_TX_FIELD_IS_RICH_TEXT
    1: PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF = _mupdf.PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF
    1: PDF_BTN_FIELD_IS_RADIO = _mupdf.PDF_BTN_FIELD_IS_RADIO
    1: PDF_BTN_FIELD_IS_PUSHBUTTON = _mupdf.PDF_BTN_FIELD_IS_PUSHBUTTON
    1: PDF_BTN_FIELD_IS_RADIOS_IN_UNISON = _mupdf.PDF_BTN_FIELD_IS_RADIOS_IN_UNISON
    1: PDF_CH_FIELD_IS_COMBO = _mupdf.PDF_CH_FIELD_IS_COMBO
    1: PDF_CH_FIELD_IS_EDIT = _mupdf.PDF_CH_FIELD_IS_EDIT
    1: PDF_CH_FIELD_IS_SORT = _mupdf.PDF_CH_FIELD_IS_SORT
    1: PDF_CH_FIELD_IS_MULTI_SELECT = _mupdf.PDF_CH_FIELD_IS_MULTI_SELECT
    1: PDF_CH_FIELD_IS_DO_NOT_SPELL_CHECK = _mupdf.PDF_CH_FIELD_IS_DO_NOT_SPELL_CHECK
    1: PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE = _mupdf.PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE
    2: class pdf_pkcs7_distinguished_name(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     cn = property(_mupdf.pdf_pkcs7_distinguished_name_cn_get, _mupdf.pdf_pkcs7_distinguished_name_cn_set)
    1:     o = property(_mupdf.pdf_pkcs7_distinguished_name_o_get, _mupdf.pdf_pkcs7_distinguished_name_o_set)
    1:     ou = property(_mupdf.pdf_pkcs7_distinguished_name_ou_get, _mupdf.pdf_pkcs7_distinguished_name_ou_set)
    1:     email = property(_mupdf.pdf_pkcs7_distinguished_name_email_get, _mupdf.pdf_pkcs7_distinguished_name_email_set)
    1:     c = property(_mupdf.pdf_pkcs7_distinguished_name_c_get, _mupdf.pdf_pkcs7_distinguished_name_c_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_pkcs7_distinguished_name_swiginit(self, _mupdf.new_pdf_pkcs7_distinguished_name())
    1:     __swig_destroy__ = _mupdf.delete_pdf_pkcs7_distinguished_name
       
       # Register pdf_pkcs7_distinguished_name in _mupdf:
    1: _mupdf.pdf_pkcs7_distinguished_name_swigregister(pdf_pkcs7_distinguished_name)
    1: PDF_SIGNATURE_ERROR_OKAY = _mupdf.PDF_SIGNATURE_ERROR_OKAY
    1: PDF_SIGNATURE_ERROR_NO_SIGNATURES = _mupdf.PDF_SIGNATURE_ERROR_NO_SIGNATURES
    1: PDF_SIGNATURE_ERROR_NO_CERTIFICATE = _mupdf.PDF_SIGNATURE_ERROR_NO_CERTIFICATE
    1: PDF_SIGNATURE_ERROR_DIGEST_FAILURE = _mupdf.PDF_SIGNATURE_ERROR_DIGEST_FAILURE
    1: PDF_SIGNATURE_ERROR_SELF_SIGNED = _mupdf.PDF_SIGNATURE_ERROR_SELF_SIGNED
    1: PDF_SIGNATURE_ERROR_SELF_SIGNED_IN_CHAIN = _mupdf.PDF_SIGNATURE_ERROR_SELF_SIGNED_IN_CHAIN
    1: PDF_SIGNATURE_ERROR_NOT_TRUSTED = _mupdf.PDF_SIGNATURE_ERROR_NOT_TRUSTED
    1: PDF_SIGNATURE_ERROR_NOT_SIGNED = _mupdf.PDF_SIGNATURE_ERROR_NOT_SIGNED
    1: PDF_SIGNATURE_ERROR_UNKNOWN = _mupdf.PDF_SIGNATURE_ERROR_UNKNOWN
    2: class pdf_pkcs7_signer(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     keep = property(_mupdf.pdf_pkcs7_signer_keep_get, _mupdf.pdf_pkcs7_signer_keep_set)
    1:     drop = property(_mupdf.pdf_pkcs7_signer_drop_get, _mupdf.pdf_pkcs7_signer_drop_set)
    1:     get_signing_name = property(_mupdf.pdf_pkcs7_signer_get_signing_name_get, _mupdf.pdf_pkcs7_signer_get_signing_name_set)
    1:     max_digest_size = property(_mupdf.pdf_pkcs7_signer_max_digest_size_get, _mupdf.pdf_pkcs7_signer_max_digest_size_set)
    1:     create_digest = property(_mupdf.pdf_pkcs7_signer_create_digest_get, _mupdf.pdf_pkcs7_signer_create_digest_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_pkcs7_signer_swiginit(self, _mupdf.new_pdf_pkcs7_signer())
    1:     __swig_destroy__ = _mupdf.delete_pdf_pkcs7_signer
       
       # Register pdf_pkcs7_signer in _mupdf:
    1: _mupdf.pdf_pkcs7_signer_swigregister(pdf_pkcs7_signer)
    2: class pdf_pkcs7_verifier(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     drop = property(_mupdf.pdf_pkcs7_verifier_drop_get, _mupdf.pdf_pkcs7_verifier_drop_set)
    1:     check_certificate = property(_mupdf.pdf_pkcs7_verifier_check_certificate_get, _mupdf.pdf_pkcs7_verifier_check_certificate_set)
    1:     check_digest = property(_mupdf.pdf_pkcs7_verifier_check_digest_get, _mupdf.pdf_pkcs7_verifier_check_digest_set)
    1:     get_signatory = property(_mupdf.pdf_pkcs7_verifier_get_signatory_get, _mupdf.pdf_pkcs7_verifier_get_signatory_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_pkcs7_verifier_swiginit(self, _mupdf.new_pdf_pkcs7_verifier())
    1:     __swig_destroy__ = _mupdf.delete_pdf_pkcs7_verifier
       
       # Register pdf_pkcs7_verifier in _mupdf:
    1: _mupdf.pdf_pkcs7_verifier_swigregister(pdf_pkcs7_verifier)
    1: PDF_SIGNATURE_SHOW_LABELS = _mupdf.PDF_SIGNATURE_SHOW_LABELS
    1: PDF_SIGNATURE_SHOW_DN = _mupdf.PDF_SIGNATURE_SHOW_DN
    1: PDF_SIGNATURE_SHOW_DATE = _mupdf.PDF_SIGNATURE_SHOW_DATE
    1: PDF_SIGNATURE_SHOW_TEXT_NAME = _mupdf.PDF_SIGNATURE_SHOW_TEXT_NAME
    1: PDF_SIGNATURE_SHOW_GRAPHIC_NAME = _mupdf.PDF_SIGNATURE_SHOW_GRAPHIC_NAME
    1: PDF_SIGNATURE_SHOW_LOGO = _mupdf.PDF_SIGNATURE_SHOW_LOGO
    2: class pdf_keystroke_event(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     value = property(_mupdf.pdf_keystroke_event_value_get, _mupdf.pdf_keystroke_event_value_set)
    1:     change = property(_mupdf.pdf_keystroke_event_change_get, _mupdf.pdf_keystroke_event_change_set)
    1:     selStart = property(_mupdf.pdf_keystroke_event_selStart_get, _mupdf.pdf_keystroke_event_selStart_set)
    1:     selEnd = property(_mupdf.pdf_keystroke_event_selEnd_get, _mupdf.pdf_keystroke_event_selEnd_set)
    1:     willCommit = property(_mupdf.pdf_keystroke_event_willCommit_get, _mupdf.pdf_keystroke_event_willCommit_set)
    1:     newChange = property(_mupdf.pdf_keystroke_event_newChange_get, _mupdf.pdf_keystroke_event_newChange_set)
    1:     newValue = property(_mupdf.pdf_keystroke_event_newValue_get, _mupdf.pdf_keystroke_event_newValue_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_keystroke_event_swiginit(self, _mupdf.new_pdf_keystroke_event())
    1:     __swig_destroy__ = _mupdf.delete_pdf_keystroke_event
       
       # Register pdf_keystroke_event in _mupdf:
    1: _mupdf.pdf_keystroke_event_swigregister(pdf_keystroke_event)
    2: class pdf_doc_event(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     type = property(_mupdf.pdf_doc_event_type_get, _mupdf.pdf_doc_event_type_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_doc_event_swiginit(self, _mupdf.new_pdf_doc_event())
    1:     __swig_destroy__ = _mupdf.delete_pdf_doc_event
       
       # Register pdf_doc_event in _mupdf:
    1: _mupdf.pdf_doc_event_swigregister(pdf_doc_event)
    1: PDF_DOCUMENT_EVENT_ALERT = _mupdf.PDF_DOCUMENT_EVENT_ALERT
    1: PDF_DOCUMENT_EVENT_PRINT = _mupdf.PDF_DOCUMENT_EVENT_PRINT
    1: PDF_DOCUMENT_EVENT_LAUNCH_URL = _mupdf.PDF_DOCUMENT_EVENT_LAUNCH_URL
    1: PDF_DOCUMENT_EVENT_MAIL_DOC = _mupdf.PDF_DOCUMENT_EVENT_MAIL_DOC
    1: PDF_DOCUMENT_EVENT_SUBMIT = _mupdf.PDF_DOCUMENT_EVENT_SUBMIT
    1: PDF_DOCUMENT_EVENT_EXEC_MENU_ITEM = _mupdf.PDF_DOCUMENT_EVENT_EXEC_MENU_ITEM
    2: class pdf_alert_event(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     doc = property(_mupdf.pdf_alert_event_doc_get, _mupdf.pdf_alert_event_doc_set)
    1:     message = property(_mupdf.pdf_alert_event_message_get, _mupdf.pdf_alert_event_message_set)
    1:     icon_type = property(_mupdf.pdf_alert_event_icon_type_get, _mupdf.pdf_alert_event_icon_type_set)
    1:     button_group_type = property(_mupdf.pdf_alert_event_button_group_type_get, _mupdf.pdf_alert_event_button_group_type_set)
    1:     title = property(_mupdf.pdf_alert_event_title_get, _mupdf.pdf_alert_event_title_set)
    1:     has_check_box = property(_mupdf.pdf_alert_event_has_check_box_get, _mupdf.pdf_alert_event_has_check_box_set)
    1:     check_box_message = property(_mupdf.pdf_alert_event_check_box_message_get, _mupdf.pdf_alert_event_check_box_message_set)
    1:     initially_checked = property(_mupdf.pdf_alert_event_initially_checked_get, _mupdf.pdf_alert_event_initially_checked_set)
    1:     finally_checked = property(_mupdf.pdf_alert_event_finally_checked_get, _mupdf.pdf_alert_event_finally_checked_set)
    1:     button_pressed = property(_mupdf.pdf_alert_event_button_pressed_get, _mupdf.pdf_alert_event_button_pressed_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_alert_event_swiginit(self, _mupdf.new_pdf_alert_event())
    1:     __swig_destroy__ = _mupdf.delete_pdf_alert_event
       
       # Register pdf_alert_event in _mupdf:
    1: _mupdf.pdf_alert_event_swigregister(pdf_alert_event)
    1: PDF_ALERT_ICON_ERROR = _mupdf.PDF_ALERT_ICON_ERROR
    1: PDF_ALERT_ICON_WARNING = _mupdf.PDF_ALERT_ICON_WARNING
    1: PDF_ALERT_ICON_QUESTION = _mupdf.PDF_ALERT_ICON_QUESTION
    1: PDF_ALERT_ICON_STATUS = _mupdf.PDF_ALERT_ICON_STATUS
    1: PDF_ALERT_BUTTON_GROUP_OK = _mupdf.PDF_ALERT_BUTTON_GROUP_OK
    1: PDF_ALERT_BUTTON_GROUP_OK_CANCEL = _mupdf.PDF_ALERT_BUTTON_GROUP_OK_CANCEL
    1: PDF_ALERT_BUTTON_GROUP_YES_NO = _mupdf.PDF_ALERT_BUTTON_GROUP_YES_NO
    1: PDF_ALERT_BUTTON_GROUP_YES_NO_CANCEL = _mupdf.PDF_ALERT_BUTTON_GROUP_YES_NO_CANCEL
    1: PDF_ALERT_BUTTON_NONE = _mupdf.PDF_ALERT_BUTTON_NONE
    1: PDF_ALERT_BUTTON_OK = _mupdf.PDF_ALERT_BUTTON_OK
    1: PDF_ALERT_BUTTON_CANCEL = _mupdf.PDF_ALERT_BUTTON_CANCEL
    1: PDF_ALERT_BUTTON_NO = _mupdf.PDF_ALERT_BUTTON_NO
    1: PDF_ALERT_BUTTON_YES = _mupdf.PDF_ALERT_BUTTON_YES
    2: class pdf_launch_url_event(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     url = property(_mupdf.pdf_launch_url_event_url_get, _mupdf.pdf_launch_url_event_url_set)
    1:     new_frame = property(_mupdf.pdf_launch_url_event_new_frame_get, _mupdf.pdf_launch_url_event_new_frame_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_launch_url_event_swiginit(self, _mupdf.new_pdf_launch_url_event())
    1:     __swig_destroy__ = _mupdf.delete_pdf_launch_url_event
       
       # Register pdf_launch_url_event in _mupdf:
    1: _mupdf.pdf_launch_url_event_swigregister(pdf_launch_url_event)
    2: class pdf_mail_doc_event(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     ask_user = property(_mupdf.pdf_mail_doc_event_ask_user_get, _mupdf.pdf_mail_doc_event_ask_user_set)
    1:     to = property(_mupdf.pdf_mail_doc_event_to_get, _mupdf.pdf_mail_doc_event_to_set)
    1:     cc = property(_mupdf.pdf_mail_doc_event_cc_get, _mupdf.pdf_mail_doc_event_cc_set)
    1:     bcc = property(_mupdf.pdf_mail_doc_event_bcc_get, _mupdf.pdf_mail_doc_event_bcc_set)
    1:     subject = property(_mupdf.pdf_mail_doc_event_subject_get, _mupdf.pdf_mail_doc_event_subject_set)
    1:     message = property(_mupdf.pdf_mail_doc_event_message_get, _mupdf.pdf_mail_doc_event_message_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_mail_doc_event_swiginit(self, _mupdf.new_pdf_mail_doc_event())
    1:     __swig_destroy__ = _mupdf.delete_pdf_mail_doc_event
       
       # Register pdf_mail_doc_event in _mupdf:
    1: _mupdf.pdf_mail_doc_event_swigregister(pdf_mail_doc_event)
    1: FZ_SUBSAMPLE_AVERAGE = _mupdf.FZ_SUBSAMPLE_AVERAGE
    1: FZ_SUBSAMPLE_BICUBIC = _mupdf.FZ_SUBSAMPLE_BICUBIC
    1: FZ_RECOMPRESS_NEVER = _mupdf.FZ_RECOMPRESS_NEVER
    1: FZ_RECOMPRESS_SAME = _mupdf.FZ_RECOMPRESS_SAME
    1: FZ_RECOMPRESS_LOSSLESS = _mupdf.FZ_RECOMPRESS_LOSSLESS
    1: FZ_RECOMPRESS_JPEG = _mupdf.FZ_RECOMPRESS_JPEG
    1: FZ_RECOMPRESS_J2K = _mupdf.FZ_RECOMPRESS_J2K
    1: FZ_RECOMPRESS_FAX = _mupdf.FZ_RECOMPRESS_FAX
    2: class pdf_image_rewriter_options(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     color_lossless_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_method_set)
    1:     color_lossy_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_method_set)
    1:     color_lossless_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_threshold_set)
    1:     color_lossless_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_to_set)
    1:     color_lossy_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_threshold_set)
    1:     color_lossy_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_to_set)
    1:     color_lossless_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_recompress_method_set)
    1:     color_lossy_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_recompress_method_set)
    1:     color_lossy_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_recompress_quality_set)
    1:     color_lossless_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_recompress_quality_set)
    1:     gray_lossless_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_method_set)
    1:     gray_lossy_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_method_set)
    1:     gray_lossless_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_threshold_set)
    1:     gray_lossless_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_to_set)
    1:     gray_lossy_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_threshold_set)
    1:     gray_lossy_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_to_set)
    1:     gray_lossless_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_recompress_method_set)
    1:     gray_lossy_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_recompress_method_set)
    1:     gray_lossy_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_recompress_quality_set)
    1:     gray_lossless_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_recompress_quality_set)
    1:     bitonal_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_bitonal_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_bitonal_image_subsample_method_set)
    1:     bitonal_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_bitonal_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_bitonal_image_subsample_threshold_set)
    1:     bitonal_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_bitonal_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_bitonal_image_subsample_to_set)
    1:     bitonal_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_bitonal_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_bitonal_image_recompress_method_set)
    1:     bitonal_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_bitonal_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_bitonal_image_recompress_quality_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_image_rewriter_options_swiginit(self, _mupdf.new_pdf_image_rewriter_options())
    1:     __swig_destroy__ = _mupdf.delete_pdf_image_rewriter_options
       
       # Register pdf_image_rewriter_options in _mupdf:
    1: _mupdf.pdf_image_rewriter_options_swigregister(pdf_image_rewriter_options)
    1: PDF_CLEAN_STRUCTURE_DROP = _mupdf.PDF_CLEAN_STRUCTURE_DROP
    1: PDF_CLEAN_STRUCTURE_KEEP = _mupdf.PDF_CLEAN_STRUCTURE_KEEP
    2: class pdf_clean_options(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     write = property(_mupdf.pdf_clean_options_write_get, _mupdf.pdf_clean_options_write_set)
    1:     image = property(_mupdf.pdf_clean_options_image_get, _mupdf.pdf_clean_options_image_set)
    1:     subset_fonts = property(_mupdf.pdf_clean_options_subset_fonts_get, _mupdf.pdf_clean_options_subset_fonts_set)
    1:     structure = property(_mupdf.pdf_clean_options_structure_get, _mupdf.pdf_clean_options_structure_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_clean_options_swiginit(self, _mupdf.new_pdf_clean_options())
    1:     __swig_destroy__ = _mupdf.delete_pdf_clean_options
       
       # Register pdf_clean_options in _mupdf:
    1: _mupdf.pdf_clean_options_swigregister(pdf_clean_options)
    2: class pdf_recolor_options(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     num_comp = property(_mupdf.pdf_recolor_options_num_comp_get, _mupdf.pdf_recolor_options_num_comp_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.pdf_recolor_options_swiginit(self, _mupdf.new_pdf_recolor_options())
    1:     __swig_destroy__ = _mupdf.delete_pdf_recolor_options
       
       # Register pdf_recolor_options in _mupdf:
    1: _mupdf.pdf_recolor_options_swigregister(pdf_recolor_options)
    1: PDF_NOT_ZUGFERD = _mupdf.PDF_NOT_ZUGFERD
    1: PDF_ZUGFERD_COMFORT = _mupdf.PDF_ZUGFERD_COMFORT
    1: PDF_ZUGFERD_BASIC = _mupdf.PDF_ZUGFERD_BASIC
    1: PDF_ZUGFERD_EXTENDED = _mupdf.PDF_ZUGFERD_EXTENDED
    1: PDF_ZUGFERD_BASIC_WL = _mupdf.PDF_ZUGFERD_BASIC_WL
    1: PDF_ZUGFERD_MINIMUM = _mupdf.PDF_ZUGFERD_MINIMUM
    1: PDF_ZUGFERD_XRECHNUNG = _mupdf.PDF_ZUGFERD_XRECHNUNG
    1: PDF_ZUGFERD_UNKNOWN = _mupdf.PDF_ZUGFERD_UNKNOWN
    2: class fz_search_page2_hit(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     quad = property(_mupdf.fz_search_page2_hit_quad_get, _mupdf.fz_search_page2_hit_quad_set)
    1:     mark = property(_mupdf.fz_search_page2_hit_mark_get, _mupdf.fz_search_page2_hit_mark_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_search_page2_hit_swiginit(self, _mupdf.new_fz_search_page2_hit())
    1:     __swig_destroy__ = _mupdf.delete_fz_search_page2_hit
       
       # Register fz_search_page2_hit in _mupdf:
    1: _mupdf.fz_search_page2_hit_swigregister(fz_search_page2_hit)
    2: class fz_install_load_system_font_funcs_args(object):
    1:     r"""
           Extra struct containing fz_install_load_system_font_funcs()'s args,
           which we wrap with virtual_fnptrs set to allow use from Python/C# via
           Swig Directors.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     f = property(_mupdf.fz_install_load_system_font_funcs_args_f_get, _mupdf.fz_install_load_system_font_funcs_args_f_set)
    1:     f_cjk = property(_mupdf.fz_install_load_system_font_funcs_args_f_cjk_get, _mupdf.fz_install_load_system_font_funcs_args_f_cjk_set)
    1:     f_fallback = property(_mupdf.fz_install_load_system_font_funcs_args_f_fallback_get, _mupdf.fz_install_load_system_font_funcs_args_f_fallback_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_install_load_system_font_funcs_args_swiginit(self, _mupdf.new_fz_install_load_system_font_funcs_args())
    1:     __swig_destroy__ = _mupdf.delete_fz_install_load_system_font_funcs_args
       
       # Register fz_install_load_system_font_funcs_args in _mupdf:
    1: _mupdf.fz_install_load_system_font_funcs_args_swigregister(fz_install_load_system_font_funcs_args)
    2: class fz_font_ucs_gid(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     ucs = property(_mupdf.fz_font_ucs_gid_ucs_get, _mupdf.fz_font_ucs_gid_ucs_set)
    1:     gid = property(_mupdf.fz_font_ucs_gid_gid_get, _mupdf.fz_font_ucs_gid_gid_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_font_ucs_gid_swiginit(self, _mupdf.new_fz_font_ucs_gid())
    1:     __swig_destroy__ = _mupdf.delete_fz_font_ucs_gid
       
       # Register fz_font_ucs_gid in _mupdf:
    1: _mupdf.fz_font_ucs_gid_swigregister(fz_font_ucs_gid)
       
    1: def ll_fz_aa_level():
           r"""
           Low-level wrapper for `::fz_aa_level()`.
           Get the number of bits of antialiasing we are
           using (for graphics). Between 0 and 8.
           """
>>>>>>     return _mupdf.ll_fz_aa_level()
       
    1: def ll_fz_abs(f):
           r"""
           Low-level wrapper for `::fz_abs()`.
           Some standard math functions, done as static inlines for speed.
           People with compilers that do not adequately implement inline
           may like to reimplement these using macros.
           """
>>>>>>     return _mupdf.ll_fz_abs(f)
       
    1: def ll_fz_absi(i):
           r"""Low-level wrapper for `::fz_absi()`."""
>>>>>>     return _mupdf.ll_fz_absi(i)
       
    1: def ll_fz_add_layout_char(block, x, w, p):
           r"""
           Low-level wrapper for `::fz_add_layout_char()`.
           Add a new char to the line at the end of the layout block.
           """
>>>>>>     return _mupdf.ll_fz_add_layout_char(block, x, w, p)
       
    1: def ll_fz_add_layout_line(block, x, y, h, p):
           r"""
           Low-level wrapper for `::fz_add_layout_line()`.
           Add a new line to the end of the layout block.
           """
>>>>>>     return _mupdf.ll_fz_add_layout_line(block, x, y, h, p)
       
    1: def ll_fz_add_separation(sep, name, cs, cs_channel):
           r"""
           Low-level wrapper for `::fz_add_separation()`.
           Add a separation (null terminated name, colorspace)
           """
>>>>>>     return _mupdf.ll_fz_add_separation(sep, name, cs, cs_channel)
       
    1: def ll_fz_add_separation_equivalents(sep, rgba, cmyk, name):
           r"""
           Low-level wrapper for `::fz_add_separation_equivalents()`.
           Add a separation with equivalents (null terminated name,
           colorspace)
       
           (old, deprecated)
           """
>>>>>>     return _mupdf.ll_fz_add_separation_equivalents(sep, rgba, cmyk, name)
       
    1: def ll_fz_adjust_rect_for_stroke(rect, stroke, ctm):
           r"""
           Low-level wrapper for `::fz_adjust_rect_for_stroke()`.
           Given a rectangle (assumed to be the bounding box for a path),
           expand it to allow for the expansion of the bbox that would be
           seen by stroking the path with the given stroke state and
           transform.
           """
>>>>>>     return _mupdf.ll_fz_adjust_rect_for_stroke(rect, stroke, ctm)
       
    1: def ll_fz_advance_glyph(font, glyph, wmode):
           r"""
           Low-level wrapper for `::fz_advance_glyph()`.
           Return the advance for a given glyph.
       
           font: The font to look for the glyph in.
       
           glyph: The glyph to find the advance for.
       
           wmode: 1 for vertical mode, 0 for horizontal.
       
           Returns the advance for the glyph.
           """
>>>>>>     return _mupdf.ll_fz_advance_glyph(font, glyph, wmode)
       
    1: def ll_fz_aes_crypt_cbc(ctx, mode, length, iv, input, output):
           r"""
           Low-level wrapper for `::fz_aes_crypt_cbc()`.
           AES block processing. Encrypts or Decrypts (according to mode,
           which must match what was initially set up) length bytes (which
           must be a multiple of 16), using (and modifying) the insertion
           vector iv, reading from input, and writing to output.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_aes_crypt_cbc(ctx, mode, length, iv, input, output)
       
    1: def ll_fz_aes_setkey_dec(ctx, key, keysize):
           r"""
           Low-level wrapper for `::fz_aes_setkey_dec()`.
           AES decryption initialization. Fills in the supplied context
           and prepares for decryption using the given key.
       
           Returns non-zero for error (key size other than 128/192/256).
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_aes_setkey_dec(ctx, key, keysize)
       
    1: def ll_fz_aes_setkey_enc(ctx, key, keysize):
           r"""
           Low-level wrapper for `::fz_aes_setkey_enc()`.
           AES encryption initialization. Fills in the supplied context
           and prepares for encryption using the given key.
       
           Returns non-zero for error (key size other than 128/192/256).
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_aes_setkey_enc(ctx, key, keysize)
       
    1: def ll_fz_alpha_from_gray(gray):
           r"""Low-level wrapper for `::fz_alpha_from_gray()`."""
>>>>>>     return _mupdf.ll_fz_alpha_from_gray(gray)
       
    1: def ll_fz_append_base64(out, data, size, newline):
           r"""
           Low-level wrapper for `::fz_append_base64()`.
           Write a base64 encoded data block, optionally with periodic newlines.
           """
>>>>>>     return _mupdf.ll_fz_append_base64(out, data, size, newline)
       
    1: def ll_fz_append_base64_buffer(out, data, newline):
           r"""
           Low-level wrapper for `::fz_append_base64_buffer()`.
           Append a base64 encoded fz_buffer, optionally with periodic newlines.
           """
>>>>>>     return _mupdf.ll_fz_append_base64_buffer(out, data, newline)
       
    1: def ll_fz_append_bits(buf, value, count):
           r"""Low-level wrapper for `::fz_append_bits()`."""
>>>>>>     return _mupdf.ll_fz_append_bits(buf, value, count)
       
    1: def ll_fz_append_bits_pad(buf):
           r"""Low-level wrapper for `::fz_append_bits_pad()`."""
>>>>>>     return _mupdf.ll_fz_append_bits_pad(buf)
       
    1: def ll_fz_append_buffer(destination, source):
           r"""
           Low-level wrapper for `::fz_append_buffer()`.
           Append the contents of the source buffer onto the end of the
           destination buffer, extending automatically as required.
       
           Ownership of buffers does not change.
           """
>>>>>>     return _mupdf.ll_fz_append_buffer(destination, source)
       
    1: def ll_fz_append_byte(buf, c):
           r"""Low-level wrapper for `::fz_append_byte()`."""
>>>>>>     return _mupdf.ll_fz_append_byte(buf, c)
       
    1: def ll_fz_append_data(buf, data, len):
           r"""
           Low-level wrapper for `::fz_append_data()`.
           fz_append_*: Append data to a buffer.
       
           The buffer will automatically grow as required.
           """
>>>>>>     return _mupdf.ll_fz_append_data(buf, data, len)
       
    1: def ll_fz_append_image_as_data_uri(out, image):
           r"""Low-level wrapper for `::fz_append_image_as_data_uri()`."""
>>>>>>     return _mupdf.ll_fz_append_image_as_data_uri(out, image)
       
    1: def ll_fz_append_int16_be(buf, x):
           r"""Low-level wrapper for `::fz_append_int16_be()`."""
>>>>>>     return _mupdf.ll_fz_append_int16_be(buf, x)
       
    1: def ll_fz_append_int16_le(buf, x):
           r"""Low-level wrapper for `::fz_append_int16_le()`."""
>>>>>>     return _mupdf.ll_fz_append_int16_le(buf, x)
       
    1: def ll_fz_append_int32_be(buf, x):
           r"""Low-level wrapper for `::fz_append_int32_be()`."""
>>>>>>     return _mupdf.ll_fz_append_int32_be(buf, x)
       
    1: def ll_fz_append_int32_le(buf, x):
           r"""Low-level wrapper for `::fz_append_int32_le()`."""
>>>>>>     return _mupdf.ll_fz_append_int32_le(buf, x)
       
    1: def ll_fz_append_json(buf, value):
           r"""Low-level wrapper for `::fz_append_json()`."""
>>>>>>     return _mupdf.ll_fz_append_json(buf, value)
       
    1: def ll_fz_append_pdf_string(buffer, text):
           r"""
           Low-level wrapper for `::fz_append_pdf_string()`.
           fz_append_pdf_string: Append a string with PDF syntax quotes and
           escapes.
       
           The buffer will automatically grow as required.
           """
>>>>>>     return _mupdf.ll_fz_append_pdf_string(buffer, text)
       
    1: def ll_fz_append_pixmap_as_data_uri(out, pixmap):
           r"""Low-level wrapper for `::fz_append_pixmap_as_data_uri()`."""
>>>>>>     return _mupdf.ll_fz_append_pixmap_as_data_uri(out, pixmap)
       
    1: def ll_fz_append_rune(buf, c):
           r"""Low-level wrapper for `::fz_append_rune()`."""
>>>>>>     return _mupdf.ll_fz_append_rune(buf, c)
       
    1: def ll_fz_append_string(buf, data):
           r"""Low-level wrapper for `::fz_append_string()`."""
>>>>>>     return _mupdf.ll_fz_append_string(buf, data)
       
    1: def ll_fz_arc4_encrypt(state, dest, src, len):
           r"""
           Low-level wrapper for `::fz_arc4_encrypt()`.
           RC4 block encrypt operation; encrypt src into dst (both of
           length len) updating the RC4 state as we go.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_arc4_encrypt(state, dest, src, len)
       
    1: def ll_fz_arc4_final(state):
           r"""
           Low-level wrapper for `::fz_arc4_final()`.
           RC4 finalization. Zero the context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_arc4_final(state)
       
    1: def ll_fz_arc4_init(state, key, len):
           r"""
           Low-level wrapper for `::fz_arc4_init()`.
           RC4 initialization. Begins an RC4 operation, writing a new
           context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_arc4_init(state, key, len)
       
    1: def ll_fz_archive_format(arch):
           r"""
           Low-level wrapper for `::fz_archive_format()`.
           Return a pointer to a string describing the format of the
           archive.
       
           The lifetime of the string is unspecified (in current
           implementations the string will persist until the archive
           is closed, but this is not guaranteed).
           """
>>>>>>     return _mupdf.ll_fz_archive_format(arch)
       
    1: def ll_fz_atof(s):
           r"""
           Low-level wrapper for `::fz_atof()`.
           Range checking atof
           """
>>>>>>     return _mupdf.ll_fz_atof(s)
       
    1: def ll_fz_atoi(s):
           r"""
           Low-level wrapper for `::fz_atoi()`.
           atoi that copes with NULL
           """
>>>>>>     return _mupdf.ll_fz_atoi(s)
       
    1: def ll_fz_atoi64(s):
           r"""
           Low-level wrapper for `::fz_atoi64()`.
           64bit atoi that copes with NULL
           """
>>>>>>     return _mupdf.ll_fz_atoi64(s)
       
    1: def ll_fz_atoz(s):
           r"""
           Low-level wrapper for `::fz_atoz()`.
           size_t atoi that copes with NULL.
       
           NOTE: limited to 63bits. Negative numbers
           are returned as 0.
           """
>>>>>>     return _mupdf.ll_fz_atoz(s)
       
    1: def ll_fz_authenticate_password(doc, password):
           r"""
           Low-level wrapper for `::fz_authenticate_password()`.
           Test if the given password can decrypt the document.
       
           password: The password string to be checked. Some document
           specifications do not specify any particular text encoding, so
           neither do we.
       
           Returns 0 for failure to authenticate, non-zero for success.
       
           For PDF documents, further information can be given by examining
           the bits in the return code.
       
               Bit 0 => No password required
               Bit 1 => User password authenticated
               Bit 2 => Owner password authenticated
           """
>>>>>>     return _mupdf.ll_fz_authenticate_password(doc, password)
       
    1: def ll_fz_autowarp_pixmap(src, points):
           r"""Low-level wrapper for `::fz_autowarp_pixmap()`."""
>>>>>>     return _mupdf.ll_fz_autowarp_pixmap(src, points)
       
    1: def ll_fz_available(stm, max):
           r"""
           Low-level wrapper for `::fz_available()`.
           Ask how many bytes are available immediately from
           a given stream.
       
           stm: The stream to read from.
       
           max: A hint for the underlying stream; the maximum number of
           bytes that we are sure we will want to read. If you do not know
           this number, give 1.
       
           Returns the number of bytes immediately available between the
           read and write pointers. This number is guaranteed only to be 0
           if we have hit EOF. The number of bytes returned here need have
           no relation to max (could be larger, could be smaller).
           """
>>>>>>     return _mupdf.ll_fz_available(stm, max)
       
    1: def ll_fz_barcode_type_from_string(str):
           r"""
           Low-level wrapper for `::fz_barcode_type_from_string()`.
           Helper function to search the above list (case insensitively)
           for an exact match. Returns FZ_BARCODE_NONE if no match found.
           """
>>>>>>     return _mupdf.ll_fz_barcode_type_from_string(str)
       
    1: def ll_fz_base_colorspace(cs):
           r"""
           Low-level wrapper for `::fz_base_colorspace()`.
           Get the 'base' colorspace for a colorspace.
       
           For indexed colorspaces, this is the colorspace the index
           decodes into. For all other colorspaces, it is the colorspace
           itself.
       
           The returned colorspace is 'borrowed' (i.e. no additional
           references are taken or dropped).
           """
>>>>>>     return _mupdf.ll_fz_base_colorspace(cs)
       
    1: def ll_fz_basename(path):
           r"""
           Low-level wrapper for `::fz_basename()`.
           Find the filename component in a path.
           """
>>>>>>     return _mupdf.ll_fz_basename(path)
       
    1: def ll_fz_begin_group(dev, area, cs, isolated, knockout, blendmode, alpha):
           r"""Low-level wrapper for `::fz_begin_group()`."""
>>>>>>     return _mupdf.ll_fz_begin_group(dev, area, cs, isolated, knockout, blendmode, alpha)
       
    1: def ll_fz_begin_layer(dev, layer_name):
           r"""Low-level wrapper for `::fz_begin_layer()`."""
>>>>>>     return _mupdf.ll_fz_begin_layer(dev, layer_name)
       
    1: def ll_fz_begin_mask(dev, area, luminosity, colorspace, bc, color_params):
           r"""Low-level wrapper for `::fz_begin_mask()`."""
>>>>>>     return _mupdf.ll_fz_begin_mask(dev, area, luminosity, colorspace, bc, color_params)
       
    1: def ll_fz_begin_metatext(dev, meta, text):
           r"""Low-level wrapper for `::fz_begin_metatext()`."""
>>>>>>     return _mupdf.ll_fz_begin_metatext(dev, meta, text)
       
    1: def ll_fz_begin_page(wri, mediabox):
           r"""
           Low-level wrapper for `::fz_begin_page()`.
           Called to start the process of writing a page to
           a document.
       
           mediabox: page size rectangle in points.
       
           Returns a borrowed fz_device to write page contents to. This
           should be kept if required, and only dropped if it was kept.
           """
>>>>>>     return _mupdf.ll_fz_begin_page(wri, mediabox)
       
    1: def ll_fz_begin_structure(dev, standard, raw, idx):
           r"""Low-level wrapper for `::fz_begin_structure()`."""
>>>>>>     return _mupdf.ll_fz_begin_structure(dev, standard, raw, idx)
       
    1: def ll_fz_begin_tile(dev, area, view, xstep, ystep, ctm):
           r"""Low-level wrapper for `::fz_begin_tile()`."""
>>>>>>     return _mupdf.ll_fz_begin_tile(dev, area, view, xstep, ystep, ctm)
       
    1: def ll_fz_begin_tile_id(dev, area, view, xstep, ystep, ctm, id):
           r"""Low-level wrapper for `::fz_begin_tile_id()`."""
>>>>>>     return _mupdf.ll_fz_begin_tile_id(dev, area, view, xstep, ystep, ctm, id)
       
    1: def ll_fz_begin_tile_tid(dev, area, view, xstep, ystep, ctm, id, doc_id):
           r"""Low-level wrapper for `::fz_begin_tile_tid()`."""
>>>>>>     return _mupdf.ll_fz_begin_tile_tid(dev, area, view, xstep, ystep, ctm, id, doc_id)
       
    1: def ll_fz_bidi_fragment_text(text, textlen, baseDir, callback, arg, flags):
           r"""
            Low-level wrapper for `::fz_bidi_fragment_text()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_bidi_fragment_text(const uint32_t *text, size_t textlen, ::fz_bidi_fragment_fn *callback, void *arg, int flags)` => ::fz_bidi_direction baseDir
       
               Partitions the given Unicode sequence into one or more
               unidirectional fragments and invokes the given callback
               function for each fragment.
       
               For example, if directionality of text is:
                               0123456789
                               rrlllrrrrr,
               we'll invoke callback with:
                               &text[0], length == 2
                               &text[2], length == 3
                               &text[5], length == 5
       
               :type text: int, in
           :param text:        start of Unicode sequence
                       :type textlen: int, in
           :param textlen:   number of Unicodes to analyse
                       :type baseDir: int, in
           :param baseDir:   direction of paragraph (specify FZ_BIDI_NEUTRAL to force auto-detection)
                       :type callback: ::fz_bidi_fragment_fn, in
           :param callback:  function to be called for each fragment
                       :type arg: void, in
           :param arg: data to be passed to the callback function
                       :type flags: int, in
           :param flags:     flags to control operation (see fz_bidi_flags above)
           """
>>>>>>     return _mupdf.ll_fz_bidi_fragment_text(text, textlen, baseDir, callback, arg, flags)
       
    1: def ll_fz_bitmap_details(bitmap, w, h, n, stride):
           r"""
            Low-level wrapper for `::fz_bitmap_details()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_bitmap_details(::fz_bitmap *bitmap)` => `(int w, int h, int n, int stride)`
       
               Retrieve details of a given bitmap.
       
               bitmap: The bitmap to query.
       
               w: Pointer to storage to retrieve width (or NULL).
       
               h: Pointer to storage to retrieve height (or NULL).
       
               n: Pointer to storage to retrieve number of color components (or
               NULL).
       
               stride: Pointer to storage to retrieve bitmap stride (or NULL).
           """
>>>>>>     return _mupdf.ll_fz_bitmap_details(bitmap, w, h, n, stride)
       
    1: def ll_fz_blendmode_name(blendmode):
           r"""
           Low-level wrapper for `::fz_blendmode_name()`.
           Map from enumeration to blend mode string.
       
           The string is static, with arbitrary lifespan.
           """
>>>>>>     return _mupdf.ll_fz_blendmode_name(blendmode)
       
    1: def ll_fz_bound_display_list(list):
           r"""
           Low-level wrapper for `::fz_bound_display_list()`.
           Return the bounding box of the page recorded in a display list.
           """
>>>>>>     return _mupdf.ll_fz_bound_display_list(list)
       
    1: def ll_fz_bound_glyph(font, gid, trm):
           r"""
           Low-level wrapper for `::fz_bound_glyph()`.
           Return a bbox for a given glyph in a font.
       
           font: The font to look for the glyph in.
       
           gid: The glyph to bound.
       
           trm: The matrix to apply to the glyph before bounding.
       
           Returns rectangle by value containing the bounds of the given
           glyph.
           """
>>>>>>     return _mupdf.ll_fz_bound_glyph(font, gid, trm)
       
    1: def ll_fz_bound_page(page):
           r"""
           Low-level wrapper for `::fz_bound_page()`.
           Determine the size of a page at 72 dpi.
           """
>>>>>>     return _mupdf.ll_fz_bound_page(page)
       
    1: def ll_fz_bound_page_box(page, box):
           r"""Low-level wrapper for `::fz_bound_page_box()`."""
>>>>>>     return _mupdf.ll_fz_bound_page_box(page, box)
       
    1: def ll_fz_bound_path(path, stroke, ctm):
           r"""
           Low-level wrapper for `::fz_bound_path()`.
           Return a bounding rectangle for a path.
       
           path: The path to bound.
       
           stroke: If NULL, the bounding rectangle given is for
           the filled path. If non-NULL the bounding rectangle
           given is for the path stroked with the given attributes.
       
           ctm: The matrix to apply to the path during stroking.
       
           r: Pointer to a fz_rect which will be used to hold
           the result.
       
           Returns r, updated to contain the bounding rectangle.
           """
>>>>>>     return _mupdf.ll_fz_bound_path(path, stroke, ctm)
       
    1: def ll_fz_bound_shade(shade, ctm):
           r"""
           Low-level wrapper for `::fz_bound_shade()`.
           Bound a given shading.
       
           shade: The shade to bound.
       
           ctm: The transform to apply to the shade before bounding.
       
           r: Pointer to storage to put the bounds in.
       
           Returns r, updated to contain the bounds for the shading.
           """
>>>>>>     return _mupdf.ll_fz_bound_shade(shade, ctm)
       
    1: def ll_fz_bound_text(text, stroke, ctm):
           r"""
           Low-level wrapper for `::fz_bound_text()`.
           Find the bounds of a given text object.
       
           text: The text object to find the bounds of.
       
           stroke: Pointer to the stroke attributes (for stroked
           text), or NULL (for filled text).
       
           ctm: The matrix in use.
       
           r: pointer to storage for the bounds.
       
           Returns a pointer to r, which is updated to contain the
           bounding box for the text object.
           """
>>>>>>     return _mupdf.ll_fz_bound_text(text, stroke, ctm)
       
    1: def ll_fz_box_type_from_string(name):
           r"""Low-level wrapper for `::fz_box_type_from_string()`."""
>>>>>>     return _mupdf.ll_fz_box_type_from_string(name)
       
    1: def ll_fz_brotli_bound(size):
           r"""
           Low-level wrapper for `::fz_brotli_bound()`.
           Returns the upper bound on the
           size of brotli compressed data of length size.
           """
>>>>>>     return _mupdf.ll_fz_brotli_bound(size)
       
    1: def ll_fz_buffer_extract(buf, data):
           r"""
            Low-level wrapper for `::fz_buffer_extract()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_buffer_extract(::fz_buffer *buf)` => `(size_t, unsigned char *data)`
       
               Take ownership of buffer contents.
       
               Performs the same task as fz_buffer_storage, but ownership of
               the data buffer returns with this call. The buffer is left
               empty.
       
               Note: Bad things may happen if this is called on a buffer with
               multiple references that is being used from multiple threads.
       
               data: Pointer to place to retrieve data pointer.
       
               Returns length of stream.
           """
>>>>>>     return _mupdf.ll_fz_buffer_extract(buf, data)
       
    1: def ll_fz_buffer_storage(buf, datap):
           r"""
            Low-level wrapper for `::fz_buffer_storage()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_buffer_storage(::fz_buffer *buf)` => `(size_t, unsigned char *datap)`
       
               Retrieve internal memory of buffer.
       
               datap: Output parameter that will be pointed to the data.
       
               Returns the current size of the data in bytes.
           """
>>>>>>     return _mupdf.ll_fz_buffer_storage(buf, datap)
       
    1: def ll_fz_calculate_font_ascender_descender(font):
           r"""
           Low-level wrapper for `::fz_calculate_font_ascender_descender()`.
           Ensure that a font has its ascender/descender values calculated
           from the actual bbox of the glyphs.
       
           Note, that we combine the declared values from the font (or the
           default values if those are not present) with the actual bbox to
           get the final result. So this can only cause ascender/descender
           to move further apart!
           """
>>>>>>     return _mupdf.ll_fz_calculate_font_ascender_descender(font)
       
    1: def ll_fz_calloc(count, size):
           r"""
           Low-level wrapper for `::fz_calloc()`.
           Allocate array of memory of count entries of size bytes.
           Clears the memory to zero.
       
           Throws exception in the event of failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_calloc(count, size)
       
    1: def ll_fz_calloc_no_throw(count, size):
           r"""
           Low-level wrapper for `::fz_calloc_no_throw()`.
           fz_calloc equivalent that returns NULL rather than throwing
           exceptions.
           """
>>>>>>     return _mupdf.ll_fz_calloc_no_throw(count, size)
       
    1: def ll_fz_caught():
           r"""
           Low-level wrapper for `::fz_caught()`.
           Within an fz_catch() block, retrieve the error code for
           the current exception.
       
           This assumes no intervening use of fz_try/fz_catch.
           """
>>>>>>     return _mupdf.ll_fz_caught()
       
    1: def ll_fz_caught_errno():
           r"""Low-level wrapper for `::fz_caught_errno()`."""
>>>>>>     return _mupdf.ll_fz_caught_errno()
       
    1: def ll_fz_caught_message():
           r"""
           Low-level wrapper for `::fz_caught_message()`.
           Within an fz_catch() block, retrieve the formatted message
           string for the current exception.
       
           This assumes no intervening use of fz_try/fz_catch.
           """
>>>>>>     return _mupdf.ll_fz_caught_message()
       
    1: def ll_fz_chartorune(rune, str):
           r"""
            Low-level wrapper for `::fz_chartorune()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_chartorune(const char *str)` => `(int, int rune)`
       
               UTF8 decode a single rune from a sequence of chars.
       
               rune: Pointer to an int to assign the decoded 'rune' to.
               (0xFFFD on error).
       
               str: Pointer to a UTF8 encoded string.
       
               Returns the number of bytes consumed.
           """
>>>>>>     return _mupdf.ll_fz_chartorune(rune, str)
       
    1: def ll_fz_chartorunen(rune, str, n):
           r"""
            Low-level wrapper for `::fz_chartorunen()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_chartorunen(const char *str, size_t n)` => `(int, int rune)`
       
               UTF8 decode a single rune from a sequence of chars
               of given length.
       
               rune: Pointer to an int to assign the decoded 'rune' to.
               (0xFFFD on error).
       
               str: Pointer to a UTF8 encoded string.
       
               n: The number of bytes available at str.
       
               Returns the number of bytes consumed.
           """
>>>>>>     return _mupdf.ll_fz_chartorunen(rune, str, n)
       
    1: def ll_fz_clamp(x, min, max):
           r"""Low-level wrapper for `::fz_clamp()`."""
>>>>>>     return _mupdf.ll_fz_clamp(x, min, max)
       
    1: def ll_fz_clamp64(x, min, max):
           r"""Low-level wrapper for `::fz_clamp64()`."""
>>>>>>     return _mupdf.ll_fz_clamp64(x, min, max)
       
    1: def ll_fz_clamp_color(cs, _in, out):
           r"""
            Low-level wrapper for `::fz_clamp_color()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_clamp_color(::fz_colorspace *cs, const float *in)` => float out
       
               Clamp the samples in a color to the correct ranges for a
               given colorspace.
           """
>>>>>>     return _mupdf.ll_fz_clamp_color(cs, _in, out)
       
    1: def ll_fz_clamp_location(doc, loc):
           r"""
           Low-level wrapper for `::fz_clamp_location()`.
           Clamps a location into valid chapter/page range. (First clamps
           the chapter into range, then the page into range).
           """
>>>>>>     return _mupdf.ll_fz_clamp_location(doc, loc)
       
    1: def ll_fz_clampd(x, min, max):
           r"""Low-level wrapper for `::fz_clampd()`."""
>>>>>>     return _mupdf.ll_fz_clampd(x, min, max)
       
    1: def ll_fz_clampi(x, min, max):
           r"""Low-level wrapper for `::fz_clampi()`."""
>>>>>>     return _mupdf.ll_fz_clampi(x, min, max)
       
    1: def ll_fz_clampp(x, min, max):
           r"""Low-level wrapper for `::fz_clampp()`."""
>>>>>>     return _mupdf.ll_fz_clampp(x, min, max)
       
    1: def ll_fz_classify_stext_rect(page, classification, rect):
           r"""Low-level wrapper for `::fz_classify_stext_rect()`."""
>>>>>>     return _mupdf.ll_fz_classify_stext_rect(page, classification, rect)
       
    1: def ll_fz_cleanname(name):
           r"""
           Low-level wrapper for `::fz_cleanname()`.
           rewrite path to the shortest string that names the same path.
       
           Eliminates multiple and trailing slashes, interprets "." and
           "..". Overwrites the string in place.
           """
>>>>>>     return _mupdf.ll_fz_cleanname(name)
       
    1: def ll_fz_cleanname_strdup(name):
           r"""
           Low-level wrapper for `::fz_cleanname_strdup()`.
           rewrite path to the shortest string that names the same path.
       
           Eliminates multiple and trailing slashes, interprets "." and
           "..". Allocates a new string that the caller must free.
           """
>>>>>>     return _mupdf.ll_fz_cleanname_strdup(name)
       
    1: def ll_fz_clear_bitmap(bit):
           r"""
           Low-level wrapper for `::fz_clear_bitmap()`.
           Set the entire bitmap to 0.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_clear_bitmap(bit)
       
    1: def ll_fz_clear_buffer(buf):
           r"""
           Low-level wrapper for `::fz_clear_buffer()`.
           Empties the buffer. Storage is not freed, but is held ready
           to be reused as the buffer is refilled.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_clear_buffer(buf)
       
    1: def ll_fz_clear_pixmap(pix):
           r"""
           Low-level wrapper for `::fz_clear_pixmap()`.
           Sets all components (including alpha) of
           all pixels in a pixmap to 0.
       
           pix: The pixmap to clear.
           """
>>>>>>     return _mupdf.ll_fz_clear_pixmap(pix)
       
    1: def ll_fz_clear_pixmap_rect_with_value(pix, value, r):
           r"""
           Low-level wrapper for `::fz_clear_pixmap_rect_with_value()`.
           Clears a subrect of a pixmap with the given value.
       
           pix: The pixmap to clear.
       
           value: Values in the range 0 to 255 are valid. Each component
           sample for each pixel in the pixmap will be set to this value,
           while alpha will always be set to 255 (non-transparent).
       
           r: the rectangle.
           """
>>>>>>     return _mupdf.ll_fz_clear_pixmap_rect_with_value(pix, value, r)
       
    1: def ll_fz_clear_pixmap_with_value(pix, value):
           r"""
           Low-level wrapper for `::fz_clear_pixmap_with_value()`.
           Clears a pixmap with the given value.
       
           pix: The pixmap to clear.
       
           value: Values in the range 0 to 255 are valid. Each component
           sample for each pixel in the pixmap will be set to this value,
           while alpha will always be set to 255 (non-transparent).
       
           This function is horrible, and should be removed from the
           API and replaced with a less magic one.
           """
>>>>>>     return _mupdf.ll_fz_clear_pixmap_with_value(pix, value)
       
    1: def ll_fz_clip_image_mask(dev, image, ctm, scissor):
           r"""Low-level wrapper for `::fz_clip_image_mask()`."""
>>>>>>     return _mupdf.ll_fz_clip_image_mask(dev, image, ctm, scissor)
       
    1: def ll_fz_clip_path(dev, path, even_odd, ctm, scissor):
           r"""Low-level wrapper for `::fz_clip_path()`."""
>>>>>>     return _mupdf.ll_fz_clip_path(dev, path, even_odd, ctm, scissor)
       
    1: def ll_fz_clip_stroke_path(dev, path, stroke, ctm, scissor):
           r"""Low-level wrapper for `::fz_clip_stroke_path()`."""
>>>>>>     return _mupdf.ll_fz_clip_stroke_path(dev, path, stroke, ctm, scissor)
       
    1: def ll_fz_clip_stroke_text(dev, text, stroke, ctm, scissor):
           r"""Low-level wrapper for `::fz_clip_stroke_text()`."""
>>>>>>     return _mupdf.ll_fz_clip_stroke_text(dev, text, stroke, ctm, scissor)
       
    1: def ll_fz_clip_text(dev, text, ctm, scissor):
           r"""Low-level wrapper for `::fz_clip_text()`."""
>>>>>>     return _mupdf.ll_fz_clip_text(dev, text, ctm, scissor)
       
    1: def ll_fz_clone_buffer(buf):
           r"""
           Low-level wrapper for `::fz_clone_buffer()`.
           Make a new buffer, containing a copy of the data used in
           the original.
           """
>>>>>>     return _mupdf.ll_fz_clone_buffer(buf)
       
    1: def ll_fz_clone_context():
           r"""
           Low-level wrapper for `::fz_clone_context()`.
           Make a clone of an existing context.
       
           This function is meant to be used in multi-threaded
           applications where each thread requires its own context, yet
           parts of the global state, for example caching, are shared.
       
           ctx: Context obtained from fz_new_context to make a copy of.
           ctx must have had locks and lock/functions setup when created.
           The two contexts will share the memory allocator, resource
           store, locks and lock/unlock functions. They will each have
           their own exception stacks though.
       
           May return NULL.
           """
>>>>>>     return _mupdf.ll_fz_clone_context()
       
    1: def ll_fz_clone_default_colorspaces(base):
           r"""
           Low-level wrapper for `::fz_clone_default_colorspaces()`.
           Returns a reference to a newly cloned default colorspaces
           structure.
       
           The new clone may safely be altered without fear of race
           conditions as the caller is the only reference holder.
           """
>>>>>>     return _mupdf.ll_fz_clone_default_colorspaces(base)
       
    1: def ll_fz_clone_path(path):
           r"""
           Low-level wrapper for `::fz_clone_path()`.
           Clone the data for a path.
       
           This is used in preference to fz_keep_path when a whole
           new copy of a path is required, rather than just a shared
           pointer. This probably indicates that the path is about to
           be modified.
       
           path: path to clone.
       
           Throws exceptions on failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_clone_path(path)
       
    1: def ll_fz_clone_pixmap(old):
           r"""
           Low-level wrapper for `::fz_clone_pixmap()`.
           Clone a pixmap, copying the pixels and associated data to new
           storage.
       
           The reference count of 'old' is unchanged.
           """
>>>>>>     return _mupdf.ll_fz_clone_pixmap(old)
       
    1: def ll_fz_clone_pixmap_area_with_different_seps(src, bbox, dcs, seps, color_params, default_cs):
           r"""Low-level wrapper for `::fz_clone_pixmap_area_with_different_seps()`."""
>>>>>>     return _mupdf.ll_fz_clone_pixmap_area_with_different_seps(src, bbox, dcs, seps, color_params, default_cs)
       
    1: def ll_fz_clone_separations_for_overprint(seps):
           r"""
           Low-level wrapper for `::fz_clone_separations_for_overprint()`.
           Return a separations object with all the spots in the input
           separations object that are set to composite, reset to be
           enabled. If there ARE no spots in the object, this returns
           NULL. If the object already has all its spots enabled, then
           just returns another handle on the same object.
           """
>>>>>>     return _mupdf.ll_fz_clone_separations_for_overprint(seps)
       
    1: def ll_fz_clone_stroke_state(stroke):
           r"""
           Low-level wrapper for `::fz_clone_stroke_state()`.
           Create an identical stroke_state structure and return a
           reference to it.
       
           stroke: The stroke state reference to clone.
       
           Exceptions may be thrown in the event of a failure to
           allocate.
           """
>>>>>>     return _mupdf.ll_fz_clone_stroke_state(stroke)
       
    1: def ll_fz_close_band_writer(writer):
           r"""
           Low-level wrapper for `::fz_close_band_writer()`.
           Finishes up the output and closes the band writer. After this
           call no more headers or bands may be written.
           """
>>>>>>     return _mupdf.ll_fz_close_band_writer(writer)
       
    1: def ll_fz_close_device(dev):
           r"""
           Low-level wrapper for `::fz_close_device()`.
           Signal the end of input, and flush any buffered output.
           This is NOT called implicitly on fz_drop_device. This
           may throw exceptions.
           """
>>>>>>     return _mupdf.ll_fz_close_device(dev)
       
    1: def ll_fz_close_document_writer(wri):
           r"""
           Low-level wrapper for `::fz_close_document_writer()`.
           Called to end the process of writing
           pages to a document.
       
           This writes any file level trailers required. After this
           completes successfully the file is up to date and complete.
           """
>>>>>>     return _mupdf.ll_fz_close_document_writer(wri)
       
    1: def ll_fz_close_output(arg_1):
           r"""
           Low-level wrapper for `::fz_close_output()`.
           Flush pending output and close an output stream.
           """
>>>>>>     return _mupdf.ll_fz_close_output(arg_1)
       
    1: def ll_fz_close_zip_writer(zip):
           r"""
           Low-level wrapper for `::fz_close_zip_writer()`.
           Close the zip file for writing.
       
           This flushes any pending data to the file. This can throw
           exceptions.
           """
>>>>>>     return _mupdf.ll_fz_close_zip_writer(zip)
       
    1: def ll_fz_closepath(path):
           r"""
           Low-level wrapper for `::fz_closepath()`.
           Close the current subpath.
       
           path: The path to modify.
       
           Throws exceptions on failure to allocate, attempting to modify
           a packed path, and illegal path closes (i.e. closing a non open
           path).
           """
>>>>>>     return _mupdf.ll_fz_closepath(path)
       
    1: def ll_fz_colorspace_colorant(cs, n):
           r"""
           Low-level wrapper for `::fz_colorspace_colorant()`.
           Retrieve a the name for a colorant.
       
           Returns a pointer with the same lifespan as the colorspace.
           """
>>>>>>     return _mupdf.ll_fz_colorspace_colorant(cs, n)
       
    1: def ll_fz_colorspace_device_n_has_cmyk(cs):
           r"""
           Low-level wrapper for `::fz_colorspace_device_n_has_cmyk()`.
           True if DeviceN color space has cyan magenta yellow or black as
           one of its colorants.
           """
>>>>>>     return _mupdf.ll_fz_colorspace_device_n_has_cmyk(cs)
       
    1: def ll_fz_colorspace_device_n_has_only_cmyk(cs):
           r"""
           Low-level wrapper for `::fz_colorspace_device_n_has_only_cmyk()`.
           True if DeviceN color space has only colorants from the CMYK set.
           """
>>>>>>     return _mupdf.ll_fz_colorspace_device_n_has_only_cmyk(cs)
       
    1: def ll_fz_colorspace_digest(cs, digest):
           r"""
           Low-level wrapper for `::fz_colorspace_digest()`.
           Get checksum of underlying ICC profile.
           """
>>>>>>     return _mupdf.ll_fz_colorspace_digest(cs, digest)
       
    1: def ll_fz_colorspace_is_cmyk(cs):
           r"""Low-level wrapper for `::fz_colorspace_is_cmyk()`."""
>>>>>>     return _mupdf.ll_fz_colorspace_is_cmyk(cs)
       
    1: def ll_fz_colorspace_is_device(cs):
           r"""Low-level wrapper for `::fz_colorspace_is_device()`."""
>>>>>>     return _mupdf.ll_fz_colorspace_is_device(cs)
       
    1: def ll_fz_colorspace_is_device_cmyk(cs):
           r"""Low-level wrapper for `::fz_colorspace_is_device_cmyk()`."""
>>>>>>     return _mupdf.ll_fz_colorspace_is_device_cmyk(cs)
       
    1: def ll_fz_colorspace_is_device_gray(cs):
           r"""Low-level wrapper for `::fz_colorspace_is_device_gray()`."""
>>>>>>     return _mupdf.ll_fz_colorspace_is_device_gray(cs)
       
    1: def ll_fz_colorspace_is_device_n(cs):
           r"""Low-level wrapper for `::fz_colorspace_is_device_n()`."""
>>>>>>     return _mupdf.ll_fz_colorspace_is_device_n(cs)
       
    1: def ll_fz_colorspace_is_gray(cs):
           r"""
           Low-level wrapper for `::fz_colorspace_is_gray()`.
           Tests for particular types of colorspaces
           """
>>>>>>     return _mupdf.ll_fz_colorspace_is_gray(cs)
       
    1: def ll_fz_colorspace_is_icc(cs):
           r"""Low-level wrapper for `::fz_colorspace_is_icc()`."""
>>>>>>     return _mupdf.ll_fz_colorspace_is_icc(cs)
       
    1: def ll_fz_colorspace_is_indexed(cs):
           r"""Low-level wrapper for `::fz_colorspace_is_indexed()`."""
>>>>>>     return _mupdf.ll_fz_colorspace_is_indexed(cs)
       
    1: def ll_fz_colorspace_is_lab(cs):
           r"""Low-level wrapper for `::fz_colorspace_is_lab()`."""
>>>>>>     return _mupdf.ll_fz_colorspace_is_lab(cs)
       
    1: def ll_fz_colorspace_is_lab_icc(cs):
           r"""Low-level wrapper for `::fz_colorspace_is_lab_icc()`."""
>>>>>>     return _mupdf.ll_fz_colorspace_is_lab_icc(cs)
       
    1: def ll_fz_colorspace_is_rgb(cs):
           r"""Low-level wrapper for `::fz_colorspace_is_rgb()`."""
>>>>>>     return _mupdf.ll_fz_colorspace_is_rgb(cs)
       
    1: def ll_fz_colorspace_is_subtractive(cs):
           r"""
           Low-level wrapper for `::fz_colorspace_is_subtractive()`.
           True for CMYK, Separation and DeviceN colorspaces.
           """
>>>>>>     return _mupdf.ll_fz_colorspace_is_subtractive(cs)
       
    1: def ll_fz_colorspace_n(cs):
           r"""
           Low-level wrapper for `::fz_colorspace_n()`.
           Query the number of colorants in a colorspace.
           """
>>>>>>     return _mupdf.ll_fz_colorspace_n(cs)
       
    1: def ll_fz_colorspace_name(cs):
           r"""
           Low-level wrapper for `::fz_colorspace_name()`.
           Query the name of a colorspace.
       
           The returned string has the same lifespan as the colorspace
           does. Caller should not free it.
           """
>>>>>>     return _mupdf.ll_fz_colorspace_name(cs)
       
    1: def ll_fz_colorspace_name_colorant(cs, n, name):
           r"""
           Low-level wrapper for `::fz_colorspace_name_colorant()`.
           Assign a name for a given colorant in a colorspace.
       
           Used while initially setting up a colorspace. The string is
           copied into local storage, so need not be retained by the
           caller.
           """
>>>>>>     return _mupdf.ll_fz_colorspace_name_colorant(cs, n, name)
       
    1: def ll_fz_colorspace_type(cs):
           r"""
           Low-level wrapper for `::fz_colorspace_type()`.
           Query the type of colorspace.
           """
>>>>>>     return _mupdf.ll_fz_colorspace_type(cs)
       
    1: def ll_fz_compare_separations(sep1, sep2):
           r"""
           Low-level wrapper for `::fz_compare_separations()`.
           Compare 2 separations structures (or NULLs).
       
           Return 0 if identical, non-zero if not identical.
           """
>>>>>>     return _mupdf.ll_fz_compare_separations(sep1, sep2)
       
    1: def ll_fz_compress_brotli(dest, compressed_length, source, source_length, level):
           r"""
            Low-level wrapper for `::fz_compress_brotli()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_compress_brotli(unsigned char *dest, const unsigned char *source, size_t source_length, ::fz_brotli_level level)` => size_t compressed_length
       
               Compress source_length bytes of data starting
               at source, into a buffer of length *destLen, starting at dest.
           compressed_length will be updated on exit to contain the size
               actually used.
           """
>>>>>>     return _mupdf.ll_fz_compress_brotli(dest, compressed_length, source, source_length, level)
       
    1: def ll_fz_compress_ccitt_fax_g3(data, columns, rows, stride):
           r"""
           Low-level wrapper for `::fz_compress_ccitt_fax_g3()`.
           Compress bitmap data as CCITT Group 3 1D fax image.
           Creates a stream assuming the default PDF parameters,
           except the number of columns.
           """
>>>>>>     return _mupdf.ll_fz_compress_ccitt_fax_g3(data, columns, rows, stride)
       
    1: def ll_fz_compress_ccitt_fax_g4(data, columns, rows, stride):
           r"""
           Low-level wrapper for `::fz_compress_ccitt_fax_g4()`.
           Compress bitmap data as CCITT Group 4 2D fax image.
           Creates a stream assuming the default PDF parameters, except
           K=-1 and the number of columns.
           """
>>>>>>     return _mupdf.ll_fz_compress_ccitt_fax_g4(data, columns, rows, stride)
       
    1: def ll_fz_compressed_buffer_size(buffer):
           r"""
           Low-level wrapper for `::fz_compressed_buffer_size()`.
           Return the storage size used for a buffer and its data.
           Used in implementing store handling.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_compressed_buffer_size(buffer)
       
    1: def ll_fz_compressed_image_buffer(image):
           r"""
           Low-level wrapper for `::fz_compressed_image_buffer()`.
           Retrieve the underlying compressed data for an image.
       
           Returns a pointer to the underlying data buffer for an image,
           or NULL if this image is not based upon a compressed data
           buffer.
       
           This is not a reference counted structure, so no reference is
           returned. Lifespan is limited to that of the image itself.
           """
>>>>>>     return _mupdf.ll_fz_compressed_image_buffer(image)
       
    1: def ll_fz_compressed_image_type(image):
           r"""
           Low-level wrapper for `::fz_compressed_image_type()`.
           Return the type of a compressed image.
       
           Any non-compressed image will have the type returned as UNKNOWN.
           """
>>>>>>     return _mupdf.ll_fz_compressed_image_type(image)
       
    1: def ll_fz_concat(left, right):
           r"""
           Low-level wrapper for `::fz_concat()`.
           Multiply two matrices.
       
           The order of the two matrices are important since matrix
           multiplication is not commutative.
       
           Returns result.
           """
>>>>>>     return _mupdf.ll_fz_concat(left, right)
       
    1: def ll_fz_concat_push_drop(concat, chain):
           r"""
           Low-level wrapper for `::fz_concat_push_drop()`.
           Add a chained stream to the end of the concatenate filter.
       
           Ownership of chain is passed in.
           """
>>>>>>     return _mupdf.ll_fz_concat_push_drop(concat, chain)
       
    1: def ll_fz_contains_rect(a, b):
           r"""
           Low-level wrapper for `::fz_contains_rect()`.
           Test rectangle inclusion.
       
           Return true if a entirely contains b.
           """
>>>>>>     return _mupdf.ll_fz_contains_rect(a, b)
       
    1: def ll_fz_convert_color(ss, sv, ds, dv, _is, params):
           r"""
            Low-level wrapper for `::fz_convert_color()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_convert_color(::fz_colorspace *ss, const float *sv, ::fz_colorspace *ds, ::fz_colorspace *is, ::fz_color_params params)` => float dv
       
               Convert color values sv from colorspace ss into colorvalues dv
               for colorspace ds, via an optional intervening space is,
               respecting the given color_params.
           """
>>>>>>     return _mupdf.ll_fz_convert_color(ss, sv, ds, dv, _is, params)
       
    1: def ll_fz_convert_error(code):
           r"""
            Low-level wrapper for `::fz_convert_error()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_convert_error()` => `(const char *, int code)`
           """
>>>>>>     return _mupdf.ll_fz_convert_error(code)
       
    1: def ll_fz_convert_indexed_pixmap_to_base(src):
           r"""
           Low-level wrapper for `::fz_convert_indexed_pixmap_to_base()`.
           Convert pixmap from indexed to base colorspace.
       
           This creates a new bitmap containing the converted pixmap data.
           """
>>>>>>     return _mupdf.ll_fz_convert_indexed_pixmap_to_base(src)
       
    1: def ll_fz_convert_pixmap(pix, cs_des, prf, default_cs, color_params, keep_alpha):
           r"""
           Low-level wrapper for `::fz_convert_pixmap()`.
           Convert an existing pixmap to a desired
           colorspace. Other properties of the pixmap, such as resolution
           and position are copied to the converted pixmap.
       
           pix: The pixmap to convert.
       
           default_cs: If NULL pix->colorspace is used. It is possible that
           the data may need to be interpreted as one of the color spaces
           in default_cs.
       
           cs_des: Desired colorspace, may be NULL to denote alpha-only.
       
           prf: Proofing color space through which we need to convert.
       
           color_params: Parameters that may be used in conversion (e.g.
           ri).
       
           keep_alpha: If 0 any alpha component is removed, otherwise
           alpha is kept if present in the pixmap.
           """
>>>>>>     return _mupdf.ll_fz_convert_pixmap(pix, cs_des, prf, default_cs, color_params, keep_alpha)
       
    1: def ll_fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, dst_color, color_params):
           r"""
            Low-level wrapper for `::fz_convert_separation_colors()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_convert_separation_colors(::fz_colorspace *src_cs, const float *src_color, ::fz_separations *dst_seps, ::fz_colorspace *dst_cs, ::fz_color_params color_params)` => float dst_color
       
               Convert a color given in terms of one colorspace,
               to a color in terms of another colorspace/separations.
           """
>>>>>>     return _mupdf.ll_fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, dst_color, color_params)
       
    1: def ll_fz_convert_separation_pixmap_to_base(src):
           r"""
           Low-level wrapper for `::fz_convert_separation_pixmap_to_base()`.
           Convert pixmap from DeviceN/Separation to base colorspace.
       
           This creates a new bitmap containing the converted pixmap data.
           """
>>>>>>     return _mupdf.ll_fz_convert_separation_pixmap_to_base(src)
       
    1: def ll_fz_copy_option(val, dest, maxlen):
           r"""
           Low-level wrapper for `::fz_copy_option()`.
           Copy an option (val) into a destination buffer (dest), of maxlen
           bytes.
       
           Returns the number of bytes (including terminator) that did not
           fit. If val is maxlen or greater bytes in size, it will be left
           unterminated.
           """
>>>>>>     return _mupdf.ll_fz_copy_option(val, dest, maxlen)
       
    1: def ll_fz_copy_pixmap_rect(dest, src, r, default_cs):
           r"""Low-level wrapper for `::fz_copy_pixmap_rect()`."""
>>>>>>     return _mupdf.ll_fz_copy_pixmap_rect(dest, src, r, default_cs)
       
    1: def ll_fz_copy_rectangle(page, area, crlf):
           r"""
           Low-level wrapper for `::fz_copy_rectangle()`.
           Return a newly allocated UTF-8 string with the text for a given
           selection rectangle.
       
           crlf: If true, write "\r\n" style line endings (otherwise "\n"
           only).
           """
>>>>>>     return _mupdf.ll_fz_copy_rectangle(page, area, crlf)
       
    1: def ll_fz_copy_selection(page, a, b, crlf):
           r"""
           Low-level wrapper for `::fz_copy_selection()`.
           Return a newly allocated UTF-8 string with the text for a given
           selection.
       
           crlf: If true, write "\r\n" style line endings (otherwise "\n"
           only).
           """
>>>>>>     return _mupdf.ll_fz_copy_selection(page, a, b, crlf)
       
    1: def ll_fz_count_active_separations(seps):
           r"""
           Low-level wrapper for `::fz_count_active_separations()`.
           Return the number of active separations.
           """
>>>>>>     return _mupdf.ll_fz_count_active_separations(seps)
       
    1: def ll_fz_count_archive_entries(arch):
           r"""
           Low-level wrapper for `::fz_count_archive_entries()`.
           Number of entries in archive.
       
           Will always return a value >= 0.
       
           May throw an exception if this type of archive cannot count the
           entries (such as a directory).
           """
>>>>>>     return _mupdf.ll_fz_count_archive_entries(arch)
       
    1: def ll_fz_count_chapter_pages(doc, chapter):
           r"""
           Low-level wrapper for `::fz_count_chapter_pages()`.
           Return the number of pages in a chapter.
           May return 0.
           """
>>>>>>     return _mupdf.ll_fz_count_chapter_pages(doc, chapter)
       
    1: def ll_fz_count_chapters(doc):
           r"""
           Low-level wrapper for `::fz_count_chapters()`.
           Return the number of chapters in the document.
           At least 1.
           """
>>>>>>     return _mupdf.ll_fz_count_chapters(doc)
       
    1: def ll_fz_count_pages(doc):
           r"""
           Low-level wrapper for `::fz_count_pages()`.
           Return the number of pages in document
       
           May return 0 for documents with no pages.
           """
>>>>>>     return _mupdf.ll_fz_count_pages(doc)
       
    1: def ll_fz_count_separations(sep):
           r"""Low-level wrapper for `::fz_count_separations()`."""
>>>>>>     return _mupdf.ll_fz_count_separations(sep)
       
    1: def ll_fz_create_link(page, bbox, uri):
           r"""
           Low-level wrapper for `::fz_create_link()`.
           Create a new link on a page.
           """
>>>>>>     return _mupdf.ll_fz_create_link(page, bbox, uri)
       
    1: def ll_fz_currentpoint(path):
           r"""
           Low-level wrapper for `::fz_currentpoint()`.
           Return the current point that a path has
           reached or (0,0) if empty.
       
           path: path to return the current point of.
           """
>>>>>>     return _mupdf.ll_fz_currentpoint(path)
       
    1: def ll_fz_curveto(path, x0, y0, x1, y1, x2, y2):
           r"""
           Low-level wrapper for `::fz_curveto()`.
           Append a 'curveto' command to an open path. (For a
           cubic bezier).
       
           path: The path to modify.
       
           x0, y0: The coordinates of the first control point for the
           curve.
       
           x1, y1: The coordinates of the second control point for the
           curve.
       
           x2, y2: The end coordinates for the curve.
       
           Throws exceptions on failure to allocate, or attempting to
           modify a packed path.
           """
>>>>>>     return _mupdf.ll_fz_curveto(path, x0, y0, x1, y1, x2, y2)
       
    1: def ll_fz_curvetov(path, x1, y1, x2, y2):
           r"""
           Low-level wrapper for `::fz_curvetov()`.
           Append a 'curvetov' command to an open path. (For a
           cubic bezier with the first control coordinate equal to
           the start point).
       
           path: The path to modify.
       
           x1, y1: The coordinates of the second control point for the
           curve.
       
           x2, y2: The end coordinates for the curve.
       
           Throws exceptions on failure to allocate, or attempting to
           modify a packed path.
           """
>>>>>>     return _mupdf.ll_fz_curvetov(path, x1, y1, x2, y2)
       
    1: def ll_fz_curvetoy(path, x0, y0, x2, y2):
           r"""
           Low-level wrapper for `::fz_curvetoy()`.
           Append a 'curvetoy' command to an open path. (For a
           cubic bezier with the second control coordinate equal to
           the end point).
       
           path: The path to modify.
       
           x0, y0: The coordinates of the first control point for the
           curve.
       
           x2, y2: The end coordinates for the curve (and the second
           control coordinate).
       
           Throws exceptions on failure to allocate, or attempting to
           modify a packed path.
           """
>>>>>>     return _mupdf.ll_fz_curvetoy(path, x0, y0, x2, y2)
       
    1: def ll_fz_debug_store(out):
           r"""
           Low-level wrapper for `::fz_debug_store()`.
           Output debugging information for the current state of the store
           to the given output channel.
           """
>>>>>>     return _mupdf.ll_fz_debug_store(out)
       
    1: def ll_fz_debug_xml(item, level):
           r"""
           Low-level wrapper for `::fz_debug_xml()`.
           Pretty-print an XML tree to stdout. (Deprecated, use
           fz_output_xml in preference).
           """
>>>>>>     return _mupdf.ll_fz_debug_xml(item, level)
       
    1: def ll_fz_decode_barcode_from_display_list(type, list, subarea, rotate):
           r"""
            Low-level wrapper for `::fz_decode_barcode_from_display_list()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_decode_barcode_from_display_list(::fz_display_list *list, ::fz_rect subarea, int rotate)` => `(char *, ::fz_barcode_type type)`
       
               Decode a barcode from a display list.
       
               type: NULL, or a pointer to recieve the barcode type decoded.
               list: The display list to render to get the barcode.
               subarea: subarea of the page to decode.
               rotate: 0, 90, 180, or 270.
       
               returns the decoded value.
           """
>>>>>>     return _mupdf.ll_fz_decode_barcode_from_display_list(type, list, subarea, rotate)
       
    1: def ll_fz_decode_barcode_from_display_list2(type, list, subarea, rotate):
           r"""
            Low-level wrapper for `::fz_decode_barcode_from_display_list2()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_decode_barcode_from_display_list2(::fz_display_list *list, ::fz_rect subarea, int rotate)` => `(std::string, ::fz_barcode_type type)`
            SWIG-friendly wrapper for fz_decode_barcode_from_display_list(),
           avoiding leak of the returned string.
           """
>>>>>>     return _mupdf.ll_fz_decode_barcode_from_display_list2(type, list, subarea, rotate)
       
    1: def ll_fz_decode_barcode_from_page(type, page, subarea, rotate):
           r"""
            Low-level wrapper for `::fz_decode_barcode_from_page()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_decode_barcode_from_page(::fz_page *page, ::fz_rect subarea, int rotate)` => `(char *, ::fz_barcode_type type)`
       
               Decode a barcode from a page.
       
               type: NULL, or a pointer to recieve the barcode type decoded.
               page: The page to decode.
               subarea: subarea of the page to decode.
               rotate: 0, 90, 180, or 270.
       
               returns the decoded value.
           """
>>>>>>     return _mupdf.ll_fz_decode_barcode_from_page(type, page, subarea, rotate)
       
    1: def ll_fz_decode_barcode_from_page2(type, page, subarea, rotate):
           r"""
            Low-level wrapper for `::fz_decode_barcode_from_page2()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_decode_barcode_from_page2(::fz_page *page, ::fz_rect subarea, int rotate)` => `(std::string, ::fz_barcode_type type)`
            SWIG-friendly wrapper for fz_decode_barcode_from_page(), avoiding
           leak of the returned string.
           """
>>>>>>     return _mupdf.ll_fz_decode_barcode_from_page2(type, page, subarea, rotate)
       
    1: def ll_fz_decode_barcode_from_pixmap(type, pix, rotate):
           r"""
            Low-level wrapper for `::fz_decode_barcode_from_pixmap()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_decode_barcode_from_pixmap(::fz_pixmap *pix, int rotate)` => `(char *, ::fz_barcode_type type)`
       
               Decode a barcode from a pixmap.
       
               type: NULL, or a pointer to recieve the barcode type decoded.
               pix: The pixmap to decode.
               rotate: 0, 90, 180, or 270.
       
               returns the decoded value as an fz_malloced block. Should
               be fz_free'd by the caller.
           """
>>>>>>     return _mupdf.ll_fz_decode_barcode_from_pixmap(type, pix, rotate)
       
    1: def ll_fz_decode_barcode_from_pixmap2(type, pix, rotate):
           r"""
            Low-level wrapper for `::fz_decode_barcode_from_pixmap2()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_decode_barcode_from_pixmap2(::fz_pixmap *pix, int rotate)` => `(std::string, ::fz_barcode_type type)`
            SWIG-friendly wrapper for fz_decode_barcode_from_pixmap(), avoiding
           leak of the returned string.
           """
>>>>>>     return _mupdf.ll_fz_decode_barcode_from_pixmap2(type, pix, rotate)
       
    1: def ll_fz_decode_tile(pix, decode):
           r"""Low-level wrapper for `::fz_decode_tile()`."""
>>>>>>     return _mupdf.ll_fz_decode_tile(pix, decode)
       
    1: def ll_fz_decode_uri(s):
           r"""
            Low-level wrapper for `::fz_decode_uri()`.
           Return a new string representing the unencoded version of the given URI.
           This decodes all escape sequences except those that would result in a reserved
           character that are part of the URI syntax (; / ? : @ & = + $ , #).
           """
>>>>>>     return _mupdf.ll_fz_decode_uri(s)
       
    1: def ll_fz_decode_uri_component(s):
           r"""
            Low-level wrapper for `::fz_decode_uri_component()`.
           Return a new string representing the unencoded version of the given URI component.
           This decodes all escape sequences!
           """
>>>>>>     return _mupdf.ll_fz_decode_uri_component(s)
       
    1: def ll_fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor, l2extra):
           r"""
            Low-level wrapper for `::fz_decomp_image_from_stream()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_decomp_image_from_stream(::fz_stream *stm, ::fz_compressed_image *image, ::fz_irect *subarea, int indexed, int l2factor)` => `(fz_pixmap *, int l2extra)`
       
               Decode a subarea of a compressed image. l2factor is the amount
               of subsampling inbuilt to the stream (i.e. performed by the
               decoder). If non NULL, l2extra is the extra amount of
               subsampling that should be performed by this routine. This will
               be updated on exit to the amount of subsampling that is still
               required to be done.
       
               Returns a kept reference.
           """
>>>>>>     return _mupdf.ll_fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor, l2extra)
       
    1: def ll_fz_decouple_type3_font(font, t3doc):
           r"""Low-level wrapper for `::fz_decouple_type3_font()`."""
>>>>>>     return _mupdf.ll_fz_decouple_type3_font(font, t3doc)
       
    1: def ll_fz_default_cmyk(default_cs):
           r"""Low-level wrapper for `::fz_default_cmyk()`."""
>>>>>>     return _mupdf.ll_fz_default_cmyk(default_cs)
       
    1: def ll_fz_default_error_callback(user, message):
           r"""
           Low-level wrapper for `::fz_default_error_callback()`.
           FIXME: Better not to expose fz_default_error_callback, and
           fz_default_warning callback and to allow 'NULL' to be used
           int fz_set_xxxx_callback to mean "defaults".
       
           FIXME: Do we need/want functions like
           fz_error_callback(ctx, message) to allow callers to inject
           stuff into the error/warning streams?
       
           The default error callback. Declared publicly just so that the
           error callback can be set back to this after it has been
           overridden.
           """
>>>>>>     return _mupdf.ll_fz_default_error_callback(user, message)
       
    1: def ll_fz_default_gray(default_cs):
           r"""
           Low-level wrapper for `::fz_default_gray()`.
           Retrieve default colorspaces (typically page local).
       
           If default_cs is non NULL, the default is retrieved from there,
           otherwise the global default is retrieved.
       
           These return borrowed references that should not be dropped,
           unless they are kept first.
           """
>>>>>>     return _mupdf.ll_fz_default_gray(default_cs)
       
    1: def ll_fz_default_halftone(num_comps):
           r"""
           Low-level wrapper for `::fz_default_halftone()`.
           Create a 'default' halftone structure
           for the given number of components.
       
           num_comps: The number of components to use.
       
           Returns a simple default halftone. The default halftone uses
           the same halftone tile for each plane, which may not be ideal
           for all purposes.
           """
>>>>>>     return _mupdf.ll_fz_default_halftone(num_comps)
       
    1: def ll_fz_default_output_intent(default_cs):
           r"""Low-level wrapper for `::fz_default_output_intent()`."""
>>>>>>     return _mupdf.ll_fz_default_output_intent(default_cs)
       
    1: def ll_fz_default_rgb(default_cs):
           r"""Low-level wrapper for `::fz_default_rgb()`."""
>>>>>>     return _mupdf.ll_fz_default_rgb(default_cs)
       
    1: def ll_fz_default_warning_callback(user, message):
           r"""
           Low-level wrapper for `::fz_default_warning_callback()`.
           The default warning callback. Declared publicly just so that
           the warning callback can be set back to this after it has been
           overridden.
           """
>>>>>>     return _mupdf.ll_fz_default_warning_callback(user, message)
       
    1: def ll_fz_defer_reap_end():
           r"""
           Low-level wrapper for `::fz_defer_reap_end()`.
           Decrement the defer reap count.
       
           If the defer reap count returns to 0, and the store
           has reapable objects in, a reap pass will begin.
       
           Call this at the end of a process during which you
           potentially might drop many reapable objects.
       
           It is vital that every fz_defer_reap_start is matched
           by a fz_defer_reap_end call.
           """
>>>>>>     return _mupdf.ll_fz_defer_reap_end()
       
    1: def ll_fz_defer_reap_start():
           r"""
           Low-level wrapper for `::fz_defer_reap_start()`.
           Increment the defer reap count.
       
           No reap operations will take place (except for those
           triggered by an immediate failed malloc) until the
           defer reap count returns to 0.
       
           Call this at the start of a process during which you
           potentially might drop many reapable objects.
       
           It is vital that every fz_defer_reap_start is matched
           by a fz_defer_reap_end call.
           """
>>>>>>     return _mupdf.ll_fz_defer_reap_start()
       
    1: def ll_fz_deflate(dest, compressed_length, source, source_length, level):
           r"""
            Low-level wrapper for `::fz_deflate()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_deflate(unsigned char *dest, const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => size_t compressed_length
       
               Compress source_length bytes of data starting
               at source, into a buffer of length *compressed_length, starting at
               dest. *compressed_length will be updated on exit to contain the size
               actually used.
           """
>>>>>>     return _mupdf.ll_fz_deflate(dest, compressed_length, source, source_length, level)
       
    1: def ll_fz_deflate_bound(size):
           r"""
           Low-level wrapper for `::fz_deflate_bound()`.
           Returns the upper bound on the
           size of flated data of length size.
           """
>>>>>>     return _mupdf.ll_fz_deflate_bound(size)
       
    1: def ll_fz_delete_link(page, link):
           r"""
           Low-level wrapper for `::fz_delete_link()`.
           Delete an existing link on a page.
           """
>>>>>>     return _mupdf.ll_fz_delete_link(page, link)
       
    1: def ll_fz_deskew_pixmap(src, degrees, border):
           r"""Low-level wrapper for `::fz_deskew_pixmap()`."""
>>>>>>     return _mupdf.ll_fz_deskew_pixmap(src, degrees, border)
       
    1: def ll_fz_detach_xml(node):
           r"""
           Low-level wrapper for `::fz_detach_xml()`.
           Detach a node from the tree, unlinking it from its parent,
           and setting the document root to the node.
           """
>>>>>>     return _mupdf.ll_fz_detach_xml(node)
       
    1: def ll_fz_detect_document(points, src):
           r"""Low-level wrapper for `::fz_detect_document()`."""
>>>>>>     return _mupdf.ll_fz_detect_document(points, src)
       
    1: def ll_fz_detect_skew(pixmap):
           r"""Low-level wrapper for `::fz_detect_skew()`."""
>>>>>>     return _mupdf.ll_fz_detect_skew(pixmap)
       
    1: def ll_fz_device_bgr():
           r"""Low-level wrapper for `::fz_device_bgr()`."""
>>>>>>     return _mupdf.ll_fz_device_bgr()
       
    1: def ll_fz_device_cmyk():
           r"""Low-level wrapper for `::fz_device_cmyk()`."""
>>>>>>     return _mupdf.ll_fz_device_cmyk()
       
    1: def ll_fz_device_current_scissor(dev):
           r"""
           Low-level wrapper for `::fz_device_current_scissor()`.
           Find current scissor region as tracked by the device.
           """
>>>>>>     return _mupdf.ll_fz_device_current_scissor(dev)
       
    1: def ll_fz_device_gray():
           r"""
           Low-level wrapper for `::fz_device_gray()`.
           Retrieve global default colorspaces.
       
           These return borrowed references that should not be dropped,
           unless they are kept first.
           """
>>>>>>     return _mupdf.ll_fz_device_gray()
       
    1: def ll_fz_device_lab():
           r"""Low-level wrapper for `::fz_device_lab()`."""
>>>>>>     return _mupdf.ll_fz_device_lab()
       
    1: def ll_fz_device_rgb():
           r"""Low-level wrapper for `::fz_device_rgb()`."""
>>>>>>     return _mupdf.ll_fz_device_rgb()
       
    1: def ll_fz_dirname(dir, path, dirsize):
           r"""
           Low-level wrapper for `::fz_dirname()`.
           extract the directory component from a path.
           """
>>>>>>     return _mupdf.ll_fz_dirname(dir, path, dirsize)
       
    1: def ll_fz_disable_device_hints(dev, hints):
           r"""
           Low-level wrapper for `::fz_disable_device_hints()`.
           Disable (clear) hint bits within the hint bitfield for a device.
           """
>>>>>>     return _mupdf.ll_fz_disable_device_hints(dev, hints)
       
    1: def ll_fz_disable_icc():
           r"""
           Low-level wrapper for `::fz_disable_icc()`.
           Disable icc profile based operation.
           """
>>>>>>     return _mupdf.ll_fz_disable_icc()
       
    1: def ll_fz_display_list_is_empty(list):
           r"""
           Low-level wrapper for `::fz_display_list_is_empty()`.
           Check for a display list being empty
       
           list: The list to check.
       
           Returns true if empty, false otherwise.
           """
>>>>>>     return _mupdf.ll_fz_display_list_is_empty(list)
       
    1: def ll_fz_div255(c, a):
           r"""
           Low-level wrapper for `::fz_div255()`.
           Undo alpha premultiplication.
           """
>>>>>>     return _mupdf.ll_fz_div255(c, a)
       
    1: def ll_fz_do_always():
           r"""Low-level wrapper for `::fz_do_always()`."""
>>>>>>     return _mupdf.ll_fz_do_always()
       
    1: def ll_fz_do_catch():
           r"""Low-level wrapper for `::fz_do_catch()`."""
>>>>>>     return _mupdf.ll_fz_do_catch()
       
    1: def ll_fz_do_try():
           r"""Low-level wrapper for `::fz_do_try()`."""
>>>>>>     return _mupdf.ll_fz_do_try()
       
    1: def ll_fz_document_handler_open(handler, stream, accel, dir, recognize_state):
           r"""
            Low-level wrapper for `::fz_document_handler_open()`.  Helper for calling `fz_document_handler::open` function pointer via
           Swig from Python/C#.
           """
>>>>>>     return _mupdf.ll_fz_document_handler_open(handler, stream, accel, dir, recognize_state)
       
    1: def ll_fz_document_handler_recognize(handler, magic):
           r"""
            Low-level wrapper for `::fz_document_handler_recognize()`.  Helper for calling a `fz_document_handler::recognize` function
           pointer via Swig from Python/C#.
           """
>>>>>>     return _mupdf.ll_fz_document_handler_recognize(handler, magic)
       
    1: def ll_fz_document_output_intent(doc):
           r"""
           Low-level wrapper for `::fz_document_output_intent()`.
           Find the output intent colorspace if the document has defined
           one.
       
           Returns a borrowed reference that should not be dropped, unless
           it is kept first.
           """
>>>>>>     return _mupdf.ll_fz_document_output_intent(doc)
       
    1: def ll_fz_document_supports_accelerator(doc):
           r"""
           Low-level wrapper for `::fz_document_supports_accelerator()`.
           Query if the document supports the saving of accelerator data.
           """
>>>>>>     return _mupdf.ll_fz_document_supports_accelerator(doc)
       
    1: def ll_fz_dom_add_attribute(elt, att, value):
           r"""
           Low-level wrapper for `::fz_dom_add_attribute()`.
           Add an attribute to an element.
       
           Ownership of att and value remain with the caller.
           """
>>>>>>     return _mupdf.ll_fz_dom_add_attribute(elt, att, value)
       
    1: def ll_fz_dom_append_child(parent, child):
           r"""
           Low-level wrapper for `::fz_dom_append_child()`.
           Insert an element as the last child of a parent, unlinking the
           child from its current position if required.
           """
>>>>>>     return _mupdf.ll_fz_dom_append_child(parent, child)
       
    1: def ll_fz_dom_attribute(elt, att):
           r"""
           Low-level wrapper for `::fz_dom_attribute()`.
           Retrieve the value of a given attribute from a given element.
       
           Returns a borrowed pointer to the value or NULL if not found.
           """
>>>>>>     return _mupdf.ll_fz_dom_attribute(elt, att)
       
    1: def ll_fz_dom_body(dom):
           r"""
           Low-level wrapper for `::fz_dom_body()`.
           Return a borrowed reference for the 'body' element of
           the given DOM.
           """
>>>>>>     return _mupdf.ll_fz_dom_body(dom)
       
    1: def ll_fz_dom_clone(elt):
           r"""
           Low-level wrapper for `::fz_dom_clone()`.
           Clone an element (and its children).
       
           A borrowed reference to the clone is returned. The clone is not
           yet linked into the DOM.
           """
>>>>>>     return _mupdf.ll_fz_dom_clone(elt)
       
    1: def ll_fz_dom_create_element(dom, tag):
           r"""
           Low-level wrapper for `::fz_dom_create_element()`.
           Create an element of a given tag type for the given DOM.
       
           The element is not linked into the DOM yet.
           """
>>>>>>     return _mupdf.ll_fz_dom_create_element(dom, tag)
       
    1: def ll_fz_dom_create_text_node(dom, text):
           r"""
           Low-level wrapper for `::fz_dom_create_text_node()`.
           Create a text node for the given DOM.
       
           The element is not linked into the DOM yet.
           """
>>>>>>     return _mupdf.ll_fz_dom_create_text_node(dom, text)
       
    1: def ll_fz_dom_document_element(dom):
           r"""
           Low-level wrapper for `::fz_dom_document_element()`.
           Return a borrowed reference for the document (the top
           level element) of the DOM.
           """
>>>>>>     return _mupdf.ll_fz_dom_document_element(dom)
       
    1: def ll_fz_dom_find(elt, tag, att, match):
           r"""
           Low-level wrapper for `::fz_dom_find()`.
           Find the first element matching the requirements in a depth first traversal from elt.
       
           The tagname must match tag, unless tag is NULL, when all tag names are considered to match.
       
           If att is NULL, then all tags match.
           Otherwise:
               If match is NULL, then only nodes that have an att attribute match.
               If match is non-NULL, then only nodes that have an att attribute that matches match match.
       
           Returns NULL (if no match found), or a borrowed reference to the first matching element.
           """
>>>>>>     return _mupdf.ll_fz_dom_find(elt, tag, att, match)
       
    1: def ll_fz_dom_find_next(elt, tag, att, match):
           r"""
           Low-level wrapper for `::fz_dom_find_next()`.
           Find the next element matching the requirements.
           """
>>>>>>     return _mupdf.ll_fz_dom_find_next(elt, tag, att, match)
       
    1: def ll_fz_dom_first_child(elt):
           r"""
           Low-level wrapper for `::fz_dom_first_child()`.
           Return a borrowed reference to the first child of a node,
           or NULL if there isn't one.
           """
>>>>>>     return _mupdf.ll_fz_dom_first_child(elt)
       
    1: def ll_fz_dom_get_attribute(elt, i, att):
           r"""
            Low-level wrapper for `::fz_dom_get_attribute()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_dom_get_attribute(::fz_xml *elt, int i)` => `(const char *, const char *att)`
       
               Enumerate through the attributes of an element.
       
               Call with i=0,1,2,3... to enumerate attributes.
       
               On return *att and the return value will be NULL if there are not
               that many attributes to read. Otherwise, *att will be filled in
               with a borrowed pointer to the attribute name, and the return
               value will be a borrowed pointer to the value.
           """
>>>>>>     return _mupdf.ll_fz_dom_get_attribute(elt, i, att)
       
    1: def ll_fz_dom_insert_after(node, new_elt):
           r"""
           Low-level wrapper for `::fz_dom_insert_after()`.
           Insert an element (new_elt), after another element (node),
           unlinking the new_elt from its current position if required.
           """
>>>>>>     return _mupdf.ll_fz_dom_insert_after(node, new_elt)
       
    1: def ll_fz_dom_insert_before(node, new_elt):
           r"""
           Low-level wrapper for `::fz_dom_insert_before()`.
           Insert an element (new_elt), before another element (node),
           unlinking the new_elt from its current position if required.
           """
>>>>>>     return _mupdf.ll_fz_dom_insert_before(node, new_elt)
       
    1: def ll_fz_dom_next(elt):
           r"""
           Low-level wrapper for `::fz_dom_next()`.
           Return a borrowed reference to the next sibling of a node,
           or NULL if there isn't one.
           """
>>>>>>     return _mupdf.ll_fz_dom_next(elt)
       
    1: def ll_fz_dom_parent(elt):
           r"""
           Low-level wrapper for `::fz_dom_parent()`.
           Return a borrowed reference to the parent of a node,
           or NULL if there isn't one.
           """
>>>>>>     return _mupdf.ll_fz_dom_parent(elt)
       
    1: def ll_fz_dom_previous(elt):
           r"""
           Low-level wrapper for `::fz_dom_previous()`.
           Return a borrowed reference to the previous sibling of a node,
           or NULL if there isn't one.
           """
>>>>>>     return _mupdf.ll_fz_dom_previous(elt)
       
    1: def ll_fz_dom_remove(elt):
           r"""
           Low-level wrapper for `::fz_dom_remove()`.
           Remove an element from the DOM. The element can be added back elsewhere
           if required.
       
           No reference counting changes for the element.
           """
>>>>>>     return _mupdf.ll_fz_dom_remove(elt)
       
    1: def ll_fz_dom_remove_attribute(elt, att):
           r"""
           Low-level wrapper for `::fz_dom_remove_attribute()`.
           Remove an attribute from an element.
           """
>>>>>>     return _mupdf.ll_fz_dom_remove_attribute(elt, att)
       
    1: def ll_fz_draw_story(story, dev, ctm):
           r"""Low-level wrapper for `::fz_draw_story()`."""
>>>>>>     return _mupdf.ll_fz_draw_story(story, dev, ctm)
       
    1: def ll_fz_drop_archive(arch):
           r"""
           Low-level wrapper for `::fz_drop_archive()`.
           Drop a reference to an archive.
       
           When the last reference is dropped, this closes and releases
           any memory or filehandles associated with the archive.
           """
>>>>>>     return _mupdf.ll_fz_drop_archive(arch)
       
    1: def ll_fz_drop_band_writer(writer):
           r"""
           Low-level wrapper for `::fz_drop_band_writer()`.
           Drop the reference to the band writer, causing it to be
           destroyed.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_drop_band_writer(writer)
       
    1: def ll_fz_drop_bitmap(bit):
           r"""
           Low-level wrapper for `::fz_drop_bitmap()`.
           Drop a reference to the bitmap. When the reference count reaches
           zero, the bitmap will be destroyed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_bitmap(bit)
       
    1: def ll_fz_drop_buffer(buf):
           r"""
           Low-level wrapper for `::fz_drop_buffer()`.
           Drop a reference to the buffer. When the reference count reaches
           zero, the buffer is destroyed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_buffer(buf)
       
    1: def ll_fz_drop_colorspace(colorspace):
           r"""
           Low-level wrapper for `::fz_drop_colorspace()`.
           Drops a reference to the colorspace.
       
           When the reference count reaches zero, the colorspace is
           destroyed.
           """
>>>>>>     return _mupdf.ll_fz_drop_colorspace(colorspace)
       
    1: def ll_fz_drop_colorspace_imp(cs_):
           r"""Low-level wrapper for `::fz_drop_colorspace_imp()`."""
>>>>>>     return _mupdf.ll_fz_drop_colorspace_imp(cs_)
       
    1: def ll_fz_drop_compressed_buffer(buf):
           r"""
           Low-level wrapper for `::fz_drop_compressed_buffer()`.
           Drop a reference to a compressed buffer. Destroys the buffer
           and frees any storage/other references held by it.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_compressed_buffer(buf)
       
    1: def ll_fz_drop_context():
           r"""
           Low-level wrapper for `::fz_drop_context()`.
           Free a context and its global state.
       
           The context and all of its global state is freed, and any
           buffered warnings are flushed (see fz_flush_warnings). If NULL
           is passed in nothing will happen.
       
           Must not be called for a context that is being used in an active
           fz_try(), fz_always() or fz_catch() block.
           """
>>>>>>     return _mupdf.ll_fz_drop_context()
       
    1: def ll_fz_drop_default_colorspaces(default_cs):
           r"""
           Low-level wrapper for `::fz_drop_default_colorspaces()`.
           Drop a reference to the default colorspaces structure. When the
           reference count reaches 0, the references it holds internally
           to the underlying colorspaces will be dropped, and the structure
           will be destroyed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_default_colorspaces(default_cs)
       
    1: def ll_fz_drop_device(dev):
           r"""
           Low-level wrapper for `::fz_drop_device()`.
           Reduce the reference count on a device. When the reference count
           reaches zero, the device and its resources will be freed.
           Don't forget to call fz_close_device before dropping the device,
           or you may get incomplete output!
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_device(dev)
       
    1: def ll_fz_drop_display_list(list):
           r"""
           Low-level wrapper for `::fz_drop_display_list()`.
           Decrement the reference count for a display list. When the
           reference count reaches zero, all the references in the display
           list itself are dropped, and the display list is freed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_display_list(list)
       
    1: def ll_fz_drop_document(doc):
           r"""
           Low-level wrapper for `::fz_drop_document()`.
           Decrement the document reference count. When the reference
           count reaches 0, the document and all it's references are
           freed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_document(doc)
       
    1: def ll_fz_drop_document_writer(wri):
           r"""
           Low-level wrapper for `::fz_drop_document_writer()`.
           Called to discard a fz_document_writer.
           This may be called at any time during the process to release all
           the resources owned by the writer.
       
           Calling drop without having previously called close may leave
           the file in an inconsistent state.
           """
>>>>>>     return _mupdf.ll_fz_drop_document_writer(wri)
       
    1: def ll_fz_drop_drawn_tiles_for_document(doc):
           r"""
           Low-level wrapper for `::fz_drop_drawn_tiles_for_document()`.
           Filter the store and throw away any stored tiles drawn for a
           given document.
           """
>>>>>>     return _mupdf.ll_fz_drop_drawn_tiles_for_document(doc)
       
    1: def ll_fz_drop_font(font):
           r"""
           Low-level wrapper for `::fz_drop_font()`.
           Drop a reference to a fz_font, destroying the
           font when the last reference is dropped.
       
           font: The font to drop a reference to.
           """
>>>>>>     return _mupdf.ll_fz_drop_font(font)
       
    1: def ll_fz_drop_function(func):
           r"""Low-level wrapper for `::fz_drop_function()`."""
>>>>>>     return _mupdf.ll_fz_drop_function(func)
       
    1: def ll_fz_drop_glyph(pix):
           r"""
           Low-level wrapper for `::fz_drop_glyph()`.
           Drop a reference and free a glyph.
       
           Decrement the reference count for the glyph. When no
           references remain the glyph will be freed.
           """
>>>>>>     return _mupdf.ll_fz_drop_glyph(pix)
       
    1: def ll_fz_drop_halftone(ht):
           r"""
           Low-level wrapper for `::fz_drop_halftone()`.
           Drop a reference to the halftone. When the reference count
           reaches zero, the halftone is destroyed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_halftone(ht)
       
    1: def ll_fz_drop_hash_table(table):
           r"""
           Low-level wrapper for `::fz_drop_hash_table()`.
           Destroy the hash table.
       
           Values are dropped using the drop function.
           """
>>>>>>     return _mupdf.ll_fz_drop_hash_table(table)
       
    1: def ll_fz_drop_image(image):
           r"""
           Low-level wrapper for `::fz_drop_image()`.
           Decrement the (normal) reference count for an image. When the
           total (normal + key) reference count reaches zero, the image and
           its resources are freed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_image(image)
       
    1: def ll_fz_drop_image_base(image):
           r"""
           Low-level wrapper for `::fz_drop_image_base()`.
           Internal destructor for the base image class members.
       
           Exposed to allow derived image classes to be written.
           """
>>>>>>     return _mupdf.ll_fz_drop_image_base(image)
       
    1: def ll_fz_drop_image_imp(image):
           r"""
           Low-level wrapper for `::fz_drop_image_imp()`.
           Internal destructor exposed for fz_store integration.
           """
>>>>>>     return _mupdf.ll_fz_drop_image_imp(image)
       
    1: def ll_fz_drop_image_store_key(image):
           r"""
           Low-level wrapper for `::fz_drop_image_store_key()`.
           Decrement the store key reference count for an image. When the
           total (normal + key) reference count reaches zero, the image and
           its resources are freed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_image_store_key(image)
       
    1: def ll_fz_drop_imp(p, refs):
           r"""
            Low-level wrapper for `::fz_drop_imp()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_drop_imp(void *p)` => `(int, int refs)`
           """
>>>>>>     return _mupdf.ll_fz_drop_imp(p, refs)
       
    1: def ll_fz_drop_imp16(p, refs):
           r"""
            Low-level wrapper for `::fz_drop_imp16()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_drop_imp16(void *p)` => `(int, int16_t refs)`
           """
>>>>>>     return _mupdf.ll_fz_drop_imp16(p, refs)
       
    1: def ll_fz_drop_imp8(p, refs):
           r"""Low-level wrapper for `::fz_drop_imp8()`."""
>>>>>>     return _mupdf.ll_fz_drop_imp8(p, refs)
       
    1: def ll_fz_drop_jbig2_globals(globals):
           r"""
           Low-level wrapper for `::fz_drop_jbig2_globals()`.
           Decrement the reference count for a jbig2 globals record.
           When the reference count hits zero, the record is freed.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_drop_jbig2_globals(globals)
       
    1: def ll_fz_drop_jbig2_globals_imp(globals):
           r"""
           Low-level wrapper for `::fz_drop_jbig2_globals_imp()`.
           Special jbig2 globals drop function for use in implementing
           store support.
           """
>>>>>>     return _mupdf.ll_fz_drop_jbig2_globals_imp(globals)
       
    1: def ll_fz_drop_key_storable(arg_1):
           r"""
           Low-level wrapper for `::fz_drop_key_storable()`.
           Decrement the (normal) reference count for a storable object.
           When the total reference count hits zero, the drop function for
           that object is called to free the object.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_key_storable(arg_1)
       
    1: def ll_fz_drop_key_storable_key(arg_1):
           r"""
           Low-level wrapper for `::fz_drop_key_storable_key()`.
           Decrement the (key) reference count for a storable object.
           When the total reference count hits zero, the drop function for
           that object is called to free the object.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_key_storable_key(arg_1)
       
    1: def ll_fz_drop_layout(block):
           r"""
           Low-level wrapper for `::fz_drop_layout()`.
           Drop layout block. Free the pool, and linked blocks.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_layout(block)
       
    1: def ll_fz_drop_link(link):
           r"""
           Low-level wrapper for `::fz_drop_link()`.
           Decrement the reference count for a link. When the reference
           count reaches zero, the link is destroyed.
       
           When a link is freed, the reference for any linked link (next)
           is dropped too, thus an entire linked list of fz_link's can be
           freed by just dropping the head.
           """
>>>>>>     return _mupdf.ll_fz_drop_link(link)
       
    1: def ll_fz_drop_outline(outline):
           r"""
           Low-level wrapper for `::fz_drop_outline()`.
           Decrements the reference count. When the reference point
           reaches zero, the outline is freed.
       
           When freed, it will drop linked     outline entries (next and down)
           too, thus a whole outline structure can be dropped by dropping
           the top entry.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_outline(outline)
       
    1: def ll_fz_drop_outline_iterator(iter):
           r"""
           Low-level wrapper for `::fz_drop_outline_iterator()`.
           Drop the current iterator.
           """
>>>>>>     return _mupdf.ll_fz_drop_outline_iterator(iter)
       
    1: def ll_fz_drop_output(arg_1):
           r"""
           Low-level wrapper for `::fz_drop_output()`.
           Free an output stream. Don't forget to close it first!
           """
>>>>>>     return _mupdf.ll_fz_drop_output(arg_1)
       
    1: def ll_fz_drop_page(page):
           r"""
           Low-level wrapper for `::fz_drop_page()`.
           Decrements the reference count for the page. When the reference
           count hits 0, the page and its references are freed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_page(page)
       
    1: def ll_fz_drop_path(path):
           r"""
           Low-level wrapper for `::fz_drop_path()`.
           Decrement the reference count. When the reference count hits
           zero, free the path.
       
           All paths can be dropped, regardless of their packing type.
           Packed paths do not own the blocks into which they are packed
           so dropping them does not free those blocks.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_path(path)
       
    1: def ll_fz_drop_pixmap(pix):
           r"""
           Low-level wrapper for `::fz_drop_pixmap()`.
           Decrement the reference count for the pixmap. When the
           reference count hits 0, the pixmap is freed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_pixmap(pix)
       
    1: def ll_fz_drop_pool(pool):
           r"""
           Low-level wrapper for `::fz_drop_pool()`.
           Drop a pool, freeing and invalidating all storage returned from
           the pool.
           """
>>>>>>     return _mupdf.ll_fz_drop_pool(pool)
       
    1: def ll_fz_drop_separations(sep):
           r"""
           Low-level wrapper for `::fz_drop_separations()`.
           Decrement the reference count for a separations structure.
           When the reference count hits zero, the separations structure
           is freed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_separations(sep)
       
    1: def ll_fz_drop_shade(shade):
           r"""
           Low-level wrapper for `::fz_drop_shade()`.
           Decrement the reference count for the shade structure. When
           the reference count hits zero, the structure is freed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_shade(shade)
       
    1: def ll_fz_drop_shade_color_cache(cache):
           r"""Low-level wrapper for `::fz_drop_shade_color_cache()`."""
>>>>>>     return _mupdf.ll_fz_drop_shade_color_cache(cache)
       
    1: def ll_fz_drop_shade_imp(shade):
           r"""
           Low-level wrapper for `::fz_drop_shade_imp()`.
           Internal function to destroy a
           shade. Only exposed for use with the fz_store.
       
           shade: The reference to destroy.
           """
>>>>>>     return _mupdf.ll_fz_drop_shade_imp(shade)
       
    1: def ll_fz_drop_stext_page(page):
           r"""Low-level wrapper for `::fz_drop_stext_page()`."""
>>>>>>     return _mupdf.ll_fz_drop_stext_page(page)
       
    1: def ll_fz_drop_storable(arg_1):
           r"""
           Low-level wrapper for `::fz_drop_storable()`.
           Decrement the reference count for a storable object. When the
           reference count hits zero, the drop function for that object
           is called to free the object.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_storable(arg_1)
       
    1: def ll_fz_drop_store_context():
           r"""
           Low-level wrapper for `::fz_drop_store_context()`.
           Decrement the reference count for the store context. When the
           reference count hits zero, the store context is freed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_store_context()
       
    1: def ll_fz_drop_story(story):
           r"""Low-level wrapper for `::fz_drop_story()`."""
>>>>>>     return _mupdf.ll_fz_drop_story(story)
       
    1: def ll_fz_drop_stream(stm):
           r"""
           Low-level wrapper for `::fz_drop_stream()`.
           Decrements the reference count for a stream.
       
           When the reference count for the stream hits zero, frees the
           storage used for the fz_stream itself, and (usually)
           releases the underlying resources that the stream is based upon
           (depends on the method used to open the stream initially).
           """
>>>>>>     return _mupdf.ll_fz_drop_stream(stm)
       
    1: def ll_fz_drop_string(str):
           r"""Low-level wrapper for `::fz_drop_string()`."""
>>>>>>     return _mupdf.ll_fz_drop_string(str)
       
    1: def ll_fz_drop_stroke_state(stroke):
           r"""
           Low-level wrapper for `::fz_drop_stroke_state()`.
           Drop a reference to a stroke state structure, destroying the
           structure if it is the last reference.
           """
>>>>>>     return _mupdf.ll_fz_drop_stroke_state(stroke)
       
    1: def ll_fz_drop_text(text):
           r"""
           Low-level wrapper for `::fz_drop_text()`.
           Decrement the reference count for the text object. When the
           reference count hits zero, the text object is freed.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_drop_text(text)
       
    1: def ll_fz_drop_tree(node, dropfunc):
           r"""
           Low-level wrapper for `::fz_drop_tree()`.
           Drop the tree.
       
           The storage used by the tree is freed, and each value has
           dropfunc called on it.
           """
>>>>>>     return _mupdf.ll_fz_drop_tree(node, dropfunc)
       
    1: def ll_fz_drop_xml(xml):
           r"""
           Low-level wrapper for `::fz_drop_xml()`.
           Drop a reference to the XML. When the last reference is
           dropped, the node and all its children and siblings will
           be freed.
           """
>>>>>>     return _mupdf.ll_fz_drop_xml(xml)
       
    1: def ll_fz_drop_zip_writer(zip):
           r"""
           Low-level wrapper for `::fz_drop_zip_writer()`.
           Drop the reference to the zipfile.
       
           In common with other 'drop' methods, this will never throw an
           exception.
           """
>>>>>>     return _mupdf.ll_fz_drop_zip_writer(zip)
       
    1: def ll_fz_dump_glyph_cache_stats(out):
           r"""
           Low-level wrapper for `::fz_dump_glyph_cache_stats()`.
           Dump debug statistics for the glyph cache.
           """
>>>>>>     return _mupdf.ll_fz_dump_glyph_cache_stats(out)
       
    1: def ll_fz_duplicate_glyph_names_from_unicode(unicode):
           r"""Low-level wrapper for `::fz_duplicate_glyph_names_from_unicode()`."""
>>>>>>     return _mupdf.ll_fz_duplicate_glyph_names_from_unicode(unicode)
       
    1: def ll_fz_empty_store():
           r"""
           Low-level wrapper for `::fz_empty_store()`.
           Evict every item from the store.
           """
>>>>>>     return _mupdf.ll_fz_empty_store()
       
    1: def ll_fz_enable_device_hints(dev, hints):
           r"""
           Low-level wrapper for `::fz_enable_device_hints()`.
           Enable (set) hint bits within the hint bitfield for a device.
           """
>>>>>>     return _mupdf.ll_fz_enable_device_hints(dev, hints)
       
    1: def ll_fz_enable_icc():
           r"""
           Low-level wrapper for `::fz_enable_icc()`.
           Enable icc profile based operation.
           """
>>>>>>     return _mupdf.ll_fz_enable_icc()
       
    1: def ll_fz_encode_character(font, unicode):
           r"""
           Low-level wrapper for `::fz_encode_character()`.
           Find the glyph id for a given unicode
           character within a font.
       
           font: The font to look for the unicode character in.
       
           unicode: The unicode character to encode.
       
           Returns the glyph id for the given unicode value, or 0 if
           unknown.
           """
>>>>>>     return _mupdf.ll_fz_encode_character(font, unicode)
       
    1: def ll_fz_encode_character_by_glyph_name(font, glyphname):
           r"""
           Low-level wrapper for `::fz_encode_character_by_glyph_name()`.
           Encode character.
       
           Either by direct lookup of glyphname within a font, or, failing
           that, by mapping glyphname to unicode and thence to the glyph
           index within the given font.
       
           Returns zero for type3 fonts.
           """
>>>>>>     return _mupdf.ll_fz_encode_character_by_glyph_name(font, glyphname)
       
    1: def ll_fz_encode_character_sc(font, unicode):
           r"""
           Low-level wrapper for `::fz_encode_character_sc()`.
           Encode character, preferring small-caps variant if available.
       
           font: The font to look for the unicode character in.
       
           unicode: The unicode character to encode.
       
           Returns the glyph id for the given unicode value, or 0 if
           unknown.
           """
>>>>>>     return _mupdf.ll_fz_encode_character_sc(font, unicode)
       
    1: def ll_fz_encode_character_with_fallback(font, unicode, script, language, out_font):
           r"""
            Low-level wrapper for `::fz_encode_character_with_fallback()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_encode_character_with_fallback(::fz_font *font, int unicode, int script, int language, ::fz_font **out_font)` => `(int)`
       
               Find the glyph id for
               a given unicode character within a font, falling back to
               an alternative if not found.
       
               font: The font to look for the unicode character in.
       
               unicode: The unicode character to encode.
       
               script: The script in use.
       
               language: The language in use.
       
               out_font: The font handle in which the given glyph represents
               the requested unicode character. The caller does not own the
               reference it is passed, so should call fz_keep_font if it is
               not simply to be used immediately.
       
               Returns the glyph id for the given unicode value in the supplied
               font (and sets *out_font to font) if it is present. Otherwise
               an alternative fallback font (based on script/language) is
               searched for. If the glyph is found therein, *out_font is set
               to this reference, and the glyph reference is returned. If it
               cannot be found anywhere, the function returns 0.
           """
>>>>>>     return _mupdf.ll_fz_encode_character_with_fallback(font, unicode, script, language, out_font)
       
    1: def ll_fz_encode_uri(s):
           r"""
            Low-level wrapper for `::fz_encode_uri()`.
           Return a new string representing the provided string encoded as a URI.
           """
>>>>>>     return _mupdf.ll_fz_encode_uri(s)
       
    1: def ll_fz_encode_uri_component(s):
           r"""
            Low-level wrapper for `::fz_encode_uri_component()`.
           Return a new string representing the provided string encoded as an URI component.
           This also encodes the special reserved characters (; / ? : @ & = + $ , #).
           """
>>>>>>     return _mupdf.ll_fz_encode_uri_component(s)
       
    1: def ll_fz_encode_uri_pathname(s):
           r"""
            Low-level wrapper for `::fz_encode_uri_pathname()`.
           Return a new string representing the provided string encoded as an URI path name.
           This also encodes the special reserved characters except /.
           """
>>>>>>     return _mupdf.ll_fz_encode_uri_pathname(s)
       
    1: def ll_fz_end_group(dev):
           r"""Low-level wrapper for `::fz_end_group()`."""
>>>>>>     return _mupdf.ll_fz_end_group(dev)
       
    1: def ll_fz_end_layer(dev):
           r"""Low-level wrapper for `::fz_end_layer()`."""
>>>>>>     return _mupdf.ll_fz_end_layer(dev)
       
    1: def ll_fz_end_mask(dev):
           r"""Low-level wrapper for `::fz_end_mask()`."""
>>>>>>     return _mupdf.ll_fz_end_mask(dev)
       
    1: def ll_fz_end_mask_tr(dev, fn):
           r"""Low-level wrapper for `::fz_end_mask_tr()`."""
>>>>>>     return _mupdf.ll_fz_end_mask_tr(dev, fn)
       
    1: def ll_fz_end_metatext(dev):
           r"""Low-level wrapper for `::fz_end_metatext()`."""
>>>>>>     return _mupdf.ll_fz_end_metatext(dev)
       
    1: def ll_fz_end_page(wri):
           r"""
           Low-level wrapper for `::fz_end_page()`.
           Called to end the process of writing a page to a
           document.
           """
>>>>>>     return _mupdf.ll_fz_end_page(wri)
       
    1: def ll_fz_end_structure(dev):
           r"""Low-level wrapper for `::fz_end_structure()`."""
>>>>>>     return _mupdf.ll_fz_end_structure(dev)
       
    1: def ll_fz_end_throw_on_repair():
           r"""Low-level wrapper for `::fz_end_throw_on_repair()`."""
>>>>>>     return _mupdf.ll_fz_end_throw_on_repair()
       
    1: def ll_fz_end_tile(dev):
           r"""Low-level wrapper for `::fz_end_tile()`."""
>>>>>>     return _mupdf.ll_fz_end_tile(dev)
       
    1: def ll_fz_enumerate_font_cmap(font, cb, opaque):
           r"""
           Low-level wrapper for `::fz_enumerate_font_cmap()`.
           Enumerate a cmap using a callback.
           """
>>>>>>     return _mupdf.ll_fz_enumerate_font_cmap(font, cb, opaque)
       
    1: def ll_fz_enumerate_font_cmap2(font):
           r"""Low-level wrapper for `::fz_enumerate_font_cmap2()`.  SWIG-friendly wrapper for fz_enumerate_font_cmap()."""
>>>>>>     return _mupdf.ll_fz_enumerate_font_cmap2(font)
       
    1: def ll_fz_error_callback(user):
           r"""
            Low-level wrapper for `::fz_error_callback()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_error_callback()` => `(fz_error_cb *, void *user)`
       
               Retrieve the currently set error callback, or NULL if none
               has been set. Optionally, if user is non-NULL, the user pointer
               given when the warning callback was set is also passed back to
               the caller.
           """
>>>>>>     return _mupdf.ll_fz_error_callback(user)
       
    1: def ll_fz_eval_function(func, _in, inlen, out, outlen):
           r"""
            Low-level wrapper for `::fz_eval_function()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_eval_function(::fz_function *func, const float *in, int inlen, int outlen)` => float out
           """
>>>>>>     return _mupdf.ll_fz_eval_function(func, _in, inlen, out, outlen)
       
    1: def ll_fz_expand_irect(a, expand):
           r"""Low-level wrapper for `::fz_expand_irect()`."""
>>>>>>     return _mupdf.ll_fz_expand_irect(a, expand)
       
    1: def ll_fz_expand_rect(b, expand):
           r"""
           Low-level wrapper for `::fz_expand_rect()`.
           Expand a bbox by a given amount in all directions.
           """
>>>>>>     return _mupdf.ll_fz_expand_rect(b, expand)
       
    1: def ll_fz_extract_ttf_from_ttc(font):
           r"""Low-level wrapper for `::fz_extract_ttf_from_ttc()`."""
>>>>>>     return _mupdf.ll_fz_extract_ttf_from_ttc(font)
       
    1: def ll_fz_file_exists(path):
           r"""
           Low-level wrapper for `::fz_file_exists()`.
           Return true if the named file exists and is readable.
           """
>>>>>>     return _mupdf.ll_fz_file_exists(path)
       
    1: def ll_fz_fill_image(dev, image, ctm, alpha, color_params):
           r"""Low-level wrapper for `::fz_fill_image()`."""
>>>>>>     return _mupdf.ll_fz_fill_image(dev, image, ctm, alpha, color_params)
       
    1: def ll_fz_fill_image_mask(dev, image, ctm, colorspace, color, alpha, color_params):
           r"""Low-level wrapper for `::fz_fill_image_mask()`."""
>>>>>>     return _mupdf.ll_fz_fill_image_mask(dev, image, ctm, colorspace, color, alpha, color_params)
       
    1: def ll_fz_fill_path(dev, path, even_odd, ctm, colorspace, color, alpha, color_params):
           r"""
           Low-level wrapper for `::fz_fill_path()`.
           Device calls; graphics primitives and containers.
           """
>>>>>>     return _mupdf.ll_fz_fill_path(dev, path, even_odd, ctm, colorspace, color, alpha, color_params)
       
    1: def ll_fz_fill_pixmap_from_display_list(list, ctm, pix):
           r"""Low-level wrapper for `::fz_fill_pixmap_from_display_list()`."""
>>>>>>     return _mupdf.ll_fz_fill_pixmap_from_display_list(list, ctm, pix)
       
    1: def ll_fz_fill_pixmap_with_color(pix, colorspace, color, color_params):
           r"""
            Low-level wrapper for `::fz_fill_pixmap_with_color()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_fill_pixmap_with_color(::fz_pixmap *pix, ::fz_colorspace *colorspace, ::fz_color_params color_params)` => float color
       
               Fill pixmap with solid color.
           """
>>>>>>     return _mupdf.ll_fz_fill_pixmap_with_color(pix, colorspace, color, color_params)
       
    1: def ll_fz_fill_shade(dev, shade, ctm, alpha, color_params):
           r"""Low-level wrapper for `::fz_fill_shade()`."""
>>>>>>     return _mupdf.ll_fz_fill_shade(dev, shade, ctm, alpha, color_params)
       
    1: def ll_fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params):
           r"""Low-level wrapper for `::fz_fill_text()`."""
>>>>>>     return _mupdf.ll_fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params)
       
    1: def ll_fz_filter_store(fn, arg, type):
           r"""
           Low-level wrapper for `::fz_filter_store()`.
           Filter every element in the store with a matching type with the
           given function.
       
           If the function returns 1 for an element, drop the element.
           """
>>>>>>     return _mupdf.ll_fz_filter_store(fn, arg, type)
       
    1: def ll_fz_find_item(drop, key, type):
           r"""
           Low-level wrapper for `::fz_find_item()`.
           Find an item within the store.
       
           drop: The function used to free the value (to ensure we get a
           value of the correct type).
       
           key: The key used to index the item.
       
           type: Functions used to manipulate the key.
       
           Returns NULL for not found, otherwise returns a pointer to the
           value indexed by key to which a reference has been taken.
           """
>>>>>>     return _mupdf.ll_fz_find_item(drop, key, type)
       
    1: def ll_fz_find_table_within_bounds(page, bounds):
           r"""
           Low-level wrapper for `::fz_find_table_within_bounds()`.
           Interpret the bounded contents of a given stext page as
           a table.
       
           The page contents will be rewritten to contain a Table
           structure with the identified content in it.
       
           This uses the same logic as for fz_table_hunt, without the
           actual hunting. fz_table_hunt hunts to find possible bounds
           for multiple tables on the page; this routine just finds a
           single table contained within the given rectangle.
       
           Returns the stext_block list that contains the content of
           the table.
           """
>>>>>>     return _mupdf.ll_fz_find_table_within_bounds(page, bounds)
       
    1: def ll_fz_flush_output(out):
           r"""
           Low-level wrapper for `::fz_flush_output()`.
           Flush unwritten data.
           """
>>>>>>     return _mupdf.ll_fz_flush_output(out)
       
    1: def ll_fz_flush_warnings():
           r"""
           Low-level wrapper for `::fz_flush_warnings()`.
           Flush any repeated warnings.
       
           Repeated warnings are buffered, counted and eventually printed
           along with the number of repetitions. Call fz_flush_warnings
           to force printing of the latest buffered warning and the
           number of repetitions, for example to make sure that all
           warnings are printed before exiting an application.
           """
>>>>>>     return _mupdf.ll_fz_flush_warnings()
       
    1: def ll_fz_font_ascender(font):
           r"""
           Low-level wrapper for `::fz_font_ascender()`.
           Retrieve font ascender in ems.
           """
>>>>>>     return _mupdf.ll_fz_font_ascender(font)
       
    1: def ll_fz_font_bbox(font):
           r"""
           Low-level wrapper for `::fz_font_bbox()`.
           Retrieve the font bbox.
       
           font: The font to query.
       
           Returns the font bbox by value; it is valid only if
           fz_font_flags(font)->invalid_bbox is zero.
           """
>>>>>>     return _mupdf.ll_fz_font_bbox(font)
       
    1: def ll_fz_font_descender(font):
           r"""
           Low-level wrapper for `::fz_font_descender()`.
           Retrieve font descender in ems.
           """
>>>>>>     return _mupdf.ll_fz_font_descender(font)
       
    1: def ll_fz_font_digest(font, digest):
           r"""
           Low-level wrapper for `::fz_font_digest()`.
           Retrieve the MD5 digest for the font's data.
           """
>>>>>>     return _mupdf.ll_fz_font_digest(font, digest)
       
    1: def ll_fz_font_flags(font):
           r"""
           Low-level wrapper for `::fz_font_flags()`.
           Retrieve a pointer to the font flags
           for a given font. These can then be updated as required.
       
           font: The font to query
       
           Returns a pointer to the flags structure (or NULL, if
           the font is NULL).
           """
>>>>>>     return _mupdf.ll_fz_font_flags(font)
       
    1: def ll_fz_font_ft_face(font):
           r"""
           Low-level wrapper for `::fz_font_ft_face()`.
           Retrieve the FT_Face handle
           for the font.
       
           font: The font to query
       
           Returns the FT_Face handle for the font, or NULL
           if not a freetype handled font. (Cast to void *
           to avoid nasty header exposure).
           """
>>>>>>     return _mupdf.ll_fz_font_ft_face(font)
       
    1: def ll_fz_font_is_bold(font):
           r"""
           Low-level wrapper for `::fz_font_is_bold()`.
           Query whether the font flags say that this font is bold.
           """
>>>>>>     return _mupdf.ll_fz_font_is_bold(font)
       
    1: def ll_fz_font_is_italic(font):
           r"""
           Low-level wrapper for `::fz_font_is_italic()`.
           Query whether the font flags say that this font is italic.
           """
>>>>>>     return _mupdf.ll_fz_font_is_italic(font)
       
    1: def ll_fz_font_is_monospaced(font):
           r"""
           Low-level wrapper for `::fz_font_is_monospaced()`.
           Query whether the font flags say that this font is monospaced.
           """
>>>>>>     return _mupdf.ll_fz_font_is_monospaced(font)
       
    1: def ll_fz_font_is_serif(font):
           r"""
           Low-level wrapper for `::fz_font_is_serif()`.
           Query whether the font flags say that this font is serif.
           """
>>>>>>     return _mupdf.ll_fz_font_is_serif(font)
       
    1: def ll_fz_font_name(font):
           r"""
           Low-level wrapper for `::fz_font_name()`.
           Retrieve a pointer to the name of the font.
       
           font: The font to query.
       
           Returns a pointer to an internal copy of the font name.
           Will never be NULL, but may be the empty string.
           """
>>>>>>     return _mupdf.ll_fz_font_name(font)
       
    1: def ll_fz_font_shaper_data(font):
           r"""
           Low-level wrapper for `::fz_font_shaper_data()`.
           Retrieve a pointer to the shaper data
           structure for the given font.
       
           font: The font to query.
       
           Returns a pointer to the shaper data structure (or NULL if
           font is NULL).
           """
>>>>>>     return _mupdf.ll_fz_font_shaper_data(font)
       
    1: def ll_fz_font_t3_procs(font):
           r"""
           Low-level wrapper for `::fz_font_t3_procs()`.
           Retrieve the Type3 procs
           for a font.
       
           font: The font to query
       
           Returns the t3_procs pointer. Will be NULL for a
           non type-3 font.
           """
>>>>>>     return _mupdf.ll_fz_font_t3_procs(font)
       
    1: def ll_fz_format_double(fmt, value):
           r"""
            Low-level wrapper for `::fz_format_double()`.  Swig-friendly and typesafe way to do fz_snprintf(fmt, value). `fmt`
           must end with one of 'efg' otherwise we throw an exception.
           """
>>>>>>     return _mupdf.ll_fz_format_double(fmt, value)
       
    1: def ll_fz_format_link_uri(doc, dest):
           r"""
           Low-level wrapper for `::fz_format_link_uri()`.
           Format an internal link to a page number, location, and possible viewing parameters,
           suitable for use with fz_create_link.
       
           Returns a newly allocated string that the caller must free.
           """
>>>>>>     return _mupdf.ll_fz_format_link_uri(doc, dest)
       
    1: def ll_fz_format_output_path(path, size, fmt, page):
           r"""
           Low-level wrapper for `::fz_format_output_path()`.
           create output file name using a template.
       
           If the path contains %[0-9]*d, the first such pattern will be
           replaced with the page number. If the template does not contain
           such a pattern, the page number will be inserted before the
           filename extension. If the template does not have a filename
           extension, the page number will be added to the end.
           """
>>>>>>     return _mupdf.ll_fz_format_output_path(path, size, fmt, page)
       
    1: def ll_fz_free(p):
           r"""
           Low-level wrapper for `::fz_free()`.
           Free a previously allocated block of memory.
       
           fz_free(ctx, NULL) does nothing.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_free(p)
       
    1: def ll_fz_free_aligned(p):
           r"""
           Low-level wrapper for `::fz_free_aligned()`.
           fz_free equivalent, for blocks allocated via fz_malloc_aligned.
           """
>>>>>>     return _mupdf.ll_fz_free_aligned(p)
       
    1: def ll_fz_ft_lock():
           r"""Low-level wrapper for `::fz_ft_lock()`."""
>>>>>>     return _mupdf.ll_fz_ft_lock()
       
    1: def ll_fz_ft_lock_held():
           r"""Low-level wrapper for `::fz_ft_lock_held()`."""
>>>>>>     return _mupdf.ll_fz_ft_lock_held()
       
    1: def ll_fz_ft_unlock():
           r"""Low-level wrapper for `::fz_ft_unlock()`."""
>>>>>>     return _mupdf.ll_fz_ft_unlock()
       
    1: def ll_fz_function_size(func):
           r"""Low-level wrapper for `::fz_function_size()`."""
>>>>>>     return _mupdf.ll_fz_function_size(func)
       
    1: def ll_fz_gamma_pixmap(pix, gamma):
           r"""
           Low-level wrapper for `::fz_gamma_pixmap()`.
           Apply gamma correction to a pixmap. All components
           of all pixels are modified (except alpha, which is unchanged).
       
           gamma: The gamma value to apply; 1.0 for no change.
           """
>>>>>>     return _mupdf.ll_fz_gamma_pixmap(pix, gamma)
       
    1: def ll_fz_generate_transition(tpix, opix, npix, time, trans):
           r"""
           Low-level wrapper for `::fz_generate_transition()`.
           Generate a frame of a transition.
       
           tpix: Target pixmap
           opix: Old pixmap
           npix: New pixmap
           time: Position within the transition (0 to 256)
           trans: Transition details
       
           Returns 1 if successfully generated a frame.
       
           Note: Pixmaps must include alpha.
           """
>>>>>>     return _mupdf.ll_fz_generate_transition(tpix, opix, npix, time, trans)
       
    1: def ll_fz_get_glyph_name(font, glyph, buf, size):
           r"""
           Low-level wrapper for `::fz_get_glyph_name()`.
           Find the name of a glyph
       
           font: The font to look for the glyph in.
       
           glyph: The glyph id to look for.
       
           buf: Pointer to a buffer for the name to be inserted into.
       
           size: The size of the buffer.
       
           If a font contains a name table, then the name of the glyph
           will be returned in the supplied buffer. Otherwise a name
           is synthesised. The name will be truncated to fit in
           the buffer.
           """
>>>>>>     return _mupdf.ll_fz_get_glyph_name(font, glyph, buf, size)
       
    1: def ll_fz_get_glyph_name2(font, glyph):
           r"""
            Low-level wrapper for `::fz_get_glyph_name2()`.
           C++ alternative to fz_get_glyph_name() that returns information in a std::string.
           """
>>>>>>     return _mupdf.ll_fz_get_glyph_name2(font, glyph)
       
    1: def ll_fz_get_pixmap_from_image(image, subarea, ctm, w, h):
           r"""
            Low-level wrapper for `::fz_get_pixmap_from_image()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_get_pixmap_from_image(::fz_image *image, const ::fz_irect *subarea, ::fz_matrix *ctm)` => `(fz_pixmap *, int w, int h)`
       
               Called to get a handle to a pixmap from an image.
       
               image: The image to retrieve a pixmap from.
       
               subarea: The subarea of the image that we actually care about
               (or NULL to indicate the whole image).
       
               ctm: Optional, unless subarea is given. If given, then on
               entry this is the transform that will be applied to the complete
               image. It should be updated on exit to the transform to apply to
               the given subarea of the image. This is used to calculate the
               desired width/height for subsampling.
       
               w: If non-NULL, a pointer to an int to be updated on exit to the
               width (in pixels) that the scaled output will cover.
       
               h: If non-NULL, a pointer to an int to be updated on exit to the
               height (in pixels) that the scaled output will cover.
       
               Returns a non NULL kept pixmap pointer. May throw exceptions.
           """
>>>>>>     return _mupdf.ll_fz_get_pixmap_from_image(image, subarea, ctm, w, h)
       
    1: def ll_fz_get_unscaled_pixmap_from_image(image):
           r"""
           Low-level wrapper for `::fz_get_unscaled_pixmap_from_image()`.
           Calls fz_get_pixmap_from_image() with ctm, subarea, w and h all set to NULL.
           """
>>>>>>     return _mupdf.ll_fz_get_unscaled_pixmap_from_image(image)
       
    1: def ll_fz_getopt(nargc, nargv, ostr):
           r"""
            Low-level wrapper for `::fz_getopt()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_getopt(int nargc, const char *ostr)` => `(int, char *nargv)`
       
               Identical to fz_getopt_long, but with a NULL longopts field, signifying no long
               options.
           """
>>>>>>     return _mupdf.ll_fz_getopt(nargc, nargv, ostr)
       
    1: def ll_fz_getopt_long(nargc, nargv, ostr, longopts):
           r"""
            Low-level wrapper for `::fz_getopt_long()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_getopt_long(int nargc, const char *ostr, const ::fz_getopt_long_options *longopts)` => `(int, char *nargv)`
       
               Simple functions/variables for use in tools.
       
               ostr = option string. Comprises single letter options, followed by : if there
               is an argument to the option.
       
               longopts: NULL (indicating no long options), or a pointer to an array of
               longoptions, terminated by an entry with option == NULL.
       
               In the event of matching a single char option, this function will normally
               return the char. The exception to this is when the option requires an
               argument and none is supplied; in this case we return ':'.
       
               In the event of matching a long option, this function returns 0, with fz_optlong
               set to point to the matching option.
       
               A long option entry may be followed with : to indicate there is an argument to the
               option. If the need for an argument is specified in this way, and no argument is
               given, an error will be displayed and argument processing will stop. If an argument
               is given, and the long option record contains a non-null flag pointer, then the code
               will decode the argument and fill in that flag pointer. Specifically,
               case-insensitive matches to 'yes', 'no', 'true' and 'false' will cause a value of 0
               or 1 as appropriate to be written; failing this the arg will be interpreted as a
               decimal integer using atoi.
       
               A long option entry may be followed by an list of options (e.g. myoption=foo|bar|baz)
               and the option will be passed to fz_opt_from_list. The return value of that will be
               placed in fz_optitem. If the return value of that function is -1, then an error will
               be displayed and argument processing will stop.
       
               In the event of reaching the end of the arg list or '--', this function returns EOF.
       
               In the event of failing to match anything, an error is printed, and we return '?'.
       
               If an argument is expected for the option, then fz_optarg will be returned pointing
               at the start of the argument. Examples of supported argument formats: '-r500', '-r 500',
               '--resolution 500', '--resolution=500'.
           """
>>>>>>     return _mupdf.ll_fz_getopt_long(nargc, nargv, ostr, longopts)
       
    1: def ll_fz_glyph_bbox(glyph):
           r"""
           Low-level wrapper for `::fz_glyph_bbox()`.
           Return the bounding box of the glyph in pixels.
           """
>>>>>>     return _mupdf.ll_fz_glyph_bbox(glyph)
       
    1: def ll_fz_glyph_bbox_no_ctx(src):
           r"""Low-level wrapper for `::fz_glyph_bbox_no_ctx()`."""
>>>>>>     return _mupdf.ll_fz_glyph_bbox_no_ctx(src)
       
    1: def ll_fz_glyph_cacheable(font, gid):
           r"""
           Low-level wrapper for `::fz_glyph_cacheable()`.
           Determine if a given glyph in a font
           is cacheable. Certain glyphs in a type 3 font cannot safely
           be cached, as their appearance depends on the enclosing
           graphic state.
       
           font: The font to look for the glyph in.
       
           gif: The glyph to query.
       
           Returns non-zero if cacheable, 0 if not.
           """
>>>>>>     return _mupdf.ll_fz_glyph_cacheable(font, gid)
       
    1: def ll_fz_glyph_height(glyph):
           r"""
           Low-level wrapper for `::fz_glyph_height()`.
           Return the height of the glyph in pixels.
           """
>>>>>>     return _mupdf.ll_fz_glyph_height(glyph)
       
    1: def ll_fz_glyph_name_from_unicode_sc(unicode):
           r"""Low-level wrapper for `::fz_glyph_name_from_unicode_sc()`."""
>>>>>>     return _mupdf.ll_fz_glyph_name_from_unicode_sc(unicode)
       
    1: def ll_fz_glyph_width(glyph):
           r"""
           Low-level wrapper for `::fz_glyph_width()`.
           Return the width of the glyph in pixels.
           """
>>>>>>     return _mupdf.ll_fz_glyph_width(glyph)
       
    1: def ll_fz_graphics_aa_level():
           r"""
           Low-level wrapper for `::fz_graphics_aa_level()`.
           Get the number of bits of antialiasing we are
           using for graphics. Between 0 and 8.
           """
>>>>>>     return _mupdf.ll_fz_graphics_aa_level()
       
    1: def ll_fz_graphics_min_line_width():
           r"""
           Low-level wrapper for `::fz_graphics_min_line_width()`.
           Get the minimum line width to be
           used for stroked lines.
       
           min_line_width: The minimum line width to use (in pixels).
           """
>>>>>>     return _mupdf.ll_fz_graphics_min_line_width()
       
    1: def ll_fz_gridfit_matrix(as_tiled, m):
           r"""
           Low-level wrapper for `::fz_gridfit_matrix()`.
           Grid fit a matrix.
       
           as_tiled = 0 => adjust the matrix so that the image of the unit
           square completely covers any pixel that was touched by the
           image of the unit square under the original matrix.
       
           as_tiled = 1 => adjust the matrix so that the corners of the
           image of the unit square align with the closest integer corner
           of the image of the unit square under the original matrix.
           """
>>>>>>     return _mupdf.ll_fz_gridfit_matrix(as_tiled, m)
       
    1: def ll_fz_grisu(f, s, exp):
           r"""
            Low-level wrapper for `::fz_grisu()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_grisu(float f, char *s)` => `(int, int exp)`
           """
>>>>>>     return _mupdf.ll_fz_grisu(f, s, exp)
       
    1: def ll_fz_grow_buffer(buf):
           r"""
           Low-level wrapper for `::fz_grow_buffer()`.
           Make some space within a buffer (i.e. ensure that
           capacity > size).
           """
>>>>>>     return _mupdf.ll_fz_grow_buffer(buf)
       
    1: def ll_fz_has_archive_entry(arch, name):
           r"""
           Low-level wrapper for `::fz_has_archive_entry()`.
           Check if entry by given name exists.
       
           If named entry does not exist 0 will be returned, if it does
           exist 1 is returned.
       
           name: Entry name to look for, this must be an exact match to
           the entry name in the archive.
           """
>>>>>>     return _mupdf.ll_fz_has_archive_entry(arch, name)
       
    1: def ll_fz_has_option(opts, key, val):
           r"""
            Low-level wrapper for `::fz_has_option()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_has_option(const char *opts, const char *key)` => `(int, const char *val)`
       
               Look for a given option (key) in the opts string. Return 1 if
               it has it, and update *val to point to the value within opts.
           """
>>>>>>     return _mupdf.ll_fz_has_option(opts, key, val)
       
    1: def ll_fz_has_permission(doc, p):
           r"""
           Low-level wrapper for `::fz_has_permission()`.
           Check permission flags on document.
           """
>>>>>>     return _mupdf.ll_fz_has_permission(doc, p)
       
    1: def ll_fz_hash_filter(table, state, callback):
           r"""
           Low-level wrapper for `::fz_hash_filter()`.
           Iterate over the entries in a hash table, removing all the ones where callback returns true.
           Does NOT free the value of the entry, so the caller is expected to take care of this.
           """
>>>>>>     return _mupdf.ll_fz_hash_filter(table, state, callback)
       
    1: def ll_fz_hash_find(table, key):
           r"""
           Low-level wrapper for `::fz_hash_find()`.
           Search for a matching hash within the table, and return the
           associated value.
           """
>>>>>>     return _mupdf.ll_fz_hash_find(table, key)
       
    1: def ll_fz_hash_for_each(table, state, callback):
           r"""
           Low-level wrapper for `::fz_hash_for_each()`.
           Iterate over the entries in a hash table.
           """
>>>>>>     return _mupdf.ll_fz_hash_for_each(table, state, callback)
       
    1: def ll_fz_hash_insert(table, key, val):
           r"""
           Low-level wrapper for `::fz_hash_insert()`.
           Insert a new key/value pair into the hash table.
       
           If an existing entry with the same key is found, no change is
           made to the hash table, and a pointer to the existing value is
           returned.
       
           If no existing entry with the same key is found, ownership of
           val passes in, key is copied, and NULL is returned.
           """
>>>>>>     return _mupdf.ll_fz_hash_insert(table, key, val)
       
    1: def ll_fz_hash_remove(table, key):
           r"""
           Low-level wrapper for `::fz_hash_remove()`.
           Remove the entry for a given key.
       
           The value is NOT freed, so the caller is expected to take care
           of this.
           """
>>>>>>     return _mupdf.ll_fz_hash_remove(table, key)
       
    1: def ll_fz_hb_lock():
           r"""
           Low-level wrapper for `::fz_hb_lock()`.
           Lock against Harfbuzz being called
           simultaneously in several threads. This reuses
           FZ_LOCK_FREETYPE.
           """
>>>>>>     return _mupdf.ll_fz_hb_lock()
       
    1: def ll_fz_hb_unlock():
           r"""
           Low-level wrapper for `::fz_hb_unlock()`.
           Unlock after a Harfbuzz call. This reuses
           FZ_LOCK_FREETYPE.
           """
>>>>>>     return _mupdf.ll_fz_hb_unlock()
       
    1: def ll_fz_highlight_selection(page, a, b, quads, max_quads):
           r"""
           Low-level wrapper for `::fz_highlight_selection()`.
           Return a list of quads to highlight lines inside the selection
           points.
           """
>>>>>>     return _mupdf.ll_fz_highlight_selection(page, a, b, quads, max_quads)
       
    1: def ll_fz_highlight_selection2(page, a, b, max_quads):
           r"""
            Low-level wrapper for `::fz_highlight_selection2()`.
           C++ alternative to fz_highlight_selection() that returns quads in a
           std::vector.
           """
>>>>>>     return _mupdf.ll_fz_highlight_selection2(page, a, b, max_quads)
       
    1: def ll_fz_ignore_error():
           r"""Low-level wrapper for `::fz_ignore_error()`."""
>>>>>>     return _mupdf.ll_fz_ignore_error()
       
    1: def ll_fz_ignore_text(dev, text, ctm):
           r"""Low-level wrapper for `::fz_ignore_text()`."""
>>>>>>     return _mupdf.ll_fz_ignore_text(dev, text, ctm)
       
    1: def ll_fz_image_orientation(image):
           r"""
           Low-level wrapper for `::fz_image_orientation()`.
           Request the natural orientation of an image.
       
           This is for images (such as JPEG) that can contain internal
           specifications of rotation/flips. This is ignored by all the
           internal decode/rendering routines, but can be used by callers
           (such as the image document handler) to respect such
           specifications.
       
           The values used by MuPDF are as follows, with the equivalent
           Exif specifications given for information:
       
           0: Undefined
           1: 0 degree ccw rotation. (Exif = 1)
           2: 90 degree ccw rotation. (Exif = 8)
           3: 180 degree ccw rotation. (Exif = 3)
           4: 270 degree ccw rotation. (Exif = 6)
           5: flip on X. (Exif = 2)
           6: flip on X, then rotate ccw by 90 degrees. (Exif = 5)
           7: flip on X, then rotate ccw by 180 degrees. (Exif = 4)
           8: flip on X, then rotate ccw by 270 degrees. (Exif = 7)
           """
>>>>>>     return _mupdf.ll_fz_image_orientation(image)
       
    1: def ll_fz_image_orientation_matrix(image):
           r"""Low-level wrapper for `::fz_image_orientation_matrix()`."""
>>>>>>     return _mupdf.ll_fz_image_orientation_matrix(image)
       
    1: def ll_fz_image_resolution(image, xres, yres):
           r"""
            Low-level wrapper for `::fz_image_resolution()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_image_resolution(::fz_image *image)` => `(int xres, int yres)`
       
               Request the natural resolution
               of an image.
       
               xres, yres: Pointers to ints to be updated with the
               natural resolution of an image (or a sensible default
               if not encoded).
           """
>>>>>>     return _mupdf.ll_fz_image_resolution(image, xres, yres)
       
    1: def ll_fz_image_size(im):
           r"""
           Low-level wrapper for `::fz_image_size()`.
           Return the size of the storage used by an image.
           """
>>>>>>     return _mupdf.ll_fz_image_size(im)
       
    1: def ll_fz_image_type_name(type):
           r"""
           Low-level wrapper for `::fz_image_type_name()`.
           Map from FZ_IMAGE_* value to string.
       
           The returned string is static and therefore must not be freed.
           """
>>>>>>     return _mupdf.ll_fz_image_type_name(type)
       
    1: def ll_fz_include_point_in_rect(r, p):
           r"""
           Low-level wrapper for `::fz_include_point_in_rect()`.
           Expand a bbox to include a given point.
           To create a rectangle that encompasses a sequence of points, the
           rectangle must first be set to be the empty rectangle at one of
           the points before including the others.
           """
>>>>>>     return _mupdf.ll_fz_include_point_in_rect(r, p)
       
    1: def ll_fz_init_text_decoder(dec, encoding):
           r"""Low-level wrapper for `::fz_init_text_decoder()`."""
>>>>>>     return _mupdf.ll_fz_init_text_decoder(dec, encoding)
       
    1: def ll_fz_install_load_system_font_funcs(f, f_cjk, f_fallback):
           r"""
           Low-level wrapper for `::fz_install_load_system_font_funcs()`.
           Install functions to allow MuPDF to request fonts from the
           system.
       
           Only one set of hooks can be in use at a time.
           """
>>>>>>     return _mupdf.ll_fz_install_load_system_font_funcs(f, f_cjk, f_fallback)
       
    1: def ll_fz_install_load_system_font_funcs2(args):
           r"""
            Low-level wrapper for `::fz_install_load_system_font_funcs2()`.
           Alternative to fz_install_load_system_font_funcs() that takes args in a
           struct, to allow use from Python/C# via Swig Directors.
           """
>>>>>>     return _mupdf.ll_fz_install_load_system_font_funcs2(args)
       
    1: def ll_fz_int2_heap_debug(heap):
           r"""Low-level wrapper for `::fz_int2_heap_debug()`."""
>>>>>>     return _mupdf.ll_fz_int2_heap_debug(heap)
       
    1: def ll_fz_int2_heap_dump(out, heap):
           r"""Low-level wrapper for `::fz_int2_heap_dump()`."""
>>>>>>     return _mupdf.ll_fz_int2_heap_dump(out, heap)
       
    1: def ll_fz_int2_heap_insert(heap, v):
           r"""Low-level wrapper for `::fz_int2_heap_insert()`."""
>>>>>>     return _mupdf.ll_fz_int2_heap_insert(heap, v)
       
    1: def ll_fz_int2_heap_sort(heap):
           r"""Low-level wrapper for `::fz_int2_heap_sort()`."""
>>>>>>     return _mupdf.ll_fz_int2_heap_sort(heap)
       
    1: def ll_fz_int2_heap_uniq(heap):
           r"""Low-level wrapper for `::fz_int2_heap_uniq()`."""
>>>>>>     return _mupdf.ll_fz_int2_heap_uniq(heap)
       
    1: def ll_fz_int_heap_debug(heap):
           r"""Low-level wrapper for `::fz_int_heap_debug()`."""
>>>>>>     return _mupdf.ll_fz_int_heap_debug(heap)
       
    1: def ll_fz_int_heap_dump(out, heap):
           r"""Low-level wrapper for `::fz_int_heap_dump()`."""
>>>>>>     return _mupdf.ll_fz_int_heap_dump(out, heap)
       
    1: def ll_fz_int_heap_insert(heap, v):
           r"""Low-level wrapper for `::fz_int_heap_insert()`."""
>>>>>>     return _mupdf.ll_fz_int_heap_insert(heap, v)
       
    1: def ll_fz_int_heap_sort(heap):
           r"""Low-level wrapper for `::fz_int_heap_sort()`."""
>>>>>>     return _mupdf.ll_fz_int_heap_sort(heap)
       
    1: def ll_fz_int_heap_uniq(heap):
           r"""Low-level wrapper for `::fz_int_heap_uniq()`."""
>>>>>>     return _mupdf.ll_fz_int_heap_uniq(heap)
       
    1: def ll_fz_intersect_irect(a, b):
           r"""
           Low-level wrapper for `::fz_intersect_irect()`.
           Compute intersection of two bounding boxes.
       
           Similar to fz_intersect_rect but operates on two bounding
           boxes instead of two rectangles.
           """
>>>>>>     return _mupdf.ll_fz_intersect_irect(a, b)
       
    1: def ll_fz_intersect_rect(a, b):
           r"""
           Low-level wrapper for `::fz_intersect_rect()`.
           Compute intersection of two rectangles.
       
           Given two rectangles, update the first to be the smallest
           axis-aligned rectangle that covers the area covered by both
           given rectangles. If either rectangle is empty then the
           intersection is also empty. If either rectangle is infinite
           then the intersection is simply the non-infinite rectangle.
           Should both rectangles be infinite, then the intersection is
           also infinite.
           """
>>>>>>     return _mupdf.ll_fz_intersect_rect(a, b)
       
    1: def ll_fz_intptr_heap_debug(heap):
           r"""Low-level wrapper for `::fz_intptr_heap_debug()`."""
>>>>>>     return _mupdf.ll_fz_intptr_heap_debug(heap)
       
    1: def ll_fz_intptr_heap_dump(out, heap):
           r"""Low-level wrapper for `::fz_intptr_heap_dump()`."""
>>>>>>     return _mupdf.ll_fz_intptr_heap_dump(out, heap)
       
    1: def ll_fz_intptr_heap_insert(heap, v):
           r"""Low-level wrapper for `::fz_intptr_heap_insert()`."""
>>>>>>     return _mupdf.ll_fz_intptr_heap_insert(heap, v)
       
    1: def ll_fz_intptr_heap_sort(heap):
           r"""Low-level wrapper for `::fz_intptr_heap_sort()`."""
>>>>>>     return _mupdf.ll_fz_intptr_heap_sort(heap)
       
    1: def ll_fz_intptr_heap_uniq(heap):
           r"""Low-level wrapper for `::fz_intptr_heap_uniq()`."""
>>>>>>     return _mupdf.ll_fz_intptr_heap_uniq(heap)
       
    1: def ll_fz_invert_bitmap(bmp):
           r"""
           Low-level wrapper for `::fz_invert_bitmap()`.
           Invert bitmap.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_invert_bitmap(bmp)
       
    1: def ll_fz_invert_matrix(matrix):
           r"""
           Low-level wrapper for `::fz_invert_matrix()`.
           Create an inverse matrix.
       
           matrix: Matrix to invert. A degenerate matrix, where the
           determinant is equal to zero, can not be inverted and the
           original matrix is returned instead.
       
           Returns inverse.
           """
>>>>>>     return _mupdf.ll_fz_invert_matrix(matrix)
       
    1: def ll_fz_invert_pixmap(pix):
           r"""
           Low-level wrapper for `::fz_invert_pixmap()`.
           Invert all the pixels in a pixmap. All components (process and
           spots) of all pixels are inverted (except alpha, which is
           unchanged).
           """
>>>>>>     return _mupdf.ll_fz_invert_pixmap(pix)
       
    1: def ll_fz_invert_pixmap_alpha(pix):
           r"""
           Low-level wrapper for `::fz_invert_pixmap_alpha()`.
           Invert the alpha of all the pixels in a pixmap.
           """
>>>>>>     return _mupdf.ll_fz_invert_pixmap_alpha(pix)
       
    1: def ll_fz_invert_pixmap_luminance(pix):
           r"""
           Low-level wrapper for `::fz_invert_pixmap_luminance()`.
           Transform the pixels in a pixmap so that luminance of each
           pixel is inverted, and the chrominance remains unchanged (as
           much as accuracy allows).
       
           All components of all pixels are inverted (except alpha, which
           is unchanged). Only supports Grey and RGB bitmaps.
           """
>>>>>>     return _mupdf.ll_fz_invert_pixmap_luminance(pix)
       
    1: def ll_fz_invert_pixmap_raw(pix):
           r"""
           Low-level wrapper for `::fz_invert_pixmap_raw()`.
           Invert all the pixels in a non-premultiplied pixmap in a
           very naive manner.
           """
>>>>>>     return _mupdf.ll_fz_invert_pixmap_raw(pix)
       
    1: def ll_fz_invert_pixmap_rect(image, rect):
           r"""
           Low-level wrapper for `::fz_invert_pixmap_rect()`.
           Invert all the pixels in a given rectangle of a (premultiplied)
           pixmap. All components of all pixels in the rectangle are
           inverted (except alpha, which is unchanged).
           """
>>>>>>     return _mupdf.ll_fz_invert_pixmap_rect(image, rect)
       
    1: def ll_fz_irect_from_rect(rect):
           r"""
           Low-level wrapper for `::fz_irect_from_rect()`.
           Convert a rect into the minimal bounding box
           that covers the rectangle.
       
           Coordinates in a bounding box are integers, so rounding of the
           rects coordinates takes place. The top left corner is rounded
           upwards and left while the bottom right corner is rounded
           downwards and to the right.
           """
>>>>>>     return _mupdf.ll_fz_irect_from_rect(rect)
       
    1: def ll_fz_irect_height(r):
           r"""
           Low-level wrapper for `::fz_irect_height()`.
           Return the height of an irect. Invalid irects return 0.
           """
>>>>>>     return _mupdf.ll_fz_irect_height(r)
       
    1: def ll_fz_irect_width(r):
           r"""
           Low-level wrapper for `::fz_irect_width()`.
           Return the width of an irect. Invalid irects return 0.
           """
>>>>>>     return _mupdf.ll_fz_irect_width(r)
       
    1: def ll_fz_is_cfb_archive(file):
           r"""
           Low-level wrapper for `::fz_is_cfb_archive()`.
           Detect if stream object is a cfb archive.
       
           Assumes that the stream object is seekable.
           """
>>>>>>     return _mupdf.ll_fz_is_cfb_archive(file)
       
    1: def ll_fz_is_directory(path):
           r"""
           Low-level wrapper for `::fz_is_directory()`.
           Determine if a given path is a directory.
       
           In the case of the path not existing, or having no access
           we will return 0.
           """
>>>>>>     return _mupdf.ll_fz_is_directory(path)
       
    1: def ll_fz_is_document_reflowable(doc):
           r"""
           Low-level wrapper for `::fz_is_document_reflowable()`.
           Is the document reflowable.
       
           Returns 1 to indicate reflowable documents, otherwise 0.
           """
>>>>>>     return _mupdf.ll_fz_is_document_reflowable(doc)
       
    1: def ll_fz_is_empty_irect(r):
           r"""Low-level wrapper for `::fz_is_empty_irect()`."""
>>>>>>     return _mupdf.ll_fz_is_empty_irect(r)
       
    1: def ll_fz_is_empty_quad(q):
           r"""
           Low-level wrapper for `::fz_is_empty_quad()`.
           Is a quad empty?
           """
>>>>>>     return _mupdf.ll_fz_is_empty_quad(q)
       
    1: def ll_fz_is_empty_rect(r):
           r"""
           Low-level wrapper for `::fz_is_empty_rect()`.
           Check if rectangle is empty.
       
           An empty rectangle is defined as one whose area is zero.
           All invalid rectangles are empty.
           """
>>>>>>     return _mupdf.ll_fz_is_empty_rect(r)
       
    1: def ll_fz_is_eof(stm):
           r"""
           Low-level wrapper for `::fz_is_eof()`.
           Query if the stream has reached EOF (during normal bytewise
           reading).
       
           See fz_is_eof_bits for the equivalent function for bitwise
           reading.
           """
>>>>>>     return _mupdf.ll_fz_is_eof(stm)
       
    1: def ll_fz_is_eof_bits(stm):
           r"""
           Low-level wrapper for `::fz_is_eof_bits()`.
           Query if the stream has reached EOF (during bitwise
           reading).
       
           See fz_is_eof for the equivalent function for bytewise
           reading.
           """
>>>>>>     return _mupdf.ll_fz_is_eof_bits(stm)
       
    1: def ll_fz_is_external_link(uri):
           r"""
           Low-level wrapper for `::fz_is_external_link()`.
           Query whether a link is external to a document (determined by
           uri containing a ':', intended to match with '://' which
           separates the scheme from the scheme specific parts in URIs).
           """
>>>>>>     return _mupdf.ll_fz_is_external_link(uri)
       
    1: def ll_fz_is_identity(m):
           r"""Low-level wrapper for `::fz_is_identity()`."""
>>>>>>     return _mupdf.ll_fz_is_identity(m)
       
    1: def ll_fz_is_infinite_irect(r):
           r"""
           Low-level wrapper for `::fz_is_infinite_irect()`.
           Check if an integer rectangle
           is infinite.
           """
>>>>>>     return _mupdf.ll_fz_is_infinite_irect(r)
       
    1: def ll_fz_is_infinite_quad(q):
           r"""
           Low-level wrapper for `::fz_is_infinite_quad()`.
           Is a quad infinite?
           """
>>>>>>     return _mupdf.ll_fz_is_infinite_quad(q)
       
    1: def ll_fz_is_infinite_rect(r):
           r"""
           Low-level wrapper for `::fz_is_infinite_rect()`.
           Check if rectangle is infinite.
           """
>>>>>>     return _mupdf.ll_fz_is_infinite_rect(r)
       
    1: def ll_fz_is_irect_inside_irect(inner, outer):
           r"""
           Low-level wrapper for `::fz_is_irect_inside_irect()`.
           Inclusion test for irects.
       
           rects are assumed to be both open or both closed.
       
           No invalid rect can include any other rect.
           No invalid rect can be included by any rect.
           Empty (point) rects can include themselves.
           Empty (line) rects can include many (subline) rects.
           """
>>>>>>     return _mupdf.ll_fz_is_irect_inside_irect(inner, outer)
       
    1: def ll_fz_is_libarchive_archive(file):
           r"""
           Low-level wrapper for `::fz_is_libarchive_archive()`.
           Detect if stream object is an archive supported by libarchive.
       
           Assumes that the stream object is seekable.
           """
>>>>>>     return _mupdf.ll_fz_is_libarchive_archive(file)
       
    1: def ll_fz_is_lossy_image(image):
           r"""Low-level wrapper for `::fz_is_lossy_image()`."""
>>>>>>     return _mupdf.ll_fz_is_lossy_image(image)
       
    1: def ll_fz_is_page_range(s):
           r"""
            Low-level wrapper for `::fz_is_page_range()`.
               Check and parse string into page ranges:
           ,?(-?+|N)(-(-?+|N))?/
           """
>>>>>>     return _mupdf.ll_fz_is_page_range(s)
       
    1: def ll_fz_is_pixmap_monochrome(pixmap):
           r"""
           Low-level wrapper for `::fz_is_pixmap_monochrome()`.
           Check if the pixmap is a 1-channel image containing samples with
           only values 0 and 255
           """
>>>>>>     return _mupdf.ll_fz_is_pixmap_monochrome(pixmap)
       
    1: def ll_fz_is_point_inside_irect(x, y, r):
           r"""
           Low-level wrapper for `::fz_is_point_inside_irect()`.
           Inclusion test for irects. (Rect is assumed to be open, i.e.
           top right corner is not included).
           """
>>>>>>     return _mupdf.ll_fz_is_point_inside_irect(x, y, r)
       
    1: def ll_fz_is_point_inside_quad(p, q):
           r"""
           Low-level wrapper for `::fz_is_point_inside_quad()`.
           Inclusion test for quads.
           """
>>>>>>     return _mupdf.ll_fz_is_point_inside_quad(p, q)
       
    1: def ll_fz_is_point_inside_rect(p, r):
           r"""
           Low-level wrapper for `::fz_is_point_inside_rect()`.
           Inclusion test for rects. (Rect is assumed to be open, i.e.
           top right corner is not included).
           """
>>>>>>     return _mupdf.ll_fz_is_point_inside_rect(p, r)
       
    1: def ll_fz_is_pow2(a):
           r"""Low-level wrapper for `::fz_is_pow2()`."""
>>>>>>     return _mupdf.ll_fz_is_pow2(a)
       
    1: def ll_fz_is_quad_inside_quad(needle, haystack):
           r"""
           Low-level wrapper for `::fz_is_quad_inside_quad()`.
           Inclusion test for quad in quad.
       
           This may break down if quads are not 'well formed'.
           """
>>>>>>     return _mupdf.ll_fz_is_quad_inside_quad(needle, haystack)
       
    1: def ll_fz_is_quad_intersecting_quad(a, b):
           r"""
           Low-level wrapper for `::fz_is_quad_intersecting_quad()`.
           Intersection test for quads.
       
           This may break down if quads are not 'well formed'.
           """
>>>>>>     return _mupdf.ll_fz_is_quad_intersecting_quad(a, b)
       
    1: def ll_fz_is_rect_inside_rect(inner, outer):
           r"""
           Low-level wrapper for `::fz_is_rect_inside_rect()`.
           Inclusion test for rects.
       
           rects are assumed to be both open or both closed.
       
           No invalid rect can include any other rect.
           No invalid rect can be included by any rect.
           Empty (point) rects can include themselves.
           Empty (line) rects can include many (subline) rects.
           """
>>>>>>     return _mupdf.ll_fz_is_rect_inside_rect(inner, outer)
       
    1: def ll_fz_is_rectilinear(m):
           r"""
           Low-level wrapper for `::fz_is_rectilinear()`.
           Check if a transformation is rectilinear.
       
           Rectilinear means that no shearing is present and that any
           rotations present are a multiple of 90 degrees. Usually this
           is used to make sure that axis-aligned rectangles before the
           transformation are still axis-aligned rectangles afterwards.
           """
>>>>>>     return _mupdf.ll_fz_is_rectilinear(m)
       
    1: def ll_fz_is_tar_archive(file):
           r"""
           Low-level wrapper for `::fz_is_tar_archive()`.
           Detect if stream object is a tar archive.
       
           Assumes that the stream object is seekable.
           """
>>>>>>     return _mupdf.ll_fz_is_tar_archive(file)
       
    1: def ll_fz_is_valid_blend_colorspace(cs):
           r"""
           Low-level wrapper for `::fz_is_valid_blend_colorspace()`.
           Check to see that a colorspace is appropriate to be used as
           a blending space (i.e. only grey, rgb or cmyk).
           """
>>>>>>     return _mupdf.ll_fz_is_valid_blend_colorspace(cs)
       
    1: def ll_fz_is_valid_irect(r):
           r"""
           Low-level wrapper for `::fz_is_valid_irect()`.
           Check if an integer rectangle is valid.
           """
>>>>>>     return _mupdf.ll_fz_is_valid_irect(r)
       
    1: def ll_fz_is_valid_quad(q):
           r"""
           Low-level wrapper for `::fz_is_valid_quad()`.
           Is a quad valid?
           """
>>>>>>     return _mupdf.ll_fz_is_valid_quad(q)
       
    1: def ll_fz_is_valid_rect(r):
           r"""
           Low-level wrapper for `::fz_is_valid_rect()`.
           Check if rectangle is valid.
           """
>>>>>>     return _mupdf.ll_fz_is_valid_rect(r)
       
    1: def ll_fz_is_valid_xml_char(c):
           r"""Low-level wrapper for `::fz_is_valid_xml_char()`."""
>>>>>>     return _mupdf.ll_fz_is_valid_xml_char(c)
       
    1: def ll_fz_is_valid_xml_string(s):
           r"""Low-level wrapper for `::fz_is_valid_xml_string()`."""
>>>>>>     return _mupdf.ll_fz_is_valid_xml_string(s)
       
    1: def ll_fz_is_zip_archive(file):
           r"""
           Low-level wrapper for `::fz_is_zip_archive()`.
           Detect if stream object is a zip archive.
       
           Assumes that the stream object is seekable.
           """
>>>>>>     return _mupdf.ll_fz_is_zip_archive(file)
       
    1: def ll_fz_iso8859_1_from_unicode(u):
           r"""Low-level wrapper for `::fz_iso8859_1_from_unicode()`."""
>>>>>>     return _mupdf.ll_fz_iso8859_1_from_unicode(u)
       
    1: def ll_fz_iso8859_7_from_unicode(u):
           r"""Low-level wrapper for `::fz_iso8859_7_from_unicode()`."""
>>>>>>     return _mupdf.ll_fz_iso8859_7_from_unicode(u)
       
    1: def ll_fz_jbig2_globals_data(globals):
           r"""
           Low-level wrapper for `::fz_jbig2_globals_data()`.
           Return buffer containing jbig2 globals data stream.
           """
>>>>>>     return _mupdf.ll_fz_jbig2_globals_data(globals)
       
    1: def ll_fz_json_array_get(array, ix):
           r"""Low-level wrapper for `::fz_json_array_get()`."""
>>>>>>     return _mupdf.ll_fz_json_array_get(array, ix)
       
    1: def ll_fz_json_array_length(array):
           r"""Low-level wrapper for `::fz_json_array_length()`."""
>>>>>>     return _mupdf.ll_fz_json_array_length(array)
       
    1: def ll_fz_json_array_push(pool, array, item):
           r"""Low-level wrapper for `::fz_json_array_push()`."""
>>>>>>     return _mupdf.ll_fz_json_array_push(pool, array, item)
       
    1: def ll_fz_json_is_array(json):
           r"""Low-level wrapper for `::fz_json_is_array()`."""
>>>>>>     return _mupdf.ll_fz_json_is_array(json)
       
    1: def ll_fz_json_is_boolean(json):
           r"""Low-level wrapper for `::fz_json_is_boolean()`."""
>>>>>>     return _mupdf.ll_fz_json_is_boolean(json)
       
    1: def ll_fz_json_is_null(json):
           r"""Low-level wrapper for `::fz_json_is_null()`."""
>>>>>>     return _mupdf.ll_fz_json_is_null(json)
       
    1: def ll_fz_json_is_number(json):
           r"""Low-level wrapper for `::fz_json_is_number()`."""
>>>>>>     return _mupdf.ll_fz_json_is_number(json)
       
    1: def ll_fz_json_is_object(json):
           r"""Low-level wrapper for `::fz_json_is_object()`."""
>>>>>>     return _mupdf.ll_fz_json_is_object(json)
       
    1: def ll_fz_json_is_string(json):
           r"""Low-level wrapper for `::fz_json_is_string()`."""
>>>>>>     return _mupdf.ll_fz_json_is_string(json)
       
    1: def ll_fz_json_new_array(pool):
           r"""Low-level wrapper for `::fz_json_new_array()`."""
>>>>>>     return _mupdf.ll_fz_json_new_array(pool)
       
    1: def ll_fz_json_new_boolean(pool, x):
           r"""Low-level wrapper for `::fz_json_new_boolean()`."""
>>>>>>     return _mupdf.ll_fz_json_new_boolean(pool, x)
       
    1: def ll_fz_json_new_null(pool):
           r"""Low-level wrapper for `::fz_json_new_null()`."""
>>>>>>     return _mupdf.ll_fz_json_new_null(pool)
       
    1: def ll_fz_json_new_number(pool, number):
           r"""Low-level wrapper for `::fz_json_new_number()`."""
>>>>>>     return _mupdf.ll_fz_json_new_number(pool, number)
       
    1: def ll_fz_json_new_object(pool):
           r"""Low-level wrapper for `::fz_json_new_object()`."""
>>>>>>     return _mupdf.ll_fz_json_new_object(pool)
       
    1: def ll_fz_json_new_string(pool, string):
           r"""Low-level wrapper for `::fz_json_new_string()`."""
>>>>>>     return _mupdf.ll_fz_json_new_string(pool, string)
       
    1: def ll_fz_json_object_get(object, key):
           r"""Low-level wrapper for `::fz_json_object_get()`."""
>>>>>>     return _mupdf.ll_fz_json_object_get(object, key)
       
    1: def ll_fz_json_object_set(pool, object, key, item):
           r"""Low-level wrapper for `::fz_json_object_set()`."""
>>>>>>     return _mupdf.ll_fz_json_object_set(pool, object, key, item)
       
    1: def ll_fz_json_to_boolean(json):
           r"""Low-level wrapper for `::fz_json_to_boolean()`."""
>>>>>>     return _mupdf.ll_fz_json_to_boolean(json)
       
    1: def ll_fz_json_to_number(json):
           r"""Low-level wrapper for `::fz_json_to_number()`."""
>>>>>>     return _mupdf.ll_fz_json_to_number(json)
       
    1: def ll_fz_json_to_string(json):
           r"""Low-level wrapper for `::fz_json_to_string()`."""
>>>>>>     return _mupdf.ll_fz_json_to_string(json)
       
    1: def ll_fz_keep_archive(arch):
           r"""
           Low-level wrapper for `::fz_keep_archive()`.
           Keep a reference to an archive.
           """
>>>>>>     return _mupdf.ll_fz_keep_archive(arch)
       
    1: def ll_fz_keep_bitmap(bit):
           r"""
           Low-level wrapper for `::fz_keep_bitmap()`.
           Take an additional reference to the bitmap. The same pointer
           is returned.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_bitmap(bit)
       
    1: def ll_fz_keep_buffer(buf):
           r"""
           Low-level wrapper for `::fz_keep_buffer()`.
           Take an additional reference to the buffer. The same pointer
           is returned.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_buffer(buf)
       
    1: def ll_fz_keep_colorspace(colorspace):
           r"""
           Low-level wrapper for `::fz_keep_colorspace()`.
           Increment the reference count for the colorspace.
       
           Returns the same pointer. Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_keep_colorspace(colorspace)
       
    1: def ll_fz_keep_compressed_buffer(cbuf):
           r"""
           Low-level wrapper for `::fz_keep_compressed_buffer()`.
           Take a reference to an fz_compressed_buffer.
           """
>>>>>>     return _mupdf.ll_fz_keep_compressed_buffer(cbuf)
       
    1: def ll_fz_keep_default_colorspaces(default_cs):
           r"""
           Low-level wrapper for `::fz_keep_default_colorspaces()`.
           Keep an additional reference to the default colorspaces
           structure.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_default_colorspaces(default_cs)
       
    1: def ll_fz_keep_device(dev):
           r"""
           Low-level wrapper for `::fz_keep_device()`.
           Increment the reference count for a device. Returns the same
           pointer.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_device(dev)
       
    1: def ll_fz_keep_display_list(list):
           r"""
           Low-level wrapper for `::fz_keep_display_list()`.
           Increment the reference count for a display list. Returns the
           same pointer.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_display_list(list)
       
    1: def ll_fz_keep_document(doc):
           r"""
           Low-level wrapper for `::fz_keep_document()`.
           Increment the document reference count. The same pointer is
           returned.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_document(doc)
       
    1: def ll_fz_keep_font(font):
           r"""
           Low-level wrapper for `::fz_keep_font()`.
           Add a reference to an existing fz_font.
       
           font: The font to add a reference to.
       
           Returns the same font.
           """
>>>>>>     return _mupdf.ll_fz_keep_font(font)
       
    1: def ll_fz_keep_function(func):
           r"""Low-level wrapper for `::fz_keep_function()`."""
>>>>>>     return _mupdf.ll_fz_keep_function(func)
       
    1: def ll_fz_keep_glyph(pix):
           r"""
           Low-level wrapper for `::fz_keep_glyph()`.
           Take a reference to a glyph.
       
           pix: The glyph to increment the reference for.
       
           Returns pix.
           """
>>>>>>     return _mupdf.ll_fz_keep_glyph(pix)
       
    1: def ll_fz_keep_halftone(half):
           r"""
           Low-level wrapper for `::fz_keep_halftone()`.
           Take an additional reference to the halftone. The same pointer
           is returned.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_halftone(half)
       
    1: def ll_fz_keep_image(image):
           r"""
           Low-level wrapper for `::fz_keep_image()`.
           Increment the (normal) reference count for an image. Returns the
           same pointer.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_image(image)
       
    1: def ll_fz_keep_image_store_key(image):
           r"""
           Low-level wrapper for `::fz_keep_image_store_key()`.
           Increment the store key reference for an image. Returns the same
           pointer. (This is the count of references for an image held by
           keys in the image store).
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_image_store_key(image)
       
    1: def ll_fz_keep_imp(p, refs):
           r"""
            Low-level wrapper for `::fz_keep_imp()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_keep_imp(void *p)` => `(void *, int refs)`
           """
>>>>>>     return _mupdf.ll_fz_keep_imp(p, refs)
       
    1: def ll_fz_keep_imp16(p, refs):
           r"""
            Low-level wrapper for `::fz_keep_imp16()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_keep_imp16(void *p)` => `(void *, int16_t refs)`
           """
>>>>>>     return _mupdf.ll_fz_keep_imp16(p, refs)
       
    1: def ll_fz_keep_imp8(p, refs):
           r"""Low-level wrapper for `::fz_keep_imp8()`."""
>>>>>>     return _mupdf.ll_fz_keep_imp8(p, refs)
       
    1: def ll_fz_keep_imp8_locked(p, refs):
           r"""Low-level wrapper for `::fz_keep_imp8_locked()`."""
>>>>>>     return _mupdf.ll_fz_keep_imp8_locked(p, refs)
       
    1: def ll_fz_keep_imp_locked(p, refs):
           r"""
            Low-level wrapper for `::fz_keep_imp_locked()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_keep_imp_locked(void *p)` => `(void *, int refs)`
           """
>>>>>>     return _mupdf.ll_fz_keep_imp_locked(p, refs)
       
    1: def ll_fz_keep_jbig2_globals(globals):
           r"""
           Low-level wrapper for `::fz_keep_jbig2_globals()`.
           Increment the reference count for a jbig2 globals record.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_keep_jbig2_globals(globals)
       
    1: def ll_fz_keep_key_storable(arg_1):
           r"""
           Low-level wrapper for `::fz_keep_key_storable()`.
           Increment the (normal) reference count for a key storable
           object. Returns the same pointer.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_key_storable(arg_1)
       
    1: def ll_fz_keep_key_storable_key(arg_1):
           r"""
           Low-level wrapper for `::fz_keep_key_storable_key()`.
           Increment the (key) reference count for a key storable
           object. Returns the same pointer.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_key_storable_key(arg_1)
       
    1: def ll_fz_keep_link(link):
           r"""
           Low-level wrapper for `::fz_keep_link()`.
           Increment the reference count for a link. The same pointer is
           returned.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_link(link)
       
    1: def ll_fz_keep_outline(outline):
           r"""
           Low-level wrapper for `::fz_keep_outline()`.
           Increment the reference count. Returns the same pointer.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_outline(outline)
       
    1: def ll_fz_keep_page(page):
           r"""
           Low-level wrapper for `::fz_keep_page()`.
           Increment the reference count for the page. Returns the same
           pointer.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_page(page)
       
    1: def ll_fz_keep_path(path):
           r"""
           Low-level wrapper for `::fz_keep_path()`.
           Increment the reference count. Returns the same pointer.
       
           All paths can be kept, regardless of their packing type.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_path(path)
       
    1: def ll_fz_keep_pixmap(pix):
           r"""
           Low-level wrapper for `::fz_keep_pixmap()`.
           Increment the reference count for the pixmap. The same pointer
           is returned.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_pixmap(pix)
       
    1: def ll_fz_keep_separations(sep):
           r"""
           Low-level wrapper for `::fz_keep_separations()`.
           Increment the reference count for a separations structure.
           Returns the same pointer.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_separations(sep)
       
    1: def ll_fz_keep_shade(shade):
           r"""
           Low-level wrapper for `::fz_keep_shade()`.
           Increment the reference count for the shade structure. The
           same pointer is returned.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_shade(shade)
       
    1: def ll_fz_keep_stext_page(page):
           r"""
           Low-level wrapper for `::fz_keep_stext_page()`.
           Take a new reference to an fz_stext_page.
           """
>>>>>>     return _mupdf.ll_fz_keep_stext_page(page)
       
    1: def ll_fz_keep_storable(arg_1):
           r"""
           Low-level wrapper for `::fz_keep_storable()`.
           Increment the reference count for a storable object.
           Returns the same pointer.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_storable(arg_1)
       
    1: def ll_fz_keep_store_context():
           r"""
           Low-level wrapper for `::fz_keep_store_context()`.
           Increment the reference count for the store context. Returns
           the same pointer.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_store_context()
       
    1: def ll_fz_keep_stream(stm):
           r"""
           Low-level wrapper for `::fz_keep_stream()`.
           Increments the reference count for a stream. Returns the same
           pointer.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_stream(stm)
       
    1: def ll_fz_keep_string(str):
           r"""Low-level wrapper for `::fz_keep_string()`."""
>>>>>>     return _mupdf.ll_fz_keep_string(str)
       
    1: def ll_fz_keep_stroke_state(stroke):
           r"""
           Low-level wrapper for `::fz_keep_stroke_state()`.
           Take an additional reference to a stroke state structure.
       
           No modifications should be carried out on a stroke
           state to which more than one reference is held, as
           this can cause race conditions.
           """
>>>>>>     return _mupdf.ll_fz_keep_stroke_state(stroke)
       
    1: def ll_fz_keep_text(text):
           r"""
           Low-level wrapper for `::fz_keep_text()`.
           Increment the reference count for the text object. The same
           pointer is returned.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_keep_text(text)
       
    1: def ll_fz_keep_xml(xml):
           r"""
           Low-level wrapper for `::fz_keep_xml()`.
           Add a reference to the XML.
           """
>>>>>>     return _mupdf.ll_fz_keep_xml(xml)
       
    1: def ll_fz_koi8u_from_unicode(u):
           r"""Low-level wrapper for `::fz_koi8u_from_unicode()`."""
>>>>>>     return _mupdf.ll_fz_koi8u_from_unicode(u)
       
    1: def ll_fz_last_page(doc):
           r"""
           Low-level wrapper for `::fz_last_page()`.
           Function to get the location for the last page in the document.
           Using this can be far more efficient in some cases than calling
           fz_count_pages and using the page number.
           """
>>>>>>     return _mupdf.ll_fz_last_page(doc)
       
    1: def ll_fz_layout_document(doc, w, h, em):
           r"""
           Low-level wrapper for `::fz_layout_document()`.
           Layout reflowable document types.
       
           w, h: Page size in points.
           em: Default font size in points.
           """
>>>>>>     return _mupdf.ll_fz_layout_document(doc, w, h, em)
       
    1: def ll_fz_linecap_from_string(s):
           r"""Low-level wrapper for `::fz_linecap_from_string()`."""
>>>>>>     return _mupdf.ll_fz_linecap_from_string(s)
       
    1: def ll_fz_linejoin_from_string(s):
           r"""Low-level wrapper for `::fz_linejoin_from_string()`."""
>>>>>>     return _mupdf.ll_fz_linejoin_from_string(s)
       
    1: def ll_fz_lineto(path, x, y):
           r"""
           Low-level wrapper for `::fz_lineto()`.
           Append a 'lineto' command to an open path.
       
           path: The path to modify.
       
           x, y: The coordinate to line to.
       
           Throws exceptions on failure to allocate, or attempting to
           modify a packed path.
           """
>>>>>>     return _mupdf.ll_fz_lineto(path, x, y)
       
    1: def ll_fz_list_archive_entry(arch, idx):
           r"""
           Low-level wrapper for `::fz_list_archive_entry()`.
           Get listed name of entry position idx.
       
           idx: Must be a value >= 0 < return value from
           fz_count_archive_entries. If not in range NULL will be
           returned.
       
           May throw an exception if this type of archive cannot list the
           entries (such as a directory).
           """
>>>>>>     return _mupdf.ll_fz_list_archive_entry(arch, idx)
       
    1: def ll_fz_load_bmp_subimage(buf, len, subimage):
           r"""Low-level wrapper for `::fz_load_bmp_subimage()`."""
>>>>>>     return _mupdf.ll_fz_load_bmp_subimage(buf, len, subimage)
       
    1: def ll_fz_load_bmp_subimage_count(buf, len):
           r"""Low-level wrapper for `::fz_load_bmp_subimage_count()`."""
>>>>>>     return _mupdf.ll_fz_load_bmp_subimage_count(buf, len)
       
    1: def ll_fz_load_chapter_page(doc, chapter, page):
           r"""
           Low-level wrapper for `::fz_load_chapter_page()`.
           Load a page.
       
           After fz_load_page is it possible to retrieve the size of the
           page using fz_bound_page, or to render the page using
           fz_run_page_*. Free the page by calling fz_drop_page.
       
           chapter: chapter number, 0 is the first chapter of the document.
           number: page number, 0 is the first page of the chapter.
           """
>>>>>>     return _mupdf.ll_fz_load_chapter_page(doc, chapter, page)
       
    1: def ll_fz_load_fallback_font(script, language, serif, bold, italic):
           r"""
           Low-level wrapper for `::fz_load_fallback_font()`.
           Try to load a fallback font for the
           given combination of font attributes. Whether a font is
           present or not will depend on the configuration in which
           MuPDF is built.
       
           script: The script desired (e.g. UCDN_SCRIPT_KATAKANA).
       
           language: The language desired (e.g. FZ_LANG_ja).
       
           serif: 1 if serif desired, 0 otherwise.
       
           bold: 1 if bold desired, 0 otherwise.
       
           italic: 1 if italic desired, 0 otherwise.
       
           Returns a new font handle, or NULL if not available.
           """
>>>>>>     return _mupdf.ll_fz_load_fallback_font(script, language, serif, bold, italic)
       
    1: def ll_fz_load_jbig2_globals(buf):
           r"""
           Low-level wrapper for `::fz_load_jbig2_globals()`.
           Create a jbig2 globals record from a buffer.
       
           Immutable once created.
           """
>>>>>>     return _mupdf.ll_fz_load_jbig2_globals(buf)
       
    1: def ll_fz_load_jbig2_subimage(buf, len, subimage):
           r"""Low-level wrapper for `::fz_load_jbig2_subimage()`."""
>>>>>>     return _mupdf.ll_fz_load_jbig2_subimage(buf, len, subimage)
       
    1: def ll_fz_load_jbig2_subimage_count(buf, len):
           r"""Low-level wrapper for `::fz_load_jbig2_subimage_count()`."""
>>>>>>     return _mupdf.ll_fz_load_jbig2_subimage_count(buf, len)
       
    1: def ll_fz_load_jpx(data, size, cs):
           r"""
           Low-level wrapper for `::fz_load_jpx()`.
           Exposed for PDF.
           """
>>>>>>     return _mupdf.ll_fz_load_jpx(data, size, cs)
       
    1: def ll_fz_load_links(page):
           r"""
           Low-level wrapper for `::fz_load_links()`.
           Load the list of links for a page.
       
           Returns a linked list of all the links on the page, each with
           its clickable region and link destination. Each link is
           reference counted so drop and free the list of links by
           calling fz_drop_link on the pointer return from fz_load_links.
       
           page: Page obtained from fz_load_page.
           """
>>>>>>     return _mupdf.ll_fz_load_links(page)
       
    1: def ll_fz_load_outline(doc):
           r"""
           Low-level wrapper for `::fz_load_outline()`.
           Load the hierarchical document outline.
       
           Should be freed by fz_drop_outline.
           """
>>>>>>     return _mupdf.ll_fz_load_outline(doc)
       
    1: def ll_fz_load_outline_from_iterator(iter):
           r"""
           Low-level wrapper for `::fz_load_outline_from_iterator()`.
           Routine to implement the old Structure based API from an iterator.
           """
>>>>>>     return _mupdf.ll_fz_load_outline_from_iterator(iter)
       
    1: def ll_fz_load_page(doc, number):
           r"""
           Low-level wrapper for `::fz_load_page()`.
           Load a given page number from a document. This may be much less
           efficient than loading by location (chapter+page) for some
           document types.
           """
>>>>>>     return _mupdf.ll_fz_load_page(doc, number)
       
    1: def ll_fz_load_pnm_subimage(buf, len, subimage):
           r"""Low-level wrapper for `::fz_load_pnm_subimage()`."""
>>>>>>     return _mupdf.ll_fz_load_pnm_subimage(buf, len, subimage)
       
    1: def ll_fz_load_pnm_subimage_count(buf, len):
           r"""Low-level wrapper for `::fz_load_pnm_subimage_count()`."""
>>>>>>     return _mupdf.ll_fz_load_pnm_subimage_count(buf, len)
       
    1: def ll_fz_load_system_cjk_font(name, ordering, serif):
           r"""
           Low-level wrapper for `::fz_load_system_cjk_font()`.
           Attempt to load a given font from
           the system.
       
           name: The name of the desired font.
       
           ordering: The ordering to load the font from (e.g. FZ_ADOBE_KOREA)
       
           serif: 1 if serif desired, 0 otherwise.
       
           Returns a new font handle, or NULL if no matching font was found
           (or on error).
           """
>>>>>>     return _mupdf.ll_fz_load_system_cjk_font(name, ordering, serif)
       
    1: def ll_fz_load_system_font(name, bold, italic, needs_exact_metrics):
           r"""
           Low-level wrapper for `::fz_load_system_font()`.
           Attempt to load a given font from the system.
       
           name: The name of the desired font.
       
           bold: 1 if bold desired, 0 otherwise.
       
           italic: 1 if italic desired, 0 otherwise.
       
           needs_exact_metrics: 1 if an exact metrical match is required,
           0 otherwise.
       
           Returns a new font handle, or NULL if no matching font was found
           (or on error).
           """
>>>>>>     return _mupdf.ll_fz_load_system_font(name, bold, italic, needs_exact_metrics)
       
    1: def ll_fz_load_tiff_subimage(buf, len, subimage):
           r"""Low-level wrapper for `::fz_load_tiff_subimage()`."""
>>>>>>     return _mupdf.ll_fz_load_tiff_subimage(buf, len, subimage)
       
    1: def ll_fz_load_tiff_subimage_count(buf, len):
           r"""
           Low-level wrapper for `::fz_load_tiff_subimage_count()`.
           Exposed for CBZ.
           """
>>>>>>     return _mupdf.ll_fz_load_tiff_subimage_count(buf, len)
       
    1: def ll_fz_load_user_css(filename):
           r"""
           Low-level wrapper for `::fz_load_user_css()`.
           Set the user stylesheet by loading the source from a file.
           If the file is missing, do nothing.
           """
>>>>>>     return _mupdf.ll_fz_load_user_css(filename)
       
    1: def ll_fz_location_from_page_number(doc, number):
           r"""
           Low-level wrapper for `::fz_location_from_page_number()`.
           Converts from page number to chapter+page. This may cause many
           chapters to be laid out in order to calculate the number of
           pages within those chapters.
           """
>>>>>>     return _mupdf.ll_fz_location_from_page_number(doc, number)
       
    1: def ll_fz_lock(lock):
           r"""
           Low-level wrapper for `::fz_lock()`.
           Lock one of the user supplied mutexes.
           """
>>>>>>     return _mupdf.ll_fz_lock(lock)
       
    1: def ll_fz_log_error(str):
           r"""
           Low-level wrapper for `::fz_log_error()`.
           Log a (preformatted) string to the registered
           error stream (stderr by default).
           """
>>>>>>     return _mupdf.ll_fz_log_error(str)
       
    1: def ll_fz_lookup_base14_font(name, len):
           r"""
            Low-level wrapper for `::fz_lookup_base14_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_lookup_base14_font(const char *name)` => `(const unsigned char *, int len)`
       
               Search the builtin base14 fonts for a match.
               Whether a given font is present or not will depend on the
               configuration in which MuPDF is built.
       
               name: The name of the font desired.
       
               len: Pointer to a place to receive the length of the discovered
               font buffer.
       
               Returns a pointer to the font file data, or NULL if not present.
           """
>>>>>>     return _mupdf.ll_fz_lookup_base14_font(name, len)
       
    1: def ll_fz_lookup_blendmode(name):
           r"""
           Low-level wrapper for `::fz_lookup_blendmode()`.
           Map from (case sensitive) blend mode string to enumeration.
           """
>>>>>>     return _mupdf.ll_fz_lookup_blendmode(name)
       
    1: def ll_fz_lookup_bookmark(doc, mark):
           r"""
           Low-level wrapper for `::fz_lookup_bookmark()`.
           Find a bookmark and return its page number.
           """
>>>>>>     return _mupdf.ll_fz_lookup_bookmark(doc, mark)
       
    1: def ll_fz_lookup_builtin_font(name, bold, italic, len):
           r"""
            Low-level wrapper for `::fz_lookup_builtin_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_lookup_builtin_font(const char *name, int bold, int italic)` => `(const unsigned char *, int len)`
       
               Search the builtin fonts for a match.
               Whether a given font is present or not will depend on the
               configuration in which MuPDF is built.
       
               name: The name of the font desired.
       
               bold: 1 if bold desired, 0 otherwise.
       
               italic: 1 if italic desired, 0 otherwise.
       
               len: Pointer to a place to receive the length of the discovered
               font buffer.
       
               Returns a pointer to the font file data, or NULL if not present.
           """
>>>>>>     return _mupdf.ll_fz_lookup_builtin_font(name, bold, italic, len)
       
    1: def ll_fz_lookup_cjk_font(ordering, len, index):
           r"""
            Low-level wrapper for `::fz_lookup_cjk_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_lookup_cjk_font(int ordering)` => `(const unsigned char *, int len, int index)`
       
               Search the builtin cjk fonts for a match.
               Whether a font is present or not will depend on the
               configuration in which MuPDF is built.
       
               ordering: The desired ordering of the font (e.g. FZ_ADOBE_KOREA).
       
               len: Pointer to a place to receive the length of the discovered
               font buffer.
       
               Returns a pointer to the font file data, or NULL if not present.
           """
>>>>>>     return _mupdf.ll_fz_lookup_cjk_font(ordering, len, index)
       
    1: def ll_fz_lookup_cjk_font_by_language(lang, len, subfont):
           r"""
            Low-level wrapper for `::fz_lookup_cjk_font_by_language()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_lookup_cjk_font_by_language(const char *lang)` => `(const unsigned char *, int len, int subfont)`
       
               Search the builtin cjk fonts for a match for a given language.
               Whether a font is present or not will depend on the
               configuration in which MuPDF is built.
       
               lang: Pointer to a (case sensitive) language string (e.g.
               "ja", "ko", "zh-Hant" etc).
       
               len: Pointer to a place to receive the length of the discovered
               font buffer.
       
               subfont: Pointer to a place to store the subfont index of the
               discovered font.
       
               Returns a pointer to the font file data, or NULL if not present.
           """
>>>>>>     return _mupdf.ll_fz_lookup_cjk_font_by_language(lang, len, subfont)
       
    1: def ll_fz_lookup_cjk_ordering_by_language(name):
           r"""
           Low-level wrapper for `::fz_lookup_cjk_ordering_by_language()`.
           Return the matching FZ_ADOBE_* ordering
           for the given language tag, such as "zh-Hant", "zh-Hans", "ja", or "ko".
           """
>>>>>>     return _mupdf.ll_fz_lookup_cjk_ordering_by_language(name)
       
    1: def ll_fz_lookup_image_type(type):
           r"""
           Low-level wrapper for `::fz_lookup_image_type()`.
           Map from (case sensitive) image type string to FZ_IMAGE_*
           type value.
           """
>>>>>>     return _mupdf.ll_fz_lookup_image_type(type)
       
    1: def ll_fz_lookup_metadata(doc, key, buf, size):
           r"""
           Low-level wrapper for `::fz_lookup_metadata()`.
           Retrieve document meta data strings.
       
           doc: The document to query.
       
           key: Which meta data key to retrieve...
       
           Basic information:
               'format'        -- Document format and version.
               'encryption'    -- Description of the encryption used.
       
           From the document information dictionary:
               'info:Title'
               'info:Author'
               'info:Subject'
               'info:Keywords'
               'info:Creator'
               'info:Producer'
               'info:CreationDate'
               'info:ModDate'
       
           buf: The buffer to hold the results (a nul-terminated UTF-8
           string).
       
           size: Size of 'buf'.
       
           Returns the number of bytes need to store the string plus terminator
           (will be larger than 'size' if the output was truncated), or -1 if the
           key is not recognized or found.
           """
>>>>>>     return _mupdf.ll_fz_lookup_metadata(doc, key, buf, size)
       
    1: def ll_fz_lookup_metadata2(doc, key):
           r"""
            Low-level wrapper for `::fz_lookup_metadata2()`.
           C++ alternative to `fz_lookup_metadata()` that returns a `std::string`
           or calls `fz_throw()` if not found.
           """
>>>>>>     return _mupdf.ll_fz_lookup_metadata2(doc, key)
       
    1: def ll_fz_lookup_noto_boxes_font(len):
           r"""
            Low-level wrapper for `::fz_lookup_noto_boxes_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_lookup_noto_boxes_font()` => `(const unsigned char *, int len)`
           """
>>>>>>     return _mupdf.ll_fz_lookup_noto_boxes_font(len)
       
    1: def ll_fz_lookup_noto_emoji_font(len):
           r"""
            Low-level wrapper for `::fz_lookup_noto_emoji_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_lookup_noto_emoji_font()` => `(const unsigned char *, int len)`
           """
>>>>>>     return _mupdf.ll_fz_lookup_noto_emoji_font(len)
       
    1: def ll_fz_lookup_noto_font(script, lang, len, subfont):
           r"""
            Low-level wrapper for `::fz_lookup_noto_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_lookup_noto_font(int script, int lang)` => `(const unsigned char *, int len, int subfont)`
       
               Search the builtin noto fonts for a match.
               Whether a font is present or not will depend on the
               configuration in which MuPDF is built.
       
               script: The script desired (e.g. UCDN_SCRIPT_KATAKANA).
       
               lang: The language desired (e.g. FZ_LANG_ja).
       
               len: Pointer to a place to receive the length of the discovered
               font buffer.
       
               Returns a pointer to the font file data, or NULL if not present.
           """
>>>>>>     return _mupdf.ll_fz_lookup_noto_font(script, lang, len, subfont)
       
    1: def ll_fz_lookup_noto_math_font(len):
           r"""
            Low-level wrapper for `::fz_lookup_noto_math_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_lookup_noto_math_font()` => `(const unsigned char *, int len)`
       
               Search the builtin noto fonts specific symbol fonts.
               Whether a font is present or not will depend on the
               configuration in which MuPDF is built.
           """
>>>>>>     return _mupdf.ll_fz_lookup_noto_math_font(len)
       
    1: def ll_fz_lookup_noto_music_font(len):
           r"""
            Low-level wrapper for `::fz_lookup_noto_music_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_lookup_noto_music_font()` => `(const unsigned char *, int len)`
           """
>>>>>>     return _mupdf.ll_fz_lookup_noto_music_font(len)
       
    1: def ll_fz_lookup_noto_stem_from_script(script, language):
           r"""
           Low-level wrapper for `::fz_lookup_noto_stem_from_script()`.
           Look up the Noto font file name for a given script.
           From the returned font stem, you can look for Noto fonts on the system in the form:
               Noto(Sans|Serif)${STEM}-Regular.(otf|ttf)
           """
>>>>>>     return _mupdf.ll_fz_lookup_noto_stem_from_script(script, language)
       
    1: def ll_fz_lookup_noto_symbol1_font(len):
           r"""
            Low-level wrapper for `::fz_lookup_noto_symbol1_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_lookup_noto_symbol1_font()` => `(const unsigned char *, int len)`
           """
>>>>>>     return _mupdf.ll_fz_lookup_noto_symbol1_font(len)
       
    1: def ll_fz_lookup_noto_symbol2_font(len):
           r"""
            Low-level wrapper for `::fz_lookup_noto_symbol2_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_lookup_noto_symbol2_font()` => `(const unsigned char *, int len)`
           """
>>>>>>     return _mupdf.ll_fz_lookup_noto_symbol2_font(len)
       
    1: def ll_fz_lookup_rendering_intent(name):
           r"""
           Low-level wrapper for `::fz_lookup_rendering_intent()`.
           Map from (case sensitive) rendering intent string to enumeration
           value.
           """
>>>>>>     return _mupdf.ll_fz_lookup_rendering_intent(name)
       
    1: def ll_fz_lookup_script_name(script, language):
           r"""Low-level wrapper for `::fz_lookup_script_name()`."""
>>>>>>     return _mupdf.ll_fz_lookup_script_name(script, language)
       
    1: def ll_fz_make_bookmark(doc, loc):
           r"""
           Low-level wrapper for `::fz_make_bookmark()`.
           Create a bookmark for the given page, which can be used to find
           the same location after the document has been laid out with
           different parameters.
           """
>>>>>>     return _mupdf.ll_fz_make_bookmark(doc, loc)
       
    1: def ll_fz_make_irect(x0, y0, x1, y1):
           r"""Low-level wrapper for `::fz_make_irect()`."""
>>>>>>     return _mupdf.ll_fz_make_irect(x0, y0, x1, y1)
       
    1: def ll_fz_make_link_dest_none():
           r"""Low-level wrapper for `::fz_make_link_dest_none()`."""
>>>>>>     return _mupdf.ll_fz_make_link_dest_none()
       
    1: def ll_fz_make_link_dest_xyz(chapter, page, x, y, z):
           r"""Low-level wrapper for `::fz_make_link_dest_xyz()`."""
>>>>>>     return _mupdf.ll_fz_make_link_dest_xyz(chapter, page, x, y, z)
       
    1: def ll_fz_make_location(chapter, page):
           r"""
           Low-level wrapper for `::fz_make_location()`.
           Simple constructor for fz_locations.
           """
>>>>>>     return _mupdf.ll_fz_make_location(chapter, page)
       
    1: def ll_fz_make_matrix(a, b, c, d, e, f):
           r"""Low-level wrapper for `::fz_make_matrix()`."""
>>>>>>     return _mupdf.ll_fz_make_matrix(a, b, c, d, e, f)
       
    1: def ll_fz_make_point(x, y):
           r"""Low-level wrapper for `::fz_make_point()`."""
>>>>>>     return _mupdf.ll_fz_make_point(x, y)
       
    1: def ll_fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y):
           r"""
           Low-level wrapper for `::fz_make_quad()`.
           Inline convenience construction function.
           """
>>>>>>     return _mupdf.ll_fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y)
       
    1: def ll_fz_make_rect(x0, y0, x1, y1):
           r"""Low-level wrapper for `::fz_make_rect()`."""
>>>>>>     return _mupdf.ll_fz_make_rect(x0, y0, x1, y1)
       
    1: def ll_fz_malloc(size):
           r"""
           Low-level wrapper for `::fz_malloc()`.
           Allocate uninitialized memory of a given size.
           Does NOT clear the memory!
       
           May return NULL for size = 0.
       
           Throws exception in the event of failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_malloc(size)
       
    1: def ll_fz_malloc_aligned(size, align):
           r"""
           Low-level wrapper for `::fz_malloc_aligned()`.
           fz_malloc equivalent, except that the block is guaranteed aligned.
           Block must be freed later using fz_free_aligned.
           """
>>>>>>     return _mupdf.ll_fz_malloc_aligned(size, align)
       
    1: def ll_fz_malloc_no_throw(size):
           r"""
           Low-level wrapper for `::fz_malloc_no_throw()`.
           fz_malloc equivalent that returns NULL rather than throwing
           exceptions.
           """
>>>>>>     return _mupdf.ll_fz_malloc_no_throw(size)
       
    1: def ll_fz_matrix_expansion(m):
           r"""
           Low-level wrapper for `::fz_matrix_expansion()`.
           Calculate average scaling factor of matrix.
           """
>>>>>>     return _mupdf.ll_fz_matrix_expansion(m)
       
    1: def ll_fz_matrix_max_expansion(m):
           r"""
           Low-level wrapper for `::fz_matrix_max_expansion()`.
           Find the largest expansion performed by this matrix.
           (i.e. max(abs(m.a),abs(m.b),abs(m.c),abs(m.d))
           """
>>>>>>     return _mupdf.ll_fz_matrix_max_expansion(m)
       
    1: def ll_fz_max(a, b):
           r"""Low-level wrapper for `::fz_max()`."""
>>>>>>     return _mupdf.ll_fz_max(a, b)
       
    1: def ll_fz_maxi(a, b):
           r"""Low-level wrapper for `::fz_maxi()`."""
>>>>>>     return _mupdf.ll_fz_maxi(a, b)
       
    1: def ll_fz_maxi64(a, b):
           r"""Low-level wrapper for `::fz_maxi64()`."""
>>>>>>     return _mupdf.ll_fz_maxi64(a, b)
       
    1: def ll_fz_maxz(a, b):
           r"""Low-level wrapper for `::fz_maxz()`."""
>>>>>>     return _mupdf.ll_fz_maxz(a, b)
       
    1: def ll_fz_md5_buffer(buffer, digest):
           r"""
           Low-level wrapper for `::fz_md5_buffer()`.
           Create an MD5 digest from buffer contents.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_md5_buffer(buffer, digest)
       
    1: def ll_fz_md5_final(state, digest):
           r"""
           Low-level wrapper for `::fz_md5_final()`.
           MD5 finalization. Ends an MD5 message-digest operation, writing
           the message digest and zeroizing the context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_md5_final(state, digest)
       
    1: def ll_fz_md5_final2(md5):
           r"""
            Low-level wrapper for `::fz_md5_final2()`.
           C++ alternative to fz_md5_final() that returns the digest by value.
           """
>>>>>>     return _mupdf.ll_fz_md5_final2(md5)
       
    1: def ll_fz_md5_init(state):
           r"""
           Low-level wrapper for `::fz_md5_init()`.
           MD5 initialization. Begins an MD5 operation, writing a new
           context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_md5_init(state)
       
    1: def ll_fz_md5_pixmap(pixmap, digest):
           r"""Low-level wrapper for `::fz_md5_pixmap()`."""
>>>>>>     return _mupdf.ll_fz_md5_pixmap(pixmap, digest)
       
    1: def ll_fz_md5_pixmap2(pixmap):
           r"""
            Low-level wrapper for `::fz_md5_pixmap2()`.
           C++ alternative to `fz_md5_pixmap()` that returns the digest by value.
           """
>>>>>>     return _mupdf.ll_fz_md5_pixmap2(pixmap)
       
    1: def ll_fz_md5_update(state, input, inlen):
           r"""
           Low-level wrapper for `::fz_md5_update()`.
           MD5 block update operation. Continues an MD5 message-digest
           operation, processing another message block, and updating the
           context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_md5_update(state, input, inlen)
       
    1: def ll_fz_md5_update_int64(state, i):
           r"""
           Low-level wrapper for `::fz_md5_update_int64()`.
           MD5 block update operation. Continues an MD5 message-digest
           operation, processing an int64, and updating the context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_md5_update_int64(state, i)
       
    1: def ll_fz_measure_string(user_font, trm, s, wmode, bidi_level, markup_dir, language):
           r"""
           Low-level wrapper for `::fz_measure_string()`.
           Measure the advance width of a UTF8 string should it be added to a text object.
       
           This uses the same layout algorithms as fz_show_string, and can be used
           to calculate text alignment adjustments.
           """
>>>>>>     return _mupdf.ll_fz_measure_string(user_font, trm, s, wmode, bidi_level, markup_dir, language)
       
    1: def ll_fz_memmem(haystack, haystacklen, needle, needlelen):
           r"""
           Low-level wrapper for `::fz_memmem()`.
           Find the start of the first occurrence of the substring needle in haystack.
           """
>>>>>>     return _mupdf.ll_fz_memmem(haystack, haystacklen, needle, needlelen)
       
    1: def ll_fz_memrnd(block, len):
           r"""
           Low-level wrapper for `::fz_memrnd()`.
           Fill block with len bytes of pseudo-randomness.
           """
>>>>>>     return _mupdf.ll_fz_memrnd(block, len)
       
    1: def ll_fz_min(a, b):
           r"""Low-level wrapper for `::fz_min()`."""
>>>>>>     return _mupdf.ll_fz_min(a, b)
       
    1: def ll_fz_mini(a, b):
           r"""Low-level wrapper for `::fz_mini()`."""
>>>>>>     return _mupdf.ll_fz_mini(a, b)
       
    1: def ll_fz_mini64(a, b):
           r"""Low-level wrapper for `::fz_mini64()`."""
>>>>>>     return _mupdf.ll_fz_mini64(a, b)
       
    1: def ll_fz_minz(a, b):
           r"""Low-level wrapper for `::fz_minz()`."""
>>>>>>     return _mupdf.ll_fz_minz(a, b)
       
    1: def ll_fz_mkdir(path):
           r"""Low-level wrapper for `::fz_mkdir()`."""
>>>>>>     return _mupdf.ll_fz_mkdir(path)
       
    1: def ll_fz_morph_error(fromcode, tocode):
           r"""
           Low-level wrapper for `::fz_morph_error()`.
           Called within a catch block this modifies the current
           exception's code. If it's of type 'fromcode' it is
           modified to 'tocode'. Typically used for 'downgrading'
           exception severity.
           """
>>>>>>     return _mupdf.ll_fz_morph_error(fromcode, tocode)
       
    1: def ll_fz_mount_multi_archive(arch_, sub, path):
           r"""
           Low-level wrapper for `::fz_mount_multi_archive()`.
           Add an archive to the set of archives handled by a multi
           archive.
       
           If path is NULL, then the archive contents will appear at the
           top level, otherwise, the archives contents will appear prefixed
           by path.
           """
>>>>>>     return _mupdf.ll_fz_mount_multi_archive(arch_, sub, path)
       
    1: def ll_fz_moveto(path, x, y):
           r"""
           Low-level wrapper for `::fz_moveto()`.
           Append a 'moveto' command to a path.
           This 'opens' a path.
       
           path: The path to modify.
       
           x, y: The coordinate to move to.
       
           Throws exceptions on failure to allocate, or attempting to
           modify a packed path.
           """
>>>>>>     return _mupdf.ll_fz_moveto(path, x, y)
       
    1: def ll_fz_mul255(a, b):
           r"""
           Low-level wrapper for `::fz_mul255()`.
           Multiply scaled two integers in the 0..255 range
           """
>>>>>>     return _mupdf.ll_fz_mul255(a, b)
       
    1: def ll_fz_needs_password(doc):
           r"""
           Low-level wrapper for `::fz_needs_password()`.
           Check if a document is encrypted with a
           non-blank password.
           """
>>>>>>     return _mupdf.ll_fz_needs_password(doc)
       
    1: def ll_fz_new_arc4_output(chain, key, keylen):
           r"""Low-level wrapper for `::fz_new_arc4_output()`."""
>>>>>>     return _mupdf.ll_fz_new_arc4_output(chain, key, keylen)
       
    1: def ll_fz_new_archive_of_size(file, size):
           r"""Low-level wrapper for `::fz_new_archive_of_size()`."""
>>>>>>     return _mupdf.ll_fz_new_archive_of_size(file, size)
       
    1: def ll_fz_new_ascii85_output(chain):
           r"""Low-level wrapper for `::fz_new_ascii85_output()`."""
>>>>>>     return _mupdf.ll_fz_new_ascii85_output(chain)
       
    1: def ll_fz_new_asciihex_output(chain):
           r"""
           Low-level wrapper for `::fz_new_asciihex_output()`.
           Compression and other filtering outputs.
       
           These outputs write encoded data to another output. Create a
           filter output with the destination, write to the filter, then
           close and drop it when you're done. These can also be chained
           together, for example to write ASCII Hex encoded, Deflate
           compressed, and RC4 encrypted data to a buffer output.
       
           Output streams don't use reference counting, so make sure to
           close all of the filters in the reverse order of creation so
           that data is flushed properly.
       
           Accordingly, ownership of 'chain' is never passed into the
           following functions, but remains with the caller, whose
           responsibility it is to ensure they exist at least until
           the returned fz_output is dropped.
           """
>>>>>>     return _mupdf.ll_fz_new_asciihex_output(chain)
       
    1: def ll_fz_new_band_writer_of_size(size, out):
           r"""Low-level wrapper for `::fz_new_band_writer_of_size()`."""
>>>>>>     return _mupdf.ll_fz_new_band_writer_of_size(size, out)
       
    1: def ll_fz_new_barcode_image(type, value, size, ec_level, quiet, hrt):
           r"""
           Low-level wrapper for `::fz_new_barcode_image()`.
           Create an fz_image from a barcode definition.
       
           type: The type of barcode to create.
           value: The value of the barcode.
           size: The size of the barcode.
           ec_level: error correction level 0-8.
           quiet: whether to include quiet zones (0 or 1).
           hrt: whether to include human readable text below the barcode (0 or 1).
       
           returns a created fz_image.
           """
>>>>>>     return _mupdf.ll_fz_new_barcode_image(type, value, size, ec_level, quiet, hrt)
       
    1: def ll_fz_new_barcode_pixmap(type, value, size, ec_level, quiet, hrt):
           r"""
           Low-level wrapper for `::fz_new_barcode_pixmap()`.
           Create an fz_pixmap from a barcode definition.
       
           type: The type of barcode to create.
           value: The value of the barcode.
           size: The size of the barcode.
           ec_level: error correction level 0-8.
           quiet: whether to include quiet zones (0 or 1).
           hrt: whether to include human readable text below the barcode (0 or 1).
       
           returns a created fz_pixmap.
           """
>>>>>>     return _mupdf.ll_fz_new_barcode_pixmap(type, value, size, ec_level, quiet, hrt)
       
    1: def ll_fz_new_base14_font(name):
           r"""
           Low-level wrapper for `::fz_new_base14_font()`.
           Create a new font from one of the built-in fonts.
           """
>>>>>>     return _mupdf.ll_fz_new_base14_font(name)
       
    1: def ll_fz_new_bbox_device(rectp):
           r"""
           Low-level wrapper for `::fz_new_bbox_device()`.
           Create a device to compute the bounding
           box of all marks on a page.
       
           The returned bounding box will be the union of all bounding
           boxes of all objects on a page.
           """
>>>>>>     return _mupdf.ll_fz_new_bbox_device(rectp)
       
    1: def ll_fz_new_bitmap(w, h, n, xres, yres):
           r"""
           Low-level wrapper for `::fz_new_bitmap()`.
           Create a new bitmap.
       
           w, h: Width and Height for the bitmap
       
           n: Number of color components (assumed to be a divisor of 8)
       
           xres, yres: X and Y resolutions (in pixels per inch).
       
           Returns pointer to created bitmap structure. The bitmap
           data is uninitialised.
           """
>>>>>>     return _mupdf.ll_fz_new_bitmap(w, h, n, xres, yres)
       
    1: def ll_fz_new_bitmap_from_image(img, ht):
           r"""
           Low-level wrapper for `::fz_new_bitmap_from_image()`.
           Make a bitmap from a pixmap and a halftone.
       
           img: The image to generate from. Currently must be a single
           color component with no alpha.
       
           ht: The halftone to use. NULL implies the default halftone.
       
           Returns the resultant bitmap. Throws exceptions in the case of
           failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_new_bitmap_from_image(img, ht)
       
    1: def ll_fz_new_bitmap_from_pixmap(pix, ht):
           r"""
           Low-level wrapper for `::fz_new_bitmap_from_pixmap()`.
           Make a bitmap from a pixmap and a halftone.
       
           pix: The pixmap to generate from. Currently must be a single
           color component with no alpha.
       
           ht: The halftone to use. NULL implies the default halftone.
       
           Returns the resultant bitmap. Throws exceptions in the case of
           failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_new_bitmap_from_pixmap(pix, ht)
       
    1: def ll_fz_new_bitmap_from_pixmap_band(pix, ht, band_start):
           r"""
           Low-level wrapper for `::fz_new_bitmap_from_pixmap_band()`.
           Make a bitmap from a pixmap and a
           halftone, allowing for the position of the pixmap within an
           overall banded rendering.
       
           pix: The pixmap to generate from. Currently must be a single
           color component with no alpha.
       
           ht: The halftone to use. NULL implies the default halftone.
       
           band_start: Vertical offset within the overall banded rendering
           (in pixels)
       
           Returns the resultant bitmap. Throws exceptions in the case of
           failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_new_bitmap_from_pixmap_band(pix, ht, band_start)
       
    1: def ll_fz_new_brotli_data(compressed_length, source, source_length, level):
           r"""
            Low-level wrapper for `::fz_new_brotli_data()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_new_brotli_data(const unsigned char *source, size_t source_length, ::fz_brotli_level level)` => `(unsigned char *, size_t compressed_length)`
       
               Compress source_length bytes of data starting
               at source, into a new memory block malloced for that purpose.
           compressed_length is updated on exit to contain the size used.
               Ownership of the block is returned from this function, and the
               caller is therefore responsible for freeing it. The block may be
               considerably larger than is actually required. The caller is
               free to fz_realloc it down if it wants to.
           """
>>>>>>     return _mupdf.ll_fz_new_brotli_data(compressed_length, source, source_length, level)
       
    1: def ll_fz_new_brotli_data_from_buffer(compressed_length, buffer, level):
           r"""
            Low-level wrapper for `::fz_new_brotli_data_from_buffer()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_new_brotli_data_from_buffer(::fz_buffer *buffer, ::fz_brotli_level level)` => `(unsigned char *, size_t compressed_length)`
       
               Compress the contents of a fz_buffer into a
               new block malloced for that purpose. *compressed_length is
               updated on exit to contain the size used. Ownership of the block
               is returned from this function, and the caller is therefore
               responsible for freeing it. The block may be considerably larger
               than is actually required. The caller is free to fz_realloc it
               down if it wants to.
           """
>>>>>>     return _mupdf.ll_fz_new_brotli_data_from_buffer(compressed_length, buffer, level)
       
    1: def ll_fz_new_buffer(capacity):
           r"""Low-level wrapper for `::fz_new_buffer()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer(capacity)
       
    1: def ll_fz_new_buffer_from_base64(data, size):
           r"""
           Low-level wrapper for `::fz_new_buffer_from_base64()`.
           Create a new buffer with data decoded from a base64 input string.
           """
>>>>>>     return _mupdf.ll_fz_new_buffer_from_base64(data, size)
       
    1: def ll_fz_new_buffer_from_copied_data(data, size):
           r"""
           Low-level wrapper for `::fz_new_buffer_from_copied_data()`.
           Create a new buffer containing a copy of the passed data.
           """
>>>>>>     return _mupdf.ll_fz_new_buffer_from_copied_data(data, size)
       
    1: def ll_fz_new_buffer_from_data(data, size):
           r"""
           Low-level wrapper for `::fz_new_buffer_from_data()`.
           Create a new buffer with existing data.
       
           data: Pointer to existing data.
           size: Size of existing data.
       
           Takes ownership of data. Does not make a copy. Calls fz_free on
           the data when the buffer is deallocated. Do not use 'data' after
           passing to this function.
       
           Returns pointer to new buffer. Throws exception on allocation
           failure.
           """
>>>>>>     return _mupdf.ll_fz_new_buffer_from_data(data, size)
       
    1: def ll_fz_new_buffer_from_display_list(list, options):
           r"""Low-level wrapper for `::fz_new_buffer_from_display_list()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_display_list(list, options)
       
    1: def ll_fz_new_buffer_from_image_as_jpeg(image, color_params, quality, invert_cmyk):
           r"""Low-level wrapper for `::fz_new_buffer_from_image_as_jpeg()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_image_as_jpeg(image, color_params, quality, invert_cmyk)
       
    1: def ll_fz_new_buffer_from_image_as_jpx(image, color_params, quality):
           r"""Low-level wrapper for `::fz_new_buffer_from_image_as_jpx()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_image_as_jpx(image, color_params, quality)
       
    1: def ll_fz_new_buffer_from_image_as_pam(image, color_params):
           r"""Low-level wrapper for `::fz_new_buffer_from_image_as_pam()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_image_as_pam(image, color_params)
       
    1: def ll_fz_new_buffer_from_image_as_pbm(image, color_params):
           r"""Low-level wrapper for `::fz_new_buffer_from_image_as_pbm()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_image_as_pbm(image, color_params)
       
    1: def ll_fz_new_buffer_from_image_as_pkm(image, color_params):
           r"""Low-level wrapper for `::fz_new_buffer_from_image_as_pkm()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_image_as_pkm(image, color_params)
       
    1: def ll_fz_new_buffer_from_image_as_png(image, color_params):
           r"""
           Low-level wrapper for `::fz_new_buffer_from_image_as_png()`.
           Re-encode a given image as a PNG into a buffer.
       
           Ownership of the buffer is returned.
           """
>>>>>>     return _mupdf.ll_fz_new_buffer_from_image_as_png(image, color_params)
       
    1: def ll_fz_new_buffer_from_image_as_pnm(image, color_params):
           r"""Low-level wrapper for `::fz_new_buffer_from_image_as_pnm()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_image_as_pnm(image, color_params)
       
    1: def ll_fz_new_buffer_from_image_as_psd(image, color_params):
           r"""Low-level wrapper for `::fz_new_buffer_from_image_as_psd()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_image_as_psd(image, color_params)
       
    1: def ll_fz_new_buffer_from_page(page, options):
           r"""Low-level wrapper for `::fz_new_buffer_from_page()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_page(page, options)
       
    1: def ll_fz_new_buffer_from_page_number(doc, number, options):
           r"""Low-level wrapper for `::fz_new_buffer_from_page_number()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_page_number(doc, number, options)
       
    1: def ll_fz_new_buffer_from_page_with_format(page, format, options, transform, cookie):
           r"""
           Low-level wrapper for `::fz_new_buffer_from_page_with_format()`.
           Returns an fz_buffer containing a page after conversion to specified format.
       
           page: The page to convert.
           format, options: Passed to fz_new_document_writer_with_output() internally.
           transform, cookie: Passed to fz_run_page() internally.
           """
>>>>>>     return _mupdf.ll_fz_new_buffer_from_page_with_format(page, format, options, transform, cookie)
       
    1: def ll_fz_new_buffer_from_pixmap_as_jpeg(pixmap, color_params, quality, invert_cmyk):
           r"""Low-level wrapper for `::fz_new_buffer_from_pixmap_as_jpeg()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_pixmap_as_jpeg(pixmap, color_params, quality, invert_cmyk)
       
    1: def ll_fz_new_buffer_from_pixmap_as_jpx(pix, color_params, quality):
           r"""Low-level wrapper for `::fz_new_buffer_from_pixmap_as_jpx()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_pixmap_as_jpx(pix, color_params, quality)
       
    1: def ll_fz_new_buffer_from_pixmap_as_pam(pixmap, color_params):
           r"""Low-level wrapper for `::fz_new_buffer_from_pixmap_as_pam()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_pixmap_as_pam(pixmap, color_params)
       
    1: def ll_fz_new_buffer_from_pixmap_as_pbm(pixmap, color_params):
           r"""Low-level wrapper for `::fz_new_buffer_from_pixmap_as_pbm()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_pixmap_as_pbm(pixmap, color_params)
       
    1: def ll_fz_new_buffer_from_pixmap_as_pkm(pixmap, color_params):
           r"""Low-level wrapper for `::fz_new_buffer_from_pixmap_as_pkm()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_pixmap_as_pkm(pixmap, color_params)
       
    1: def ll_fz_new_buffer_from_pixmap_as_png(pixmap, color_params):
           r"""
           Low-level wrapper for `::fz_new_buffer_from_pixmap_as_png()`.
           Re-encode a given pixmap as a PNG into a buffer.
       
           Ownership of the buffer is returned.
           """
>>>>>>     return _mupdf.ll_fz_new_buffer_from_pixmap_as_png(pixmap, color_params)
       
    1: def ll_fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params):
           r"""Low-level wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params)
       
    1: def ll_fz_new_buffer_from_pixmap_as_psd(pix, color_params):
           r"""Low-level wrapper for `::fz_new_buffer_from_pixmap_as_psd()`."""
>>>>>>     return _mupdf.ll_fz_new_buffer_from_pixmap_as_psd(pix, color_params)
       
    1: def ll_fz_new_buffer_from_shared_data(data, size):
           r"""
           Low-level wrapper for `::fz_new_buffer_from_shared_data()`.
           Like fz_new_buffer, but does not take ownership.
           """
>>>>>>     return _mupdf.ll_fz_new_buffer_from_shared_data(data, size)
       
    1: def ll_fz_new_buffer_from_stext_page(text):
           r"""
           Low-level wrapper for `::fz_new_buffer_from_stext_page()`.
           Convert structured text into plain text.
           """
>>>>>>     return _mupdf.ll_fz_new_buffer_from_stext_page(text)
       
    1: def ll_fz_new_builtin_font(name, is_bold, is_italic):
           r"""Low-level wrapper for `::fz_new_builtin_font()`."""
>>>>>>     return _mupdf.ll_fz_new_builtin_font(name, is_bold, is_italic)
       
    1: def ll_fz_new_cal_gray_colorspace(wp, bp, gamma):
           r"""
           Low-level wrapper for `::fz_new_cal_gray_colorspace()`.
           Create a calibrated gray colorspace.
       
           The returned reference should be dropped when it is finished
           with.
       
           Colorspaces are immutable once created.
           """
>>>>>>     return _mupdf.ll_fz_new_cal_gray_colorspace(wp, bp, gamma)
       
    1: def ll_fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix):
           r"""
           Low-level wrapper for `::fz_new_cal_rgb_colorspace()`.
           Create a calibrated rgb colorspace.
       
           The returned reference should be dropped when it is finished
           with.
       
           Colorspaces are immutable once created.
           """
>>>>>>     return _mupdf.ll_fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix)
       
    1: def ll_fz_new_cbz_writer(path, options):
           r"""Low-level wrapper for `::fz_new_cbz_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_cbz_writer(path, options)
       
    1: def ll_fz_new_cbz_writer_with_output(out, options):
           r"""Low-level wrapper for `::fz_new_cbz_writer_with_output()`."""
>>>>>>     return _mupdf.ll_fz_new_cbz_writer_with_output(out, options)
       
    1: def ll_fz_new_cjk_font(ordering):
           r"""Low-level wrapper for `::fz_new_cjk_font()`."""
>>>>>>     return _mupdf.ll_fz_new_cjk_font(ordering)
       
    1: def ll_fz_new_color_pcl_band_writer(out, options):
           r"""
           Low-level wrapper for `::fz_new_color_pcl_band_writer()`.
           Create a new band writer, outputting color pcl.
           """
>>>>>>     return _mupdf.ll_fz_new_color_pcl_band_writer(out, options)
       
    1: def ll_fz_new_colorspace(type, flags, n, name):
           r"""
           Low-level wrapper for `::fz_new_colorspace()`.
           Creates a new colorspace instance and returns a reference.
       
           No internal checking is done that the colorspace type (e.g.
           CMYK) matches with the flags (e.g. FZ_COLORSPACE_HAS_CMYK) or
           colorant count (n) or name.
       
           The reference should be dropped when it is finished with.
       
           Colorspaces are immutable once created (with the exception of
           setting up colorant names for separation spaces).
           """
>>>>>>     return _mupdf.ll_fz_new_colorspace(type, flags, n, name)
       
    1: def ll_fz_new_compressed_buffer():
           r"""
           Low-level wrapper for `::fz_new_compressed_buffer()`.
           Create a new, UNKNOWN format, compressed_buffer.
           """
>>>>>>     return _mupdf.ll_fz_new_compressed_buffer()
       
    1: def ll_fz_new_context_imp(alloc, locks, max_store, version):
           r"""Low-level wrapper for `::fz_new_context_imp()`."""
>>>>>>     return _mupdf.ll_fz_new_context_imp(alloc, locks, max_store, version)
       
    1: def ll_fz_new_csv_writer(path, options):
           r"""Low-level wrapper for `::fz_new_csv_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_csv_writer(path, options)
       
    1: def ll_fz_new_csv_writer_with_output(out, options):
           r"""Low-level wrapper for `::fz_new_csv_writer_with_output()`."""
>>>>>>     return _mupdf.ll_fz_new_csv_writer_with_output(out, options)
       
    1: def ll_fz_new_default_colorspaces():
           r"""
           Low-level wrapper for `::fz_new_default_colorspaces()`.
           Create a new default colorspace structure with values inherited
           from the context, and return a reference to it.
       
           These can be overridden using fz_set_default_xxxx.
       
           These should not be overridden while more than one caller has
           the reference for fear of race conditions.
       
           The caller should drop this reference once finished with it.
           """
>>>>>>     return _mupdf.ll_fz_new_default_colorspaces()
       
    1: def ll_fz_new_deflate_output(chain, effort, raw):
           r"""Low-level wrapper for `::fz_new_deflate_output()`."""
>>>>>>     return _mupdf.ll_fz_new_deflate_output(chain, effort, raw)
       
    1: def ll_fz_new_deflated_data(compressed_length, source, source_length, level):
           r"""
            Low-level wrapper for `::fz_new_deflated_data()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_new_deflated_data(const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`
       
               Compress source_length bytes of data starting
               at source, into a new memory block malloced for that purpose.
           compressed_length is updated on exit to contain the size used.
               Ownership of the block is returned from this function, and the
               caller is therefore responsible for freeing it. The block may be
               considerably larger than is actually required. The caller is
               free to fz_realloc it down if it wants to.
           """
>>>>>>     return _mupdf.ll_fz_new_deflated_data(compressed_length, source, source_length, level)
       
    1: def ll_fz_new_deflated_data_from_buffer(compressed_length, buffer, level):
           r"""
            Low-level wrapper for `::fz_new_deflated_data_from_buffer()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_new_deflated_data_from_buffer(::fz_buffer *buffer, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`
       
               Compress the contents of a fz_buffer into a
               new block malloced for that purpose. *compressed_length is
               updated on exit to contain the size used. Ownership of the block
               is returned from this function, and the caller is therefore
               responsible for freeing it. The block may be considerably larger
               than is actually required. The caller is free to fz_realloc it
               down if it wants to.
           """
>>>>>>     return _mupdf.ll_fz_new_deflated_data_from_buffer(compressed_length, buffer, level)
       
    1: def ll_fz_new_device_of_size(size):
           r"""
           Low-level wrapper for `::fz_new_device_of_size()`.
           Devices are created by calls to device implementations, for
           instance: foo_new_device(). These will be implemented by calling
           fz_new_derived_device(ctx, foo_device) where foo_device is a
           structure "derived from" fz_device, for instance
           typedef struct { fz_device base;  ...extras...} foo_device;
           """
>>>>>>     return _mupdf.ll_fz_new_device_of_size(size)
       
    1: def ll_fz_new_display_list(mediabox):
           r"""
           Low-level wrapper for `::fz_new_display_list()`.
           Create an empty display list.
       
           A display list contains drawing commands (text, images, etc.).
           Use fz_new_list_device for populating the list.
       
           mediabox: Bounds of the page (in points) represented by the
           display list.
           """
>>>>>>     return _mupdf.ll_fz_new_display_list(mediabox)
       
    1: def ll_fz_new_display_list_from_page(page):
           r"""
           Low-level wrapper for `::fz_new_display_list_from_page()`.
           Create a display list.
       
           Ownership of the display list is returned to the caller.
           """
>>>>>>     return _mupdf.ll_fz_new_display_list_from_page(page)
       
    1: def ll_fz_new_display_list_from_page_contents(page):
           r"""
           Low-level wrapper for `::fz_new_display_list_from_page_contents()`.
           Create a display list from page contents (no annotations).
       
           Ownership of the display list is returned to the caller.
           """
>>>>>>     return _mupdf.ll_fz_new_display_list_from_page_contents(page)
       
    1: def ll_fz_new_display_list_from_page_number(doc, number):
           r"""Low-level wrapper for `::fz_new_display_list_from_page_number()`."""
>>>>>>     return _mupdf.ll_fz_new_display_list_from_page_number(doc, number)
       
    1: def ll_fz_new_display_list_from_svg(buf, base_uri, dir, w, h):
           r"""
            Low-level wrapper for `::fz_new_display_list_from_svg()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_new_display_list_from_svg(::fz_buffer *buf, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`
       
               Parse an SVG document into a display-list.
           """
>>>>>>     return _mupdf.ll_fz_new_display_list_from_svg(buf, base_uri, dir, w, h)
       
    1: def ll_fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir, w, h):
           r"""
            Low-level wrapper for `::fz_new_display_list_from_svg_xml()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_new_display_list_from_svg_xml(::fz_xml_doc *xmldoc, ::fz_xml *xml, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`
       
               Parse an SVG document into a display-list.
           """
>>>>>>     return _mupdf.ll_fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir, w, h)
       
    1: def ll_fz_new_document_of_size(size):
           r"""
           Low-level wrapper for `::fz_new_document_of_size()`.
           New documents are typically created by calls like
           foo_new_document(fz_context *ctx, ...). These work by
           deriving a new document type from fz_document, for instance:
           typedef struct { fz_document base; ...extras... } foo_document;
           These are allocated by calling
           fz_new_derived_document(ctx, foo_document)
           """
>>>>>>     return _mupdf.ll_fz_new_document_of_size(size)
       
    1: def ll_fz_new_document_writer(path, format, options):
           r"""
           Low-level wrapper for `::fz_new_document_writer()`.
           Create a new fz_document_writer, for a
           file of the given type.
       
           path: The document name to write (or NULL for default)
       
           format: Which format to write (currently cbz, html, pdf, pam,
           pbm, pgm, pkm, png, ppm, pnm, svg, text, xhtml, docx, odt)
       
           options: NULL, or pointer to comma separated string to control
           file generation.
           """
>>>>>>     return _mupdf.ll_fz_new_document_writer(path, format, options)
       
    1: def ll_fz_new_document_writer_of_size(size, begin_page, end_page, close, drop):
           r"""
           Low-level wrapper for `::fz_new_document_writer_of_size()`.
           Internal function to allocate a
           block for a derived document_writer structure, with the base
           structure's function pointers populated correctly, and the extra
           space zero initialised.
           """
>>>>>>     return _mupdf.ll_fz_new_document_writer_of_size(size, begin_page, end_page, close, drop)
       
    1: def ll_fz_new_document_writer_with_buffer(buf, format, options):
           r"""Low-level wrapper for `::fz_new_document_writer_with_buffer()`."""
>>>>>>     return _mupdf.ll_fz_new_document_writer_with_buffer(buf, format, options)
       
    1: def ll_fz_new_document_writer_with_output(out, format, options):
           r"""
           Low-level wrapper for `::fz_new_document_writer_with_output()`.
           Like fz_new_document_writer but takes a fz_output for writing
           the result. Only works for multi-page formats.
           """
>>>>>>     return _mupdf.ll_fz_new_document_writer_with_output(out, format, options)
       
    1: def ll_fz_new_docx_writer(path, options):
           r"""Low-level wrapper for `::fz_new_docx_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_docx_writer(path, options)
       
    1: def ll_fz_new_docx_writer_with_output(out, options):
           r"""Low-level wrapper for `::fz_new_docx_writer_with_output()`."""
>>>>>>     return _mupdf.ll_fz_new_docx_writer_with_output(out, options)
       
    1: def ll_fz_new_dom(tag):
           r"""
           Low-level wrapper for `::fz_new_dom()`.
           Make new xml dom root element.
           """
>>>>>>     return _mupdf.ll_fz_new_dom(tag)
       
    1: def ll_fz_new_dom_node(dom, tag):
           r"""
           Low-level wrapper for `::fz_new_dom_node()`.
           Create a new dom node.
       
           This will NOT be linked in yet.
           """
>>>>>>     return _mupdf.ll_fz_new_dom_node(dom, tag)
       
    1: def ll_fz_new_dom_text_node(dom, text):
           r"""
           Low-level wrapper for `::fz_new_dom_text_node()`.
           Create a new dom text node.
       
           This will NOT be linked in yet.
           """
>>>>>>     return _mupdf.ll_fz_new_dom_text_node(dom, text)
       
    1: def ll_fz_new_draw_device(transform, dest):
           r"""
           Low-level wrapper for `::fz_new_draw_device()`.
           Create a device to draw on a pixmap.
       
           dest: Target pixmap for the draw device. See fz_new_pixmap*
           for how to obtain a pixmap. The pixmap is not cleared by the
           draw device, see fz_clear_pixmap* for how to clear it prior to
           calling fz_new_draw_device. Free the device by calling
           fz_drop_device.
       
           transform: Transform from user space in points to device space
           in pixels.
           """
>>>>>>     return _mupdf.ll_fz_new_draw_device(transform, dest)
       
    1: def ll_fz_new_draw_device_type3(transform, dest):
           r"""Low-level wrapper for `::fz_new_draw_device_type3()`."""
>>>>>>     return _mupdf.ll_fz_new_draw_device_type3(transform, dest)
       
    1: def ll_fz_new_draw_device_with_bbox(transform, dest, clip):
           r"""
           Low-level wrapper for `::fz_new_draw_device_with_bbox()`.
           Create a device to draw on a pixmap.
       
           dest: Target pixmap for the draw device. See fz_new_pixmap*
           for how to obtain a pixmap. The pixmap is not cleared by the
           draw device, see fz_clear_pixmap* for how to clear it prior to
           calling fz_new_draw_device. Free the device by calling
           fz_drop_device.
       
           transform: Transform from user space in points to device space
           in pixels.
       
           clip: Bounding box to restrict any marking operations of the
           draw device.
           """
>>>>>>     return _mupdf.ll_fz_new_draw_device_with_bbox(transform, dest, clip)
       
    1: def ll_fz_new_draw_device_with_bbox_proof(transform, dest, clip, cs):
           r"""
           Low-level wrapper for `::fz_new_draw_device_with_bbox_proof()`.
           Create a device to draw on a pixmap.
       
           dest: Target pixmap for the draw device. See fz_new_pixmap*
           for how to obtain a pixmap. The pixmap is not cleared by the
           draw device, see fz_clear_pixmap* for how to clear it prior to
           calling fz_new_draw_device. Free the device by calling
           fz_drop_device.
       
           transform: Transform from user space in points to device space
           in pixels.
       
           clip: Bounding box to restrict any marking operations of the
           draw device.
       
           proof_cs: Color space to render to prior to mapping to color
           space defined by pixmap.
           """
>>>>>>     return _mupdf.ll_fz_new_draw_device_with_bbox_proof(transform, dest, clip, cs)
       
    1: def ll_fz_new_draw_device_with_options(options, mediabox, pixmap):
           r"""
            Low-level wrapper for `::fz_new_draw_device_with_options()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_new_draw_device_with_options(const ::fz_draw_options *options, ::fz_rect mediabox, ::fz_pixmap **pixmap)` => `(fz_device *)`
       
               Create a new pixmap and draw device, using the specified options.
       
               options: Options to configure the draw device, and choose the
               resolution and colorspace.
       
               mediabox: The bounds of the page in points.
       
               pixmap: An out parameter containing the newly created pixmap.
           """
>>>>>>     return _mupdf.ll_fz_new_draw_device_with_options(options, mediabox, pixmap)
       
    1: def ll_fz_new_draw_device_with_proof(transform, dest, proof_cs):
           r"""
           Low-level wrapper for `::fz_new_draw_device_with_proof()`.
           Create a device to draw on a pixmap.
       
           dest: Target pixmap for the draw device. See fz_new_pixmap*
           for how to obtain a pixmap. The pixmap is not cleared by the
           draw device, see fz_clear_pixmap* for how to clear it prior to
           calling fz_new_draw_device. Free the device by calling
           fz_drop_device.
       
           transform: Transform from user space in points to device space
           in pixels.
       
           proof_cs: Intermediate color space to map though when mapping to
           color space defined by pixmap.
           """
>>>>>>     return _mupdf.ll_fz_new_draw_device_with_proof(transform, dest, proof_cs)
       
    1: def ll_fz_new_font_from_buffer(name, buffer, index, use_glyph_bbox):
           r"""
           Low-level wrapper for `::fz_new_font_from_buffer()`.
           Create a new font from a font file in a fz_buffer.
       
           Fonts created in this way, will be eligible for embedding by default.
       
           name: Name of font (leave NULL to use name from font).
       
           buffer: Buffer to load from.
       
           index: Which font from the file to load (0 for default).
       
           use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.
       
           Returns new font handle, or throws exception on error.
           """
>>>>>>     return _mupdf.ll_fz_new_font_from_buffer(name, buffer, index, use_glyph_bbox)
       
    1: def ll_fz_new_font_from_file(name, path, index, use_glyph_bbox):
           r"""
           Low-level wrapper for `::fz_new_font_from_file()`.
           Create a new font from a font file.
       
           Fonts created in this way, will be eligible for embedding by default.
       
           name: Name of font (leave NULL to use name from font).
       
           path: File path to load from.
       
           index: Which font from the file to load (0 for default).
       
           use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.
       
           Returns new font handle, or throws exception on error.
           """
>>>>>>     return _mupdf.ll_fz_new_font_from_file(name, path, index, use_glyph_bbox)
       
    1: def ll_fz_new_font_from_memory(name, data, len, index, use_glyph_bbox):
           r"""
           Low-level wrapper for `::fz_new_font_from_memory()`.
           Create a new font from a font file in memory.
       
           Fonts created in this way, will be eligible for embedding by default.
       
           name: Name of font (leave NULL to use name from font).
       
           data: Pointer to the font file data.
       
           len: Length of the font file data.
       
           index: Which font from the file to load (0 for default).
       
           use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.
       
           Returns new font handle, or throws exception on error.
           """
>>>>>>     return _mupdf.ll_fz_new_font_from_memory(name, data, len, index, use_glyph_bbox)
       
    1: def ll_fz_new_function_of_size(size, size2, m, n, eval, drop):
           r"""Low-level wrapper for `::fz_new_function_of_size()`."""
>>>>>>     return _mupdf.ll_fz_new_function_of_size(size, size2, m, n, eval, drop)
       
    1: def ll_fz_new_hash_table(initialsize, keylen, lock, drop_val):
           r"""
           Low-level wrapper for `::fz_new_hash_table()`.
           Create a new hash table.
       
           initialsize: The initial size of the hashtable. The hashtable
           may grow (double in size) if it starts to get crowded (80%
           full).
       
           keylen: byte length for each key.
       
           lock: -1 for no lock, otherwise the FZ_LOCK to use to protect
           this table.
       
           drop_val: Function to use to destroy values on table drop.
           """
>>>>>>     return _mupdf.ll_fz_new_hash_table(initialsize, keylen, lock, drop_val)
       
    1: def ll_fz_new_icc_colorspace(type, flags, name, buf):
           r"""
           Low-level wrapper for `::fz_new_icc_colorspace()`.
           Create a colorspace from an ICC profile supplied in buf.
       
           Limited checking is done to ensure that the colorspace type is
           appropriate for the supplied ICC profile.
       
           An additional reference is taken to buf, which will be dropped
           on destruction. Ownership is NOT passed in.
       
           The returned reference should be dropped when it is finished
           with.
       
           Colorspaces are immutable once created.
           """
>>>>>>     return _mupdf.ll_fz_new_icc_colorspace(type, flags, name, buf)
       
    1: def ll_fz_new_image_from_buffer(buffer):
           r"""
           Low-level wrapper for `::fz_new_image_from_buffer()`.
           Create a new image from a
           buffer of data, inferring its type from the format
           of the data.
           """
>>>>>>     return _mupdf.ll_fz_new_image_from_buffer(buffer)
       
    1: def ll_fz_new_image_from_compressed_buffer(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask):
           r"""
           Low-level wrapper for `::fz_new_image_from_compressed_buffer()`.
           Create an image based on
           the data in the supplied compressed buffer.
       
           w,h: Width and height of the created image.
       
           bpc: Bits per component.
       
           colorspace: The colorspace (determines the number of components,
           and any color conversions required while decoding).
       
           xres, yres: The X and Y resolutions respectively.
       
           interpolate: 1 if interpolation should be used when decoding
           this image, 0 otherwise.
       
           imagemask: 1 if this is an imagemask (i.e. transparency bitmap
           mask), 0 otherwise.
       
           decode: NULL, or a pointer to to a decode array. The default
           decode array is [0 1] (repeated n times, for n color components).
       
           colorkey: NULL, or a pointer to a colorkey array. The default
           colorkey array is [0 255] (repeated n times, for n color
           components).
       
           buffer: Buffer of compressed data and compression parameters.
           Ownership of this reference is passed in.
       
           mask: NULL, or another image to use as a mask for this one.
           A new reference is taken to this image. Supplying a masked
           image as a mask to another image is illegal!
           """
>>>>>>     return _mupdf.ll_fz_new_image_from_compressed_buffer(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask)
       
    1: def ll_fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask):
           r"""
            Low-level wrapper for `::fz_new_image_from_compressed_buffer2()`.  Swig-friendly wrapper for fz_new_image_from_compressed_buffer(),
           uses specified `decode` and `colorkey` if they are not null (in which
           case we assert that they have size `2*fz_colorspace_n(colorspace)`).
           """
>>>>>>     return _mupdf.ll_fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask)
       
    1: def ll_fz_new_image_from_display_list(w, h, list):
           r"""
           Low-level wrapper for `::fz_new_image_from_display_list()`.
           Create a new image from a display list.
       
           w, h: The conceptual width/height of the image.
       
           transform: The matrix that needs to be applied to the given
           list to make it render to the unit square.
       
           list: The display list.
           """
>>>>>>     return _mupdf.ll_fz_new_image_from_display_list(w, h, list)
       
    1: def ll_fz_new_image_from_file(path):
           r"""
           Low-level wrapper for `::fz_new_image_from_file()`.
           Create a new image from the contents
           of a file, inferring its type from the format of the
           data.
           """
>>>>>>     return _mupdf.ll_fz_new_image_from_file(path)
       
    1: def ll_fz_new_image_from_pixmap(pixmap, mask):
           r"""
           Low-level wrapper for `::fz_new_image_from_pixmap()`.
           Create an image from the given
           pixmap.
       
           pixmap: The pixmap to base the image upon. A new reference
           to this is taken.
       
           mask: NULL, or another image to use as a mask for this one.
           A new reference is taken to this image. Supplying a masked
           image as a mask to another image is illegal!
           """
>>>>>>     return _mupdf.ll_fz_new_image_from_pixmap(pixmap, mask)
       
    1: def ll_fz_new_image_from_svg(buf, base_uri, dir):
           r"""
           Low-level wrapper for `::fz_new_image_from_svg()`.
           Create a scalable image from an SVG document.
           """
>>>>>>     return _mupdf.ll_fz_new_image_from_svg(buf, base_uri, dir)
       
    1: def ll_fz_new_image_from_svg_xml(xmldoc, xml, base_uri, dir):
           r"""
           Low-level wrapper for `::fz_new_image_from_svg_xml()`.
           Create a scalable image from an SVG document.
           """
>>>>>>     return _mupdf.ll_fz_new_image_from_svg_xml(xmldoc, xml, base_uri, dir)
       
    1: def ll_fz_new_image_of_size(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, mask, size, get_pixmap, get_size, drop):
           r"""
           Low-level wrapper for `::fz_new_image_of_size()`.
           Internal function to make a new fz_image structure
           for a derived class.
       
           w,h: Width and height of the created image.
       
           bpc: Bits per component.
       
           colorspace: The colorspace (determines the number of components,
           and any color conversions required while decoding).
       
           xres, yres: The X and Y resolutions respectively.
       
           interpolate: 1 if interpolation should be used when decoding
           this image, 0 otherwise.
       
           imagemask: 1 if this is an imagemask (i.e. transparent), 0
           otherwise.
       
           decode: NULL, or a pointer to to a decode array. The default
           decode array is [0 1] (repeated n times, for n color components).
       
           colorkey: NULL, or a pointer to a colorkey array. The default
           colorkey array is [0 255] (repeated n times, for n color
           components).
       
           mask: NULL, or another image to use as a mask for this one.
           A new reference is taken to this image. Supplying a masked
           image as a mask to another image is illegal!
       
           size: The size of the required allocated structure (the size of
           the derived structure).
       
           get: The function to be called to obtain a decoded pixmap.
       
           get_size: The function to be called to return the storage size
           used by this image.
       
           drop: The function to be called to dispose of this image once
           the last reference is dropped.
       
           Returns a pointer to an allocated structure of the required size,
           with the first sizeof(fz_image) bytes initialised as appropriate
           given the supplied parameters, and the other bytes set to zero.
           """
>>>>>>     return _mupdf.ll_fz_new_image_of_size(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, mask, size, get_pixmap, get_size, drop)
       
    1: def ll_fz_new_indexed_colorspace(base, high, lookup):
           r"""
           Low-level wrapper for `::fz_new_indexed_colorspace()`.
           Create an indexed colorspace.
       
           The supplied lookup table is high palette entries long. Each
           entry is n bytes long, where n is given by the number of
           colorants in the base colorspace, one byte per colorant.
       
           Ownership of lookup is passed it; it will be freed on
           destruction, so must be heap allocated.
       
           The colorspace will keep an additional reference to the base
           colorspace that will be dropped on destruction.
       
           The returned reference should be dropped when it is finished
           with.
       
           Colorspaces are immutable once created.
           """
>>>>>>     return _mupdf.ll_fz_new_indexed_colorspace(base, high, lookup)
       
    1: def ll_fz_new_jpeg_pixmap_writer(path, options):
           r"""Low-level wrapper for `::fz_new_jpeg_pixmap_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_jpeg_pixmap_writer(path, options)
       
    1: def ll_fz_new_layout():
           r"""
           Low-level wrapper for `::fz_new_layout()`.
           Create a new layout block, with new allocation pool, zero
           matrices, and initialise linked pointers.
           """
>>>>>>     return _mupdf.ll_fz_new_layout()
       
    1: def ll_fz_new_link_of_size(size, rect, uri):
           r"""
           Low-level wrapper for `::fz_new_link_of_size()`.
           Create a new link record.
       
           next is set to NULL with the expectation that the caller will
           handle the linked list setup. Internal function.
       
           Different document types will be implemented by deriving from
           fz_link. This macro allocates such derived structures, and
           initialises the base sections.
           """
>>>>>>     return _mupdf.ll_fz_new_link_of_size(size, rect, uri)
       
    1: def ll_fz_new_list_device(list):
           r"""
           Low-level wrapper for `::fz_new_list_device()`.
           Create a rendering device for a display list.
       
           When the device is rendering a page it will populate the
           display list with drawing commands (text, images, etc.). The
           display list can later be reused to render a page many times
           without having to re-interpret the page from the document file
           for each rendering. Once the device is no longer needed, free
           it with fz_drop_device.
       
           list: A display list that the list device takes a reference to.
           """
>>>>>>     return _mupdf.ll_fz_new_list_device(list)
       
    1: def ll_fz_new_log_for_module(module):
           r"""
           Low-level wrapper for `::fz_new_log_for_module()`.
           Internal function to actually do the opening of the logfile.
       
           Caller should close/drop the output when finished with it.
           """
>>>>>>     return _mupdf.ll_fz_new_log_for_module(module)
       
    1: def ll_fz_new_mono_pcl_band_writer(out, options):
           r"""
           Low-level wrapper for `::fz_new_mono_pcl_band_writer()`.
           Create a new band writer, outputting monochrome pcl.
           """
>>>>>>     return _mupdf.ll_fz_new_mono_pcl_band_writer(out, options)
       
    1: def ll_fz_new_mono_pwg_band_writer(out, pwg):
           r"""
           Low-level wrapper for `::fz_new_mono_pwg_band_writer()`.
           Create a new monochrome pwg band writer.
           """
>>>>>>     return _mupdf.ll_fz_new_mono_pwg_band_writer(out, pwg)
       
    1: def ll_fz_new_multi_archive():
           r"""
           Low-level wrapper for `::fz_new_multi_archive()`.
           Create a new multi archive (initially empty).
           """
>>>>>>     return _mupdf.ll_fz_new_multi_archive()
       
    1: def ll_fz_new_ocr_device(target, ctm, mediabox, with_list, language, datadir, progress, progress_arg):
           r"""
           Low-level wrapper for `::fz_new_ocr_device()`.
           Create a device to OCR the text on the page.
       
           Renders the page internally to a bitmap that is then OCRd. Text
           is then forwarded onto the target device.
       
           target: The target device to receive the OCRd text.
       
           ctm: The transform to apply to the mediabox to get the size for
           the rendered page image. Also used to calculate the resolution
           for the page image. In general, this will be the same as the CTM
           that you pass to fz_run_page (or fz_run_display_list) to feed
           this device.
       
           mediabox: The mediabox (in points). Combined with the CTM to get
           the bounds of the pixmap used internally for the rendered page
           image.
       
           with_list: If with_list is false, then all non-text operations
           are forwarded instantly to the target device. This results in
           the target device seeing all NON-text operations, followed by
           all the text operations (derived from OCR).
       
           If with_list is true, then all the marking operations are
           collated into a display list which is then replayed to the
           target device at the end.
       
           language: NULL (for "eng"), or a pointer to a string to describe
           the languages/scripts that should be used for OCR (e.g.
           "eng,ara").
       
           datadir: NULL (for ""), or a pointer to a path string otherwise
           provided to Tesseract in the TESSDATA_PREFIX environment variable.
       
           progress: NULL, or function to be called periodically to indicate
           progress. Return 0 to continue, or 1 to cancel. progress_arg is
           returned as the void *. The int is a value between 0 and 100 to
           indicate progress.
       
           progress_arg: A void * value to be parrotted back to the progress
           function.
           """
>>>>>>     return _mupdf.ll_fz_new_ocr_device(target, ctm, mediabox, with_list, language, datadir, progress, progress_arg)
       
    1: def ll_fz_new_odt_writer(path, options):
           r"""Low-level wrapper for `::fz_new_odt_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_odt_writer(path, options)
       
    1: def ll_fz_new_odt_writer_with_output(out, options):
           r"""Low-level wrapper for `::fz_new_odt_writer_with_output()`."""
>>>>>>     return _mupdf.ll_fz_new_odt_writer_with_output(out, options)
       
    1: def ll_fz_new_outline():
           r"""
           Low-level wrapper for `::fz_new_outline()`.
           Create a new outline entry with zeroed fields for the caller
           to fill in.
           """
>>>>>>     return _mupdf.ll_fz_new_outline()
       
    1: def ll_fz_new_outline_iterator(doc):
           r"""
           Low-level wrapper for `::fz_new_outline_iterator()`.
           Get an iterator for the document outline.
       
           Should be freed by fz_drop_outline_iterator.
           """
>>>>>>     return _mupdf.ll_fz_new_outline_iterator(doc)
       
    1: def ll_fz_new_outline_iterator_of_size(size, doc):
           r"""Low-level wrapper for `::fz_new_outline_iterator_of_size()`."""
>>>>>>     return _mupdf.ll_fz_new_outline_iterator_of_size(size, doc)
       
    1: def ll_fz_new_output(bufsiz, state, write, close, drop):
           r"""
           Low-level wrapper for `::fz_new_output()`.
           Create a new output object with the given
           internal state and function pointers.
       
           state: Internal state (opaque to everything but implementation).
       
           write: Function to output a given buffer.
       
           close: Cleanup function to destroy state when output closed.
           May permissibly be null.
           """
>>>>>>     return _mupdf.ll_fz_new_output(bufsiz, state, write, close, drop)
       
    1: def ll_fz_new_output_with_buffer(buf):
           r"""
           Low-level wrapper for `::fz_new_output_with_buffer()`.
           Open an output stream that appends
           to a buffer.
       
           buf: The buffer to append to.
           """
>>>>>>     return _mupdf.ll_fz_new_output_with_buffer(buf)
       
    1: def ll_fz_new_output_with_file_ptr(file):
           r"""
           Low-level wrapper for `::fz_new_output_with_file_ptr()`.
           Open an output stream that writes to a
           given FILE *.
       
           file: The file pointers to write to. NULL is interpreted as effectively
           meaning /dev/null or similar.
           """
>>>>>>     return _mupdf.ll_fz_new_output_with_file_ptr(file)
       
    1: def ll_fz_new_output_with_path(filename, append):
           r"""
           Low-level wrapper for `::fz_new_output_with_path()`.
           Open an output stream that writes to a
           given path.
       
           filename: The filename to write to (specified in UTF-8).
       
           append: non-zero if we should append to the file, rather than
           overwriting it.
           """
>>>>>>     return _mupdf.ll_fz_new_output_with_path(filename, append)
       
    1: def ll_fz_new_page_of_size(size, doc):
           r"""
           Low-level wrapper for `::fz_new_page_of_size()`.
           Different document types will be implemented by deriving from
           fz_page. This macro allocates such derived structures, and
           initialises the base sections.
           """
>>>>>>     return _mupdf.ll_fz_new_page_of_size(size, doc)
       
    1: def ll_fz_new_pam_band_writer(out):
           r"""
           Low-level wrapper for `::fz_new_pam_band_writer()`.
           Create a band writer targeting pnm (greyscale, rgb or cmyk,
           with or without alpha).
           """
>>>>>>     return _mupdf.ll_fz_new_pam_band_writer(out)
       
    1: def ll_fz_new_pam_pixmap_writer(path, options):
           r"""Low-level wrapper for `::fz_new_pam_pixmap_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_pam_pixmap_writer(path, options)
       
    1: def ll_fz_new_path():
           r"""
           Low-level wrapper for `::fz_new_path()`.
           Create a new (empty) path structure.
           """
>>>>>>     return _mupdf.ll_fz_new_path()
       
    1: def ll_fz_new_pbm_band_writer(out):
           r"""
           Low-level wrapper for `::fz_new_pbm_band_writer()`.
           Create a new band writer, targeting pbm.
           """
>>>>>>     return _mupdf.ll_fz_new_pbm_band_writer(out)
       
    1: def ll_fz_new_pbm_pixmap_writer(path, options):
           r"""Low-level wrapper for `::fz_new_pbm_pixmap_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_pbm_pixmap_writer(path, options)
       
    1: def ll_fz_new_pcl_writer(path, options):
           r"""Low-level wrapper for `::fz_new_pcl_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_pcl_writer(path, options)
       
    1: def ll_fz_new_pcl_writer_with_output(out, options):
           r"""Low-level wrapper for `::fz_new_pcl_writer_with_output()`."""
>>>>>>     return _mupdf.ll_fz_new_pcl_writer_with_output(out, options)
       
    1: def ll_fz_new_pclm_band_writer(out, options):
           r"""
           Low-level wrapper for `::fz_new_pclm_band_writer()`.
           Create a new band writer, outputting pclm
           """
>>>>>>     return _mupdf.ll_fz_new_pclm_band_writer(out, options)
       
    1: def ll_fz_new_pclm_writer(path, options):
           r"""Low-level wrapper for `::fz_new_pclm_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_pclm_writer(path, options)
       
    1: def ll_fz_new_pclm_writer_with_output(out, options):
           r"""Low-level wrapper for `::fz_new_pclm_writer_with_output()`."""
>>>>>>     return _mupdf.ll_fz_new_pclm_writer_with_output(out, options)
       
    1: def ll_fz_new_pdf_document_from_fz_document(ptr):
           r"""Low-level wrapper for `::fz_new_pdf_document_from_fz_document()`."""
>>>>>>     return _mupdf.ll_fz_new_pdf_document_from_fz_document(ptr)
       
    1: def ll_fz_new_pdf_writer(path, options):
           r"""
           Low-level wrapper for `::fz_new_pdf_writer()`.
           Document writers for various possible output formats.
       
           All of the "_with_output" variants pass the ownership of out in
           immediately upon calling. The writers are responsible for
           dropping the fz_output when they are finished with it (even
           if they throw an exception during creation).
           """
>>>>>>     return _mupdf.ll_fz_new_pdf_writer(path, options)
       
    1: def ll_fz_new_pdf_writer_with_output(out, options):
           r"""Low-level wrapper for `::fz_new_pdf_writer_with_output()`."""
>>>>>>     return _mupdf.ll_fz_new_pdf_writer_with_output(out, options)
       
    1: def ll_fz_new_pdfocr_band_writer(out, options):
           r"""
           Low-level wrapper for `::fz_new_pdfocr_band_writer()`.
           Create a new band writer, outputting pdfocr.
       
           Ownership of output stays with the caller, the band writer
           borrows the reference. The caller must keep the output around
           for the duration of the band writer, and then close/drop as
           appropriate.
           """
>>>>>>     return _mupdf.ll_fz_new_pdfocr_band_writer(out, options)
       
    1: def ll_fz_new_pdfocr_writer(path, options):
           r"""Low-level wrapper for `::fz_new_pdfocr_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_pdfocr_writer(path, options)
       
    1: def ll_fz_new_pdfocr_writer_with_output(out, options):
           r"""Low-level wrapper for `::fz_new_pdfocr_writer_with_output()`."""
>>>>>>     return _mupdf.ll_fz_new_pdfocr_writer_with_output(out, options)
       
    1: def ll_fz_new_pgm_pixmap_writer(path, options):
           r"""Low-level wrapper for `::fz_new_pgm_pixmap_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_pgm_pixmap_writer(path, options)
       
    1: def ll_fz_new_pixmap(cs, w, h, seps, alpha):
           r"""
           Low-level wrapper for `::fz_new_pixmap()`.
           Create a new pixmap, with its origin at (0,0)
       
           cs: The colorspace to use for the pixmap, or NULL for an alpha
           plane/mask.
       
           w: The width of the pixmap (in pixels)
       
           h: The height of the pixmap (in pixels)
       
           seps: Details of separations.
       
           alpha: 0 for no alpha, 1 for alpha.
       
           Returns a pointer to the new pixmap. Throws exception on failure
           to allocate.
           """
>>>>>>     return _mupdf.ll_fz_new_pixmap(cs, w, h, seps, alpha)
       
    1: def ll_fz_new_pixmap_from_alpha_channel(src):
           r"""Low-level wrapper for `::fz_new_pixmap_from_alpha_channel()`."""
>>>>>>     return _mupdf.ll_fz_new_pixmap_from_alpha_channel(src)
       
    1: def ll_fz_new_pixmap_from_color_and_mask(color, mask):
           r"""Low-level wrapper for `::fz_new_pixmap_from_color_and_mask()`."""
>>>>>>     return _mupdf.ll_fz_new_pixmap_from_color_and_mask(color, mask)
       
    1: def ll_fz_new_pixmap_from_display_list(list, ctm, cs, alpha):
           r"""
           Low-level wrapper for `::fz_new_pixmap_from_display_list()`.
           Render the page to a pixmap using the transform and colorspace.
       
           Ownership of the pixmap is returned to the caller.
           """
>>>>>>     return _mupdf.ll_fz_new_pixmap_from_display_list(list, ctm, cs, alpha)
       
    1: def ll_fz_new_pixmap_from_display_list_with_separations(list, ctm, cs, seps, alpha):
           r"""
           Low-level wrapper for `::fz_new_pixmap_from_display_list_with_separations()`.
           Render the page contents with control over spot colors.
       
           Ownership of the pixmap is returned to the caller.
           """
>>>>>>     return _mupdf.ll_fz_new_pixmap_from_display_list_with_separations(list, ctm, cs, seps, alpha)
       
    1: def ll_fz_new_pixmap_from_page(page, ctm, cs, alpha):
           r"""Low-level wrapper for `::fz_new_pixmap_from_page()`."""
>>>>>>     return _mupdf.ll_fz_new_pixmap_from_page(page, ctm, cs, alpha)
       
    1: def ll_fz_new_pixmap_from_page_contents(page, ctm, cs, alpha):
           r"""
           Low-level wrapper for `::fz_new_pixmap_from_page_contents()`.
           Render the page contents without annotations.
       
           Ownership of the pixmap is returned to the caller.
           """
>>>>>>     return _mupdf.ll_fz_new_pixmap_from_page_contents(page, ctm, cs, alpha)
       
    1: def ll_fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha):
           r"""Low-level wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`."""
>>>>>>     return _mupdf.ll_fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha)
       
    1: def ll_fz_new_pixmap_from_page_number(doc, number, ctm, cs, alpha):
           r"""Low-level wrapper for `::fz_new_pixmap_from_page_number()`."""
>>>>>>     return _mupdf.ll_fz_new_pixmap_from_page_number(doc, number, ctm, cs, alpha)
       
    1: def ll_fz_new_pixmap_from_page_number_with_separations(doc, number, ctm, cs, seps, alpha):
           r"""Low-level wrapper for `::fz_new_pixmap_from_page_number_with_separations()`."""
>>>>>>     return _mupdf.ll_fz_new_pixmap_from_page_number_with_separations(doc, number, ctm, cs, seps, alpha)
       
    1: def ll_fz_new_pixmap_from_page_with_separations(page, ctm, cs, seps, alpha):
           r"""Low-level wrapper for `::fz_new_pixmap_from_page_with_separations()`."""
>>>>>>     return _mupdf.ll_fz_new_pixmap_from_page_with_separations(page, ctm, cs, seps, alpha)
       
    1: def ll_fz_new_pixmap_from_pixmap(pixmap, rect):
           r"""
           Low-level wrapper for `::fz_new_pixmap_from_pixmap()`.
           Create a new pixmap that represents a subarea of the specified
           pixmap. A reference is taken to this pixmap that will be dropped
           on destruction.
       
           The supplied rectangle must be wholly contained within the
           original pixmap.
       
           Returns a pointer to the new pixmap. Throws exception on failure
           to allocate.
           """
>>>>>>     return _mupdf.ll_fz_new_pixmap_from_pixmap(pixmap, rect)
       
    1: def ll_fz_new_pixmap_with_bbox(colorspace, bbox, seps, alpha):
           r"""
           Low-level wrapper for `::fz_new_pixmap_with_bbox()`.
           Create a pixmap of a given size, location and pixel format.
       
           The bounding box specifies the size of the created pixmap and
           where it will be located. The colorspace determines the number
           of components per pixel. Alpha is always present. Pixmaps are
           reference counted, so drop references using fz_drop_pixmap.
       
           colorspace: Colorspace format used for the created pixmap. The
           pixmap will keep a reference to the colorspace.
       
           bbox: Bounding box specifying location/size of created pixmap.
       
           seps: Details of separations.
       
           alpha: 0 for no alpha, 1 for alpha.
       
           Returns a pointer to the new pixmap. Throws exception on failure
           to allocate.
           """
>>>>>>     return _mupdf.ll_fz_new_pixmap_with_bbox(colorspace, bbox, seps, alpha)
       
    1: def ll_fz_new_pixmap_with_bbox_and_data(colorspace, rect, seps, alpha, samples):
           r"""
           Low-level wrapper for `::fz_new_pixmap_with_bbox_and_data()`.
           Create a pixmap of a given size, location and pixel format,
           using the supplied data block.
       
           The bounding box specifies the size of the created pixmap and
           where it will be located. The colorspace determines the number
           of components per pixel. Alpha is always present. Pixmaps are
           reference counted, so drop references using fz_drop_pixmap.
       
           colorspace: Colorspace format used for the created pixmap. The
           pixmap will keep a reference to the colorspace.
       
           rect: Bounding box specifying location/size of created pixmap.
       
           seps: Details of separations.
       
           alpha: Number of alpha planes (0 or 1).
       
           samples: The data block to keep the samples in.
       
           Returns a pointer to the new pixmap. Throws exception on failure
           to allocate.
           """
>>>>>>     return _mupdf.ll_fz_new_pixmap_with_bbox_and_data(colorspace, rect, seps, alpha, samples)
       
    1: def ll_fz_new_pixmap_with_data(colorspace, w, h, seps, alpha, stride, samples):
           r"""
           Low-level wrapper for `::fz_new_pixmap_with_data()`.
           Create a new pixmap, with its origin at
           (0,0) using the supplied data block.
       
           cs: The colorspace to use for the pixmap, or NULL for an alpha
           plane/mask.
       
           w: The width of the pixmap (in pixels)
       
           h: The height of the pixmap (in pixels)
       
           seps: Details of separations.
       
           alpha: 0 for no alpha, 1 for alpha.
       
           stride: The byte offset from the pixel data in a row to the
           pixel data in the next row.
       
           samples: The data block to keep the samples in.
       
           Returns a pointer to the new pixmap. Throws exception on failure to
           allocate.
           """
>>>>>>     return _mupdf.ll_fz_new_pixmap_with_data(colorspace, w, h, seps, alpha, stride, samples)
       
    1: def ll_fz_new_pixmap_writer(path, options, default_path, n, save):
           r"""Low-level wrapper for `::fz_new_pixmap_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_pixmap_writer(path, options, default_path, n, save)
       
    1: def ll_fz_new_pkm_band_writer(out):
           r"""
           Low-level wrapper for `::fz_new_pkm_band_writer()`.
           Create a new pkm band writer for CMYK pixmaps.
           """
>>>>>>     return _mupdf.ll_fz_new_pkm_band_writer(out)
       
    1: def ll_fz_new_pkm_pixmap_writer(path, options):
           r"""Low-level wrapper for `::fz_new_pkm_pixmap_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_pkm_pixmap_writer(path, options)
       
    1: def ll_fz_new_png_band_writer(out):
           r"""
           Low-level wrapper for `::fz_new_png_band_writer()`.
           Create a new png band writer (greyscale or RGB, with or without
           alpha).
           """
>>>>>>     return _mupdf.ll_fz_new_png_band_writer(out)
       
    1: def ll_fz_new_png_pixmap_writer(path, options):
           r"""Low-level wrapper for `::fz_new_png_pixmap_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_png_pixmap_writer(path, options)
       
    1: def ll_fz_new_pnm_band_writer(out):
           r"""
           Low-level wrapper for `::fz_new_pnm_band_writer()`.
           Create a band writer targeting pnm (greyscale or rgb, no
           alpha).
           """
>>>>>>     return _mupdf.ll_fz_new_pnm_band_writer(out)
       
    1: def ll_fz_new_pnm_pixmap_writer(path, options):
           r"""Low-level wrapper for `::fz_new_pnm_pixmap_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_pnm_pixmap_writer(path, options)
       
    1: def ll_fz_new_pool():
           r"""
           Low-level wrapper for `::fz_new_pool()`.
           Create a new pool to allocate from.
           """
>>>>>>     return _mupdf.ll_fz_new_pool()
       
    1: def ll_fz_new_pool_array_imp(pool, size, initial):
           r"""Low-level wrapper for `::fz_new_pool_array_imp()`."""
>>>>>>     return _mupdf.ll_fz_new_pool_array_imp(pool, size, initial)
       
    1: def ll_fz_new_ppm_pixmap_writer(path, options):
           r"""Low-level wrapper for `::fz_new_ppm_pixmap_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_ppm_pixmap_writer(path, options)
       
    1: def ll_fz_new_ps_band_writer(out):
           r"""
           Low-level wrapper for `::fz_new_ps_band_writer()`.
           Create a postscript band writer for gray, rgb, or cmyk, no
           alpha.
           """
>>>>>>     return _mupdf.ll_fz_new_ps_band_writer(out)
       
    1: def ll_fz_new_ps_writer(path, options):
           r"""Low-level wrapper for `::fz_new_ps_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_ps_writer(path, options)
       
    1: def ll_fz_new_ps_writer_with_output(out, options):
           r"""Low-level wrapper for `::fz_new_ps_writer_with_output()`."""
>>>>>>     return _mupdf.ll_fz_new_ps_writer_with_output(out, options)
       
    1: def ll_fz_new_psd_band_writer(out):
           r"""
           Low-level wrapper for `::fz_new_psd_band_writer()`.
           Open a PSD band writer.
           """
>>>>>>     return _mupdf.ll_fz_new_psd_band_writer(out)
       
    1: def ll_fz_new_pwg_band_writer(out, pwg):
           r"""
           Low-level wrapper for `::fz_new_pwg_band_writer()`.
           Create a new color pwg band writer.
           """
>>>>>>     return _mupdf.ll_fz_new_pwg_band_writer(out, pwg)
       
    1: def ll_fz_new_pwg_writer(path, options):
           r"""Low-level wrapper for `::fz_new_pwg_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_pwg_writer(path, options)
       
    1: def ll_fz_new_pwg_writer_with_output(out, options):
           r"""Low-level wrapper for `::fz_new_pwg_writer_with_output()`."""
>>>>>>     return _mupdf.ll_fz_new_pwg_writer_with_output(out, options)
       
    1: def ll_fz_new_rle_output(chain):
           r"""Low-level wrapper for `::fz_new_rle_output()`."""
>>>>>>     return _mupdf.ll_fz_new_rle_output(chain)
       
    1: def ll_fz_new_separations(controllable):
           r"""
           Low-level wrapper for `::fz_new_separations()`.
           Create a new separations structure (initially empty)
           """
>>>>>>     return _mupdf.ll_fz_new_separations(controllable)
       
    1: def ll_fz_new_stext_device(page, options):
           r"""
           Low-level wrapper for `::fz_new_stext_device()`.
           Create a device to extract the text on a page.
       
           Gather the text on a page into blocks and lines.
       
           The reading order is taken from the order the text is drawn in
           the source file, so may not be accurate.
       
           page: The text page to which content should be added. This will
           usually be a newly created (empty) text page, but it can be one
           containing data already (for example when merging multiple
           pages, or watermarking).
       
           options: Options to configure the stext device.
           """
>>>>>>     return _mupdf.ll_fz_new_stext_device(page, options)
       
    1: def ll_fz_new_stext_device_for_page(stext_page, opts, chapter_num, page_num, mediabox):
           r"""
           Low-level wrapper for `::fz_new_stext_device_for_page()`.
           Create a device to extract the text on a page into an existing
           fz_stext_page structure.
       
           Gather the text on a page into blocks and lines.
       
           The reading order is taken from the order the text is drawn in
           the source file, so may not be accurate.
       
           stext_page: The text page to which content should be added. This will
           usually be a newly created (empty) text page, but it can be one
           containing data already (for example when merging multiple
           pages, or watermarking).
       
           options: Options to configure the stext device.
       
           The next 2 parameters are copied into the fz_stext_page structure's
           ids section, so only have to be valid if you expect to interrogate
           that section later.
       
           chapter_num: The chapter number that this page came from.
       
           page_num: The page number that this page came from.
       
           The final parameter is copied into the fz_stext_page structure's
           ids section. The mediabox for the enture fz_stext_page is unioned
           with this, so pass fz_empty_bbox if you don't care about getting
           a valid value back from the ids section, but you don't want to
           upset the value in the page->mediabox field.
       
           mediabox: The mediabox for this page.
           """
>>>>>>     return _mupdf.ll_fz_new_stext_device_for_page(stext_page, opts, chapter_num, page_num, mediabox)
       
    1: def ll_fz_new_stext_page(mediabox):
           r"""
           Low-level wrapper for `::fz_new_stext_page()`.
           Create an empty text page.
       
           The text page is filled out by the text device to contain the
           blocks and lines of text on the page.
       
           mediabox: optional mediabox information.
           """
>>>>>>     return _mupdf.ll_fz_new_stext_page(mediabox)
       
    1: def ll_fz_new_stext_page_from_chapter_page_number(doc, chapter, number, options):
           r"""Low-level wrapper for `::fz_new_stext_page_from_chapter_page_number()`."""
>>>>>>     return _mupdf.ll_fz_new_stext_page_from_chapter_page_number(doc, chapter, number, options)
       
    1: def ll_fz_new_stext_page_from_display_list(list, options):
           r"""Low-level wrapper for `::fz_new_stext_page_from_display_list()`."""
>>>>>>     return _mupdf.ll_fz_new_stext_page_from_display_list(list, options)
       
    1: def ll_fz_new_stext_page_from_page(page, options):
           r"""
           Low-level wrapper for `::fz_new_stext_page_from_page()`.
           Extract text from page.
       
           Ownership of the fz_stext_page is returned to the caller.
           """
>>>>>>     return _mupdf.ll_fz_new_stext_page_from_page(page, options)
       
    1: def ll_fz_new_stext_page_from_page_number(doc, number, options):
           r"""Low-level wrapper for `::fz_new_stext_page_from_page_number()`."""
>>>>>>     return _mupdf.ll_fz_new_stext_page_from_page_number(doc, number, options)
       
    1: def ll_fz_new_stext_struct(page, standard, raw, index):
           r"""Low-level wrapper for `::fz_new_stext_struct()`."""
>>>>>>     return _mupdf.ll_fz_new_stext_struct(page, standard, raw, index)
       
    1: def ll_fz_new_store_context(max):
           r"""
           Low-level wrapper for `::fz_new_store_context()`.
           Create a new store inside the context
       
           max: The maximum size (in bytes) that the store is allowed to
           grow to. FZ_STORE_UNLIMITED means no limit.
           """
>>>>>>     return _mupdf.ll_fz_new_store_context(max)
       
    1: def ll_fz_new_story(buf, user_css, em, dir):
           r"""Low-level wrapper for `::fz_new_story()`."""
>>>>>>     return _mupdf.ll_fz_new_story(buf, user_css, em, dir)
       
    1: def ll_fz_new_stream(state, next, drop):
           r"""
           Low-level wrapper for `::fz_new_stream()`.
           Create a new stream object with the given
           internal state and function pointers.
       
           state: Internal state (opaque to everything but implementation).
       
           next: Should provide the next set of bytes (up to max) of stream
           data. Return the number of bytes read, or EOF when there is no
           more data.
       
           drop: Should clean up and free the internal state. May not
           throw exceptions.
           """
>>>>>>     return _mupdf.ll_fz_new_stream(state, next, drop)
       
    1: def ll_fz_new_string(str):
           r"""Low-level wrapper for `::fz_new_string()`."""
>>>>>>     return _mupdf.ll_fz_new_string(str)
       
    1: def ll_fz_new_stroke_state():
           r"""
           Low-level wrapper for `::fz_new_stroke_state()`.
           Create a new (empty) stroke state structure (with no dash
           data) and return a reference to it.
       
           Throws exception on failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_new_stroke_state()
       
    1: def ll_fz_new_stroke_state_with_dash_len(len):
           r"""
           Low-level wrapper for `::fz_new_stroke_state_with_dash_len()`.
           Create a new (empty) stroke state structure, with room for
           dash data of the given length, and return a reference to it.
       
           len: The number of dash elements to allow room for.
       
           Throws exception on failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_new_stroke_state_with_dash_len(len)
       
    1: def ll_fz_new_svg_device(out, page_width, page_height, text_format, reuse_images):
           r"""
           Low-level wrapper for `::fz_new_svg_device()`.
           Create a device that outputs (single page) SVG files to
           the given output stream.
       
           Equivalent to fz_new_svg_device_with_id passing id = NULL.
           """
>>>>>>     return _mupdf.ll_fz_new_svg_device(out, page_width, page_height, text_format, reuse_images)
       
    1: def ll_fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images, id):
           r"""
            Low-level wrapper for `::fz_new_svg_device_with_id()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_new_svg_device_with_id(::fz_output *out, float page_width, float page_height, int text_format, int reuse_images)` => `(fz_device *, int id)`
       
               Create a device that outputs (single page) SVG files to
               the given output stream.
       
               output: The output stream to send the constructed SVG page to.
       
               page_width, page_height: The page dimensions to use (in points).
       
               text_format: How to emit text. One of the following values:
                       FZ_SVG_TEXT_AS_TEXT: As <text> elements with possible
                       layout errors and mismatching fonts.
                       FZ_SVG_TEXT_AS_PATH: As <path> elements with exact
                       visual appearance.
       
               reuse_images: Share image resources using <symbol> definitions.
       
               id: ID parameter to keep generated IDs unique across SVG files.
           """
>>>>>>     return _mupdf.ll_fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images, id)
       
    1: def ll_fz_new_svg_writer(path, options):
           r"""Low-level wrapper for `::fz_new_svg_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_svg_writer(path, options)
       
    1: def ll_fz_new_svg_writer_with_output(out, options):
           r"""Low-level wrapper for `::fz_new_svg_writer_with_output()`."""
>>>>>>     return _mupdf.ll_fz_new_svg_writer_with_output(out, options)
       
    1: def ll_fz_new_test_device(is_color, threshold, options, passthrough):
           r"""
            Low-level wrapper for `::fz_new_test_device()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_new_test_device(float threshold, int options, ::fz_device *passthrough)` => `(fz_device *, int is_color)`
       
               Create a device to test for features.
       
               Currently only tests for the presence of non-grayscale colors.
       
               is_color: Possible values returned:
                       0: Definitely greyscale
                       1: Probably color (all colors were grey, but there
                       were images or shadings in a non grey colorspace).
                       2: Definitely color
       
               threshold: The difference from grayscale that will be tolerated.
               Typical values to use are either 0 (be exact) and 0.02 (allow an
               imperceptible amount of slop).
       
               options: A set of bitfield options, from the FZ_TEST_OPT set.
       
               passthrough: A device to pass all calls through to, or NULL.
               If set, then the test device can both test and pass through to
               an underlying device (like, say, the display list device). This
               means that a display list can be created and at the end we'll
               know if it's colored or not.
       
               In the absence of a passthrough device, the device will throw
               an exception to stop page interpretation when color is found.
           """
>>>>>>     return _mupdf.ll_fz_new_test_device(is_color, threshold, options, passthrough)
       
    1: def ll_fz_new_text():
           r"""
           Low-level wrapper for `::fz_new_text()`.
           Create a new empty fz_text object.
       
           Throws exception on failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_new_text()
       
    1: def ll_fz_new_text_writer(format, path, options):
           r"""Low-level wrapper for `::fz_new_text_writer()`."""
>>>>>>     return _mupdf.ll_fz_new_text_writer(format, path, options)
       
    1: def ll_fz_new_text_writer_with_output(format, out, options):
           r"""Low-level wrapper for `::fz_new_text_writer_with_output()`."""
>>>>>>     return _mupdf.ll_fz_new_text_writer_with_output(format, out, options)
       
    1: def ll_fz_new_trace_device(out):
           r"""
           Low-level wrapper for `::fz_new_trace_device()`.
           Create a device to print a debug trace of all device calls.
           """
>>>>>>     return _mupdf.ll_fz_new_trace_device(out)
       
    1: def ll_fz_new_tree_archive(tree):
           r"""
           Low-level wrapper for `::fz_new_tree_archive()`.
           Create an archive that holds named buffers.
       
           tree can either be a preformed tree with fz_buffers as values,
           or it can be NULL for an empty tree.
           """
>>>>>>     return _mupdf.ll_fz_new_tree_archive(tree)
       
    1: def ll_fz_new_type3_font(name, matrix):
           r"""
           Low-level wrapper for `::fz_new_type3_font()`.
           Create a new (empty) type3 font.
       
           name: Name of font (or NULL).
       
           matrix: Font matrix.
       
           Returns a new font handle, or throws exception on
           allocation failure.
           """
>>>>>>     return _mupdf.ll_fz_new_type3_font(name, matrix)
       
    1: def ll_fz_new_xhtml_document_from_document(old_doc, opts):
           r"""
           Low-level wrapper for `::fz_new_xhtml_document_from_document()`.
           Use text extraction to convert the input document into XHTML,
           then open the result as a new document that can be reflowed.
           """
>>>>>>     return _mupdf.ll_fz_new_xhtml_document_from_document(old_doc, opts)
       
    1: def ll_fz_new_xmltext_device(out):
           r"""
           Low-level wrapper for `::fz_new_xmltext_device()`.
           Create a device to output raw information.
           """
>>>>>>     return _mupdf.ll_fz_new_xmltext_device(out)
       
    1: def ll_fz_new_zip_writer(filename):
           r"""
           Low-level wrapper for `::fz_new_zip_writer()`.
           Create a new zip writer that writes to a given file.
       
           Open an archive using a seekable stream object rather than
           opening a file or directory on disk.
           """
>>>>>>     return _mupdf.ll_fz_new_zip_writer(filename)
       
    1: def ll_fz_new_zip_writer_with_output(out):
           r"""
           Low-level wrapper for `::fz_new_zip_writer_with_output()`.
           Create a new zip writer that writes to a given output stream.
       
           Ownership of out passes in immediately upon calling this function.
           The caller should never drop the fz_output, even if this function throws
           an exception.
           """
>>>>>>     return _mupdf.ll_fz_new_zip_writer_with_output(out)
       
    1: def ll_fz_next_page(doc, loc):
           r"""
           Low-level wrapper for `::fz_next_page()`.
           Function to get the location of the next page (allowing for the
           end of chapters etc). If at the end of the document, returns the
           current location.
           """
>>>>>>     return _mupdf.ll_fz_next_page(doc, loc)
       
    1: def ll_fz_normalize_vector(p):
           r"""
           Low-level wrapper for `::fz_normalize_vector()`.
           Normalize a vector to length one.
           """
>>>>>>     return _mupdf.ll_fz_normalize_vector(p)
       
    1: def ll_fz_open_a85d(chain):
           r"""
           Low-level wrapper for `::fz_open_a85d()`.
           a85d filter performs ASCII 85 Decoding of data read
           from the chained filter.
           """
>>>>>>     return _mupdf.ll_fz_open_a85d(chain)
       
    1: def ll_fz_open_accelerated_document(filename, accel):
           r"""
           Low-level wrapper for `::fz_open_accelerated_document()`.
           Open a document file and read its basic structure so pages and
           objects can be located. MuPDF will try to repair broken
           documents (without actually changing the file contents).
       
           The returned fz_document is used when calling most other
           document related functions.
       
           filename: a path to a file as it would be given to open(2).
           """
>>>>>>     return _mupdf.ll_fz_open_accelerated_document(filename, accel)
       
    1: def ll_fz_open_accelerated_document_with_stream(magic, stream, accel):
           r"""
           Low-level wrapper for `::fz_open_accelerated_document_with_stream()`.
           Open a document using the specified stream object rather than
           opening a file on disk.
       
           magic: a string used to detect document type; either a file name
           or mime-type.
       
           stream: a stream of the document contents.
       
           accel: NULL, or a stream of the 'accelerator' contents for this document.
       
           NOTE: The caller retains ownership of 'stream' and 'accel' - the document will
           take its own references if required.
           """
>>>>>>     return _mupdf.ll_fz_open_accelerated_document_with_stream(magic, stream, accel)
       
    1: def ll_fz_open_accelerated_document_with_stream_and_dir(magic, stream, accel, dir):
           r"""
           Low-level wrapper for `::fz_open_accelerated_document_with_stream_and_dir()`.
           Open a document using the specified stream object rather than
           opening a file on disk.
       
           magic: a string used to detect document type; either a file name
           or mime-type.
       
           stream: a stream of the document contents.
       
           accel: NULL, or a stream of the 'accelerator' contents for this document.
       
           dir: NULL, or the 'directory context' for the stream contents.
       
           NOTE: The caller retains ownership of 'stream', 'accel' and 'dir' - the document will
           take its own references if required.
           """
>>>>>>     return _mupdf.ll_fz_open_accelerated_document_with_stream_and_dir(magic, stream, accel, dir)
       
    1: def ll_fz_open_aesd(chain, key, keylen):
           r"""
           Low-level wrapper for `::fz_open_aesd()`.
           aesd filter performs AES decoding of data read from the chained
           filter using the supplied key.
           """
>>>>>>     return _mupdf.ll_fz_open_aesd(chain, key, keylen)
       
    1: def ll_fz_open_ahxd(chain):
           r"""
           Low-level wrapper for `::fz_open_ahxd()`.
           ahxd filter performs ASCII Hex decoding of data read
           from the chained filter.
           """
>>>>>>     return _mupdf.ll_fz_open_ahxd(chain)
       
    1: def ll_fz_open_arc4(chain, key, keylen):
           r"""
           Low-level wrapper for `::fz_open_arc4()`.
           arc4 filter performs RC4 decoding of data read from the chained
           filter using the supplied key.
           """
>>>>>>     return _mupdf.ll_fz_open_arc4(chain, key, keylen)
       
    1: def ll_fz_open_archive(filename):
           r"""
           Low-level wrapper for `::fz_open_archive()`.
           Open a zip or tar archive
       
           Open a file and identify its archive type based on the archive
           signature contained inside.
       
           filename: a path to a file as it would be given to open(2).
           """
>>>>>>     return _mupdf.ll_fz_open_archive(filename)
       
    1: def ll_fz_open_archive_entry(arch, name):
           r"""
           Low-level wrapper for `::fz_open_archive_entry()`.
           Opens an archive entry as a stream.
       
           name: Entry name to look for, this must be an exact match to
           the entry name in the archive.
       
           Throws an exception if a matching entry cannot be found.
           """
>>>>>>     return _mupdf.ll_fz_open_archive_entry(arch, name)
       
    1: def ll_fz_open_archive_with_stream(file):
           r"""
           Low-level wrapper for `::fz_open_archive_with_stream()`.
           Open zip or tar archive stream.
       
           Open an archive using a seekable stream object rather than
           opening a file or directory on disk.
           """
>>>>>>     return _mupdf.ll_fz_open_archive_with_stream(file)
       
    1: def ll_fz_open_brotlid(chain):
           r"""
           Low-level wrapper for `::fz_open_brotlid()`.
           brotlid filter performs Brotli decoding of data read
           from the chained filter.
           """
>>>>>>     return _mupdf.ll_fz_open_brotlid(chain)
       
    1: def ll_fz_open_buffer(buf):
           r"""
           Low-level wrapper for `::fz_open_buffer()`.
           Open a buffer as a stream.
       
           buf: The buffer to open. Ownership of the buffer is NOT passed
           in (this function takes its own reference).
       
           Returns pointer to newly created stream. May throw exceptions on
           failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_open_buffer(buf)
       
    1: def ll_fz_open_cfb_archive(filename):
           r"""
           Low-level wrapper for `::fz_open_cfb_archive()`.
           Open a cfb file as an archive.
       
           An exception is thrown if the file is not recognised as a cfb.
       
           filename: a path to an archive file as it would be given to
           open(2).
           """
>>>>>>     return _mupdf.ll_fz_open_cfb_archive(filename)
       
    1: def ll_fz_open_cfb_archive_with_stream(file):
           r"""
           Low-level wrapper for `::fz_open_cfb_archive_with_stream()`.
           Open a cfb file as an archive.
       
           Open an archive using a seekable stream object rather than
           opening a file or directory on disk.
       
           An exception is thrown if the file is not recognised as a chm.
           """
>>>>>>     return _mupdf.ll_fz_open_cfb_archive_with_stream(file)
       
    1: def ll_fz_open_compressed_buffer(arg_1):
           r"""
           Low-level wrapper for `::fz_open_compressed_buffer()`.
           Open a stream to read the decompressed version of a buffer.
           """
>>>>>>     return _mupdf.ll_fz_open_compressed_buffer(arg_1)
       
    1: def ll_fz_open_concat(max, pad):
           r"""
           Low-level wrapper for `::fz_open_concat()`.
           Concat filter concatenates several streams into one.
           """
>>>>>>     return _mupdf.ll_fz_open_concat(max, pad)
       
    1: def ll_fz_open_dctd(chain, color_transform, invert_cmyk, l2factor, jpegtables):
           r"""
           Low-level wrapper for `::fz_open_dctd()`.
           dctd filter performs DCT (JPEG) decoding of data read
           from the chained filter.
       
           color_transform implements the PDF color_transform option
               use -1 for default behavior
               use 0 to disable YUV-RGB / YCCK-CMYK transforms
               use 1 to enable YUV-RGB / YCCK-CMYK transforms
       
           invert_cmyk implements the necessary inversion for Photoshop CMYK images
               use 0 if embedded in PDF
               use 1 if not embedded in PDF
       
           For subsampling on decode, set l2factor to the log2 of the
           reduction required (therefore 0 = full size decode).
       
           jpegtables is an optional stream from which the JPEG tables
           can be read. Use NULL if not required.
           """
>>>>>>     return _mupdf.ll_fz_open_dctd(chain, color_transform, invert_cmyk, l2factor, jpegtables)
       
    1: def ll_fz_open_directory(path):
           r"""
           Low-level wrapper for `::fz_open_directory()`.
           Open a directory as if it was an archive.
       
           A special case where a directory is opened as if it was an
           archive.
       
           Note that for directories it is not possible to retrieve the
           number of entries or list the entries. It is however possible
           to check if the archive has a particular entry.
       
           path: a path to a directory as it would be given to opendir(3).
           """
>>>>>>     return _mupdf.ll_fz_open_directory(path)
       
    1: def ll_fz_open_document(filename):
           r"""
           Low-level wrapper for `::fz_open_document()`.
           Open a document file and read its basic structure so pages and
           objects can be located. MuPDF will try to repair broken
           documents (without actually changing the file contents).
       
           The returned fz_document is used when calling most other
           document related functions.
       
           filename: a path to a file as it would be given to open(2).
           """
>>>>>>     return _mupdf.ll_fz_open_document(filename)
       
    1: def ll_fz_open_document_with_buffer(magic, buffer):
           r"""
           Low-level wrapper for `::fz_open_document_with_buffer()`.
           Open a document using a buffer rather than opening a file on disk.
           """
>>>>>>     return _mupdf.ll_fz_open_document_with_buffer(magic, buffer)
       
    1: def ll_fz_open_document_with_stream(magic, stream):
           r"""
           Low-level wrapper for `::fz_open_document_with_stream()`.
           Open a document using the specified stream object rather than
           opening a file on disk.
       
           magic: a string used to detect document type; either a file name
           or mime-type.
       
           stream: a stream representing the contents of the document file.
       
           NOTE: The caller retains ownership of 'stream' - the document will take its
           own reference if required.
           """
>>>>>>     return _mupdf.ll_fz_open_document_with_stream(magic, stream)
       
    1: def ll_fz_open_document_with_stream_and_dir(magic, stream, dir):
           r"""
           Low-level wrapper for `::fz_open_document_with_stream_and_dir()`.
           Open a document using the specified stream object rather than
           opening a file on disk.
       
           magic: a string used to detect document type; either a file name
           or mime-type.
       
           stream: a stream representing the contents of the document file.
       
           dir: a 'directory context' for those filetypes that need it.
       
           NOTE: The caller retains ownership of 'stream' and 'dir' - the document will
           take its own references if required.
           """
>>>>>>     return _mupdf.ll_fz_open_document_with_stream_and_dir(magic, stream, dir)
       
    1: def ll_fz_open_endstream_filter(chain, len, offset):
           r"""
           Low-level wrapper for `::fz_open_endstream_filter()`.
           The endstream filter reads a PDF substream, and starts to look
           for an 'endstream' token after the specified length.
           """
>>>>>>     return _mupdf.ll_fz_open_endstream_filter(chain, len, offset)
       
    1: def ll_fz_open_faxd(chain, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1):
           r"""
           Low-level wrapper for `::fz_open_faxd()`.
           faxd filter performs FAX decoding of data read from
           the chained filter.
       
           k: see fax specification (fax default is 0).
       
           end_of_line: whether we expect end of line markers (fax default
           is 0).
       
           encoded_byte_align: whether we align to bytes after each line
           (fax default is 0).
       
           columns: how many columns in the image (fax default is 1728).
       
           rows: 0 for unspecified or the number of rows of data to expect.
       
           end_of_block: whether we expect end of block markers (fax
           default is 1).
       
           black_is_1: determines the polarity of the image (fax default is
           0).
           """
>>>>>>     return _mupdf.ll_fz_open_faxd(chain, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1)
       
    1: def ll_fz_open_file(filename):
           r"""
           Low-level wrapper for `::fz_open_file()`.
           Open the named file and wrap it in a stream.
       
           filename: Path to a file. On non-Windows machines the filename
           should be exactly as it would be passed to fopen(2). On Windows
           machines, the path should be UTF-8 encoded so that non-ASCII
           characters can be represented. Other platforms do the encoding
           as standard anyway (and in most cases, particularly for MacOS
           and Linux, the encoding they use is UTF-8 anyway).
           """
>>>>>>     return _mupdf.ll_fz_open_file(filename)
       
    1: def ll_fz_open_file_autodelete(filename):
           r"""
           Low-level wrapper for `::fz_open_file_autodelete()`.
           Do the same as fz_open_file, but delete the file upon close.
           """
>>>>>>     return _mupdf.ll_fz_open_file_autodelete(filename)
       
    1: def ll_fz_open_file_ptr_no_close(file):
           r"""
           Low-level wrapper for `::fz_open_file_ptr_no_close()`.
           Create a stream from a FILE * that will not be closed
           when the stream is dropped.
           """
>>>>>>     return _mupdf.ll_fz_open_file_ptr_no_close(file)
       
    1: def ll_fz_open_flated(chain, window_bits):
           r"""
           Low-level wrapper for `::fz_open_flated()`.
           flated filter performs LZ77 decoding (inflating) of data read
           from the chained filter.
       
           window_bits: How large a decompression window to use. Typically
           15. A negative number, -n, means to use n bits, but to expect
           raw data with no header.
           """
>>>>>>     return _mupdf.ll_fz_open_flated(chain, window_bits)
       
    1: def ll_fz_open_image_decomp_stream(arg_1, arg_2, l2factor):
           r"""
            Low-level wrapper for `::fz_open_image_decomp_stream()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_open_image_decomp_stream(::fz_stream *arg_0, ::fz_compression_params *arg_1)` => `(fz_stream *, int l2factor)`
       
               Open a stream to read the decompressed version of another stream
               with optional log2 subsampling.
           """
>>>>>>     return _mupdf.ll_fz_open_image_decomp_stream(arg_1, arg_2, l2factor)
       
    1: def ll_fz_open_image_decomp_stream_from_buffer(arg_1, l2factor):
           r"""
            Low-level wrapper for `::fz_open_image_decomp_stream_from_buffer()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_open_image_decomp_stream_from_buffer(::fz_compressed_buffer *arg_0)` => `(fz_stream *, int l2factor)`
       
               Open a stream to read the decompressed version of a buffer,
               with optional log2 subsampling.
       
               l2factor = NULL for no subsampling, or a pointer to an integer
               containing the maximum log2 subsample factor acceptable (0 =
               none, 1 = halve dimensions, 2 = quarter dimensions etc). If
               non-NULL, then *l2factor will be updated on exit with the actual
               log2 subsample factor achieved.
           """
>>>>>>     return _mupdf.ll_fz_open_image_decomp_stream_from_buffer(arg_1, l2factor)
       
    1: def ll_fz_open_jbig2d(chain, globals, embedded):
           r"""
           Low-level wrapper for `::fz_open_jbig2d()`.
           Open a filter that performs jbig2 decompression on the chained
           stream, using the optional globals record.
           """
>>>>>>     return _mupdf.ll_fz_open_jbig2d(chain, globals, embedded)
       
    1: def ll_fz_open_leecher(chain, buf):
           r"""
           Low-level wrapper for `::fz_open_leecher()`.
           Attach a filter to a stream that will store any
           characters read from the stream into the supplied buffer.
       
           chain: The underlying stream to leech from.
       
           buf: The buffer into which the read data should be appended.
           The buffer will be resized as required.
       
           Returns pointer to newly created stream. May throw exceptions on
           failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_open_leecher(chain, buf)
       
    1: def ll_fz_open_libarchive_archive(filename):
           r"""
           Low-level wrapper for `::fz_open_libarchive_archive()`.
           Open an archive using libarchive.
       
           An exception is thrown if the file is not supported by libarchive.
       
           filename: a path to an archive file as it would be given to
           open(2).
           """
>>>>>>     return _mupdf.ll_fz_open_libarchive_archive(filename)
       
    1: def ll_fz_open_libarchive_archive_with_stream(file):
           r"""
           Low-level wrapper for `::fz_open_libarchive_archive_with_stream()`.
           Open an archive using libarchive.
       
           Open an archive using a seekable stream object rather than
           opening a file or directory on disk.
       
           An exception is thrown if the stream is not supported by libarchive.
           """
>>>>>>     return _mupdf.ll_fz_open_libarchive_archive_with_stream(file)
       
    1: def ll_fz_open_libarchived(chain):
           r"""
           Low-level wrapper for `::fz_open_libarchived()`.
           libarchived filter performs generic compressed decoding of data
           in any format understood by libarchive from the chained filter.
       
           This will throw an exception if libarchive is not built in, or
           if the compression format is not recognised.
           """
>>>>>>     return _mupdf.ll_fz_open_libarchived(chain)
       
    1: def ll_fz_open_lzwd(chain, early_change, min_bits, reverse_bits, old_tiff):
           r"""
           Low-level wrapper for `::fz_open_lzwd()`.
           lzwd filter performs LZW decoding of data read from the chained
           filter.
       
           early_change: (Default 1) specifies whether to change codes 1
           bit early.
       
           min_bits: (Default 9) specifies the minimum number of bits to
           use.
       
           reverse_bits: (Default 0) allows for compatibility with gif and
           old style tiffs (1).
       
           old_tiff: (Default 0) allows for different handling of the clear
           code, as found in old style tiffs.
           """
>>>>>>     return _mupdf.ll_fz_open_lzwd(chain, early_change, min_bits, reverse_bits, old_tiff)
       
    1: def ll_fz_open_memory(data, len):
           r"""
           Low-level wrapper for `::fz_open_memory()`.
           Open a block of memory as a stream.
       
           data: Pointer to start of data block. Ownership of the data
           block is NOT passed in.
       
           len: Number of bytes in data block.
       
           Returns pointer to newly created stream. May throw exceptions on
           failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_open_memory(data, len)
       
    1: def ll_fz_open_null_filter(chain, len, offset):
           r"""
           Low-level wrapper for `::fz_open_null_filter()`.
           The null filter reads a specified amount of data from the
           substream.
           """
>>>>>>     return _mupdf.ll_fz_open_null_filter(chain, len, offset)
       
    1: def ll_fz_open_predict(chain, predictor, columns, colors, bpc):
           r"""
           Low-level wrapper for `::fz_open_predict()`.
           predict filter performs pixel prediction on data read from
           the chained filter.
       
           predictor: 1 = copy, 2 = tiff, other = inline PNG predictor
       
           columns: width of image in pixels
       
           colors: number of components.
       
           bpc: bits per component (typically 8)
           """
>>>>>>     return _mupdf.ll_fz_open_predict(chain, predictor, columns, colors, bpc)
       
    1: def ll_fz_open_range_filter(chain, ranges, nranges):
           r"""
           Low-level wrapper for `::fz_open_range_filter()`.
           The range filter copies data from specified ranges of the
           chained stream.
           """
>>>>>>     return _mupdf.ll_fz_open_range_filter(chain, ranges, nranges)
       
    1: def ll_fz_open_reflowed_document(underdoc, opts):
           r"""Low-level wrapper for `::fz_open_reflowed_document()`."""
>>>>>>     return _mupdf.ll_fz_open_reflowed_document(underdoc, opts)
       
    1: def ll_fz_open_rld(chain):
           r"""
           Low-level wrapper for `::fz_open_rld()`.
           rld filter performs Run Length Decoding of data read
           from the chained filter.
           """
>>>>>>     return _mupdf.ll_fz_open_rld(chain)
       
    1: def ll_fz_open_sgilog16(chain, w):
           r"""
           Low-level wrapper for `::fz_open_sgilog16()`.
           SGI Log 16bit (greyscale) decode from the chained filter.
           Decodes lines of w pixels to 8bpp greyscale.
           """
>>>>>>     return _mupdf.ll_fz_open_sgilog16(chain, w)
       
    1: def ll_fz_open_sgilog24(chain, w):
           r"""
           Low-level wrapper for `::fz_open_sgilog24()`.
           SGI Log 24bit (LUV) decode from the chained filter.
           Decodes lines of w pixels to 8bpc rgb.
           """
>>>>>>     return _mupdf.ll_fz_open_sgilog24(chain, w)
       
    1: def ll_fz_open_sgilog32(chain, w):
           r"""
           Low-level wrapper for `::fz_open_sgilog32()`.
           SGI Log 32bit (LUV) decode from the chained filter.
           Decodes lines of w pixels to 8bpc rgb.
           """
>>>>>>     return _mupdf.ll_fz_open_sgilog32(chain, w)
       
    1: def ll_fz_open_tar_archive(filename):
           r"""
           Low-level wrapper for `::fz_open_tar_archive()`.
           Open a tar archive file.
       
           An exception is thrown if the file is not a tar archive as
           indicated by the presence of a tar signature.
       
           filename: a path to a tar archive file as it would be given to
           open(2).
           """
>>>>>>     return _mupdf.ll_fz_open_tar_archive(filename)
       
    1: def ll_fz_open_tar_archive_with_stream(file):
           r"""
           Low-level wrapper for `::fz_open_tar_archive_with_stream()`.
           Open a tar archive stream.
       
           Open an archive using a seekable stream object rather than
           opening a file or directory on disk.
       
           An exception is thrown if the stream is not a tar archive as
           indicated by the presence of a tar signature.
       
           """
>>>>>>     return _mupdf.ll_fz_open_tar_archive_with_stream(file)
       
    1: def ll_fz_open_thunder(chain, w):
           r"""
           Low-level wrapper for `::fz_open_thunder()`.
           4bit greyscale Thunderscan decoding from the chained filter.
           Decodes lines of w pixels to 8bpp greyscale.
           """
>>>>>>     return _mupdf.ll_fz_open_thunder(chain, w)
       
    1: def ll_fz_open_zip_archive(path):
           r"""
           Low-level wrapper for `::fz_open_zip_archive()`.
           Open a zip archive file.
       
           An exception is thrown if the file is not a zip archive as
           indicated by the presence of a zip signature.
       
           filename: a path to a zip archive file as it would be given to
           open(2).
           """
>>>>>>     return _mupdf.ll_fz_open_zip_archive(path)
       
    1: def ll_fz_open_zip_archive_with_stream(file):
           r"""
           Low-level wrapper for `::fz_open_zip_archive_with_stream()`.
           Open a zip archive stream.
       
           Open an archive using a seekable stream object rather than
           opening a file or directory on disk.
       
           An exception is thrown if the stream is not a zip archive as
           indicated by the presence of a zip signature.
       
           """
>>>>>>     return _mupdf.ll_fz_open_zip_archive_with_stream(file)
       
    1: def ll_fz_opt_from_list(opt, optlist):
           r"""
           Low-level wrapper for `::fz_opt_from_list()`.
           Return the index of a (case-insensitive) option within an optlist.
       
           For instance for optlist = "Foo|Bar|Baz", and  opt = "bar",
           this would return 1.
       
           If the optlist ends with "|*" then that is a catch all case and
           matches all options allowing the caller to process it itself.
           fz_optarg will be set to point to the option, and the return
           value will be the index of the '*' option within that list.
       
           If an optlist entry ends with ':' (e.g. "Foo:") then that option
           may have suboptions appended to it (for example "JPG:80") and
           fz_optarg will be set to point at "80". Otherwise fz_optarg will
           be set to NULL.
       
           In the event of no-match found, prints an error and returns -1.
           """
>>>>>>     return _mupdf.ll_fz_opt_from_list(opt, optlist)
       
    1: def ll_fz_option_eq(a, b):
           r"""
           Low-level wrapper for `::fz_option_eq()`.
           Check to see if an option, a, from a string matches a reference
           option, b.
       
           (i.e. a could be 'foo' or 'foo,bar...' etc, but b can only be
           'foo'.)
           """
>>>>>>     return _mupdf.ll_fz_option_eq(a, b)
       
    1: def ll_fz_optpath(opt):
           r"""
           Low-level wrapper for `::fz_optpath()`.
           Convert "-" to "/dev/stdout" for use with command lines.
           Also converts "nul" and "con" on Windows.
           """
>>>>>>     return _mupdf.ll_fz_optpath(opt)
       
    1: def ll_fz_outline_glyph(font, gid, ctm):
           r"""
           Low-level wrapper for `::fz_outline_glyph()`.
           Look a glyph up from a font, and return the outline of the
           glyph using the given transform.
       
           The caller owns the returned path, and so is responsible for
           ensuring that it eventually gets dropped.
           """
>>>>>>     return _mupdf.ll_fz_outline_glyph(font, gid, ctm)
       
    1: def ll_fz_outline_iterator_delete(iter):
           r"""
           Low-level wrapper for `::fz_outline_iterator_delete()`.
           Delete the current item.
       
           This implicitly moves us to the 'next' item, and the return code is as for fz_outline_iterator_next.
           """
>>>>>>     return _mupdf.ll_fz_outline_iterator_delete(iter)
       
    1: def ll_fz_outline_iterator_down(iter):
           r"""Low-level wrapper for `::fz_outline_iterator_down()`."""
>>>>>>     return _mupdf.ll_fz_outline_iterator_down(iter)
       
    1: def ll_fz_outline_iterator_from_outline(outline):
           r"""Low-level wrapper for `::fz_outline_iterator_from_outline()`."""
>>>>>>     return _mupdf.ll_fz_outline_iterator_from_outline(outline)
       
    1: def ll_fz_outline_iterator_insert(iter, item):
           r"""
           Low-level wrapper for `::fz_outline_iterator_insert()`.
           Call to insert a new item BEFORE the current point.
       
           Ownership of pointers are retained by the caller. The item data will be copied.
       
           After an insert, we do not change where we are pointing.
           The return code is the same as for next, it indicates the current iterator position.
       
           Note that for PDF documents at least, the is_open field is ignored. All childless
           nodes are considered closed by PDF, hence (given every newly inserted node is
           childless by definition) all new nodes are inserted with is_open == false.
           """
>>>>>>     return _mupdf.ll_fz_outline_iterator_insert(iter, item)
       
    1: def ll_fz_outline_iterator_item(iter):
           r"""
           Low-level wrapper for `::fz_outline_iterator_item()`.
           Call to get the current outline item.
       
           Can return NULL. The item is only valid until the next call.
           """
>>>>>>     return _mupdf.ll_fz_outline_iterator_item(iter)
       
    1: def ll_fz_outline_iterator_next(iter):
           r"""
           Low-level wrapper for `::fz_outline_iterator_next()`.
           Calls to move the iterator position.
       
           A negative return value means we could not move as requested. Otherwise:
           0 = the final position has a valid item.
           1 = not a valid item, but we can insert an item here.
           """
>>>>>>     return _mupdf.ll_fz_outline_iterator_next(iter)
       
    1: def ll_fz_outline_iterator_prev(iter):
           r"""Low-level wrapper for `::fz_outline_iterator_prev()`."""
>>>>>>     return _mupdf.ll_fz_outline_iterator_prev(iter)
       
    1: def ll_fz_outline_iterator_up(iter):
           r"""Low-level wrapper for `::fz_outline_iterator_up()`."""
>>>>>>     return _mupdf.ll_fz_outline_iterator_up(iter)
       
    1: def ll_fz_outline_iterator_update(iter, item):
           r"""
           Low-level wrapper for `::fz_outline_iterator_update()`.
           Update the current item properties according to the given item.
           """
>>>>>>     return _mupdf.ll_fz_outline_iterator_update(iter, item)
       
    1: def ll_fz_output_accelerator(doc, accel):
           r"""
           Low-level wrapper for `::fz_output_accelerator()`.
           Output accelerator data for the document to a given output
           stream.
           """
>>>>>>     return _mupdf.ll_fz_output_accelerator(doc, accel)
       
    1: def ll_fz_output_supports_stream(out):
           r"""
           Low-level wrapper for `::fz_output_supports_stream()`.
           Query whether a given fz_output supports fz_stream_from_output.
           """
>>>>>>     return _mupdf.ll_fz_output_supports_stream(out)
       
    1: def ll_fz_output_xml(out, item, level):
           r"""
           Low-level wrapper for `::fz_output_xml()`.
           Pretty-print an XML tree to given output.
           """
>>>>>>     return _mupdf.ll_fz_output_xml(out, item, level)
       
    1: def ll_fz_overlaps_rect(a, b):
           r"""
           Low-level wrapper for `::fz_overlaps_rect()`.
           Test rectangle overlap.
       
           Returns true if the area of the overlap is
           non zero.
           """
>>>>>>     return _mupdf.ll_fz_overlaps_rect(a, b)
       
    1: def ll_fz_pack_path(pack, path):
           r"""
           Low-level wrapper for `::fz_pack_path()`.
           Pack a path into the given block.
           To minimise the size of paths, this function allows them to be
           packed into a buffer with other information. Paths can be used
           interchangeably regardless of how they are packed.
       
           pack: Pointer to a block of data to pack the path into. Should
           be aligned by the caller to the same alignment as required for
           a fz_path pointer.
       
           path: The path to pack.
       
           Returns the number of bytes within the block used. Callers can
           access the packed path data by casting the value of pack on
           entry to be a fz_path *.
       
           Throws exceptions on failure to allocate.
       
           Implementation details: Paths can be 'unpacked', 'flat', or
           'open'. Standard paths, as created are 'unpacked'. Paths
           will be packed as 'flat', unless they are too large
           (where large indicates that they exceed some private
           implementation defined limits, currently including having
           more than 256 coordinates or commands).
       
           Large paths are 'open' packed as a header into the given block,
           plus pointers to other data blocks.
       
           Users should not have to care about whether paths are 'open'
           or 'flat' packed. Simply pack a path (if required), and then
           forget about the details.
           """
>>>>>>     return _mupdf.ll_fz_pack_path(pack, path)
       
    1: def ll_fz_packed_path_size(path):
           r"""
           Low-level wrapper for `::fz_packed_path_size()`.
           Return the number of bytes required to pack a path.
           """
>>>>>>     return _mupdf.ll_fz_packed_path_size(path)
       
    1: def ll_fz_page_label(page, buf, size):
           r"""
           Low-level wrapper for `::fz_page_label()`.
           Get page label for a given page.
           """
>>>>>>     return _mupdf.ll_fz_page_label(page, buf, size)
       
    1: def ll_fz_page_number_from_location(doc, loc):
           r"""
           Low-level wrapper for `::fz_page_number_from_location()`.
           Converts from chapter+page to page number. This may cause many
           chapters to be laid out in order to calculate the number of
           pages within those chapters.
           """
>>>>>>     return _mupdf.ll_fz_page_number_from_location(doc, loc)
       
    1: def ll_fz_page_presentation(page, transition, duration):
           r"""
            Low-level wrapper for `::fz_page_presentation()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_page_presentation(::fz_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`
       
               Get the presentation details for a given page.
       
               transition: A pointer to a transition struct to fill out.
       
               duration: A pointer to a place to set the page duration in
               seconds. Will be set to 0 if no transition is specified for the
               page.
       
               Returns: a pointer to the transition structure, or NULL if there
               is no transition specified for the page.
           """
>>>>>>     return _mupdf.ll_fz_page_presentation(page, transition, duration)
       
    1: def ll_fz_page_separations(page):
           r"""
           Low-level wrapper for `::fz_page_separations()`.
           Get the separations details for a page.
           This will be NULL, unless the format specifically supports
           separations (such as PDF files). May be NULL even
           so, if there are no separations on a page.
       
           Returns a reference that must be dropped.
           """
>>>>>>     return _mupdf.ll_fz_page_separations(page)
       
    1: def ll_fz_page_uses_overprint(page):
           r"""
           Low-level wrapper for `::fz_page_uses_overprint()`.
           Query if a given page requires overprint.
           """
>>>>>>     return _mupdf.ll_fz_page_uses_overprint(page)
       
    1: def ll_fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop, cache):
           r"""
            Low-level wrapper for `::fz_paint_shade()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_paint_shade(::fz_shade *shade, ::fz_colorspace *override_cs, ::fz_matrix ctm, ::fz_pixmap *dest, ::fz_color_params color_params, ::fz_irect bbox, const ::fz_overprint *eop, ::fz_shade_color_cache **cache)` =>
       
               Render a shade to a given pixmap.
       
               shade: The shade to paint.
       
               override_cs: NULL, or colorspace to override the shades
               inbuilt colorspace.
       
               ctm: The transform to apply.
       
               dest: The pixmap to render into.
       
               color_params: The color rendering settings
       
               bbox: Pointer to a bounding box to limit the rendering
               of the shade.
       
               eop: NULL, or pointer to overprint bitmap.
       
               cache: *cache is used to cache color information. If *cache is NULL it
               is set to point to a new fz_shade_color_cache. If cache is NULL it is
               ignored.
           """
>>>>>>     return _mupdf.ll_fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop, cache)
       
    1: def ll_fz_paragraph_break(page):
           r"""
           Low-level wrapper for `::fz_paragraph_break()`.
           Attempt to break paragraphs at plausible places.
           """
>>>>>>     return _mupdf.ll_fz_paragraph_break(page)
       
    1: def ll_fz_parse_draw_options(options, string):
           r"""
           Low-level wrapper for `::fz_parse_draw_options()`.
           Parse draw device options from a comma separated key-value string.
           """
>>>>>>     return _mupdf.ll_fz_parse_draw_options(options, string)
       
    1: def ll_fz_parse_json(pool, s):
           r"""Low-level wrapper for `::fz_parse_json()`."""
>>>>>>     return _mupdf.ll_fz_parse_json(pool, s)
       
    1: def ll_fz_parse_page_range(s, a, b, n):
           r"""
            Low-level wrapper for `::fz_parse_page_range()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_parse_page_range(const char *s, int n)` => `(const char *, int a, int b)`
           """
>>>>>>     return _mupdf.ll_fz_parse_page_range(s, a, b, n)
       
    1: def ll_fz_parse_pcl_options(opts, args):
           r"""
           Low-level wrapper for `::fz_parse_pcl_options()`.
           Parse PCL options.
       
           Currently defined options and values are as follows:
       
               preset=X        Either "generic" or one of the presets as for fz_pcl_preset.
               spacing=0       No vertical spacing capability
               spacing=1       PCL 3 spacing (<ESC>*p+<n>Y)
               spacing=2       PCL 4 spacing (<ESC>*b<n>Y)
               spacing=3       PCL 5 spacing (<ESC>*b<n>Y and clear seed row)
               mode2           Disable/Enable mode 2 graphics compression
               mode3           Disable/Enable mode 3 graphics compression
               eog_reset       End of graphics (<ESC>*rB) resets all parameters
               has_duplex      Duplex supported (<ESC>&l<duplex>S)
               has_papersize   Papersize setting supported (<ESC>&l<sizecode>A)
               has_copies      Number of copies supported (<ESC>&l<copies>X)
               is_ljet4pjl     Disable/Enable HP 4PJL model-specific output
               is_oce9050      Disable/Enable Oce 9050 model-specific output
           """
>>>>>>     return _mupdf.ll_fz_parse_pcl_options(opts, args)
       
    1: def ll_fz_parse_pclm_options(opts, args):
           r"""
           Low-level wrapper for `::fz_parse_pclm_options()`.
           Parse PCLm options.
       
           Currently defined options and values are as follows:
       
               compression=none: No compression
               compression=flate: Flate compression
               strip-height=n: Strip height (default 16)
           """
>>>>>>     return _mupdf.ll_fz_parse_pclm_options(opts, args)
       
    1: def ll_fz_parse_pdfocr_options(opts, args):
           r"""
           Low-level wrapper for `::fz_parse_pdfocr_options()`.
           Parse PDFOCR options.
       
           Currently defined options and values are as follows:
       
               compression=none: No compression
               compression=flate: Flate compression
               strip-height=n: Strip height (default 16)
               ocr-language=<lang>: OCR Language (default eng)
               ocr-datadir=<datadir>: OCR data path (default rely on TESSDATA_PREFIX)
           """
>>>>>>     return _mupdf.ll_fz_parse_pdfocr_options(opts, args)
       
    1: def ll_fz_parse_stext_options(opts, string):
           r"""
           Low-level wrapper for `::fz_parse_stext_options()`.
           Parse stext device options from a comma separated key-value
           string.
           """
>>>>>>     return _mupdf.ll_fz_parse_stext_options(opts, string)
       
    1: def ll_fz_parse_xml(buf, preserve_white):
           r"""
           Low-level wrapper for `::fz_parse_xml()`.
           Parse the contents of buffer into a tree of xml nodes.
       
           preserve_white: whether to keep or delete all-whitespace nodes.
           """
>>>>>>     return _mupdf.ll_fz_parse_xml(buf, preserve_white)
       
    1: def ll_fz_parse_xml_archive_entry(dir, filename, preserve_white):
           r"""
           Low-level wrapper for `::fz_parse_xml_archive_entry()`.
           Parse the contents of an archive entry into a tree of xml nodes.
       
           preserve_white: whether to keep or delete all-whitespace nodes.
           """
>>>>>>     return _mupdf.ll_fz_parse_xml_archive_entry(dir, filename, preserve_white)
       
    1: def ll_fz_parse_xml_from_html5(buf):
           r"""
           Low-level wrapper for `::fz_parse_xml_from_html5()`.
           Parse the contents of a buffer into a tree of XML nodes,
           using the HTML5 parsing algorithm.
           """
>>>>>>     return _mupdf.ll_fz_parse_xml_from_html5(buf)
       
    1: def ll_fz_parse_xml_stream(stream, preserve_white):
           r"""
           Low-level wrapper for `::fz_parse_xml_stream()`.
           Parse the contents of buffer into a tree of xml nodes.
       
           preserve_white: whether to keep or delete all-whitespace nodes.
           """
>>>>>>     return _mupdf.ll_fz_parse_xml_stream(stream, preserve_white)
       
    1: def ll_fz_path_is_rect(path, ctm):
           r"""
           Low-level wrapper for `::fz_path_is_rect()`.
           Check whether a given path, under the given transform
           is an axis-aligned rectangle.
       
           We accept zero width or height rectangles, so
           "move 100, 100; line 200, 100" would count as
           a rectangle too.
           """
>>>>>>     return _mupdf.ll_fz_path_is_rect(path, ctm)
       
    1: def ll_fz_path_is_rect_with_bounds(path, ctm, bounds):
           r"""
           Low-level wrapper for `::fz_path_is_rect_with_bounds()`.
           Check whether a given path, under the given transform
           is an axis-aligned rectangle.
       
           We accept zero width or height rectangles, so
           "move 100, 100; line 200, 100" would count as
           a rectangle too.
       
           bounds = NULL, or place to return the rectangle
           bounds if the path is a rectangle.
           """
>>>>>>     return _mupdf.ll_fz_path_is_rect_with_bounds(path, ctm, bounds)
       
    1: def ll_fz_pcl_preset(opts, preset):
           r"""
           Low-level wrapper for `::fz_pcl_preset()`.
           Initialize PCL option struct for a given preset.
       
           Currently defined presets include:
       
               generic Generic PCL printer
               ljet4   HP DeskJet
               dj500   HP DeskJet 500
               fs600   Kyocera FS-600
               lj      HP LaserJet, HP LaserJet Plus
               lj2     HP LaserJet IIp, HP LaserJet IId
               lj3     HP LaserJet III
               lj3d    HP LaserJet IIId
               lj4     HP LaserJet 4
               lj4pl   HP LaserJet 4 PL
               lj4d    HP LaserJet 4d
               lp2563b HP 2563B line printer
               oce9050 Oce 9050 Line printer
           """
>>>>>>     return _mupdf.ll_fz_pcl_preset(opts, preset)
       
    1: def ll_fz_pdfocr_band_writer_set_progress(writer, progress_fn, progress_arg):
           r"""
           Low-level wrapper for `::fz_pdfocr_band_writer_set_progress()`.
           Set the progress callback for a pdfocr bandwriter.
           """
>>>>>>     return _mupdf.ll_fz_pdfocr_band_writer_set_progress(writer, progress_fn, progress_arg)
       
    1: def ll_fz_pdfocr_writer_set_progress(writer, progress, arg_3):
           r"""Low-level wrapper for `::fz_pdfocr_writer_set_progress()`."""
>>>>>>     return _mupdf.ll_fz_pdfocr_writer_set_progress(writer, progress, arg_3)
       
    1: def ll_fz_peek_byte(stm):
           r"""
           Low-level wrapper for `::fz_peek_byte()`.
           Peek at the next byte in a stream.
       
           stm: The stream to peek at.
       
           Returns -1 for EOF, or the next byte that will be read.
           """
>>>>>>     return _mupdf.ll_fz_peek_byte(stm)
       
    1: def ll_fz_pixmap_alpha(pix):
           r"""
           Low-level wrapper for `::fz_pixmap_alpha()`.
           Return the number of alpha planes in a pixmap.
       
           Returns the number of alphas. Does not throw exceptions.
           """
>>>>>>     return _mupdf.ll_fz_pixmap_alpha(pix)
       
    1: def ll_fz_pixmap_bbox(pix):
           r"""
           Low-level wrapper for `::fz_pixmap_bbox()`.
           Return the bounding box for a pixmap.
           """
>>>>>>     return _mupdf.ll_fz_pixmap_bbox(pix)
       
    1: def ll_fz_pixmap_colorants(pix):
           r"""
           Low-level wrapper for `::fz_pixmap_colorants()`.
           Return the number of colorants in a pixmap.
       
           Returns the number of colorants (components, less any spots and
           alpha).
           """
>>>>>>     return _mupdf.ll_fz_pixmap_colorants(pix)
       
    1: def ll_fz_pixmap_colorspace(pix):
           r"""
           Low-level wrapper for `::fz_pixmap_colorspace()`.
           Return the colorspace of a pixmap
       
           Returns colorspace.
           """
>>>>>>     return _mupdf.ll_fz_pixmap_colorspace(pix)
       
    1: def ll_fz_pixmap_components(pix):
           r"""
           Low-level wrapper for `::fz_pixmap_components()`.
           Return the number of components in a pixmap.
       
           Returns the number of components (including spots and alpha).
           """
>>>>>>     return _mupdf.ll_fz_pixmap_components(pix)
       
    1: def ll_fz_pixmap_height(pix):
           r"""
           Low-level wrapper for `::fz_pixmap_height()`.
           Return the height of the pixmap in pixels.
           """
>>>>>>     return _mupdf.ll_fz_pixmap_height(pix)
       
    1: def ll_fz_pixmap_image_tile(cimg):
           r"""
           Low-level wrapper for `::fz_pixmap_image_tile()`.
           Retrieve the underlying fz_pixmap for an image.
       
           Returns a pointer to the underlying fz_pixmap for an image,
           or NULL if this image is not based upon an fz_pixmap.
       
           No reference is returned. Lifespan is limited to that of
           the image itself. If required, use fz_keep_pixmap to take
           a reference to keep it longer.
           """
>>>>>>     return _mupdf.ll_fz_pixmap_image_tile(cimg)
       
    1: def ll_fz_pixmap_samples(pix):
           r"""
           Low-level wrapper for `::fz_pixmap_samples()`.
           Returns a pointer to the pixel data of a pixmap.
       
           Returns the pointer.
           """
>>>>>>     return _mupdf.ll_fz_pixmap_samples(pix)
       
    1: def ll_fz_pixmap_samples_int(pixmap):
           r"""Low-level wrapper for `::fz_pixmap_samples_int()`."""
>>>>>>     return _mupdf.ll_fz_pixmap_samples_int(pixmap)
       
    1: def ll_fz_pixmap_size(pix):
           r"""
           Low-level wrapper for `::fz_pixmap_size()`.
           Return sizeof fz_pixmap plus size of data, in bytes.
           """
>>>>>>     return _mupdf.ll_fz_pixmap_size(pix)
       
    1: def ll_fz_pixmap_spots(pix):
           r"""
           Low-level wrapper for `::fz_pixmap_spots()`.
           Return the number of spots in a pixmap.
       
           Returns the number of spots (components, less colorants and
           alpha). Does not throw exceptions.
           """
>>>>>>     return _mupdf.ll_fz_pixmap_spots(pix)
       
    1: def ll_fz_pixmap_stride(pix):
           r"""
           Low-level wrapper for `::fz_pixmap_stride()`.
           Return the number of bytes in a row in the pixmap.
           """
>>>>>>     return _mupdf.ll_fz_pixmap_stride(pix)
       
    1: def ll_fz_pixmap_width(pix):
           r"""
           Low-level wrapper for `::fz_pixmap_width()`.
           Return the width of the pixmap in pixels.
           """
>>>>>>     return _mupdf.ll_fz_pixmap_width(pix)
       
    1: def ll_fz_pixmap_x(pix):
           r"""
           Low-level wrapper for `::fz_pixmap_x()`.
           Return the x value of the pixmap in pixels.
           """
>>>>>>     return _mupdf.ll_fz_pixmap_x(pix)
       
    1: def ll_fz_pixmap_y(pix):
           r"""
           Low-level wrapper for `::fz_pixmap_y()`.
           Return the y value of the pixmap in pixels.
           """
>>>>>>     return _mupdf.ll_fz_pixmap_y(pix)
       
    1: def ll_fz_place_story(story, where, filled):
           r"""Low-level wrapper for `::fz_place_story()`."""
>>>>>>     return _mupdf.ll_fz_place_story(story, where, filled)
       
    1: def ll_fz_place_story_flags(story, where, filled, flags):
           r"""Low-level wrapper for `::fz_place_story_flags()`."""
>>>>>>     return _mupdf.ll_fz_place_story_flags(story, where, filled, flags)
       
    1: def ll_fz_pool_alloc(pool, size):
           r"""
           Low-level wrapper for `::fz_pool_alloc()`.
           Allocate a block of size bytes from the pool.
           """
>>>>>>     return _mupdf.ll_fz_pool_alloc(pool, size)
       
    1: def ll_fz_pool_array_append(arr, idx):
           r"""
            Low-level wrapper for `::fz_pool_array_append()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_pool_array_append(::fz_pool_array *arr)` => `(void *, size_t idx)`
       
               Append an element to the end of the array.
       
               Returns a pointer to the new element (initially all 0's), and
               (optionally) the index of that element.
           """
>>>>>>     return _mupdf.ll_fz_pool_array_append(arr, idx)
       
    1: def ll_fz_pool_array_len(arr):
           r"""
           Low-level wrapper for `::fz_pool_array_len()`.
           Get the length of the array.
           """
>>>>>>     return _mupdf.ll_fz_pool_array_len(arr)
       
    1: def ll_fz_pool_array_lookup(arr, idx):
           r"""
           Low-level wrapper for `::fz_pool_array_lookup()`.
           Lookup an element in the array.
           """
>>>>>>     return _mupdf.ll_fz_pool_array_lookup(arr, idx)
       
    1: def ll_fz_pool_size(pool):
           r"""
           Low-level wrapper for `::fz_pool_size()`.
           The current size of the pool.
       
           The number of bytes of storage currently allocated to the pool.
           This is the total of the storage used for the blocks making
           up the pool, rather then total of the allocated blocks so far,
           so it will increase in 'lumps'.
           from the pool, then the pool size may still be X
           """
>>>>>>     return _mupdf.ll_fz_pool_size(pool)
       
    1: def ll_fz_pool_strdup(pool, s):
           r"""
           Low-level wrapper for `::fz_pool_strdup()`.
           strdup equivalent allocating from the pool.
           """
>>>>>>     return _mupdf.ll_fz_pool_strdup(pool, s)
       
    1: def ll_fz_pop_clip(dev):
           r"""Low-level wrapper for `::fz_pop_clip()`."""
>>>>>>     return _mupdf.ll_fz_pop_clip(dev)
       
    1: def ll_fz_post_scale(m, sx, sy):
           r"""
           Low-level wrapper for `::fz_post_scale()`.
           Scale a matrix by postmultiplication.
       
           m: Pointer to the matrix to scale
       
           sx, sy: Scaling factors along the X- and Y-axes. A scaling
           factor of 1.0 will not cause any scaling along the relevant
           axis.
       
           Returns m (updated).
           """
>>>>>>     return _mupdf.ll_fz_post_scale(m, sx, sy)
       
    1: def ll_fz_pre_rotate(m, degrees):
           r"""
           Low-level wrapper for `::fz_pre_rotate()`.
           Rotate a transformation by premultiplying.
       
           The premultiplied matrix is of the form
           [ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].
       
           m: Pointer to matrix to premultiply.
       
           degrees: Degrees of counter clockwise rotation. Values less
           than zero and greater than 360 are handled as expected.
       
           Returns m (updated).
           """
>>>>>>     return _mupdf.ll_fz_pre_rotate(m, degrees)
       
    1: def ll_fz_pre_scale(m, sx, sy):
           r"""
           Low-level wrapper for `::fz_pre_scale()`.
           Scale a matrix by premultiplication.
       
           m: Pointer to the matrix to scale
       
           sx, sy: Scaling factors along the X- and Y-axes. A scaling
           factor of 1.0 will not cause any scaling along the relevant
           axis.
       
           Returns m (updated).
           """
>>>>>>     return _mupdf.ll_fz_pre_scale(m, sx, sy)
       
    1: def ll_fz_pre_shear(m, sx, sy):
           r"""
           Low-level wrapper for `::fz_pre_shear()`.
           Premultiply a matrix with a shearing matrix.
       
           The shearing matrix is of the form [ 1 sy sx 1 0 0 ].
       
           m: pointer to matrix to premultiply
       
           sx, sy: Shearing factors. A shearing factor of 0.0 will not
           cause any shearing along the relevant axis.
       
           Returns m (updated).
           """
>>>>>>     return _mupdf.ll_fz_pre_shear(m, sx, sy)
       
    1: def ll_fz_pre_translate(m, tx, ty):
           r"""
           Low-level wrapper for `::fz_pre_translate()`.
           Translate a matrix by premultiplication.
       
           m: The matrix to translate
       
           tx, ty: Translation distances along the X- and Y-axes. A
           translation of 0 will not cause any translation along the
           relevant axis.
       
           Returns m.
           """
>>>>>>     return _mupdf.ll_fz_pre_translate(m, tx, ty)
       
    1: def ll_fz_prepare_t3_glyph(font, gid):
           r"""
           Low-level wrapper for `::fz_prepare_t3_glyph()`.
           Force a type3 font to cache the displaylist for a given glyph
           id.
       
           This caching can involve reading the underlying file, so must
           happen ahead of time, so we aren't suddenly forced to read the
           file while playing a displaylist back.
           """
>>>>>>     return _mupdf.ll_fz_prepare_t3_glyph(font, gid)
       
    1: def ll_fz_previous_page(doc, loc):
           r"""
           Low-level wrapper for `::fz_previous_page()`.
           Function to get the location of the previous page (allowing for
           the end of chapters etc). If already at the start of the
           document, returns the current page.
           """
>>>>>>     return _mupdf.ll_fz_previous_page(doc, loc)
       
    1: def ll_fz_print_stext_header_as_html(out):
           r"""Low-level wrapper for `::fz_print_stext_header_as_html()`."""
>>>>>>     return _mupdf.ll_fz_print_stext_header_as_html(out)
       
    1: def ll_fz_print_stext_header_as_xhtml(out):
           r"""Low-level wrapper for `::fz_print_stext_header_as_xhtml()`."""
>>>>>>     return _mupdf.ll_fz_print_stext_header_as_xhtml(out)
       
    1: def ll_fz_print_stext_page_as_html(out, page, id):
           r"""
           Low-level wrapper for `::fz_print_stext_page_as_html()`.
           Output structured text to a file in HTML (visual) format.
           """
>>>>>>     return _mupdf.ll_fz_print_stext_page_as_html(out, page, id)
       
    1: def ll_fz_print_stext_page_as_json(out, page, scale):
           r"""
           Low-level wrapper for `::fz_print_stext_page_as_json()`.
           Output structured text to a file in JSON format.
           """
>>>>>>     return _mupdf.ll_fz_print_stext_page_as_json(out, page, scale)
       
    1: def ll_fz_print_stext_page_as_text(out, page):
           r"""
           Low-level wrapper for `::fz_print_stext_page_as_text()`.
           Output structured text to a file in plain-text UTF-8 format.
           """
>>>>>>     return _mupdf.ll_fz_print_stext_page_as_text(out, page)
       
    1: def ll_fz_print_stext_page_as_xhtml(out, page, id):
           r"""
           Low-level wrapper for `::fz_print_stext_page_as_xhtml()`.
           Output structured text to a file in XHTML (semantic) format.
           """
>>>>>>     return _mupdf.ll_fz_print_stext_page_as_xhtml(out, page, id)
       
    1: def ll_fz_print_stext_page_as_xml(out, page, id):
           r"""
           Low-level wrapper for `::fz_print_stext_page_as_xml()`.
           Output structured text to a file in XML format.
           """
>>>>>>     return _mupdf.ll_fz_print_stext_page_as_xml(out, page, id)
       
    1: def ll_fz_print_stext_trailer_as_html(out):
           r"""Low-level wrapper for `::fz_print_stext_trailer_as_html()`."""
>>>>>>     return _mupdf.ll_fz_print_stext_trailer_as_html(out)
       
    1: def ll_fz_print_stext_trailer_as_xhtml(out):
           r"""Low-level wrapper for `::fz_print_stext_trailer_as_xhtml()`."""
>>>>>>     return _mupdf.ll_fz_print_stext_trailer_as_xhtml(out)
       
    1: def ll_fz_process_opened_pages(doc, process_openend_page, state):
           r"""
           Low-level wrapper for `::fz_process_opened_pages()`.
           Iterates over all opened pages of the document, calling the
           provided callback for each page for processing. If the callback
           returns non-NULL then the iteration stops and that value is returned
           to the called of fz_process_opened_pages().
       
           The state pointer provided to fz_process_opened_pages() is
           passed on to the callback but is owned by the caller.
       
           Returns the first non-NULL value returned by the callback,
           or NULL if the callback returned NULL for all opened pages.
           """
>>>>>>     return _mupdf.ll_fz_process_opened_pages(doc, process_openend_page, state)
       
    1: def ll_fz_process_shade(shade, ctm, scissor, prepare, process, process_arg):
           r"""
           Low-level wrapper for `::fz_process_shade()`.
           Process a shade, using supplied callback functions. This
           decomposes the shading to a mesh (even ones that are not
           natively meshes, such as linear or radial shadings), and
           processes triangles from those meshes.
       
           shade: The shade to process.
       
           ctm: The transform to use
       
           prepare: Callback function to 'prepare' each vertex.
           This function is passed an array of floats, and populates
           a fz_vertex structure.
       
           process: This function is passed 3 pointers to vertex
           structures, and actually performs the processing (typically
           filling the area between the vertices).
       
           process_arg: An opaque argument passed through from caller
           to callback functions.
           """
>>>>>>     return _mupdf.ll_fz_process_shade(shade, ctm, scissor, prepare, process, process_arg)
       
    1: def ll_fz_ptr_heap_insert(heap, v, HEAP_CMP):
           r"""Low-level wrapper for `::fz_ptr_heap_insert()`."""
>>>>>>     return _mupdf.ll_fz_ptr_heap_insert(heap, v, HEAP_CMP)
       
    1: def ll_fz_ptr_heap_sort(heap, HEAP_CMP):
           r"""Low-level wrapper for `::fz_ptr_heap_sort()`."""
>>>>>>     return _mupdf.ll_fz_ptr_heap_sort(heap, HEAP_CMP)
       
    1: def ll_fz_ptr_heap_uniq(heap, HEAP_CMP):
           r"""Low-level wrapper for `::fz_ptr_heap_uniq()`."""
>>>>>>     return _mupdf.ll_fz_ptr_heap_uniq(heap, HEAP_CMP)
       
    1: def ll_fz_purge_glyph_cache():
           r"""
           Low-level wrapper for `::fz_purge_glyph_cache()`.
           Purge all the glyphs from the cache.
           """
>>>>>>     return _mupdf.ll_fz_purge_glyph_cache()
       
    1: def ll_fz_quad_from_rect(r):
           r"""
           Low-level wrapper for `::fz_quad_from_rect()`.
           Convert a rect to a quad (losslessly).
           """
>>>>>>     return _mupdf.ll_fz_quad_from_rect(r)
       
    1: def ll_fz_quadto(path, x0, y0, x1, y1):
           r"""
           Low-level wrapper for `::fz_quadto()`.
           Append a 'quadto' command to an open path. (For a
           quadratic bezier).
       
           path: The path to modify.
       
           x0, y0: The control coordinates for the quadratic curve.
       
           x1, y1: The end coordinates for the quadratic curve.
       
           Throws exceptions on failure to allocate, or attempting to
           modify a packed path.
           """
>>>>>>     return _mupdf.ll_fz_quadto(path, x0, y0, x1, y1)
       
    1: def ll_fz_range_limit_xml_char(c):
           r"""Low-level wrapper for `::fz_range_limit_xml_char()`."""
>>>>>>     return _mupdf.ll_fz_range_limit_xml_char(c)
       
    1: def ll_fz_read(stm, data, len):
           r"""
           Low-level wrapper for `::fz_read()`.
           Read from a stream into a given data block.
       
           stm: The stream to read from.
       
           data: The data block to read into.
       
           len: The length of the data block (in bytes).
       
           Returns the number of bytes read. May throw exceptions.
           """
>>>>>>     return _mupdf.ll_fz_read(stm, data, len)
       
    1: def ll_fz_read_all(stm, initial):
           r"""
           Low-level wrapper for `::fz_read_all()`.
           Read all of a stream into a buffer.
       
           stm: The stream to read from
       
           initial: Suggested initial size for the buffer.
       
           Returns a buffer created from reading from the stream. May throw
           exceptions on failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_read_all(stm, initial)
       
    1: def ll_fz_read_archive_entry(arch, name):
           r"""
           Low-level wrapper for `::fz_read_archive_entry()`.
           Reads all bytes in an archive entry
           into a buffer.
       
           name: Entry name to look for, this must be an exact match to
           the entry name in the archive.
       
           Throws an exception if a matching entry cannot be found.
           """
>>>>>>     return _mupdf.ll_fz_read_archive_entry(arch, name)
       
    1: def ll_fz_read_best(stm, initial, truncated, worst_case):
           r"""
            Low-level wrapper for `::fz_read_best()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_read_best(::fz_stream *stm, size_t initial, size_t worst_case)` => `(fz_buffer *, int truncated)`
       
               Attempt to read a stream into a buffer. If truncated
               is NULL behaves as fz_read_all, sets a truncated flag in case of
               error.
       
               stm: The stream to read from.
       
               initial: Suggested initial size for the buffer.
       
               truncated: Flag to store success/failure indication in.
       
               worst_case: 0 for unknown, otherwise an upper bound for the
               size of the stream.
       
               Returns a buffer created from reading from the stream.
           """
>>>>>>     return _mupdf.ll_fz_read_best(stm, initial, truncated, worst_case)
       
    1: def ll_fz_read_bits(stm, n):
           r"""
           Low-level wrapper for `::fz_read_bits()`.
           Read the next n bits from a stream (assumed to
           be packed most significant bit first).
       
           stm: The stream to read from.
       
           n: The number of bits to read, between 1 and 8*sizeof(int)
           inclusive.
       
           Returns -1 for EOF, or the required number of bits.
           """
>>>>>>     return _mupdf.ll_fz_read_bits(stm, n)
       
    1: def ll_fz_read_byte(stm):
           r"""
           Low-level wrapper for `::fz_read_byte()`.
           Read the next byte from a stream.
       
           stm: The stream t read from.
       
           Returns -1 for end of stream, or the next byte. May
           throw exceptions.
           """
>>>>>>     return _mupdf.ll_fz_read_byte(stm)
       
    1: def ll_fz_read_file(filename):
           r"""
           Low-level wrapper for `::fz_read_file()`.
           Read all the contents of a file into a buffer.
           """
>>>>>>     return _mupdf.ll_fz_read_file(filename)
       
    1: def ll_fz_read_float(stm):
           r"""Low-level wrapper for `::fz_read_float()`."""
>>>>>>     return _mupdf.ll_fz_read_float(stm)
       
    1: def ll_fz_read_float_le(stm):
           r"""Low-level wrapper for `::fz_read_float_le()`."""
>>>>>>     return _mupdf.ll_fz_read_float_le(stm)
       
    1: def ll_fz_read_int16(stm):
           r"""Low-level wrapper for `::fz_read_int16()`."""
>>>>>>     return _mupdf.ll_fz_read_int16(stm)
       
    1: def ll_fz_read_int16_le(stm):
           r"""Low-level wrapper for `::fz_read_int16_le()`."""
>>>>>>     return _mupdf.ll_fz_read_int16_le(stm)
       
    1: def ll_fz_read_int32(stm):
           r"""Low-level wrapper for `::fz_read_int32()`."""
>>>>>>     return _mupdf.ll_fz_read_int32(stm)
       
    1: def ll_fz_read_int32_le(stm):
           r"""Low-level wrapper for `::fz_read_int32_le()`."""
>>>>>>     return _mupdf.ll_fz_read_int32_le(stm)
       
    1: def ll_fz_read_int64(stm):
           r"""Low-level wrapper for `::fz_read_int64()`."""
>>>>>>     return _mupdf.ll_fz_read_int64(stm)
       
    1: def ll_fz_read_int64_le(stm):
           r"""Low-level wrapper for `::fz_read_int64_le()`."""
>>>>>>     return _mupdf.ll_fz_read_int64_le(stm)
       
    1: def ll_fz_read_line(stm, buf, max):
           r"""
           Low-level wrapper for `::fz_read_line()`.
           Read a line from stream into the buffer until either a
           terminating newline or EOF, which it replaces with a null byte
           ('').
       
           Returns buf on success, and NULL when end of file occurs while
           no characters have been read.
           """
>>>>>>     return _mupdf.ll_fz_read_line(stm, buf, max)
       
    1: def ll_fz_read_rbits(stm, n):
           r"""
           Low-level wrapper for `::fz_read_rbits()`.
           Read the next n bits from a stream (assumed to
           be packed least significant bit first).
       
           stm: The stream to read from.
       
           n: The number of bits to read, between 1 and 8*sizeof(int)
           inclusive.
       
           Returns (unsigned int)-1 for EOF, or the required number of bits.
           """
>>>>>>     return _mupdf.ll_fz_read_rbits(stm, n)
       
    1: def ll_fz_read_rune(_in):
           r"""
           Low-level wrapper for `::fz_read_rune()`.
           Read a utf-8 rune from a stream.
       
           In the event of encountering badly formatted utf-8 codes
           (such as a leading code with an unexpected number of following
           codes) no error/exception is given, but undefined values may be
           returned.
           """
>>>>>>     return _mupdf.ll_fz_read_rune(_in)
       
    1: def ll_fz_read_string(stm, buffer, len):
           r"""
           Low-level wrapper for `::fz_read_string()`.
           Read a null terminated string from the stream into
           a buffer of a given length. The buffer will be null terminated.
           Throws on failure (including the failure to fit the entire
           string including the terminator into the buffer).
           """
>>>>>>     return _mupdf.ll_fz_read_string(stm, buffer, len)
       
    1: def ll_fz_read_uint16(stm):
           r"""
           Low-level wrapper for `::fz_read_uint16()`.
           fz_read_[u]int(16|24|32|64)(_le)?
       
           Read a 16/32/64 bit signed/unsigned integer from stream,
           in big or little-endian byte orders.
       
           Throws an exception if EOF is encountered.
           """
>>>>>>     return _mupdf.ll_fz_read_uint16(stm)
       
    1: def ll_fz_read_uint16_le(stm):
           r"""Low-level wrapper for `::fz_read_uint16_le()`."""
>>>>>>     return _mupdf.ll_fz_read_uint16_le(stm)
       
    1: def ll_fz_read_uint24(stm):
           r"""Low-level wrapper for `::fz_read_uint24()`."""
>>>>>>     return _mupdf.ll_fz_read_uint24(stm)
       
    1: def ll_fz_read_uint24_le(stm):
           r"""Low-level wrapper for `::fz_read_uint24_le()`."""
>>>>>>     return _mupdf.ll_fz_read_uint24_le(stm)
       
    1: def ll_fz_read_uint32(stm):
           r"""Low-level wrapper for `::fz_read_uint32()`."""
>>>>>>     return _mupdf.ll_fz_read_uint32(stm)
       
    1: def ll_fz_read_uint32_le(stm):
           r"""Low-level wrapper for `::fz_read_uint32_le()`."""
>>>>>>     return _mupdf.ll_fz_read_uint32_le(stm)
       
    1: def ll_fz_read_uint64(stm):
           r"""Low-level wrapper for `::fz_read_uint64()`."""
>>>>>>     return _mupdf.ll_fz_read_uint64(stm)
       
    1: def ll_fz_read_uint64_le(stm):
           r"""Low-level wrapper for `::fz_read_uint64_le()`."""
>>>>>>     return _mupdf.ll_fz_read_uint64_le(stm)
       
    1: def ll_fz_read_utf16_be(stm):
           r"""Low-level wrapper for `::fz_read_utf16_be()`."""
>>>>>>     return _mupdf.ll_fz_read_utf16_be(stm)
       
    1: def ll_fz_read_utf16_le(stm):
           r"""
           Low-level wrapper for `::fz_read_utf16_le()`.
           Read a utf-16 rune from a stream. (little endian and
           big endian respectively).
       
           In the event of encountering badly formatted utf-16 codes
           (mismatched surrogates) no error/exception is given, but
           undefined values may be returned.
           """
>>>>>>     return _mupdf.ll_fz_read_utf16_le(stm)
       
    1: def ll_fz_realloc(p, size):
           r"""
           Low-level wrapper for `::fz_realloc()`.
           Reallocates a block of memory to given size. Existing contents
           up to min(old_size,new_size) are maintained. The rest of the
           block is uninitialised.
       
           fz_realloc(ctx, NULL, size) behaves like fz_malloc(ctx, size).
       
           fz_realloc(ctx, p, 0); behaves like fz_free(ctx, p).
       
           Throws exception in the event of failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_realloc(p, size)
       
    1: def ll_fz_realloc_no_throw(p, size):
           r"""
           Low-level wrapper for `::fz_realloc_no_throw()`.
           fz_realloc equivalent that returns NULL rather than throwing
           exceptions.
           """
>>>>>>     return _mupdf.ll_fz_realloc_no_throw(p, size)
       
    1: def ll_fz_realpath(path, resolved_path):
           r"""
           Low-level wrapper for `::fz_realpath()`.
           Resolve a path to an absolute file name.
           The resolved path buffer must be of at least PATH_MAX size.
           """
>>>>>>     return _mupdf.ll_fz_realpath(path, resolved_path)
       
    1: def ll_fz_recognize_document(magic):
           r"""
           Low-level wrapper for `::fz_recognize_document()`.
           Given a magic find a document handler that can handle a
           document of this type.
       
           magic: Can be a filename extension (including initial period) or
           a mimetype.
           """
>>>>>>     return _mupdf.ll_fz_recognize_document(magic)
       
    1: def ll_fz_recognize_document_content(filename):
           r"""
           Low-level wrapper for `::fz_recognize_document_content()`.
           Given a filename find a document handler that can handle a
           document of this type.
       
           filename: The filename of the document. This will be opened and sampled
           to check data.
           """
>>>>>>     return _mupdf.ll_fz_recognize_document_content(filename)
       
    1: def ll_fz_recognize_document_stream_and_dir_content(stream, dir, magic):
           r"""
           Low-level wrapper for `::fz_recognize_document_stream_and_dir_content()`.
           Given a magic find a document handler that can handle a
           document of this type.
       
           stream: the file stream to sample. May be NULL if the document is
           a directory.
       
           dir: an fz_archive representing the directory from which the
           stream was opened (or NULL).
       
           magic: Can be a filename extension (including initial period) or
           a mimetype.
           """
>>>>>>     return _mupdf.ll_fz_recognize_document_stream_and_dir_content(stream, dir, magic)
       
    1: def ll_fz_recognize_document_stream_content(stream, magic):
           r"""
           Low-level wrapper for `::fz_recognize_document_stream_content()`.
           Given a magic find a document handler that can handle a
           document of this type.
       
           stream: the file stream to sample. May be NULL if the document is
           a directory.
       
           magic: Can be a filename extension (including initial period) or
           a mimetype.
           """
>>>>>>     return _mupdf.ll_fz_recognize_document_stream_content(stream, magic)
       
    1: def ll_fz_recognize_image_format(p):
           r"""
           Low-level wrapper for `::fz_recognize_image_format()`.
           Recognise image format strings in the first 8 bytes from image
           data.
           """
>>>>>>     return _mupdf.ll_fz_recognize_image_format(p)
       
    1: def ll_fz_rect_from_irect(bbox):
           r"""
           Low-level wrapper for `::fz_rect_from_irect()`.
           Convert a bbox into a rect.
       
           For our purposes, a rect can represent all the values we meet in
           a bbox, so nothing can go wrong.
       
           rect: A place to store the generated rectangle.
       
           bbox: The bbox to convert.
       
           Returns rect (updated).
           """
>>>>>>     return _mupdf.ll_fz_rect_from_irect(bbox)
       
    1: def ll_fz_rect_from_quad(q):
           r"""
           Low-level wrapper for `::fz_rect_from_quad()`.
           Convert a quad to the smallest rect that covers it.
           """
>>>>>>     return _mupdf.ll_fz_rect_from_quad(q)
       
    1: def ll_fz_rectto(path, x0, y0, x1, y1):
           r"""
           Low-level wrapper for `::fz_rectto()`.
           Append a 'rectto' command to an open path.
       
           The rectangle is equivalent to:
               moveto x0 y0
               lineto x1 y0
               lineto x1 y1
               lineto x0 y1
               closepath
       
           path: The path to modify.
       
           x0, y0: First corner of the rectangle.
       
           x1, y1: Second corner of the rectangle.
       
           Throws exceptions on failure to allocate, or attempting to
           modify a packed path.
           """
>>>>>>     return _mupdf.ll_fz_rectto(path, x0, y0, x1, y1)
       
    1: def ll_fz_register_activity_logger(activity, opaque):
           r"""Low-level wrapper for `::fz_register_activity_logger()`."""
>>>>>>     return _mupdf.ll_fz_register_activity_logger(activity, opaque)
       
    1: def ll_fz_register_archive_handler(handler):
           r"""Low-level wrapper for `::fz_register_archive_handler()`."""
>>>>>>     return _mupdf.ll_fz_register_archive_handler(handler)
       
    1: def ll_fz_register_document_handler(handler):
           r"""
           Low-level wrapper for `::fz_register_document_handler()`.
           Register a handler for a document type.
       
           handler: The handler to register. This must live on for the duration of the
           use of this handler. It will be passed back to the handler for calls so
           the caller can use it to retrieve state.
           """
>>>>>>     return _mupdf.ll_fz_register_document_handler(handler)
       
    1: def ll_fz_register_document_handlers():
           r"""
           Low-level wrapper for `::fz_register_document_handlers()`.
           Register handlers for all the standard document types supported in
           this build.
           """
>>>>>>     return _mupdf.ll_fz_register_document_handlers()
       
    1: def ll_fz_remove_item(drop, key, type):
           r"""
           Low-level wrapper for `::fz_remove_item()`.
           Remove an item from the store.
       
           If an item indexed by the given key exists in the store, remove
           it.
       
           drop: The function used to free the value (to ensure we get a
           value of the correct type).
       
           key: The key used to find the item to remove.
       
           type: Functions used to manipulate the key.
           """
>>>>>>     return _mupdf.ll_fz_remove_item(drop, key, type)
       
    1: def ll_fz_render_flags(dev, set, clear):
           r"""Low-level wrapper for `::fz_render_flags()`."""
>>>>>>     return _mupdf.ll_fz_render_flags(dev, set, clear)
       
    1: def ll_fz_render_glyph_pixmap(font, gid, ctm, scissor, aa):
           r"""
           Low-level wrapper for `::fz_render_glyph_pixmap()`.
           Create a pixmap containing a rendered glyph.
       
           Lookup gid from font, clip it with scissor, and rendering it
           with aa bits of antialiasing into a new pixmap.
       
           The caller takes ownership of the pixmap and so must free it.
       
           Note: This function is no longer used for normal rendering
           operations, and is kept around just because we use it in the
           app. It should be considered "at risk" of removal from the API.
           """
>>>>>>     return _mupdf.ll_fz_render_glyph_pixmap(font, gid, ctm, scissor, aa)
       
    1: def ll_fz_render_t3_glyph_direct(dev, font, gid, trm, gstate, def_cs, fill_gstate, stroke_gstate):
           r"""
           Low-level wrapper for `::fz_render_t3_glyph_direct()`.
           Nasty PDF interpreter specific hernia, required to allow the
           interpreter to replay glyphs from a type3 font directly into
           the target device.
       
           This is only used in exceptional circumstances (such as type3
           glyphs that inherit current graphics state, or nested type3
           glyphs).
           """
>>>>>>     return _mupdf.ll_fz_render_t3_glyph_direct(dev, font, gid, trm, gstate, def_cs, fill_gstate, stroke_gstate)
       
    1: def ll_fz_rendering_intent_name(ri):
           r"""
           Low-level wrapper for `::fz_rendering_intent_name()`.
           Map from enumerated rendering intent to string.
       
           The returned string is static and therefore must not be freed.
           """
>>>>>>     return _mupdf.ll_fz_rendering_intent_name(ri)
       
    1: def ll_fz_report_error():
           r"""Low-level wrapper for `::fz_report_error()`."""
>>>>>>     return _mupdf.ll_fz_report_error()
       
    1: def ll_fz_reset_output(arg_1):
           r"""
           Low-level wrapper for `::fz_reset_output()`.
           Reset a closed output stream. Returns state to
           (broadly) that which it was in when opened. Not
           all outputs can be reset, so this may throw an
           exception.
           """
>>>>>>     return _mupdf.ll_fz_reset_output(arg_1)
       
    1: def ll_fz_reset_story(story):
           r"""Low-level wrapper for `::fz_reset_story()`."""
>>>>>>     return _mupdf.ll_fz_reset_story(story)
       
    1: def ll_fz_resize_buffer(buf, capacity):
           r"""
           Low-level wrapper for `::fz_resize_buffer()`.
           Ensure that a buffer has a given capacity,
           truncating data if required.
       
           capacity: The desired capacity for the buffer. If the current
           size of the buffer contents is smaller than capacity, it is
           truncated.
           """
>>>>>>     return _mupdf.ll_fz_resize_buffer(buf, capacity)
       
    1: def ll_fz_resolve_link(doc, uri, xp, yp):
           r"""
            Low-level wrapper for `::fz_resolve_link()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_resolve_link(::fz_document *doc, const char *uri)` => `(fz_location, float xp, float yp)`
       
               Resolve an internal link to a page number.
       
               xp, yp: Pointer to store coordinate of destination on the page.
       
               Returns (-1,-1) if the URI cannot be resolved.
           """
>>>>>>     return _mupdf.ll_fz_resolve_link(doc, uri, xp, yp)
       
    1: def ll_fz_resolve_link_dest(doc, uri):
           r"""
           Low-level wrapper for `::fz_resolve_link_dest()`.
           Resolve an internal link to a page number, location, and possible viewing parameters.
       
           Returns location (-1,-1) if the URI cannot be resolved.
           """
>>>>>>     return _mupdf.ll_fz_resolve_link_dest(doc, uri)
       
    1: def ll_fz_rethrow():
           r"""Low-level wrapper for `::fz_rethrow()`."""
>>>>>>     return _mupdf.ll_fz_rethrow()
       
    1: def ll_fz_rethrow_if(errcode):
           r"""
           Low-level wrapper for `::fz_rethrow_if()`.
           Within an fz_catch() block, rethrow the current exception
           if the errcode of the current exception matches.
       
           This assumes no intervening use of fz_try/fz_catch.
           """
>>>>>>     return _mupdf.ll_fz_rethrow_if(errcode)
       
    1: def ll_fz_rethrow_unless(errcode):
           r"""Low-level wrapper for `::fz_rethrow_unless()`."""
>>>>>>     return _mupdf.ll_fz_rethrow_unless(errcode)
       
    1: def ll_fz_rotate(degrees):
           r"""
           Low-level wrapper for `::fz_rotate()`.
           Create a rotation matrix.
       
           The returned matrix is of the form
           [ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].
       
           m: Pointer to place to store matrix
       
           degrees: Degrees of counter clockwise rotation. Values less
           than zero and greater than 360 are handled as expected.
       
           Returns m.
           """
>>>>>>     return _mupdf.ll_fz_rotate(degrees)
       
    1: def ll_fz_round_rect(rect):
           r"""
           Low-level wrapper for `::fz_round_rect()`.
           Round rectangle coordinates.
       
           Coordinates in a bounding box are integers, so rounding of the
           rects coordinates takes place. The top left corner is rounded
           upwards and left while the bottom right corner is rounded
           downwards and to the right.
       
           This differs from fz_irect_from_rect, in that fz_irect_from_rect
           slavishly follows the numbers (i.e any slight over/under
           calculations can cause whole extra pixels to be added).
           fz_round_rect allows for a small amount of rounding error when
           calculating the bbox.
           """
>>>>>>     return _mupdf.ll_fz_round_rect(rect)
       
    1: def ll_fz_run_display_list(list, dev, ctm, scissor, cookie):
           r"""
           Low-level wrapper for `::fz_run_display_list()`.
           (Re)-run a display list through a device.
       
           list: A display list, created by fz_new_display_list and
           populated with objects from a page by running fz_run_page on a
           device obtained from fz_new_list_device.
       
           ctm: Transform to apply to display list contents. May include
           for example scaling and rotation, see fz_scale, fz_rotate and
           fz_concat. Set to fz_identity if no transformation is desired.
       
           scissor: Only the part of the contents of the display list
           visible within this area will be considered when the list is
           run through the device. This does not imply for tile objects
           contained in the display list.
       
           cookie: Communication mechanism between caller and library
           running the page. Intended for multi-threaded applications,
           while single-threaded applications set cookie to NULL. The
           caller may abort an ongoing page run. Cookie also communicates
           progress information back to the caller. The fields inside
           cookie are continually updated while the page is being run.
           """
>>>>>>     return _mupdf.ll_fz_run_display_list(list, dev, ctm, scissor, cookie)
       
    1: def ll_fz_run_document_structure(doc, dev, cookie):
           r"""
           Low-level wrapper for `::fz_run_document_structure()`.
           Run the document structure through a device.
       
           doc: Document in question.
       
           dev: Device obtained from fz_new_*_device.
       
           cookie: Communication mechanism between caller and library.
           Intended for multi-threaded applications, while
           single-threaded applications set cookie to NULL. The
           caller may abort an ongoing rendering of a page. Cookie also
           communicates progress information back to the caller. The
           fields inside cookie are continually updated while the page is
           rendering.
           """
>>>>>>     return _mupdf.ll_fz_run_document_structure(doc, dev, cookie)
       
    1: def ll_fz_run_page(page, dev, transform, cookie):
           r"""
           Low-level wrapper for `::fz_run_page()`.
           Run a page through a device.
       
           page: Page obtained from fz_load_page.
       
           dev: Device obtained from fz_new_*_device.
       
           transform: Transform to apply to page. May include for example
           scaling and rotation, see fz_scale, fz_rotate and fz_concat.
           Set to fz_identity if no transformation is desired.
       
           cookie: Communication mechanism between caller and library
           rendering the page. Intended for multi-threaded applications,
           while single-threaded applications set cookie to NULL. The
           caller may abort an ongoing rendering of a page. Cookie also
           communicates progress information back to the caller. The
           fields inside cookie are continually updated while the page is
           rendering.
           """
>>>>>>     return _mupdf.ll_fz_run_page(page, dev, transform, cookie)
       
    1: def ll_fz_run_page_annots(page, dev, transform, cookie):
           r"""
           Low-level wrapper for `::fz_run_page_annots()`.
           Run the annotations on a page through a device.
           """
>>>>>>     return _mupdf.ll_fz_run_page_annots(page, dev, transform, cookie)
       
    1: def ll_fz_run_page_contents(page, dev, transform, cookie):
           r"""
           Low-level wrapper for `::fz_run_page_contents()`.
           Run a page through a device. Just the main
           page content, without the annotations, if any.
       
           page: Page obtained from fz_load_page.
       
           dev: Device obtained from fz_new_*_device.
       
           transform: Transform to apply to page. May include for example
           scaling and rotation, see fz_scale, fz_rotate and fz_concat.
           Set to fz_identity if no transformation is desired.
       
           cookie: Communication mechanism between caller and library
           rendering the page. Intended for multi-threaded applications,
           while single-threaded applications set cookie to NULL. The
           caller may abort an ongoing rendering of a page. Cookie also
           communicates progress information back to the caller. The
           fields inside cookie are continually updated while the page is
           rendering.
           """
>>>>>>     return _mupdf.ll_fz_run_page_contents(page, dev, transform, cookie)
       
    1: def ll_fz_run_page_widgets(page, dev, transform, cookie):
           r"""
           Low-level wrapper for `::fz_run_page_widgets()`.
           Run the widgets on a page through a device.
           """
>>>>>>     return _mupdf.ll_fz_run_page_widgets(page, dev, transform, cookie)
       
    1: def ll_fz_run_t3_glyph(font, gid, trm, dev):
           r"""
           Low-level wrapper for `::fz_run_t3_glyph()`.
           Run a glyph from a Type3 font to
           a given device.
       
           font: The font to find the glyph in.
       
           gid: The glyph to run.
       
           trm: The transform to apply.
       
           dev: The device to render onto.
           """
>>>>>>     return _mupdf.ll_fz_run_t3_glyph(font, gid, trm, dev)
       
    1: def ll_fz_runeidx(str, p):
           r"""
           Low-level wrapper for `::fz_runeidx()`.
           Compute the index of a rune in a string.
       
           str: Pointer to beginning of a string.
       
           p: Pointer to a char in str.
       
           Returns the index of the rune pointed to by p in str.
           """
>>>>>>     return _mupdf.ll_fz_runeidx(str, p)
       
    1: def ll_fz_runelen(rune):
           r"""
           Low-level wrapper for `::fz_runelen()`.
           Count how many chars are required to represent a rune.
       
           rune: The rune to encode.
       
           Returns the number of bytes required to represent this run in
           UTF8.
           """
>>>>>>     return _mupdf.ll_fz_runelen(rune)
       
    1: def ll_fz_runeptr(str, idx):
           r"""
           Low-level wrapper for `::fz_runeptr()`.
           Obtain a pointer to the char representing the rune
           at a given index.
       
           str: Pointer to beginning of a string.
       
           idx: Index of a rune to return a char pointer to.
       
           Returns a pointer to the char where the desired rune starts,
           or NULL if the string ends before the index is reached.
           """
>>>>>>     return _mupdf.ll_fz_runeptr(str, idx)
       
    1: def ll_fz_runetochar(str, rune):
           r"""
           Low-level wrapper for `::fz_runetochar()`.
           UTF8 encode a rune to a sequence of chars.
       
           str: Pointer to a place to put the UTF8 encoded character.
       
           rune: Pointer to a 'rune'.
       
           Returns the number of bytes the rune took to output.
           """
>>>>>>     return _mupdf.ll_fz_runetochar(str, rune)
       
    1: def ll_fz_samples_get(pixmap, offset):
           r"""
            Low-level wrapper for `::fz_samples_get()`.
           Provides simple (but slow) access to pixmap data from Python and C#.
           """
>>>>>>     return _mupdf.ll_fz_samples_get(pixmap, offset)
       
    1: def ll_fz_samples_set(pixmap, offset, value):
           r"""
            Low-level wrapper for `::fz_samples_set()`.
           Provides simple (but slow) write access to pixmap data from Python and
           C#.
           """
>>>>>>     return _mupdf.ll_fz_samples_set(pixmap, offset, value)
       
    1: def ll_fz_save_accelerator(doc, accel):
           r"""
           Low-level wrapper for `::fz_save_accelerator()`.
           Save accelerator data for the document to a given file.
           """
>>>>>>     return _mupdf.ll_fz_save_accelerator(doc, accel)
       
    1: def ll_fz_save_bitmap_as_pbm(bitmap, filename):
           r"""
           Low-level wrapper for `::fz_save_bitmap_as_pbm()`.
           Save a bitmap as a pbm.
           """
>>>>>>     return _mupdf.ll_fz_save_bitmap_as_pbm(bitmap, filename)
       
    1: def ll_fz_save_bitmap_as_pcl(bitmap, filename, append, pcl):
           r"""
           Low-level wrapper for `::fz_save_bitmap_as_pcl()`.
           Save a bitmap as mono PCL.
           """
>>>>>>     return _mupdf.ll_fz_save_bitmap_as_pcl(bitmap, filename, append, pcl)
       
    1: def ll_fz_save_bitmap_as_pkm(bitmap, filename):
           r"""
           Low-level wrapper for `::fz_save_bitmap_as_pkm()`.
           Save a CMYK bitmap as a pkm.
           """
>>>>>>     return _mupdf.ll_fz_save_bitmap_as_pkm(bitmap, filename)
       
    1: def ll_fz_save_bitmap_as_pwg(bitmap, filename, append, pwg):
           r"""
           Low-level wrapper for `::fz_save_bitmap_as_pwg()`.
           Save a bitmap as a PWG.
           """
>>>>>>     return _mupdf.ll_fz_save_bitmap_as_pwg(bitmap, filename, append, pwg)
       
    1: def ll_fz_save_buffer(buf, filename):
           r"""
           Low-level wrapper for `::fz_save_buffer()`.
           Save the contents of a buffer to a file.
           """
>>>>>>     return _mupdf.ll_fz_save_buffer(buf, filename)
       
    1: def ll_fz_save_pixmap_as_jpeg(pixmap, filename, quality):
           r"""
           Low-level wrapper for `::fz_save_pixmap_as_jpeg()`.
           Save a pixmap as a JPEG.
           """
>>>>>>     return _mupdf.ll_fz_save_pixmap_as_jpeg(pixmap, filename, quality)
       
    1: def ll_fz_save_pixmap_as_jpx(pixmap, filename, q):
           r"""
           Low-level wrapper for `::fz_save_pixmap_as_jpx()`.
           Save pixmap data as JP2K with no subsampling.
       
           quality = 100 = lossless
           otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
           """
>>>>>>     return _mupdf.ll_fz_save_pixmap_as_jpx(pixmap, filename, q)
       
    1: def ll_fz_save_pixmap_as_pam(pixmap, filename):
           r"""
           Low-level wrapper for `::fz_save_pixmap_as_pam()`.
           Save a pixmap as a pnm (greyscale, rgb or cmyk, with or without
           alpha).
           """
>>>>>>     return _mupdf.ll_fz_save_pixmap_as_pam(pixmap, filename)
       
    1: def ll_fz_save_pixmap_as_pbm(pixmap, filename):
           r"""
           Low-level wrapper for `::fz_save_pixmap_as_pbm()`.
           Save a pixmap as a pbm. (Performing halftoning).
           """
>>>>>>     return _mupdf.ll_fz_save_pixmap_as_pbm(pixmap, filename)
       
    1: def ll_fz_save_pixmap_as_pcl(pixmap, filename, append, pcl):
           r"""
           Low-level wrapper for `::fz_save_pixmap_as_pcl()`.
           Save an (RGB) pixmap as color PCL.
           """
>>>>>>     return _mupdf.ll_fz_save_pixmap_as_pcl(pixmap, filename, append, pcl)
       
    1: def ll_fz_save_pixmap_as_pclm(pixmap, filename, append, options):
           r"""
           Low-level wrapper for `::fz_save_pixmap_as_pclm()`.
           Save a (Greyscale or RGB) pixmap as pclm.
           """
>>>>>>     return _mupdf.ll_fz_save_pixmap_as_pclm(pixmap, filename, append, options)
       
    1: def ll_fz_save_pixmap_as_pdfocr(pixmap, filename, append, options):
           r"""
           Low-level wrapper for `::fz_save_pixmap_as_pdfocr()`.
           Save a (Greyscale or RGB) pixmap as pdfocr.
           """
>>>>>>     return _mupdf.ll_fz_save_pixmap_as_pdfocr(pixmap, filename, append, options)
       
    1: def ll_fz_save_pixmap_as_pkm(pixmap, filename):
           r"""
           Low-level wrapper for `::fz_save_pixmap_as_pkm()`.
           Save a CMYK pixmap as a pkm. (Performing halftoning).
           """
>>>>>>     return _mupdf.ll_fz_save_pixmap_as_pkm(pixmap, filename)
       
    1: def ll_fz_save_pixmap_as_png(pixmap, filename):
           r"""
           Low-level wrapper for `::fz_save_pixmap_as_png()`.
           Save a (Greyscale or RGB) pixmap as a png.
           """
>>>>>>     return _mupdf.ll_fz_save_pixmap_as_png(pixmap, filename)
       
    1: def ll_fz_save_pixmap_as_pnm(pixmap, filename):
           r"""
           Low-level wrapper for `::fz_save_pixmap_as_pnm()`.
           Save a pixmap as a pnm (greyscale or rgb, no alpha).
           """
>>>>>>     return _mupdf.ll_fz_save_pixmap_as_pnm(pixmap, filename)
       
    1: def ll_fz_save_pixmap_as_ps(pixmap, filename, append):
           r"""
           Low-level wrapper for `::fz_save_pixmap_as_ps()`.
           Save a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
           """
>>>>>>     return _mupdf.ll_fz_save_pixmap_as_ps(pixmap, filename, append)
       
    1: def ll_fz_save_pixmap_as_psd(pixmap, filename):
           r"""
           Low-level wrapper for `::fz_save_pixmap_as_psd()`.
           Save a pixmap as a PSD file.
           """
>>>>>>     return _mupdf.ll_fz_save_pixmap_as_psd(pixmap, filename)
       
    1: def ll_fz_save_pixmap_as_pwg(pixmap, filename, append, pwg):
           r"""
           Low-level wrapper for `::fz_save_pixmap_as_pwg()`.
           Save a pixmap as a PWG.
           """
>>>>>>     return _mupdf.ll_fz_save_pixmap_as_pwg(pixmap, filename, append, pwg)
       
    1: def ll_fz_save_xml(root, path, indented):
           r"""
           Low-level wrapper for `::fz_save_xml()`.
           As for fz_write_xml, but direct to a file.
           """
>>>>>>     return _mupdf.ll_fz_save_xml(root, path, indented)
       
    1: def ll_fz_scale(sx, sy):
           r"""
           Low-level wrapper for `::fz_scale()`.
           Create a scaling matrix.
       
           The returned matrix is of the form [ sx 0 0 sy 0 0 ].
       
           m: Pointer to the matrix to populate
       
           sx, sy: Scaling factors along the X- and Y-axes. A scaling
           factor of 1.0 will not cause any scaling along the relevant
           axis.
       
           Returns m.
           """
>>>>>>     return _mupdf.ll_fz_scale(sx, sy)
       
    1: def ll_fz_scale_pixmap(src, x, y, w, h, clip):
           r"""Low-level wrapper for `::fz_scale_pixmap()`."""
>>>>>>     return _mupdf.ll_fz_scale_pixmap(src, x, y, w, h, clip)
       
    1: def ll_fz_search_chapter_page_number(doc, chapter, page, needle, hit_mark, hit_bbox, hit_max):
           r"""
            Low-level wrapper for `::fz_search_chapter_page_number()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_search_chapter_page_number(::fz_document *doc, int chapter, int page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
           """
>>>>>>     return _mupdf.ll_fz_search_chapter_page_number(doc, chapter, page, needle, hit_mark, hit_bbox, hit_max)
       
    1: def ll_fz_search_chapter_page_number_cb(doc, chapter, page, needle, cb, opaque):
           r"""Low-level wrapper for `::fz_search_chapter_page_number_cb()`."""
>>>>>>     return _mupdf.ll_fz_search_chapter_page_number_cb(doc, chapter, page, needle, cb, opaque)
       
    1: def ll_fz_search_display_list(list, needle, hit_mark, hit_bbox, hit_max):
           r"""
            Low-level wrapper for `::fz_search_display_list()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_search_display_list(::fz_display_list *list, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
           """
>>>>>>     return _mupdf.ll_fz_search_display_list(list, needle, hit_mark, hit_bbox, hit_max)
       
    1: def ll_fz_search_display_list_cb(list, needle, cb, opaque):
           r"""Low-level wrapper for `::fz_search_display_list_cb()`."""
>>>>>>     return _mupdf.ll_fz_search_display_list_cb(list, needle, cb, opaque)
       
    1: def ll_fz_search_page(page, needle, hit_mark, hit_bbox, hit_max):
           r"""
            Low-level wrapper for `::fz_search_page()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_search_page(::fz_page *page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
       
               Search for the 'needle' text on the page.
               Record the hits in the hit_bbox array and return the number of
               hits. Will stop looking once it has filled hit_max rectangles.
           """
>>>>>>     return _mupdf.ll_fz_search_page(page, needle, hit_mark, hit_bbox, hit_max)
       
    1: def ll_fz_search_page2(doc, number, needle, hit_max):
           r"""
            Low-level wrapper for `::fz_search_page2()`.
           C++ alternative to fz_search_page() that returns information in a std::vector.
           """
>>>>>>     return _mupdf.ll_fz_search_page2(doc, number, needle, hit_max)
       
    1: def ll_fz_search_page_cb(page, needle, cb, opaque):
           r"""
           Low-level wrapper for `::fz_search_page_cb()`.
           Search for the 'needle' text on the page.
           """
>>>>>>     return _mupdf.ll_fz_search_page_cb(page, needle, cb, opaque)
       
    1: def ll_fz_search_page_number(doc, number, needle, hit_mark, hit_bbox, hit_max):
           r"""
            Low-level wrapper for `::fz_search_page_number()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_search_page_number(::fz_document *doc, int number, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
           """
>>>>>>     return _mupdf.ll_fz_search_page_number(doc, number, needle, hit_mark, hit_bbox, hit_max)
       
    1: def ll_fz_search_page_number_cb(doc, number, needle, cb, opaque):
           r"""Low-level wrapper for `::fz_search_page_number_cb()`."""
>>>>>>     return _mupdf.ll_fz_search_page_number_cb(doc, number, needle, cb, opaque)
       
    1: def ll_fz_search_stext_page(text, needle, hit_mark, hit_bbox, hit_max):
           r"""
            Low-level wrapper for `::fz_search_stext_page()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_search_stext_page(::fz_stext_page *text, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
       
               Search for occurrence of 'needle' in text page.
       
               Return the number of quads and store hit quads in the passed in
               array.
       
               NOTE: This is an experimental interface and subject to change
               without notice.
           """
>>>>>>     return _mupdf.ll_fz_search_stext_page(text, needle, hit_mark, hit_bbox, hit_max)
       
    1: def ll_fz_search_stext_page_cb(text, needle, cb, opaque):
           r"""
           Low-level wrapper for `::fz_search_stext_page_cb()`.
           Search for occurrence of 'needle' in text page.
       
           Call callback once for each hit. This callback will receive
           (potentially) multiple quads for each hit.
       
           Returns the number of hits - note that this is potentially
           different from (i.e. is not greater than) the number of quads
           as returned by the non callback API.
       
           NOTE: This is an experimental interface and subject to change
           without notice.
           """
>>>>>>     return _mupdf.ll_fz_search_stext_page_cb(text, needle, cb, opaque)
       
    1: def ll_fz_seek(stm, offset, whence):
           r"""
           Low-level wrapper for `::fz_seek()`.
           Seek within a stream.
       
           stm: The stream to seek within.
       
           offset: The offset to seek to.
       
           whence: From where the offset is measured (see fseek).
           SEEK_SET - start of stream.
           SEEK_CUR - current position.
           SEEK_END - end of stream.
       
           """
>>>>>>     return _mupdf.ll_fz_seek(stm, offset, whence)
       
    1: def ll_fz_seek_output(out, off, whence):
           r"""
           Low-level wrapper for `::fz_seek_output()`.
           Seek to the specified file position.
           See fseek for arguments.
       
           Throw an error on unseekable outputs.
           """
>>>>>>     return _mupdf.ll_fz_seek_output(out, off, whence)
       
    1: def ll_fz_segment_stext_page(page):
           r"""
           Low-level wrapper for `::fz_segment_stext_page()`.
           Perform segmentation analysis on an (unstructured) page to look for
           recursive subdivisions.
       
           Essentially this code attempts to split the page horizontally and/or
           vertically repeatedly into smaller and smaller "segments" (divisions).
       
           This minimises the reordering of the content, but some reordering
           may be unavoidable.
       
           Returns 0 if no changes were made to the document.
       
           This is experimental code, and may change (or be removed) in future
           versions!
           """
>>>>>>     return _mupdf.ll_fz_segment_stext_page(page)
       
    1: def ll_fz_segment_stext_rect(page, rect):
           r"""
           Low-level wrapper for `::fz_segment_stext_rect()`.
           Perform segmentation analysis on a rectangle of a given
           stext page.
       
           Like fz_segment_stext_page, this attempts to split the given page
           region horizontally and/or vertically repeatedly into smaller and
           smaller "segments".
       
           This works for pages with structure too, but splitting with
           rectangles that cut across structure blocks may not behave as
           expected.
       
           This minimises the reordering of the content (as viewed from the
           perspective of a depth first traversal), but some reordering may
           be unavoidable.
       
           This function accepts smaller gaps for segmentation than the full
           page segmentation does.
       
           Returns 0 if no changes were made to the document.
       
           This is experimental code, and may change (or be removed) in future
           versions!
           """
>>>>>>     return _mupdf.ll_fz_segment_stext_rect(page, rect)
       
    1: def ll_fz_separation_current_behavior(sep, separation):
           r"""
           Low-level wrapper for `::fz_separation_current_behavior()`.
           Test for the current behavior of a separation.
           """
>>>>>>     return _mupdf.ll_fz_separation_current_behavior(sep, separation)
       
    1: def ll_fz_separation_equivalent(seps, idx, dst_cs, dst_color, prf, color_params):
           r"""
            Low-level wrapper for `::fz_separation_equivalent()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_separation_equivalent(const ::fz_separations *seps, int idx, ::fz_colorspace *dst_cs, ::fz_colorspace *prf, ::fz_color_params color_params)` => float dst_color
       
               Get the equivalent separation color in a given colorspace.
           """
>>>>>>     return _mupdf.ll_fz_separation_equivalent(seps, idx, dst_cs, dst_color, prf, color_params)
       
    1: def ll_fz_separation_name(sep, separation):
           r"""Low-level wrapper for `::fz_separation_name()`."""
>>>>>>     return _mupdf.ll_fz_separation_name(sep, separation)
       
    1: def ll_fz_set_aa_level(bits):
           r"""
           Low-level wrapper for `::fz_set_aa_level()`.
           Set the number of bits of antialiasing we should
           use (for both text and graphics).
       
           bits: The number of bits of antialiasing to use (values are
           clamped to within the 0 to 8 range).
           """
>>>>>>     return _mupdf.ll_fz_set_aa_level(bits)
       
    1: def ll_fz_set_compressed_image_buffer(cimg, buf):
           r"""Low-level wrapper for `::fz_set_compressed_image_buffer()`."""
>>>>>>     return _mupdf.ll_fz_set_compressed_image_buffer(cimg, buf)
       
    1: def ll_fz_set_default_cmyk(default_cs, cs):
           r"""Low-level wrapper for `::fz_set_default_cmyk()`."""
>>>>>>     return _mupdf.ll_fz_set_default_cmyk(default_cs, cs)
       
    1: def ll_fz_set_default_colorspaces(dev, default_cs):
           r"""Low-level wrapper for `::fz_set_default_colorspaces()`."""
>>>>>>     return _mupdf.ll_fz_set_default_colorspaces(dev, default_cs)
       
    1: def ll_fz_set_default_gray(default_cs, cs):
           r"""
           Low-level wrapper for `::fz_set_default_gray()`.
           Set new defaults within the default colorspace structure.
       
           New references are taken to the new default, and references to
           the old defaults dropped.
       
           Never throws exceptions.
           """
>>>>>>     return _mupdf.ll_fz_set_default_gray(default_cs, cs)
       
    1: def ll_fz_set_default_output_intent(default_cs, cs):
           r"""Low-level wrapper for `::fz_set_default_output_intent()`."""
>>>>>>     return _mupdf.ll_fz_set_default_output_intent(default_cs, cs)
       
    1: def ll_fz_set_default_rgb(default_cs, cs):
           r"""Low-level wrapper for `::fz_set_default_rgb()`."""
>>>>>>     return _mupdf.ll_fz_set_default_rgb(default_cs, cs)
       
    1: def ll_fz_set_error_callback(error_cb, user):
           r"""
           Low-level wrapper for `::fz_set_error_callback()`.
           Set the error callback. This will be called as part of the
           exception handling.
       
           The callback must not throw exceptions!
           """
>>>>>>     return _mupdf.ll_fz_set_error_callback(error_cb, user)
       
    1: def ll_fz_set_font_bbox(font, xmin, ymin, xmax, ymax):
           r"""
           Low-level wrapper for `::fz_set_font_bbox()`.
           Set the font bbox.
       
           font: The font to set the bbox for.
       
           xmin, ymin, xmax, ymax: The bounding box.
           """
>>>>>>     return _mupdf.ll_fz_set_font_bbox(font, xmin, ymin, xmax, ymax)
       
    1: def ll_fz_set_font_embedding(font, embed):
           r"""
           Low-level wrapper for `::fz_set_font_embedding()`.
           Control whether a given font should be embedded or not when writing.
           """
>>>>>>     return _mupdf.ll_fz_set_font_embedding(font, embed)
       
    1: def ll_fz_set_graphics_aa_level(bits):
           r"""
           Low-level wrapper for `::fz_set_graphics_aa_level()`.
           Set the number of bits of antialiasing we
           should use for graphics.
       
           bits: The number of bits of antialiasing to use (values are
           clamped to within the 0 to 8 range).
           """
>>>>>>     return _mupdf.ll_fz_set_graphics_aa_level(bits)
       
    1: def ll_fz_set_graphics_min_line_width(min_line_width):
           r"""
           Low-level wrapper for `::fz_set_graphics_min_line_width()`.
           Set the minimum line width to be
           used for stroked lines.
       
           min_line_width: The minimum line width to use (in pixels).
           """
>>>>>>     return _mupdf.ll_fz_set_graphics_min_line_width(min_line_width)
       
    1: def ll_fz_set_link_rect(link, rect):
           r"""Low-level wrapper for `::fz_set_link_rect()`."""
>>>>>>     return _mupdf.ll_fz_set_link_rect(link, rect)
       
    1: def ll_fz_set_link_uri(link, uri):
           r"""Low-level wrapper for `::fz_set_link_uri()`."""
>>>>>>     return _mupdf.ll_fz_set_link_uri(link, uri)
       
    1: def ll_fz_set_metadata(doc, key, value):
           r"""Low-level wrapper for `::fz_set_metadata()`."""
>>>>>>     return _mupdf.ll_fz_set_metadata(doc, key, value)
       
    1: def ll_fz_set_pixmap_image_tile(cimg, pix):
           r"""Low-level wrapper for `::fz_set_pixmap_image_tile()`."""
>>>>>>     return _mupdf.ll_fz_set_pixmap_image_tile(cimg, pix)
       
    1: def ll_fz_set_pixmap_resolution(pix, xres, yres):
           r"""
           Low-level wrapper for `::fz_set_pixmap_resolution()`.
           Set the pixels per inch resolution of the pixmap.
           """
>>>>>>     return _mupdf.ll_fz_set_pixmap_resolution(pix, xres, yres)
       
    1: def ll_fz_set_separation_behavior(sep, separation, behavior):
           r"""
           Low-level wrapper for `::fz_set_separation_behavior()`.
           Control the rendering of a given separation.
           """
>>>>>>     return _mupdf.ll_fz_set_separation_behavior(sep, separation, behavior)
       
    1: def ll_fz_set_stddbg(out):
           r"""
           Low-level wrapper for `::fz_set_stddbg()`.
           Set the output stream to be used for fz_stddbg. Set to NULL to
           reset to default (stderr).
           """
>>>>>>     return _mupdf.ll_fz_set_stddbg(out)
       
    1: def ll_fz_set_text_aa_level(bits):
           r"""
           Low-level wrapper for `::fz_set_text_aa_level()`.
           Set the number of bits of antialiasing we
           should use for text.
       
           bits: The number of bits of antialiasing to use (values are
           clamped to within the 0 to 8 range).
           """
>>>>>>     return _mupdf.ll_fz_set_text_aa_level(bits)
       
    1: def ll_fz_set_use_document_css(use):
           r"""
           Low-level wrapper for `::fz_set_use_document_css()`.
           Toggle whether to respect document styles in HTML and EPUB.
           """
>>>>>>     return _mupdf.ll_fz_set_use_document_css(use)
       
    1: def ll_fz_set_user_context(user):
           r"""
           Low-level wrapper for `::fz_set_user_context()`.
           Set the user field in the context.
       
           NULL initially, this field can be set to any opaque value
           required by the user. It is copied on clones.
           """
>>>>>>     return _mupdf.ll_fz_set_user_context(user)
       
    1: def ll_fz_set_user_css(text):
           r"""
           Low-level wrapper for `::fz_set_user_css()`.
           Set the user stylesheet source text for use with HTML and EPUB.
           """
>>>>>>     return _mupdf.ll_fz_set_user_css(text)
       
    1: def ll_fz_set_warning_callback(warning_cb, user):
           r"""
           Low-level wrapper for `::fz_set_warning_callback()`.
           Set the warning callback. This will be called as part of the
           exception handling.
       
           The callback must not throw exceptions!
           """
>>>>>>     return _mupdf.ll_fz_set_warning_callback(warning_cb, user)
       
    1: def ll_fz_sha256_final(state, digest):
           r"""
           Low-level wrapper for `::fz_sha256_final()`.
           MD5 finalization. Ends an MD5 message-digest operation, writing
           the message digest and zeroizing the context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_sha256_final(state, digest)
       
    1: def ll_fz_sha256_init(state):
           r"""
           Low-level wrapper for `::fz_sha256_init()`.
           SHA256 initialization. Begins an SHA256 operation, initialising
           the supplied context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_sha256_init(state)
       
    1: def ll_fz_sha256_update(state, input, inlen):
           r"""
           Low-level wrapper for `::fz_sha256_update()`.
           SHA256 block update operation. Continues an SHA256 message-
           digest operation, processing another message block, and updating
           the context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_sha256_update(state, input, inlen)
       
    1: def ll_fz_sha384_final(state, digest):
           r"""
           Low-level wrapper for `::fz_sha384_final()`.
           SHA384 finalization. Ends an SHA384 message-digest operation,
           writing the message digest and zeroizing the context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_sha384_final(state, digest)
       
    1: def ll_fz_sha384_init(state):
           r"""
           Low-level wrapper for `::fz_sha384_init()`.
           SHA384 initialization. Begins an SHA384 operation, initialising
           the supplied context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_sha384_init(state)
       
    1: def ll_fz_sha384_update(state, input, inlen):
           r"""
           Low-level wrapper for `::fz_sha384_update()`.
           SHA384 block update operation. Continues an SHA384 message-
           digest operation, processing another message block, and updating
           the context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_sha384_update(state, input, inlen)
       
    1: def ll_fz_sha512_final(state, digest):
           r"""
           Low-level wrapper for `::fz_sha512_final()`.
           SHA512 finalization. Ends an SHA512 message-digest operation,
           writing the message digest and zeroizing the context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_sha512_final(state, digest)
       
    1: def ll_fz_sha512_init(state):
           r"""
           Low-level wrapper for `::fz_sha512_init()`.
           SHA512 initialization. Begins an SHA512 operation, initialising
           the supplied context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_sha512_init(state)
       
    1: def ll_fz_sha512_update(state, input, inlen):
           r"""
           Low-level wrapper for `::fz_sha512_update()`.
           SHA512 block update operation. Continues an SHA512 message-
           digest operation, processing another message block, and updating
           the context.
       
           Never throws an exception.
           """
>>>>>>     return _mupdf.ll_fz_sha512_update(state, input, inlen)
       
    1: def ll_fz_shear(sx, sy):
           r"""
           Low-level wrapper for `::fz_shear()`.
           Create a shearing matrix.
       
           The returned matrix is of the form [ 1 sy sx 1 0 0 ].
       
           m: pointer to place to store returned matrix
       
           sx, sy: Shearing factors. A shearing factor of 0.0 will not
           cause any shearing along the relevant axis.
       
           Returns m.
           """
>>>>>>     return _mupdf.ll_fz_shear(sx, sy)
       
    1: def ll_fz_show_glyph(text, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language):
           r"""
           Low-level wrapper for `::fz_show_glyph()`.
           Add a glyph/unicode value to a text object.
       
           text: Text object to add to.
       
           font: The font the glyph should be added in.
       
           trm: The transform to use for the glyph.
       
           glyph: The glyph id to add.
       
           unicode: The unicode character for the glyph.
       
           cid: The CJK CID value or raw character code.
       
           wmode: 1 for vertical mode, 0 for horizontal.
       
           bidi_level: The bidirectional level for this glyph.
       
           markup_dir: The direction of the text as specified in the
           markup.
       
           language: The language in use (if known, 0 otherwise)
           (e.g. FZ_LANG_zh_Hans).
       
           Throws exception on failure to allocate.
           """
>>>>>>     return _mupdf.ll_fz_show_glyph(text, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language)
       
    1: def ll_fz_show_glyph_aux(text, font, trm, adv, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang):
           r"""Low-level wrapper for `::fz_show_glyph_aux()`."""
>>>>>>     return _mupdf.ll_fz_show_glyph_aux(text, font, trm, adv, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang)
       
    1: def ll_fz_show_string(text, font, trm, s, wmode, bidi_level, markup_dir, language):
           r"""
           Low-level wrapper for `::fz_show_string()`.
           Add a UTF8 string to a text object.
       
           text: Text object to add to.
       
           font: The font the string should be added in.
       
           trm: The transform to use.
       
           s: The utf-8 string to add.
       
           wmode: 1 for vertical mode, 0 for horizontal.
       
           bidi_level: The bidirectional level for this glyph.
       
           markup_dir: The direction of the text as specified in the markup.
       
           language: The language in use (if known, 0 otherwise)
               (e.g. FZ_LANG_zh_Hans).
       
           Returns the transform updated with the advance width of the
           string.
           """
>>>>>>     return _mupdf.ll_fz_show_string(text, font, trm, s, wmode, bidi_level, markup_dir, language)
       
    1: def ll_fz_shrink_store(percent):
           r"""
           Low-level wrapper for `::fz_shrink_store()`.
           Evict items from the store until the total size of
           the objects in the store is reduced to a given percentage of its
           current size.
       
           percent: %age of current size to reduce the store to.
       
           Returns non zero if we managed to free enough memory, zero
           otherwise.
           """
>>>>>>     return _mupdf.ll_fz_shrink_store(percent)
       
    1: def ll_fz_skip(stm, len):
           r"""
           Low-level wrapper for `::fz_skip()`.
           Read from a stream discarding data.
       
           stm: The stream to read from.
       
           len: The number of bytes to read.
       
           Returns the number of bytes read. May throw exceptions.
           """
>>>>>>     return _mupdf.ll_fz_skip(stm, len)
       
    1: def ll_fz_skip_space(stm):
           r"""
           Low-level wrapper for `::fz_skip_space()`.
           Skip over whitespace (bytes <= 32) in a stream.
           """
>>>>>>     return _mupdf.ll_fz_skip_space(stm)
       
    1: def ll_fz_skip_string(stm, str):
           r"""
           Low-level wrapper for `::fz_skip_string()`.
           Skip over a given string in a stream. Return 0 if successfully
           skipped, non-zero otherwise. As many characters will be skipped
           over as matched in the string.
           """
>>>>>>     return _mupdf.ll_fz_skip_string(stm, str)
       
    1: def ll_fz_slice_buffer(buf, start, end):
           r"""
           Low-level wrapper for `::fz_slice_buffer()`.
           Create a new buffer with a (subset of) the data from the buffer.
       
           start: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.
       
           end: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.
       
           """
>>>>>>     return _mupdf.ll_fz_slice_buffer(buf, start, end)
       
    1: def ll_fz_snap_selection(page, ap, bp, mode):
           r"""Low-level wrapper for `::fz_snap_selection()`."""
>>>>>>     return _mupdf.ll_fz_snap_selection(page, ap, bp, mode)
       
    1: def ll_fz_start_throw_on_repair():
           r"""Low-level wrapper for `::fz_start_throw_on_repair()`."""
>>>>>>     return _mupdf.ll_fz_start_throw_on_repair()
       
    1: def ll_fz_stat_ctime(path):
           r"""Low-level wrapper for `::fz_stat_ctime()`."""
>>>>>>     return _mupdf.ll_fz_stat_ctime(path)
       
    1: def ll_fz_stat_mtime(path):
           r"""Low-level wrapper for `::fz_stat_mtime()`."""
>>>>>>     return _mupdf.ll_fz_stat_mtime(path)
       
    1: def ll_fz_stddbg():
           r"""
           Low-level wrapper for `::fz_stddbg()`.
           Retrieve an fz_output for the default debugging stream. On
           Windows this will be OutputDebugString for non-console apps.
           Otherwise, it is always fz_stderr.
       
           Optionally may be fz_dropped when finished with.
           """
>>>>>>     return _mupdf.ll_fz_stddbg()
       
    1: def ll_fz_stderr():
           r"""
           Low-level wrapper for `::fz_stderr()`.
           Retrieve an fz_output that directs to stdout.
       
           Optionally may be fz_dropped when finished with.
           """
>>>>>>     return _mupdf.ll_fz_stderr()
       
    1: def ll_fz_stdout():
           r"""
           Low-level wrapper for `::fz_stdout()`.
           Retrieve an fz_output that directs to stdout.
       
           Optionally may be fz_dropped when finished with.
           """
>>>>>>     return _mupdf.ll_fz_stdout()
       
    1: def ll_fz_stext_page_block_iterator_begin(page):
           r"""Low-level wrapper for `::fz_stext_page_block_iterator_begin()`."""
>>>>>>     return _mupdf.ll_fz_stext_page_block_iterator_begin(page)
       
    1: def ll_fz_stext_page_block_iterator_down(pos):
           r"""Low-level wrapper for `::fz_stext_page_block_iterator_down()`."""
>>>>>>     return _mupdf.ll_fz_stext_page_block_iterator_down(pos)
       
    1: def ll_fz_stext_page_block_iterator_eod(pos):
           r"""Low-level wrapper for `::fz_stext_page_block_iterator_eod()`."""
>>>>>>     return _mupdf.ll_fz_stext_page_block_iterator_eod(pos)
       
    1: def ll_fz_stext_page_block_iterator_eod_dfs(pos):
           r"""Low-level wrapper for `::fz_stext_page_block_iterator_eod_dfs()`."""
>>>>>>     return _mupdf.ll_fz_stext_page_block_iterator_eod_dfs(pos)
       
    1: def ll_fz_stext_page_block_iterator_next(pos):
           r"""Low-level wrapper for `::fz_stext_page_block_iterator_next()`."""
>>>>>>     return _mupdf.ll_fz_stext_page_block_iterator_next(pos)
       
    1: def ll_fz_stext_page_block_iterator_next_dfs(pos):
           r"""Low-level wrapper for `::fz_stext_page_block_iterator_next_dfs()`."""
>>>>>>     return _mupdf.ll_fz_stext_page_block_iterator_next_dfs(pos)
       
    1: def ll_fz_stext_page_block_iterator_up(pos):
           r"""Low-level wrapper for `::fz_stext_page_block_iterator_up()`."""
>>>>>>     return _mupdf.ll_fz_stext_page_block_iterator_up(pos)
       
    1: def ll_fz_stext_page_details_for_block(page, block):
           r"""
           Low-level wrapper for `::fz_stext_page_details_for_block()`.
           Helper function to retrieve the details for a given id from a block.
           """
>>>>>>     return _mupdf.ll_fz_stext_page_details_for_block(page, block)
       
    1: def ll_fz_stext_remove_page_fill(page):
           r"""Low-level wrapper for `::fz_stext_remove_page_fill()`."""
>>>>>>     return _mupdf.ll_fz_stext_remove_page_fill(page)
       
    1: def ll_fz_store_item(key, val, itemsize, type):
           r"""
           Low-level wrapper for `::fz_store_item()`.
           Add an item to the store.
       
           Add an item into the store, returning NULL for success. If an
           item with the same key is found in the store, then our item will
           not be inserted, and the function will return a pointer to that
           value instead. This function takes its own reference to val, as
           required (i.e. the caller maintains ownership of its own
           reference).
       
           key: The key used to index the item.
       
           val: The value to store.
       
           itemsize: The size in bytes of the value (as counted towards the
           store size).
       
           type: Functions used to manipulate the key.
           """
>>>>>>     return _mupdf.ll_fz_store_item(key, val, itemsize, type)
       
    1: def ll_fz_store_scavenge(size, phase):
           r"""
            Low-level wrapper for `::fz_store_scavenge()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_store_scavenge(size_t size)` => `(int, int phase)`
       
               Internal function used as part of the scavenging
               allocator; when we fail to allocate memory, before returning a
               failure to the caller, we try to scavenge space within the store
               by evicting at least 'size' bytes. The allocator then retries.
       
               size: The number of bytes we are trying to have free.
       
               phase: What phase of the scavenge we are in. Updated on exit.
       
               Returns non zero if we managed to free any memory.
           """
>>>>>>     return _mupdf.ll_fz_store_scavenge(size, phase)
       
    1: def ll_fz_store_scavenge_external(size, phase):
           r"""
            Low-level wrapper for `::fz_store_scavenge_external()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_store_scavenge_external(size_t size)` => `(int, int phase)`
       
               External function for callers to use
               to scavenge while trying allocations.
       
               size: The number of bytes we are trying to have free.
       
               phase: What phase of the scavenge we are in. Updated on exit.
       
               Returns non zero if we managed to free any memory.
           """
>>>>>>     return _mupdf.ll_fz_store_scavenge_external(size, phase)
       
    1: def ll_fz_story_document(story):
           r"""Low-level wrapper for `::fz_story_document()`."""
>>>>>>     return _mupdf.ll_fz_story_document(story)
       
    1: def ll_fz_story_positions(story, cb, arg):
           r"""Low-level wrapper for `::fz_story_positions()`."""
>>>>>>     return _mupdf.ll_fz_story_positions(story, cb, arg)
       
    1: def ll_fz_story_warnings(story):
           r"""Low-level wrapper for `::fz_story_warnings()`."""
>>>>>>     return _mupdf.ll_fz_story_warnings(story)
       
    1: def ll_fz_strcasecmp(a, b):
           r"""
           Low-level wrapper for `::fz_strcasecmp()`.
           Case insensitive (UTF8) string comparison.
           """
>>>>>>     return _mupdf.ll_fz_strcasecmp(a, b)
       
    1: def ll_fz_strdup(s):
           r"""
           Low-level wrapper for `::fz_strdup()`.
           Portable strdup implementation, using fz allocators.
           """
>>>>>>     return _mupdf.ll_fz_strdup(s)
       
    1: def ll_fz_stream_filename(stm):
           r"""
           Low-level wrapper for `::fz_stream_filename()`.
           Return the filename (UTF-8 encoded) from which a stream was opened.
       
           Returns NULL if the filename is not available (or the stream was
           opened from a source other than a file).
           """
>>>>>>     return _mupdf.ll_fz_stream_filename(stm)
       
    1: def ll_fz_stream_from_output(arg_1):
           r"""
           Low-level wrapper for `::fz_stream_from_output()`.
           Obtain the fz_output in the form of a fz_stream.
       
           This allows data to be read back from some forms of fz_output
           object. When finished reading, the fz_stream should be released
           by calling fz_drop_stream. Until the fz_stream is dropped, no
           further operations should be performed on the fz_output object.
           """
>>>>>>     return _mupdf.ll_fz_stream_from_output(arg_1)
       
    1: def ll_fz_string_from_barcode_type(type):
           r"""
           Low-level wrapper for `::fz_string_from_barcode_type()`.
           Return barcode string matching one of the above barcode types.
           All lowercase, e.g. "none", "aztec" etc.
           """
>>>>>>     return _mupdf.ll_fz_string_from_barcode_type(type)
       
    1: def ll_fz_string_from_box_type(box):
           r"""Low-level wrapper for `::fz_string_from_box_type()`."""
>>>>>>     return _mupdf.ll_fz_string_from_box_type(box)
       
    1: def ll_fz_string_from_buffer(buf):
           r"""
           Low-level wrapper for `::fz_string_from_buffer()`.
           Ensure that a buffer's data ends in a
           0 byte, and return a pointer to it.
           """
>>>>>>     return _mupdf.ll_fz_string_from_buffer(buf)
       
    1: def ll_fz_string_from_linecap(cap):
           r"""Low-level wrapper for `::fz_string_from_linecap()`."""
>>>>>>     return _mupdf.ll_fz_string_from_linecap(cap)
       
    1: def ll_fz_string_from_linejoin(join):
           r"""Low-level wrapper for `::fz_string_from_linejoin()`."""
>>>>>>     return _mupdf.ll_fz_string_from_linejoin(join)
       
    1: def ll_fz_string_from_text_language(str, lang):
           r"""
           Low-level wrapper for `::fz_string_from_text_language()`.
           Recover ISO 639 (639-{1,2,3,5}) language specification
           strings losslessly from a 15 bit fz_text_language code.
       
           No validation is carried out. See note above.
           """
>>>>>>     return _mupdf.ll_fz_string_from_text_language(str, lang)
       
    1: def ll_fz_string_from_text_language2(lang):
           r"""
            Low-level wrapper for `::fz_string_from_text_language2()`.
           C++ alternative to fz_string_from_text_language() that returns information in a std::string.
           """
>>>>>>     return _mupdf.ll_fz_string_from_text_language2(lang)
       
    1: def ll_fz_strlcat(dst, src, n):
           r"""
           Low-level wrapper for `::fz_strlcat()`.
           Concatenate 2 strings, with a maximum length.
       
           dst: pointer to first string in a buffer of n bytes.
       
           src: pointer to string to concatenate.
       
           n: Size (in bytes) of buffer that dst is in.
       
           Returns the real length that a concatenated dst + src would have
           been (not including terminator).
           """
>>>>>>     return _mupdf.ll_fz_strlcat(dst, src, n)
       
    1: def ll_fz_strlcpy(dst, src, n):
           r"""
           Low-level wrapper for `::fz_strlcpy()`.
           Copy at most n-1 chars of a string into a destination
           buffer with null termination, returning the real length of the
           initial string (excluding terminator).
       
           dst: Destination buffer, at least n bytes long.
       
           src: C string (non-NULL).
       
           n: Size of dst buffer in bytes.
       
           Returns the length (excluding terminator) of src.
           """
>>>>>>     return _mupdf.ll_fz_strlcpy(dst, src, n)
       
    1: def ll_fz_strncasecmp(a, b, n):
           r"""
           Low-level wrapper for `::fz_strncasecmp()`.
           Case insensitive (UTF8) string comparison.
       
           n = maximum number of bytes to read from either a or b.
           """
>>>>>>     return _mupdf.ll_fz_strncasecmp(a, b, n)
       
    1: def ll_fz_strnlen(s, maxlen):
           r"""
           Low-level wrapper for `::fz_strnlen()`.
           Return strlen(s), if that is less than maxlen, or maxlen if
           there is no null byte ('') among the first maxlen bytes.
           """
>>>>>>     return _mupdf.ll_fz_strnlen(s, maxlen)
       
    1: def ll_fz_stroke_path(dev, path, stroke, ctm, colorspace, color, alpha, color_params):
           r"""Low-level wrapper for `::fz_stroke_path()`."""
>>>>>>     return _mupdf.ll_fz_stroke_path(dev, path, stroke, ctm, colorspace, color, alpha, color_params)
       
    1: def ll_fz_stroke_state_eq(a, b):
           r"""Low-level wrapper for `::fz_stroke_state_eq()`."""
>>>>>>     return _mupdf.ll_fz_stroke_state_eq(a, b)
       
    1: def ll_fz_stroke_text(dev, text, stroke, ctm, colorspace, color, alpha, color_params):
           r"""Low-level wrapper for `::fz_stroke_text()`."""
>>>>>>     return _mupdf.ll_fz_stroke_text(dev, text, stroke, ctm, colorspace, color, alpha, color_params)
       
    1: def ll_fz_strsep(stringp, delim):
           r"""
            Low-level wrapper for `::fz_strsep()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_strsep(const char *delim)` => `(char *, char *stringp)`
       
               Given a pointer to a C string (or a pointer to NULL) break
               it at the first occurrence of a delimiter char (from a given
               set).
       
               stringp: Pointer to a C string pointer (or NULL). Updated on
               exit to point to the first char of the string after the
               delimiter that was found. The string pointed to by stringp will
               be corrupted by this call (as the found delimiter will be
               overwritten by 0).
       
               delim: A C string of acceptable delimiter characters.
       
               Returns a pointer to a C string containing the chars of stringp
               up to the first delimiter char (or the end of the string), or
               NULL.
           """
>>>>>>     return _mupdf.ll_fz_strsep(stringp, delim)
       
    1: def ll_fz_strstr(haystack, needle):
           r"""
           Low-level wrapper for `::fz_strstr()`.
           Safe strstr function.
       
           haystack: Where to look (may be NULL).
       
           needled: What to look for.
       
           Returns NULL if unmatched, or pointer to start of match.
           """
>>>>>>     return _mupdf.ll_fz_strstr(haystack, needle)
       
    1: def ll_fz_strstrcase(haystack, needle):
           r"""
           Low-level wrapper for `::fz_strstrcase()`.
           Safe case-insensitive strstr function. (Accepts UTF-8).
       
           haystack: Where to look (may be NULL).
       
           needled: What to look for.
       
           Returns NULL if unmatched, or pointer to start of match.
           """
>>>>>>     return _mupdf.ll_fz_strstrcase(haystack, needle)
       
    1: def ll_fz_strtof(s, es):
           r"""
            Low-level wrapper for `::fz_strtof()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_strtof(const char *s)` => `(float, char *es)`
       
               Locale-independent decimal to binary conversion. On overflow
               return (-)INFINITY and set errno to ERANGE. On underflow return
               0 and set errno to ERANGE. Special inputs (case insensitive):
               "NAN", "INF" or "INFINITY".
           """
>>>>>>     return _mupdf.ll_fz_strtof(s, es)
       
    1: def ll_fz_structure_from_string(str):
           r"""Low-level wrapper for `::fz_structure_from_string()`."""
>>>>>>     return _mupdf.ll_fz_structure_from_string(str)
       
    1: def ll_fz_structure_to_string(type):
           r"""Low-level wrapper for `::fz_structure_to_string()`."""
>>>>>>     return _mupdf.ll_fz_structure_to_string(type)
       
    1: def ll_fz_strverscmp(s1, s2):
           r"""
           Low-level wrapper for `::fz_strverscmp()`.
           portable strverscmp(3) function
           """
>>>>>>     return _mupdf.ll_fz_strverscmp(s1, s2)
       
    1: def ll_fz_subpixel_adjust(ctm, subpix_ctm, qe, qf):
           r"""
           Low-level wrapper for `::fz_subpixel_adjust()`.
           Perform subpixel quantisation and adjustment on a glyph matrix.
       
           ctm: On entry, the desired 'ideal' transformation for a glyph.
           On exit, adjusted to a (very similar) transformation quantised
           for subpixel caching.
       
           subpix_ctm: Initialised by the routine to the transform that
           should be used to render the glyph.
       
           qe, qf: which subpixel position we quantised to.
       
           Returns: the size of the glyph.
       
           Note: This is currently only exposed for use in our app. It
           should be considered "at risk" of removal from the API.
           """
>>>>>>     return _mupdf.ll_fz_subpixel_adjust(ctm, subpix_ctm, qe, qf)
       
    1: def ll_fz_subsample_pixmap(tile, factor):
           r"""Low-level wrapper for `::fz_subsample_pixmap()`."""
>>>>>>     return _mupdf.ll_fz_subsample_pixmap(tile, factor)
       
    1: def ll_fz_subset_cff_for_gids(orig, gids, num_gids, symbolic, cidfont):
           r"""
            Low-level wrapper for `::fz_subset_cff_for_gids()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_subset_cff_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
           """
>>>>>>     return _mupdf.ll_fz_subset_cff_for_gids(orig, gids, num_gids, symbolic, cidfont)
       
    1: def ll_fz_subset_ttf_for_gids(orig, gids, num_gids, symbolic, cidfont):
           r"""
            Low-level wrapper for `::fz_subset_ttf_for_gids()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_subset_ttf_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
           """
>>>>>>     return _mupdf.ll_fz_subset_ttf_for_gids(orig, gids, num_gids, symbolic, cidfont)
       
    1: def ll_fz_sync_bits(stm):
           r"""
           Low-level wrapper for `::fz_sync_bits()`.
           Called after reading bits to tell the stream
           that we are about to return to reading bytewise. Resyncs
           the stream to whole byte boundaries.
           """
>>>>>>     return _mupdf.ll_fz_sync_bits(stm)
       
    1: def ll_fz_table_hunt(page):
           r"""
           Low-level wrapper for `::fz_table_hunt()`.
           Hunt for possible tables on a page, and update the stext with
           information.
           """
>>>>>>     return _mupdf.ll_fz_table_hunt(page)
       
    1: def ll_fz_table_hunt_within_bounds(page, bounds):
           r"""
           Low-level wrapper for `::fz_table_hunt_within_bounds()`.
           Hunt for possible tables within a specific rect on a page, and
           update the stext with information.
           """
>>>>>>     return _mupdf.ll_fz_table_hunt_within_bounds(page, bounds)
       
    1: def ll_fz_tell(stm):
           r"""
           Low-level wrapper for `::fz_tell()`.
           return the current reading position within a stream
           """
>>>>>>     return _mupdf.ll_fz_tell(stm)
       
    1: def ll_fz_tell_output(out):
           r"""
           Low-level wrapper for `::fz_tell_output()`.
           Return the current file position.
       
           Throw an error on untellable outputs.
           """
>>>>>>     return _mupdf.ll_fz_tell_output(out)
       
    1: def ll_fz_terminate_buffer(buf):
           r"""
           Low-level wrapper for `::fz_terminate_buffer()`.
           Zero-terminate buffer in order to use as a C string.
       
           This byte is invisible and does not affect the length of the
           buffer as returned by fz_buffer_storage. The zero byte is
           written *after* the data, and subsequent writes will overwrite
           the terminating byte.
       
           Subsequent changes to the size of the buffer (such as by
           fz_buffer_trim, fz_buffer_grow, fz_resize_buffer, etc) may
           invalidate this.
           """
>>>>>>     return _mupdf.ll_fz_terminate_buffer(buf)
       
    1: def ll_fz_text_aa_level():
           r"""
           Low-level wrapper for `::fz_text_aa_level()`.
           Get the number of bits of antialiasing we are
           using for text. Between 0 and 8.
           """
>>>>>>     return _mupdf.ll_fz_text_aa_level()
       
    1: def ll_fz_text_language_from_string(str):
           r"""
           Low-level wrapper for `::fz_text_language_from_string()`.
           Convert ISO 639 (639-{1,2,3,5}) language specification
           strings losslessly to a 15 bit fz_text_language code.
       
           No validation is carried out. Obviously invalid (out
           of spec) codes will be mapped to FZ_LANG_UNSET, but
           well-formed (but undefined) codes will be blithely
           accepted.
           """
>>>>>>     return _mupdf.ll_fz_text_language_from_string(str)
       
    1: def ll_fz_tint_pixmap(pix, black, white):
           r"""
           Low-level wrapper for `::fz_tint_pixmap()`.
           Tint all the pixels in an RGB, BGR, or Gray pixmap.
       
           black: Map black to this hexadecimal RGB color.
       
           white: Map white to this hexadecimal RGB color.
           """
>>>>>>     return _mupdf.ll_fz_tint_pixmap(pix, black, white)
       
    1: def ll_fz_tolower(c):
           r"""
           Low-level wrapper for `::fz_tolower()`.
           Unicode aware tolower and toupper functions.
           """
>>>>>>     return _mupdf.ll_fz_tolower(c)
       
    1: def ll_fz_toupper(c):
           r"""Low-level wrapper for `::fz_toupper()`."""
>>>>>>     return _mupdf.ll_fz_toupper(c)
       
    1: def ll_fz_transform_page(mediabox, resolution, rotate):
           r"""
           Low-level wrapper for `::fz_transform_page()`.
           Create transform matrix to draw page
           at a given resolution and rotation. Adjusts the scaling
           factors so that the page covers whole number of
           pixels and adjust the page origin to be at 0,0.
           """
>>>>>>     return _mupdf.ll_fz_transform_page(mediabox, resolution, rotate)
       
    1: def ll_fz_transform_path(path, transform):
           r"""
           Low-level wrapper for `::fz_transform_path()`.
           Transform a path by a given
           matrix.
       
           path: The path to modify (must not be a packed path).
       
           transform: The transform to apply.
       
           Throws exceptions if the path is packed, or on failure
           to allocate.
           """
>>>>>>     return _mupdf.ll_fz_transform_path(path, transform)
       
    1: def ll_fz_transform_point(point, m):
           r"""
           Low-level wrapper for `::fz_transform_point()`.
           Apply a transformation to a point.
       
           transform: Transformation matrix to apply. See fz_concat,
           fz_scale, fz_rotate and fz_translate for how to create a
           matrix.
       
           point: Pointer to point to update.
       
           Returns transform (unchanged).
           """
>>>>>>     return _mupdf.ll_fz_transform_point(point, m)
       
    1: def ll_fz_transform_point_xy(x, y, m):
           r"""Low-level wrapper for `::fz_transform_point_xy()`."""
>>>>>>     return _mupdf.ll_fz_transform_point_xy(x, y, m)
       
    1: def ll_fz_transform_quad(q, m):
           r"""
           Low-level wrapper for `::fz_transform_quad()`.
           Transform a quad by a matrix.
           """
>>>>>>     return _mupdf.ll_fz_transform_quad(q, m)
       
    1: def ll_fz_transform_rect(rect, m):
           r"""
           Low-level wrapper for `::fz_transform_rect()`.
           Apply a transform to a rectangle.
       
           After the four corner points of the axis-aligned rectangle
           have been transformed it may not longer be axis-aligned. So a
           new axis-aligned rectangle is created covering at least the
           area of the transformed rectangle.
       
           transform: Transformation matrix to apply. See fz_concat,
           fz_scale and fz_rotate for how to create a matrix.
       
           rect: Rectangle to be transformed. The two special cases
           fz_empty_rect and fz_infinite_rect, may be used but are
           returned unchanged as expected.
           """
>>>>>>     return _mupdf.ll_fz_transform_rect(rect, m)
       
    1: def ll_fz_transform_vector(vector, m):
           r"""
           Low-level wrapper for `::fz_transform_vector()`.
           Apply a transformation to a vector.
       
           transform: Transformation matrix to apply. See fz_concat,
           fz_scale and fz_rotate for how to create a matrix. Any
           translation will be ignored.
       
           vector: Pointer to vector to update.
           """
>>>>>>     return _mupdf.ll_fz_transform_vector(vector, m)
       
    1: def ll_fz_translate(tx, ty):
           r"""
           Low-level wrapper for `::fz_translate()`.
           Create a translation matrix.
       
           The returned matrix is of the form [ 1 0 0 1 tx ty ].
       
           m: A place to store the created matrix.
       
           tx, ty: Translation distances along the X- and Y-axes. A
           translation of 0 will not cause any translation along the
           relevant axis.
       
           Returns m.
           """
>>>>>>     return _mupdf.ll_fz_translate(tx, ty)
       
    1: def ll_fz_translate_irect(a, xoff, yoff):
           r"""Low-level wrapper for `::fz_translate_irect()`."""
>>>>>>     return _mupdf.ll_fz_translate_irect(a, xoff, yoff)
       
    1: def ll_fz_translate_rect(a, xoff, yoff):
           r"""
           Low-level wrapper for `::fz_translate_rect()`.
           Translate bounding box.
       
           Translate a bbox by a given x and y offset. Allows for overflow.
           """
>>>>>>     return _mupdf.ll_fz_translate_rect(a, xoff, yoff)
       
    1: def ll_fz_tree_archive_add_buffer(arch_, name, buf):
           r"""
           Low-level wrapper for `::fz_tree_archive_add_buffer()`.
           Add a named buffer to an existing tree archive.
       
           The tree will take a new reference to the buffer. Ownership
           is not transferred.
           """
>>>>>>     return _mupdf.ll_fz_tree_archive_add_buffer(arch_, name, buf)
       
    1: def ll_fz_tree_archive_add_data(arch_, name, data, size):
           r"""
           Low-level wrapper for `::fz_tree_archive_add_data()`.
           Add a named block of data to an existing tree archive.
       
           The data will be copied into a buffer, and so the caller
           may free it as soon as this returns.
           """
>>>>>>     return _mupdf.ll_fz_tree_archive_add_data(arch_, name, data, size)
       
    1: def ll_fz_tree_insert(root, key, value):
           r"""
           Low-level wrapper for `::fz_tree_insert()`.
           Insert a new key/value pair and rebalance the tree.
           Return the new root of the tree after inserting and rebalancing.
           May be called with a NULL root to create a new tree.
       
           No data is copied into the tree structure; key and value are
           merely kept as pointers.
           """
>>>>>>     return _mupdf.ll_fz_tree_insert(root, key, value)
       
    1: def ll_fz_tree_lookup(node, key):
           r"""
           Low-level wrapper for `::fz_tree_lookup()`.
           Look for the value of a node in the tree with the given key.
       
           Simple pointer equivalence is used for key.
       
           Returns NULL for no match.
           """
>>>>>>     return _mupdf.ll_fz_tree_lookup(node, key)
       
    1: def ll_fz_trim_buffer(buf):
           r"""
           Low-level wrapper for `::fz_trim_buffer()`.
           Trim wasted capacity from a buffer by resizing internal memory.
           """
>>>>>>     return _mupdf.ll_fz_trim_buffer(buf)
       
    1: def ll_fz_trim_path(path):
           r"""
           Low-level wrapper for `::fz_trim_path()`.
           Minimise the internal storage used by a path.
       
           As paths are constructed, the internal buffers
           grow. To avoid repeated reallocations they
           grow with some spare space. Once a path has
           been fully constructed, this call allows the
           excess space to be trimmed.
           """
>>>>>>     return _mupdf.ll_fz_trim_path(path)
       
    1: def ll_fz_truncate_output(arg_1):
           r"""
           Low-level wrapper for `::fz_truncate_output()`.
           Truncate the output at the current position.
       
           This allows output streams which have seeked back from the end
           of their storage to be truncated at the current point.
           """
>>>>>>     return _mupdf.ll_fz_truncate_output(arg_1)
       
    1: def ll_fz_try_invert_matrix(inv, src):
           r"""
           Low-level wrapper for `::fz_try_invert_matrix()`.
           Attempt to create an inverse matrix.
       
           inv: Place to store inverse matrix.
       
           src: Matrix to invert. A degenerate matrix, where the
           determinant is equal to zero, can not be inverted.
       
           Returns 1 if matrix is degenerate (singular), or 0 otherwise.
           """
>>>>>>     return _mupdf.ll_fz_try_invert_matrix(inv, src)
       
    1: def ll_fz_try_open_archive_entry(arch, name):
           r"""
           Low-level wrapper for `::fz_try_open_archive_entry()`.
           Opens an archive entry as a stream.
       
           Returns NULL if a matching entry cannot be found, otherwise
           behaves exactly as fz_open_archive_entry.
           """
>>>>>>     return _mupdf.ll_fz_try_open_archive_entry(arch, name)
       
    1: def ll_fz_try_open_archive_with_stream(file):
           r"""
           Low-level wrapper for `::fz_try_open_archive_with_stream()`.
           Open zip or tar archive stream.
       
           Does the same as fz_open_archive_with_stream, but will not throw
           an error in the event of failing to recognise the format. Will
           still throw errors in other cases though!
           """
>>>>>>     return _mupdf.ll_fz_try_open_archive_with_stream(file)
       
    1: def ll_fz_try_open_file(name):
           r"""
           Low-level wrapper for `::fz_try_open_file()`.
           Open the named file and wrap it in a stream.
       
           Does the same as fz_open_file, but in the event the file
           does not open, it will return NULL rather than throw an
           exception.
           """
>>>>>>     return _mupdf.ll_fz_try_open_file(name)
       
    1: def ll_fz_try_parse_xml_archive_entry(dir, filename, preserve_white):
           r"""
           Low-level wrapper for `::fz_try_parse_xml_archive_entry()`.
           Try and parse the contents of an archive entry into a tree of xml nodes.
       
           preserve_white: whether to keep or delete all-whitespace nodes.
       
           Will return NULL if the archive entry can't be found. Otherwise behaves
           the same as fz_parse_xml_archive_entry. May throw exceptions.
           """
>>>>>>     return _mupdf.ll_fz_try_parse_xml_archive_entry(dir, filename, preserve_white)
       
    1: def ll_fz_try_read_archive_entry(arch, name):
           r"""
           Low-level wrapper for `::fz_try_read_archive_entry()`.
           Reads all bytes in an archive entry
           into a buffer.
       
           name: Entry name to look for, this must be an exact match to
           the entry name in the archive.
       
           Returns NULL if a matching entry cannot be found. Otherwise behaves
           the same as fz_read_archive_entry. Exceptions may be thrown.
           """
>>>>>>     return _mupdf.ll_fz_try_read_archive_entry(arch, name)
       
    1: def ll_fz_try_read_file(filename):
           r"""
           Low-level wrapper for `::fz_try_read_file()`.
           Read all the contents of a file into a buffer.
       
           Returns NULL if the file does not exist, otherwise
           behaves exactly as fz_read_file.
           """
>>>>>>     return _mupdf.ll_fz_try_read_file(filename)
       
    1: def ll_fz_tune_image_decode(image_decode, arg):
           r"""
           Low-level wrapper for `::fz_tune_image_decode()`.
           Set the tuning function to use for
           image decode.
       
           image_decode: Function to use.
       
           arg: Opaque argument to be passed to tuning function.
           """
>>>>>>     return _mupdf.ll_fz_tune_image_decode(image_decode, arg)
       
    1: def ll_fz_tune_image_scale(image_scale, arg):
           r"""
           Low-level wrapper for `::fz_tune_image_scale()`.
           Set the tuning function to use for
           image scaling.
       
           image_scale: Function to use.
       
           arg: Opaque argument to be passed to tuning function.
           """
>>>>>>     return _mupdf.ll_fz_tune_image_scale(image_scale, arg)
       
    1: def ll_fz_unicode_from_glyph_name(name):
           r"""Low-level wrapper for `::fz_unicode_from_glyph_name()`."""
>>>>>>     return _mupdf.ll_fz_unicode_from_glyph_name(name)
       
    1: def ll_fz_unicode_from_glyph_name_strict(name):
           r"""Low-level wrapper for `::fz_unicode_from_glyph_name_strict()`."""
>>>>>>     return _mupdf.ll_fz_unicode_from_glyph_name_strict(name)
       
    1: def ll_fz_union_rect(a, b):
           r"""
           Low-level wrapper for `::fz_union_rect()`.
           Compute union of two rectangles.
       
           Given two rectangles, update the first to be the smallest
           axis-aligned rectangle that encompasses both given rectangles.
           If either rectangle is infinite then the union is also infinite.
           If either rectangle is empty then the union is simply the
           non-empty rectangle. Should both rectangles be empty, then the
           union is also empty.
           """
>>>>>>     return _mupdf.ll_fz_union_rect(a, b)
       
    1: def ll_fz_unlock(lock):
           r"""
           Low-level wrapper for `::fz_unlock()`.
           Unlock one of the user supplied mutexes.
           """
>>>>>>     return _mupdf.ll_fz_unlock(lock)
       
    1: def ll_fz_unpack_stream(src, depth, w, h, n, indexed, pad, skip):
           r"""Low-level wrapper for `::fz_unpack_stream()`."""
>>>>>>     return _mupdf.ll_fz_unpack_stream(src, depth, w, h, n, indexed, pad, skip)
       
    1: def ll_fz_unread_byte(stm):
           r"""
           Low-level wrapper for `::fz_unread_byte()`.
           Unread the single last byte successfully
           read from a stream. Do not call this without having
           successfully read a byte.
       
           stm: The stream to operate upon.
           """
>>>>>>     return _mupdf.ll_fz_unread_byte(stm)
       
    1: def ll_fz_unshare_stroke_state(shared):
           r"""
           Low-level wrapper for `::fz_unshare_stroke_state()`.
           Given a reference to a (possibly) shared stroke_state structure,
           return a reference to an equivalent stroke_state structure
           that is guaranteed to be unshared (i.e. one that can
           safely be modified).
       
           shared: The reference to a (possibly) shared structure
           to unshare. Ownership of this reference is passed in
           to this function, even in the case of exceptions being
           thrown.
       
           Exceptions may be thrown in the event of failure to
           allocate if required.
           """
>>>>>>     return _mupdf.ll_fz_unshare_stroke_state(shared)
       
    1: def ll_fz_unshare_stroke_state_with_dash_len(shared, len):
           r"""
           Low-level wrapper for `::fz_unshare_stroke_state_with_dash_len()`.
           Given a reference to a (possibly) shared stroke_state structure,
           return a reference to a stroke_state structure (with room for a
           given amount of dash data) that is guaranteed to be unshared
           (i.e. one that can safely be modified).
       
           shared: The reference to a (possibly) shared structure
           to unshare. Ownership of this reference is passed in
           to this function, even in the case of exceptions being
           thrown.
       
           Exceptions may be thrown in the event of failure to
           allocate if required.
           """
>>>>>>     return _mupdf.ll_fz_unshare_stroke_state_with_dash_len(shared, len)
       
    1: def ll_fz_urldecode(url):
           r"""
           Low-level wrapper for `::fz_urldecode()`.
           Like fz_decode_uri_component but in-place.
           """
>>>>>>     return _mupdf.ll_fz_urldecode(url)
       
    1: def ll_fz_use_document_css():
           r"""
           Low-level wrapper for `::fz_use_document_css()`.
           Return whether to respect document styles in HTML and EPUB.
           """
>>>>>>     return _mupdf.ll_fz_use_document_css()
       
    1: def ll_fz_user_context():
           r"""
           Low-level wrapper for `::fz_user_context()`.
           Read the user field from the context.
           """
>>>>>>     return _mupdf.ll_fz_user_context()
       
    1: def ll_fz_user_css():
           r"""
           Low-level wrapper for `::fz_user_css()`.
           Get the user stylesheet source text.
           """
>>>>>>     return _mupdf.ll_fz_user_css()
       
    1: def ll_fz_utflen(s):
           r"""
           Low-level wrapper for `::fz_utflen()`.
           Count how many runes the UTF-8 encoded string
           consists of.
       
           s: The UTF-8 encoded, NUL-terminated text string.
       
           Returns the number of runes in the string.
           """
>>>>>>     return _mupdf.ll_fz_utflen(s)
       
    1: def ll_fz_var_imp(arg_0):
           r"""Low-level wrapper for `::fz_var_imp()`."""
>>>>>>     return _mupdf.ll_fz_var_imp(arg_0)
       
    1: def ll_fz_walk_path(path, walker, arg):
           r"""
           Low-level wrapper for `::fz_walk_path()`.
           Walk the segments of a path, calling the
           appropriate callback function from a given set for each
           segment of the path.
       
           path: The path to walk.
       
           walker: The set of callback functions to use. The first
           4 callback pointers in the set must be non-NULL. The
           subsequent ones can either be supplied, or can be left
           as NULL, in which case the top 4 functions will be
           called as appropriate to simulate them.
       
           arg: An opaque argument passed in to each callback.
       
           Exceptions will only be thrown if the underlying callback
           functions throw them.
           """
>>>>>>     return _mupdf.ll_fz_walk_path(path, walker, arg)
       
    1: def ll_fz_warn(*args):
           r"""Low-level wrapper for `::fz_warn()`."""
>>>>>>     return _mupdf.ll_fz_warn(*args)
       
    1: def ll_fz_warning_callback(user):
           r"""
            Low-level wrapper for `::fz_warning_callback()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_fz_warning_callback()` => `(fz_warning_cb *, void *user)`
       
               Retrieve the currently set warning callback, or NULL if none
               has been set. Optionally, if user is non-NULL, the user pointer
               given when the warning callback was set is also passed back to
               the caller.
           """
>>>>>>     return _mupdf.ll_fz_warning_callback(user)
       
    1: def ll_fz_warp_pixmap(src, points, width, height):
           r"""Low-level wrapper for `::fz_warp_pixmap()`."""
>>>>>>     return _mupdf.ll_fz_warp_pixmap(src, points, width, height)
       
    1: def ll_fz_windows_1250_from_unicode(u):
           r"""Low-level wrapper for `::fz_windows_1250_from_unicode()`."""
>>>>>>     return _mupdf.ll_fz_windows_1250_from_unicode(u)
       
    1: def ll_fz_windows_1251_from_unicode(u):
           r"""Low-level wrapper for `::fz_windows_1251_from_unicode()`."""
>>>>>>     return _mupdf.ll_fz_windows_1251_from_unicode(u)
       
    1: def ll_fz_windows_1252_from_unicode(u):
           r"""Low-level wrapper for `::fz_windows_1252_from_unicode()`."""
>>>>>>     return _mupdf.ll_fz_windows_1252_from_unicode(u)
       
    1: def ll_fz_write_band(writer, stride, band_height, samples):
           r"""
           Low-level wrapper for `::fz_write_band()`.
           Cause a band writer to write the next band
           of data for an image.
       
           stride: The byte offset from the first byte of the data
           for a pixel to the first byte of the data for the same pixel
           on the row below.
       
           band_height: The number of lines in this band.
       
           samples: Pointer to first byte of the data.
           """
>>>>>>     return _mupdf.ll_fz_write_band(writer, stride, band_height, samples)
       
    1: def ll_fz_write_base64(out, data, size, newline):
           r"""
           Low-level wrapper for `::fz_write_base64()`.
           Write a base64 encoded data block, optionally with periodic
           newlines.
           """
>>>>>>     return _mupdf.ll_fz_write_base64(out, data, size, newline)
       
    1: def ll_fz_write_base64_buffer(out, data, newline):
           r"""
           Low-level wrapper for `::fz_write_base64_buffer()`.
           Write a base64 encoded fz_buffer, optionally with periodic
           newlines.
           """
>>>>>>     return _mupdf.ll_fz_write_base64_buffer(out, data, newline)
       
    1: def ll_fz_write_bitmap_as_pbm(out, bitmap):
           r"""
           Low-level wrapper for `::fz_write_bitmap_as_pbm()`.
           Write a bitmap as a pbm.
           """
>>>>>>     return _mupdf.ll_fz_write_bitmap_as_pbm(out, bitmap)
       
    1: def ll_fz_write_bitmap_as_pcl(out, bitmap, pcl):
           r"""
           Low-level wrapper for `::fz_write_bitmap_as_pcl()`.
           Write a bitmap as mono PCL.
           """
>>>>>>     return _mupdf.ll_fz_write_bitmap_as_pcl(out, bitmap, pcl)
       
    1: def ll_fz_write_bitmap_as_pkm(out, bitmap):
           r"""
           Low-level wrapper for `::fz_write_bitmap_as_pkm()`.
           Write a CMYK bitmap as a pkm.
           """
>>>>>>     return _mupdf.ll_fz_write_bitmap_as_pkm(out, bitmap)
       
    1: def ll_fz_write_bitmap_as_pwg(out, bitmap, pwg):
           r"""
           Low-level wrapper for `::fz_write_bitmap_as_pwg()`.
           Write a bitmap as a PWG.
           """
>>>>>>     return _mupdf.ll_fz_write_bitmap_as_pwg(out, bitmap, pwg)
       
    1: def ll_fz_write_bitmap_as_pwg_page(out, bitmap, pwg):
           r"""
           Low-level wrapper for `::fz_write_bitmap_as_pwg_page()`.
           Write a bitmap as a PWG page.
       
           Caller should provide a file header by calling
           fz_write_pwg_file_header, but can then write several pages to
           the same file.
           """
>>>>>>     return _mupdf.ll_fz_write_bitmap_as_pwg_page(out, bitmap, pwg)
       
    1: def ll_fz_write_bits(out, data, num_bits):
           r"""
           Low-level wrapper for `::fz_write_bits()`.
           Write num_bits of data to the end of the output stream, assumed to be packed
           most significant bits first.
           """
>>>>>>     return _mupdf.ll_fz_write_bits(out, data, num_bits)
       
    1: def ll_fz_write_bits_sync(out):
           r"""
           Low-level wrapper for `::fz_write_bits_sync()`.
           Sync to byte boundary after writing bits.
           """
>>>>>>     return _mupdf.ll_fz_write_bits_sync(out)
       
    1: def ll_fz_write_buffer(out, data):
           r"""Low-level wrapper for `::fz_write_buffer()`."""
>>>>>>     return _mupdf.ll_fz_write_buffer(out, data)
       
    1: def ll_fz_write_byte(out, x):
           r"""Low-level wrapper for `::fz_write_byte()`."""
>>>>>>     return _mupdf.ll_fz_write_byte(out, x)
       
    1: def ll_fz_write_char(out, x):
           r"""Low-level wrapper for `::fz_write_char()`."""
>>>>>>     return _mupdf.ll_fz_write_char(out, x)
       
    1: def ll_fz_write_data(out, data, size):
           r"""
           Low-level wrapper for `::fz_write_data()`.
           Write data to output.
       
           data: Pointer to data to write.
           size: Size of data to write in bytes.
           """
>>>>>>     return _mupdf.ll_fz_write_data(out, data, size)
       
    1: def ll_fz_write_document(wri, doc):
           r"""
           Low-level wrapper for `::fz_write_document()`.
           Convenience function to feed all the pages of a document to
           fz_begin_page/fz_run_page/fz_end_page.
           """
>>>>>>     return _mupdf.ll_fz_write_document(wri, doc)
       
    1: def ll_fz_write_float_be(out, f):
           r"""Low-level wrapper for `::fz_write_float_be()`."""
>>>>>>     return _mupdf.ll_fz_write_float_be(out, f)
       
    1: def ll_fz_write_float_le(out, f):
           r"""Low-level wrapper for `::fz_write_float_le()`."""
>>>>>>     return _mupdf.ll_fz_write_float_le(out, f)
       
    1: def ll_fz_write_header(writer, w, h, n, alpha, xres, yres, pagenum, cs, seps):
           r"""
           Low-level wrapper for `::fz_write_header()`.
           Cause a band writer to write the header for
           a banded image with the given properties/dimensions etc. This
           also configures the bandwriter for the format of the data to be
           passed in future calls.
       
           w, h: Width and Height of the entire page.
       
           n: Number of components (including spots and alphas).
       
           alpha: Number of alpha components.
       
           xres, yres: X and Y resolutions in dpi.
       
           cs: Colorspace (NULL for bitmaps)
       
           seps: Separation details (or NULL).
           """
>>>>>>     return _mupdf.ll_fz_write_header(writer, w, h, n, alpha, xres, yres, pagenum, cs, seps)
       
    1: def ll_fz_write_image_as_data_uri(out, image):
           r"""
           Low-level wrapper for `::fz_write_image_as_data_uri()`.
           Write image as a data URI (for HTML and SVG output).
           """
>>>>>>     return _mupdf.ll_fz_write_image_as_data_uri(out, image)
       
    1: def ll_fz_write_int16_be(out, x):
           r"""Low-level wrapper for `::fz_write_int16_be()`."""
>>>>>>     return _mupdf.ll_fz_write_int16_be(out, x)
       
    1: def ll_fz_write_int16_le(out, x):
           r"""Low-level wrapper for `::fz_write_int16_le()`."""
>>>>>>     return _mupdf.ll_fz_write_int16_le(out, x)
       
    1: def ll_fz_write_int32_be(out, x):
           r"""
           Low-level wrapper for `::fz_write_int32_be()`.
           Write different sized data to an output stream.
           """
>>>>>>     return _mupdf.ll_fz_write_int32_be(out, x)
       
    1: def ll_fz_write_int32_le(out, x):
           r"""Low-level wrapper for `::fz_write_int32_le()`."""
>>>>>>     return _mupdf.ll_fz_write_int32_le(out, x)
       
    1: def ll_fz_write_json(out, value):
           r"""Low-level wrapper for `::fz_write_json()`."""
>>>>>>     return _mupdf.ll_fz_write_json(out, value)
       
    1: def ll_fz_write_pixmap_as_data_uri(out, pixmap):
           r"""Low-level wrapper for `::fz_write_pixmap_as_data_uri()`."""
>>>>>>     return _mupdf.ll_fz_write_pixmap_as_data_uri(out, pixmap)
       
    1: def ll_fz_write_pixmap_as_jpeg(out, pix, quality, invert_cmyk):
           r"""
           Low-level wrapper for `::fz_write_pixmap_as_jpeg()`.
           Write a pixmap as a JPEG.
           """
>>>>>>     return _mupdf.ll_fz_write_pixmap_as_jpeg(out, pix, quality, invert_cmyk)
       
    1: def ll_fz_write_pixmap_as_jpx(out, pix, quality):
           r"""
           Low-level wrapper for `::fz_write_pixmap_as_jpx()`.
           Pixmap data as JP2K with no subsampling.
       
           quality = 100 = lossless
           otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
           """
>>>>>>     return _mupdf.ll_fz_write_pixmap_as_jpx(out, pix, quality)
       
    1: def ll_fz_write_pixmap_as_pam(out, pixmap):
           r"""
           Low-level wrapper for `::fz_write_pixmap_as_pam()`.
           Write a pixmap as a pnm (greyscale, rgb or cmyk, with or without
           alpha).
           """
>>>>>>     return _mupdf.ll_fz_write_pixmap_as_pam(out, pixmap)
       
    1: def ll_fz_write_pixmap_as_pcl(out, pixmap, pcl):
           r"""
           Low-level wrapper for `::fz_write_pixmap_as_pcl()`.
           Write an (RGB) pixmap as color PCL.
           """
>>>>>>     return _mupdf.ll_fz_write_pixmap_as_pcl(out, pixmap, pcl)
       
    1: def ll_fz_write_pixmap_as_pclm(out, pixmap, options):
           r"""
           Low-level wrapper for `::fz_write_pixmap_as_pclm()`.
           Write a (Greyscale or RGB) pixmap as pclm.
           """
>>>>>>     return _mupdf.ll_fz_write_pixmap_as_pclm(out, pixmap, options)
       
    1: def ll_fz_write_pixmap_as_pdfocr(out, pixmap, options):
           r"""
           Low-level wrapper for `::fz_write_pixmap_as_pdfocr()`.
           Write a (Greyscale or RGB) pixmap as pdfocr.
           """
>>>>>>     return _mupdf.ll_fz_write_pixmap_as_pdfocr(out, pixmap, options)
       
    1: def ll_fz_write_pixmap_as_png(out, pixmap):
           r"""
           Low-level wrapper for `::fz_write_pixmap_as_png()`.
           Write a (Greyscale or RGB) pixmap as a png.
           """
>>>>>>     return _mupdf.ll_fz_write_pixmap_as_png(out, pixmap)
       
    1: def ll_fz_write_pixmap_as_pnm(out, pixmap):
           r"""
           Low-level wrapper for `::fz_write_pixmap_as_pnm()`.
           Write a pixmap as a pnm (greyscale or rgb, no alpha).
           """
>>>>>>     return _mupdf.ll_fz_write_pixmap_as_pnm(out, pixmap)
       
    1: def ll_fz_write_pixmap_as_ps(out, pixmap):
           r"""
           Low-level wrapper for `::fz_write_pixmap_as_ps()`.
           Write a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
           """
>>>>>>     return _mupdf.ll_fz_write_pixmap_as_ps(out, pixmap)
       
    1: def ll_fz_write_pixmap_as_psd(out, pixmap):
           r"""
           Low-level wrapper for `::fz_write_pixmap_as_psd()`.
           Write a pixmap as a PSD file.
           """
>>>>>>     return _mupdf.ll_fz_write_pixmap_as_psd(out, pixmap)
       
    1: def ll_fz_write_pixmap_as_pwg(out, pixmap, pwg):
           r"""
           Low-level wrapper for `::fz_write_pixmap_as_pwg()`.
           Write a pixmap as a PWG.
           """
>>>>>>     return _mupdf.ll_fz_write_pixmap_as_pwg(out, pixmap, pwg)
       
    1: def ll_fz_write_pixmap_as_pwg_page(out, pixmap, pwg):
           r"""
           Low-level wrapper for `::fz_write_pixmap_as_pwg_page()`.
           Write a pixmap as a PWG page.
       
           Caller should provide a file header by calling
           fz_write_pwg_file_header, but can then write several pages to
           the same file.
           """
>>>>>>     return _mupdf.ll_fz_write_pixmap_as_pwg_page(out, pixmap, pwg)
       
    1: def ll_fz_write_ps_file_header(out):
           r"""
           Low-level wrapper for `::fz_write_ps_file_header()`.
           Write the file level header for ps band writer output.
           """
>>>>>>     return _mupdf.ll_fz_write_ps_file_header(out)
       
    1: def ll_fz_write_ps_file_trailer(out, pages):
           r"""
           Low-level wrapper for `::fz_write_ps_file_trailer()`.
           Write the file level trailer for ps band writer output.
           """
>>>>>>     return _mupdf.ll_fz_write_ps_file_trailer(out, pages)
       
    1: def ll_fz_write_pwg_file_header(out):
           r"""
           Low-level wrapper for `::fz_write_pwg_file_header()`.
           Output the file header to a pwg stream, ready for pages to follow it.
           """
>>>>>>     return _mupdf.ll_fz_write_pwg_file_header(out)
       
    1: def ll_fz_write_rune(out, rune):
           r"""
           Low-level wrapper for `::fz_write_rune()`.
           Write a UTF-8 encoded unicode character.
           """
>>>>>>     return _mupdf.ll_fz_write_rune(out, rune)
       
    1: def ll_fz_write_stabilized_story(writer, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir):
           r"""Low-level wrapper for `::fz_write_stabilized_story()`."""
>>>>>>     return _mupdf.ll_fz_write_stabilized_story(writer, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir)
       
    1: def ll_fz_write_story(writer, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref):
           r"""Low-level wrapper for `::fz_write_story()`."""
>>>>>>     return _mupdf.ll_fz_write_story(writer, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref)
       
    1: def ll_fz_write_stream(out, _in):
           r"""
           Low-level wrapper for `::fz_write_stream()`.
           Copy the stream contents to the output.
           """
>>>>>>     return _mupdf.ll_fz_write_stream(out, _in)
       
    1: def ll_fz_write_string(out, s):
           r"""
           Low-level wrapper for `::fz_write_string()`.
           Write a string. Does not write zero terminator.
           """
>>>>>>     return _mupdf.ll_fz_write_string(out, s)
       
    1: def ll_fz_write_uint16_be(out, x):
           r"""Low-level wrapper for `::fz_write_uint16_be()`."""
>>>>>>     return _mupdf.ll_fz_write_uint16_be(out, x)
       
    1: def ll_fz_write_uint16_le(out, x):
           r"""Low-level wrapper for `::fz_write_uint16_le()`."""
>>>>>>     return _mupdf.ll_fz_write_uint16_le(out, x)
       
    1: def ll_fz_write_uint32_be(out, x):
           r"""Low-level wrapper for `::fz_write_uint32_be()`."""
>>>>>>     return _mupdf.ll_fz_write_uint32_be(out, x)
       
    1: def ll_fz_write_uint32_le(out, x):
           r"""Low-level wrapper for `::fz_write_uint32_le()`."""
>>>>>>     return _mupdf.ll_fz_write_uint32_le(out, x)
       
    1: def ll_fz_write_xml(root, out, indented):
           r"""
           Low-level wrapper for `::fz_write_xml()`.
           Write our xml structure out to an xml stream.
       
           Properly formatted XML is only allowed to have a single top-level node
           under which everything must sit. Our structures allow for multiple
           top level nodes. If required, we will output an extra 'ROOT' node
           at the top so that the xml is well-formed.
       
           If 'indented' is non-zero then additional whitespace will be added to
           make the XML easier to read in a text editor. It will NOT be properly
           compliant.
           """
>>>>>>     return _mupdf.ll_fz_write_xml(root, out, indented)
       
    1: def ll_fz_write_zip_entry(zip, name, buf, compress):
           r"""
           Low-level wrapper for `::fz_write_zip_entry()`.
           Given a buffer of data, (optionally) compress it, and add it to
           the zip file with the given name.
           """
>>>>>>     return _mupdf.ll_fz_write_zip_entry(zip, name, buf, compress)
       
    1: def ll_fz_xml_add_att(pool, node, key, val):
           r"""
           Low-level wrapper for `::fz_xml_add_att()`.
           Add an attribute to an XML node.
           """
>>>>>>     return _mupdf.ll_fz_xml_add_att(pool, node, key, val)
       
    1: def ll_fz_xml_att(item, att):
           r"""
           Low-level wrapper for `::fz_xml_att()`.
           Return the value of an attribute of an XML node.
           NULL if the attribute doesn't exist.
           """
>>>>>>     return _mupdf.ll_fz_xml_att(item, att)
       
    1: def ll_fz_xml_att_alt(item, one, two):
           r"""
           Low-level wrapper for `::fz_xml_att_alt()`.
           Return the value of an attribute of an XML node.
           If the first attribute doesn't exist, try the second.
           NULL if neither attribute exists.
           """
>>>>>>     return _mupdf.ll_fz_xml_att_alt(item, one, two)
       
    1: def ll_fz_xml_att_eq(item, name, match):
           r"""
           Low-level wrapper for `::fz_xml_att_eq()`.
           Check for a matching attribute on an XML node.
       
           If the node has the requested attribute (name), and the value
           matches (match) then return 1. Otherwise, 0.
           """
>>>>>>     return _mupdf.ll_fz_xml_att_eq(item, name, match)
       
    1: def ll_fz_xml_down(item):
           r"""
           Low-level wrapper for `::fz_xml_down()`.
           Return first child of XML node.
           """
>>>>>>     return _mupdf.ll_fz_xml_down(item)
       
    1: def ll_fz_xml_find(item, tag):
           r"""
           Low-level wrapper for `::fz_xml_find()`.
           Search the siblings of XML nodes starting with item looking for
           the first with the given tag.
       
           Return NULL if none found.
           """
>>>>>>     return _mupdf.ll_fz_xml_find(item, tag)
       
    1: def ll_fz_xml_find_dfs(item, tag, att, match):
           r"""
           Low-level wrapper for `::fz_xml_find_dfs()`.
           Perform a depth first search from item, returning the first
           child that matches the given tag (or any tag if tag is NULL),
           with the given attribute (if att is non NULL), that matches
           match (if match is non NULL).
           """
>>>>>>     return _mupdf.ll_fz_xml_find_dfs(item, tag, att, match)
       
    1: def ll_fz_xml_find_dfs_top(item, tag, att, match, top):
           r"""
           Low-level wrapper for `::fz_xml_find_dfs_top()`.
           Perform a depth first search from item, returning the first
           child that matches the given tag (or any tag if tag is NULL),
           with the given attribute (if att is non NULL), that matches
           match (if match is non NULL). The search stops if it ever
           reaches the top of the tree, or the declared 'top' item.
           """
>>>>>>     return _mupdf.ll_fz_xml_find_dfs_top(item, tag, att, match, top)
       
    1: def ll_fz_xml_find_down(item, tag):
           r"""
           Low-level wrapper for `::fz_xml_find_down()`.
           Search the siblings of XML nodes starting with the first child
           of item looking for the first with the given tag.
       
           Return NULL if none found.
           """
>>>>>>     return _mupdf.ll_fz_xml_find_down(item, tag)
       
    1: def ll_fz_xml_find_down_match(item, tag, att, match):
           r"""
           Low-level wrapper for `::fz_xml_find_down_match()`.
           Search the siblings of XML nodes starting with the first child
           of item looking for the first with the given tag (or any tag if
           tag is NULL), and with a matching attribute.
       
           Return NULL if none found.
           """
>>>>>>     return _mupdf.ll_fz_xml_find_down_match(item, tag, att, match)
       
    1: def ll_fz_xml_find_match(item, tag, att, match):
           r"""
           Low-level wrapper for `::fz_xml_find_match()`.
           Search the siblings of XML nodes starting with item looking for
           the first with the given tag (or any tag if tag is NULL), and
           with a matching attribute.
       
           Return NULL if none found.
           """
>>>>>>     return _mupdf.ll_fz_xml_find_match(item, tag, att, match)
       
    1: def ll_fz_xml_find_next(item, tag):
           r"""
           Low-level wrapper for `::fz_xml_find_next()`.
           Search the siblings of XML nodes starting with the first sibling
           of item looking for the first with the given tag.
       
           Return NULL if none found.
           """
>>>>>>     return _mupdf.ll_fz_xml_find_next(item, tag)
       
    1: def ll_fz_xml_find_next_dfs(item, tag, att, match):
           r"""
           Low-level wrapper for `::fz_xml_find_next_dfs()`.
           Perform a depth first search onwards from item, returning the first
           child that matches the given tag (or any tag if tag is NULL),
           with the given attribute (if att is non NULL), that matches
           match (if match is non NULL).
           """
>>>>>>     return _mupdf.ll_fz_xml_find_next_dfs(item, tag, att, match)
       
    1: def ll_fz_xml_find_next_dfs_top(item, tag, att, match, top):
           r"""
           Low-level wrapper for `::fz_xml_find_next_dfs_top()`.
           Perform a depth first search onwards from item, returning the first
           child that matches the given tag (or any tag if tag is NULL),
           with the given attribute (if att is non NULL), that matches
           match (if match is non NULL). The search stops if it ever reaches
           the top of the tree, or the declared 'top' item.
           """
>>>>>>     return _mupdf.ll_fz_xml_find_next_dfs_top(item, tag, att, match, top)
       
    1: def ll_fz_xml_find_next_match(item, tag, att, match):
           r"""
           Low-level wrapper for `::fz_xml_find_next_match()`.
           Search the siblings of XML nodes starting with the first sibling
           of item looking for the first with the given tag (or any tag if tag
           is NULL), and with a matching attribute.
       
           Return NULL if none found.
           """
>>>>>>     return _mupdf.ll_fz_xml_find_next_match(item, tag, att, match)
       
    1: def ll_fz_xml_is_tag(item, name):
           r"""
           Low-level wrapper for `::fz_xml_is_tag()`.
           Return true if the tag name matches.
           """
>>>>>>     return _mupdf.ll_fz_xml_is_tag(item, name)
       
    1: def ll_fz_xml_next(item):
           r"""
           Low-level wrapper for `::fz_xml_next()`.
           Return next sibling of XML node.
           """
>>>>>>     return _mupdf.ll_fz_xml_next(item)
       
    1: def ll_fz_xml_prev(item):
           r"""
           Low-level wrapper for `::fz_xml_prev()`.
           Return previous sibling of XML node.
           """
>>>>>>     return _mupdf.ll_fz_xml_prev(item)
       
    1: def ll_fz_xml_root(xml):
           r"""
           Low-level wrapper for `::fz_xml_root()`.
           Return the topmost XML node of a document.
           """
>>>>>>     return _mupdf.ll_fz_xml_root(xml)
       
    1: def ll_fz_xml_tag(item):
           r"""
           Low-level wrapper for `::fz_xml_tag()`.
           Return tag of XML node. Return NULL for text nodes.
           """
>>>>>>     return _mupdf.ll_fz_xml_tag(item)
       
    1: def ll_fz_xml_text(item):
           r"""
           Low-level wrapper for `::fz_xml_text()`.
           Return the text content of an XML node.
           Return NULL if the node is a tag.
           """
>>>>>>     return _mupdf.ll_fz_xml_text(item)
       
    1: def ll_fz_xml_up(item):
           r"""
           Low-level wrapper for `::fz_xml_up()`.
           Return parent of XML node.
           """
>>>>>>     return _mupdf.ll_fz_xml_up(item)
       
    1: def ll_pdf_abandon_operation(doc):
           r"""Low-level wrapper for `::pdf_abandon_operation()`."""
>>>>>>     return _mupdf.ll_pdf_abandon_operation(doc)
       
    1: def ll_pdf_access_alert_event(evt):
           r"""Low-level wrapper for `::pdf_access_alert_event()`."""
>>>>>>     return _mupdf.ll_pdf_access_alert_event(evt)
       
    1: def ll_pdf_access_exec_menu_item_event(evt):
           r"""Low-level wrapper for `::pdf_access_exec_menu_item_event()`."""
>>>>>>     return _mupdf.ll_pdf_access_exec_menu_item_event(evt)
       
    1: def ll_pdf_access_launch_url_event(evt):
           r"""Low-level wrapper for `::pdf_access_launch_url_event()`."""
>>>>>>     return _mupdf.ll_pdf_access_launch_url_event(evt)
       
    1: def ll_pdf_access_mail_doc_event(evt):
           r"""Low-level wrapper for `::pdf_access_mail_doc_event()`."""
>>>>>>     return _mupdf.ll_pdf_access_mail_doc_event(evt)
       
    1: def ll_pdf_add_annot_border_dash_item(annot, length):
           r"""Low-level wrapper for `::pdf_add_annot_border_dash_item()`."""
>>>>>>     return _mupdf.ll_pdf_add_annot_border_dash_item(annot, length)
       
    1: def ll_pdf_add_annot_ink_list(annot, n, stroke):
           r"""Low-level wrapper for `::pdf_add_annot_ink_list()`."""
>>>>>>     return _mupdf.ll_pdf_add_annot_ink_list(annot, n, stroke)
       
    1: def ll_pdf_add_annot_ink_list_stroke(annot):
           r"""Low-level wrapper for `::pdf_add_annot_ink_list_stroke()`."""
>>>>>>     return _mupdf.ll_pdf_add_annot_ink_list_stroke(annot)
       
    1: def ll_pdf_add_annot_ink_list_stroke_vertex(annot, p):
           r"""Low-level wrapper for `::pdf_add_annot_ink_list_stroke_vertex()`."""
>>>>>>     return _mupdf.ll_pdf_add_annot_ink_list_stroke_vertex(annot, p)
       
    1: def ll_pdf_add_annot_quad_point(annot, quad):
           r"""Low-level wrapper for `::pdf_add_annot_quad_point()`."""
>>>>>>     return _mupdf.ll_pdf_add_annot_quad_point(annot, quad)
       
    1: def ll_pdf_add_annot_vertex(annot, p):
           r"""Low-level wrapper for `::pdf_add_annot_vertex()`."""
>>>>>>     return _mupdf.ll_pdf_add_annot_vertex(annot, p)
       
    1: def ll_pdf_add_cid_font(doc, font):
           r"""Low-level wrapper for `::pdf_add_cid_font()`."""
>>>>>>     return _mupdf.ll_pdf_add_cid_font(doc, font)
       
    1: def ll_pdf_add_cjk_font(doc, font, script, wmode, serif):
           r"""Low-level wrapper for `::pdf_add_cjk_font()`."""
>>>>>>     return _mupdf.ll_pdf_add_cjk_font(doc, font, script, wmode, serif)
       
    1: def ll_pdf_add_codespace(cmap, low, high, n):
           r"""Low-level wrapper for `::pdf_add_codespace()`."""
>>>>>>     return _mupdf.ll_pdf_add_codespace(cmap, low, high, n)
       
    1: def ll_pdf_add_colorspace(doc, cs):
           r"""Low-level wrapper for `::pdf_add_colorspace()`."""
>>>>>>     return _mupdf.ll_pdf_add_colorspace(doc, cs)
       
    1: def ll_pdf_add_embedded_file(doc, filename, mimetype, contents, created, modified, add_checksum):
           r"""Low-level wrapper for `::pdf_add_embedded_file()`."""
>>>>>>     return _mupdf.ll_pdf_add_embedded_file(doc, filename, mimetype, contents, created, modified, add_checksum)
       
    1: def ll_pdf_add_hmtx(font, lo, hi, w):
           r"""Low-level wrapper for `::pdf_add_hmtx()`."""
>>>>>>     return _mupdf.ll_pdf_add_hmtx(font, lo, hi, w)
       
    1: def ll_pdf_add_image(doc, image):
           r"""Low-level wrapper for `::pdf_add_image()`."""
>>>>>>     return _mupdf.ll_pdf_add_image(doc, image)
       
    1: def ll_pdf_add_journal_fragment(doc, parent, copy, copy_stream, newobj):
           r"""Low-level wrapper for `::pdf_add_journal_fragment()`."""
>>>>>>     return _mupdf.ll_pdf_add_journal_fragment(doc, parent, copy, copy_stream, newobj)
       
    1: def ll_pdf_add_new_array(doc, initial):
           r"""Low-level wrapper for `::pdf_add_new_array()`."""
>>>>>>     return _mupdf.ll_pdf_add_new_array(doc, initial)
       
    1: def ll_pdf_add_new_dict(doc, initial):
           r"""Low-level wrapper for `::pdf_add_new_dict()`."""
>>>>>>     return _mupdf.ll_pdf_add_new_dict(doc, initial)
       
    1: def ll_pdf_add_object(doc, obj):
           r"""Low-level wrapper for `::pdf_add_object()`."""
>>>>>>     return _mupdf.ll_pdf_add_object(doc, obj)
       
    1: def ll_pdf_add_object_drop(doc, obj):
           r"""Low-level wrapper for `::pdf_add_object_drop()`."""
>>>>>>     return _mupdf.ll_pdf_add_object_drop(doc, obj)
       
    1: def ll_pdf_add_page(doc, mediabox, rotate, resources, contents):
           r"""Low-level wrapper for `::pdf_add_page()`."""
>>>>>>     return _mupdf.ll_pdf_add_page(doc, mediabox, rotate, resources, contents)
       
    1: def ll_pdf_add_simple_font(doc, font, encoding):
           r"""Low-level wrapper for `::pdf_add_simple_font()`."""
>>>>>>     return _mupdf.ll_pdf_add_simple_font(doc, font, encoding)
       
    1: def ll_pdf_add_stream(doc, buf, obj, compressed):
           r"""Low-level wrapper for `::pdf_add_stream()`."""
>>>>>>     return _mupdf.ll_pdf_add_stream(doc, buf, obj, compressed)
       
    1: def ll_pdf_add_substitute_font(doc, font):
           r"""Low-level wrapper for `::pdf_add_substitute_font()`."""
>>>>>>     return _mupdf.ll_pdf_add_substitute_font(doc, font)
       
    1: def ll_pdf_add_vmtx(font, lo, hi, x, y, w):
           r"""Low-level wrapper for `::pdf_add_vmtx()`."""
>>>>>>     return _mupdf.ll_pdf_add_vmtx(font, lo, hi, x, y, w)
       
    1: def ll_pdf_annot_MK_BC(annot, n, color):
           r"""
            Low-level wrapper for `::pdf_annot_MK_BC()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_annot_MK_BC(::pdf_annot *annot, float color[4])` => int n
           """
>>>>>>     return _mupdf.ll_pdf_annot_MK_BC(annot, n, color)
       
    1: def ll_pdf_annot_MK_BC_rgb(annot, rgb):
           r"""Low-level wrapper for `::pdf_annot_MK_BC_rgb()`."""
>>>>>>     return _mupdf.ll_pdf_annot_MK_BC_rgb(annot, rgb)
       
    1: def ll_pdf_annot_MK_BG(annot, n, color):
           r"""
            Low-level wrapper for `::pdf_annot_MK_BG()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_annot_MK_BG(::pdf_annot *annot, float color[4])` => int n
           """
>>>>>>     return _mupdf.ll_pdf_annot_MK_BG(annot, n, color)
       
    1: def ll_pdf_annot_MK_BG_rgb(annot, rgb):
           r"""Low-level wrapper for `::pdf_annot_MK_BG_rgb()`."""
>>>>>>     return _mupdf.ll_pdf_annot_MK_BG_rgb(annot, rgb)
       
    1: def ll_pdf_annot_active(annot):
           r"""Low-level wrapper for `::pdf_annot_active()`."""
>>>>>>     return _mupdf.ll_pdf_annot_active(annot)
       
    1: def ll_pdf_annot_ap(annot):
           r"""Low-level wrapper for `::pdf_annot_ap()`."""
>>>>>>     return _mupdf.ll_pdf_annot_ap(annot)
       
    1: def ll_pdf_annot_author(annot):
           r"""Low-level wrapper for `::pdf_annot_author()`."""
>>>>>>     return _mupdf.ll_pdf_annot_author(annot)
       
    1: def ll_pdf_annot_border(annot):
           r"""Low-level wrapper for `::pdf_annot_border()`."""
>>>>>>     return _mupdf.ll_pdf_annot_border(annot)
       
    1: def ll_pdf_annot_border_dash_count(annot):
           r"""Low-level wrapper for `::pdf_annot_border_dash_count()`."""
>>>>>>     return _mupdf.ll_pdf_annot_border_dash_count(annot)
       
    1: def ll_pdf_annot_border_dash_item(annot, i):
           r"""Low-level wrapper for `::pdf_annot_border_dash_item()`."""
>>>>>>     return _mupdf.ll_pdf_annot_border_dash_item(annot, i)
       
    1: def ll_pdf_annot_border_effect(annot):
           r"""Low-level wrapper for `::pdf_annot_border_effect()`."""
>>>>>>     return _mupdf.ll_pdf_annot_border_effect(annot)
       
    1: def ll_pdf_annot_border_effect_intensity(annot):
           r"""Low-level wrapper for `::pdf_annot_border_effect_intensity()`."""
>>>>>>     return _mupdf.ll_pdf_annot_border_effect_intensity(annot)
       
    1: def ll_pdf_annot_border_style(annot):
           r"""Low-level wrapper for `::pdf_annot_border_style()`."""
>>>>>>     return _mupdf.ll_pdf_annot_border_style(annot)
       
    1: def ll_pdf_annot_border_width(annot):
           r"""Low-level wrapper for `::pdf_annot_border_width()`."""
>>>>>>     return _mupdf.ll_pdf_annot_border_width(annot)
       
    1: def ll_pdf_annot_callout_line(annot, callout, n):
           r"""
            Low-level wrapper for `::pdf_annot_callout_line()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_annot_callout_line(::pdf_annot *annot, ::fz_point callout[3])` => int n
           """
>>>>>>     return _mupdf.ll_pdf_annot_callout_line(annot, callout, n)
       
    1: def ll_pdf_annot_callout_point(annot):
           r"""Low-level wrapper for `::pdf_annot_callout_point()`."""
>>>>>>     return _mupdf.ll_pdf_annot_callout_point(annot)
       
    1: def ll_pdf_annot_callout_style(annot):
           r"""Low-level wrapper for `::pdf_annot_callout_style()`."""
>>>>>>     return _mupdf.ll_pdf_annot_callout_style(annot)
       
    1: def ll_pdf_annot_color(annot, n, color):
           r"""
            Low-level wrapper for `::pdf_annot_color()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_annot_color(::pdf_annot *annot, float color[4])` => int n
           """
>>>>>>     return _mupdf.ll_pdf_annot_color(annot, n, color)
       
    1: def ll_pdf_annot_contents(annot):
           r"""Low-level wrapper for `::pdf_annot_contents()`."""
>>>>>>     return _mupdf.ll_pdf_annot_contents(annot)
       
    1: def ll_pdf_annot_creation_date(annot):
           r"""Low-level wrapper for `::pdf_annot_creation_date()`."""
>>>>>>     return _mupdf.ll_pdf_annot_creation_date(annot)
       
    1: def ll_pdf_annot_default_appearance(annot, font, size, n, color):
           r"""
            Low-level wrapper for `::pdf_annot_default_appearance()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_annot_default_appearance(::pdf_annot *annot, float color[4])` => `(const char *font, float size, int n)`
           """
>>>>>>     return _mupdf.ll_pdf_annot_default_appearance(annot, font, size, n, color)
       
    1: def ll_pdf_annot_default_appearance_unmapped(annot, font_name, font_name_len, size, n, color):
           r"""
            Low-level wrapper for `::pdf_annot_default_appearance_unmapped()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_annot_default_appearance_unmapped(::pdf_annot *annot, char *font_name, int font_name_len, float color[4])` => `(float size, int n)`
           """
>>>>>>     return _mupdf.ll_pdf_annot_default_appearance_unmapped(annot, font_name, font_name_len, size, n, color)
       
    1: def ll_pdf_annot_ensure_local_xref(annot):
           r"""Low-level wrapper for `::pdf_annot_ensure_local_xref()`."""
>>>>>>     return _mupdf.ll_pdf_annot_ensure_local_xref(annot)
       
    1: def ll_pdf_annot_event_blur(annot):
           r"""Low-level wrapper for `::pdf_annot_event_blur()`."""
>>>>>>     return _mupdf.ll_pdf_annot_event_blur(annot)
       
    1: def ll_pdf_annot_event_down(annot):
           r"""Low-level wrapper for `::pdf_annot_event_down()`."""
>>>>>>     return _mupdf.ll_pdf_annot_event_down(annot)
       
    1: def ll_pdf_annot_event_enter(annot):
           r"""Low-level wrapper for `::pdf_annot_event_enter()`."""
>>>>>>     return _mupdf.ll_pdf_annot_event_enter(annot)
       
    1: def ll_pdf_annot_event_exit(annot):
           r"""Low-level wrapper for `::pdf_annot_event_exit()`."""
>>>>>>     return _mupdf.ll_pdf_annot_event_exit(annot)
       
    1: def ll_pdf_annot_event_focus(annot):
           r"""Low-level wrapper for `::pdf_annot_event_focus()`."""
>>>>>>     return _mupdf.ll_pdf_annot_event_focus(annot)
       
    1: def ll_pdf_annot_event_page_close(annot):
           r"""Low-level wrapper for `::pdf_annot_event_page_close()`."""
>>>>>>     return _mupdf.ll_pdf_annot_event_page_close(annot)
       
    1: def ll_pdf_annot_event_page_invisible(annot):
           r"""Low-level wrapper for `::pdf_annot_event_page_invisible()`."""
>>>>>>     return _mupdf.ll_pdf_annot_event_page_invisible(annot)
       
    1: def ll_pdf_annot_event_page_open(annot):
           r"""Low-level wrapper for `::pdf_annot_event_page_open()`."""
>>>>>>     return _mupdf.ll_pdf_annot_event_page_open(annot)
       
    1: def ll_pdf_annot_event_page_visible(annot):
           r"""Low-level wrapper for `::pdf_annot_event_page_visible()`."""
>>>>>>     return _mupdf.ll_pdf_annot_event_page_visible(annot)
       
    1: def ll_pdf_annot_event_up(annot):
           r"""Low-level wrapper for `::pdf_annot_event_up()`."""
>>>>>>     return _mupdf.ll_pdf_annot_event_up(annot)
       
    1: def ll_pdf_annot_field_event_keystroke(doc, annot, evt):
           r"""Low-level wrapper for `::pdf_annot_field_event_keystroke()`."""
>>>>>>     return _mupdf.ll_pdf_annot_field_event_keystroke(doc, annot, evt)
       
    1: def ll_pdf_annot_field_flags(annot):
           r"""Low-level wrapper for `::pdf_annot_field_flags()`."""
>>>>>>     return _mupdf.ll_pdf_annot_field_flags(annot)
       
    1: def ll_pdf_annot_field_label(widget):
           r"""Low-level wrapper for `::pdf_annot_field_label()`."""
>>>>>>     return _mupdf.ll_pdf_annot_field_label(widget)
       
    1: def ll_pdf_annot_field_value(annot):
           r"""Low-level wrapper for `::pdf_annot_field_value()`."""
>>>>>>     return _mupdf.ll_pdf_annot_field_value(annot)
       
    1: def ll_pdf_annot_filespec(annot):
           r"""Low-level wrapper for `::pdf_annot_filespec()`."""
>>>>>>     return _mupdf.ll_pdf_annot_filespec(annot)
       
    1: def ll_pdf_annot_flags(annot):
           r"""Low-level wrapper for `::pdf_annot_flags()`."""
>>>>>>     return _mupdf.ll_pdf_annot_flags(annot)
       
    1: def ll_pdf_annot_has_author(annot):
           r"""Low-level wrapper for `::pdf_annot_has_author()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_author(annot)
       
    1: def ll_pdf_annot_has_border(annot):
           r"""Low-level wrapper for `::pdf_annot_has_border()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_border(annot)
       
    1: def ll_pdf_annot_has_border_effect(annot):
           r"""Low-level wrapper for `::pdf_annot_has_border_effect()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_border_effect(annot)
       
    1: def ll_pdf_annot_has_callout(annot):
           r"""Low-level wrapper for `::pdf_annot_has_callout()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_callout(annot)
       
    1: def ll_pdf_annot_has_default_appearance(annot):
           r"""Low-level wrapper for `::pdf_annot_has_default_appearance()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_default_appearance(annot)
       
    1: def ll_pdf_annot_has_filespec(annot):
           r"""Low-level wrapper for `::pdf_annot_has_filespec()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_filespec(annot)
       
    1: def ll_pdf_annot_has_icon_name(annot):
           r"""Low-level wrapper for `::pdf_annot_has_icon_name()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_icon_name(annot)
       
    1: def ll_pdf_annot_has_ink_list(annot):
           r"""Low-level wrapper for `::pdf_annot_has_ink_list()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_ink_list(annot)
       
    1: def ll_pdf_annot_has_intent(annot):
           r"""Low-level wrapper for `::pdf_annot_has_intent()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_intent(annot)
       
    1: def ll_pdf_annot_has_interior_color(annot):
           r"""Low-level wrapper for `::pdf_annot_has_interior_color()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_interior_color(annot)
       
    1: def ll_pdf_annot_has_line(annot):
           r"""Low-level wrapper for `::pdf_annot_has_line()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_line(annot)
       
    1: def ll_pdf_annot_has_line_ending_styles(annot):
           r"""Low-level wrapper for `::pdf_annot_has_line_ending_styles()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_line_ending_styles(annot)
       
    1: def ll_pdf_annot_has_open(annot):
           r"""Low-level wrapper for `::pdf_annot_has_open()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_open(annot)
       
    1: def ll_pdf_annot_has_popup(annot):
           r"""Low-level wrapper for `::pdf_annot_has_popup()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_popup(annot)
       
    1: def ll_pdf_annot_has_quad_points(annot):
           r"""Low-level wrapper for `::pdf_annot_has_quad_points()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_quad_points(annot)
       
    1: def ll_pdf_annot_has_quadding(annot):
           r"""Low-level wrapper for `::pdf_annot_has_quadding()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_quadding(annot)
       
    1: def ll_pdf_annot_has_rect(annot):
           r"""Low-level wrapper for `::pdf_annot_has_rect()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_rect(annot)
       
    1: def ll_pdf_annot_has_rich_contents(annot):
           r"""Low-level wrapper for `::pdf_annot_has_rich_contents()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_rich_contents(annot)
       
    1: def ll_pdf_annot_has_rich_defaults(annot):
           r"""Low-level wrapper for `::pdf_annot_has_rich_defaults()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_rich_defaults(annot)
       
    1: def ll_pdf_annot_has_vertices(annot):
           r"""Low-level wrapper for `::pdf_annot_has_vertices()`."""
>>>>>>     return _mupdf.ll_pdf_annot_has_vertices(annot)
       
    1: def ll_pdf_annot_hidden_for_editing(annot):
           r"""Low-level wrapper for `::pdf_annot_hidden_for_editing()`."""
>>>>>>     return _mupdf.ll_pdf_annot_hidden_for_editing(annot)
       
    1: def ll_pdf_annot_hot(annot):
           r"""Low-level wrapper for `::pdf_annot_hot()`."""
>>>>>>     return _mupdf.ll_pdf_annot_hot(annot)
       
    1: def ll_pdf_annot_icon_name(annot):
           r"""Low-level wrapper for `::pdf_annot_icon_name()`."""
>>>>>>     return _mupdf.ll_pdf_annot_icon_name(annot)
       
    1: def ll_pdf_annot_ink_list_count(annot):
           r"""Low-level wrapper for `::pdf_annot_ink_list_count()`."""
>>>>>>     return _mupdf.ll_pdf_annot_ink_list_count(annot)
       
    1: def ll_pdf_annot_ink_list_stroke_count(annot, i):
           r"""Low-level wrapper for `::pdf_annot_ink_list_stroke_count()`."""
>>>>>>     return _mupdf.ll_pdf_annot_ink_list_stroke_count(annot, i)
       
    1: def ll_pdf_annot_ink_list_stroke_vertex(annot, i, k):
           r"""Low-level wrapper for `::pdf_annot_ink_list_stroke_vertex()`."""
>>>>>>     return _mupdf.ll_pdf_annot_ink_list_stroke_vertex(annot, i, k)
       
    1: def ll_pdf_annot_intent(annot):
           r"""Low-level wrapper for `::pdf_annot_intent()`."""
>>>>>>     return _mupdf.ll_pdf_annot_intent(annot)
       
    1: def ll_pdf_annot_interior_color(annot, n, color):
           r"""
            Low-level wrapper for `::pdf_annot_interior_color()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_annot_interior_color(::pdf_annot *annot, float color[4])` => int n
           """
>>>>>>     return _mupdf.ll_pdf_annot_interior_color(annot, n, color)
       
    1: def ll_pdf_annot_is_open(annot):
           r"""Low-level wrapper for `::pdf_annot_is_open()`."""
>>>>>>     return _mupdf.ll_pdf_annot_is_open(annot)
       
    1: def ll_pdf_annot_is_standard_stamp(annot):
           r"""Low-level wrapper for `::pdf_annot_is_standard_stamp()`."""
>>>>>>     return _mupdf.ll_pdf_annot_is_standard_stamp(annot)
       
    1: def ll_pdf_annot_language(annot):
           r"""Low-level wrapper for `::pdf_annot_language()`."""
>>>>>>     return _mupdf.ll_pdf_annot_language(annot)
       
    1: def ll_pdf_annot_line(annot, a, b):
           r"""Low-level wrapper for `::pdf_annot_line()`."""
>>>>>>     return _mupdf.ll_pdf_annot_line(annot, a, b)
       
    1: def ll_pdf_annot_line_caption(annot):
           r"""Low-level wrapper for `::pdf_annot_line_caption()`."""
>>>>>>     return _mupdf.ll_pdf_annot_line_caption(annot)
       
    1: def ll_pdf_annot_line_caption_offset(annot):
           r"""Low-level wrapper for `::pdf_annot_line_caption_offset()`."""
>>>>>>     return _mupdf.ll_pdf_annot_line_caption_offset(annot)
       
    1: def ll_pdf_annot_line_end_style(annot):
           r"""Low-level wrapper for `::pdf_annot_line_end_style()`."""
>>>>>>     return _mupdf.ll_pdf_annot_line_end_style(annot)
       
    1: def ll_pdf_annot_line_ending_styles(annot, start_style, end_style):
           r"""
            Low-level wrapper for `::pdf_annot_line_ending_styles()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_annot_line_ending_styles(::pdf_annot *annot)` => `(enum pdf_line_ending start_style, enum pdf_line_ending end_style)`
           """
>>>>>>     return _mupdf.ll_pdf_annot_line_ending_styles(annot, start_style, end_style)
       
    1: def ll_pdf_annot_line_leader(annot):
           r"""Low-level wrapper for `::pdf_annot_line_leader()`."""
>>>>>>     return _mupdf.ll_pdf_annot_line_leader(annot)
       
    1: def ll_pdf_annot_line_leader_extension(annot):
           r"""Low-level wrapper for `::pdf_annot_line_leader_extension()`."""
>>>>>>     return _mupdf.ll_pdf_annot_line_leader_extension(annot)
       
    1: def ll_pdf_annot_line_leader_offset(annot):
           r"""Low-level wrapper for `::pdf_annot_line_leader_offset()`."""
>>>>>>     return _mupdf.ll_pdf_annot_line_leader_offset(annot)
       
    1: def ll_pdf_annot_line_start_style(annot):
           r"""Low-level wrapper for `::pdf_annot_line_start_style()`."""
>>>>>>     return _mupdf.ll_pdf_annot_line_start_style(annot)
       
    1: def ll_pdf_annot_modification_date(annot):
           r"""Low-level wrapper for `::pdf_annot_modification_date()`."""
>>>>>>     return _mupdf.ll_pdf_annot_modification_date(annot)
       
    1: def ll_pdf_annot_needs_resynthesis(annot):
           r"""Low-level wrapper for `::pdf_annot_needs_resynthesis()`."""
>>>>>>     return _mupdf.ll_pdf_annot_needs_resynthesis(annot)
       
    1: def ll_pdf_annot_obj(annot):
           r"""Low-level wrapper for `::pdf_annot_obj()`."""
>>>>>>     return _mupdf.ll_pdf_annot_obj(annot)
       
    1: def ll_pdf_annot_opacity(annot):
           r"""Low-level wrapper for `::pdf_annot_opacity()`."""
>>>>>>     return _mupdf.ll_pdf_annot_opacity(annot)
       
    1: def ll_pdf_annot_page(annot):
           r"""Low-level wrapper for `::pdf_annot_page()`."""
>>>>>>     return _mupdf.ll_pdf_annot_page(annot)
       
    1: def ll_pdf_annot_pop_and_discard_local_xref(annot):
           r"""Low-level wrapper for `::pdf_annot_pop_and_discard_local_xref()`."""
>>>>>>     return _mupdf.ll_pdf_annot_pop_and_discard_local_xref(annot)
       
    1: def ll_pdf_annot_pop_local_xref(annot):
           r"""Low-level wrapper for `::pdf_annot_pop_local_xref()`."""
>>>>>>     return _mupdf.ll_pdf_annot_pop_local_xref(annot)
       
    1: def ll_pdf_annot_popup(annot):
           r"""Low-level wrapper for `::pdf_annot_popup()`."""
>>>>>>     return _mupdf.ll_pdf_annot_popup(annot)
       
    1: def ll_pdf_annot_push_local_xref(annot):
           r"""Low-level wrapper for `::pdf_annot_push_local_xref()`."""
>>>>>>     return _mupdf.ll_pdf_annot_push_local_xref(annot)
       
    1: def ll_pdf_annot_quad_point(annot, i):
           r"""Low-level wrapper for `::pdf_annot_quad_point()`."""
>>>>>>     return _mupdf.ll_pdf_annot_quad_point(annot, i)
       
    1: def ll_pdf_annot_quad_point_count(annot):
           r"""Low-level wrapper for `::pdf_annot_quad_point_count()`."""
>>>>>>     return _mupdf.ll_pdf_annot_quad_point_count(annot)
       
    1: def ll_pdf_annot_quadding(annot):
           r"""Low-level wrapper for `::pdf_annot_quadding()`."""
>>>>>>     return _mupdf.ll_pdf_annot_quadding(annot)
       
    1: def ll_pdf_annot_rect(annot):
           r"""Low-level wrapper for `::pdf_annot_rect()`."""
>>>>>>     return _mupdf.ll_pdf_annot_rect(annot)
       
    1: def ll_pdf_annot_request_resynthesis(annot):
           r"""Low-level wrapper for `::pdf_annot_request_resynthesis()`."""
>>>>>>     return _mupdf.ll_pdf_annot_request_resynthesis(annot)
       
    1: def ll_pdf_annot_request_synthesis(annot):
           r"""Low-level wrapper for `::pdf_annot_request_synthesis()`."""
>>>>>>     return _mupdf.ll_pdf_annot_request_synthesis(annot)
       
    1: def ll_pdf_annot_rich_contents(annot):
           r"""Low-level wrapper for `::pdf_annot_rich_contents()`."""
>>>>>>     return _mupdf.ll_pdf_annot_rich_contents(annot)
       
    1: def ll_pdf_annot_rich_defaults(annot):
           r"""Low-level wrapper for `::pdf_annot_rich_defaults()`."""
>>>>>>     return _mupdf.ll_pdf_annot_rich_defaults(annot)
       
    1: def ll_pdf_annot_stamp_image_obj(annot):
           r"""Low-level wrapper for `::pdf_annot_stamp_image_obj()`."""
>>>>>>     return _mupdf.ll_pdf_annot_stamp_image_obj(annot)
       
    1: def ll_pdf_annot_transform(annot):
           r"""Low-level wrapper for `::pdf_annot_transform()`."""
>>>>>>     return _mupdf.ll_pdf_annot_transform(annot)
       
    1: def ll_pdf_annot_type(annot):
           r"""Low-level wrapper for `::pdf_annot_type()`."""
>>>>>>     return _mupdf.ll_pdf_annot_type(annot)
       
    1: def ll_pdf_annot_type_from_string(subtype):
           r"""Low-level wrapper for `::pdf_annot_type_from_string()`."""
>>>>>>     return _mupdf.ll_pdf_annot_type_from_string(subtype)
       
    1: def ll_pdf_annot_vertex(annot, i):
           r"""Low-level wrapper for `::pdf_annot_vertex()`."""
>>>>>>     return _mupdf.ll_pdf_annot_vertex(annot, i)
       
    1: def ll_pdf_annot_vertex_count(annot):
           r"""Low-level wrapper for `::pdf_annot_vertex_count()`."""
>>>>>>     return _mupdf.ll_pdf_annot_vertex_count(annot)
       
    1: def ll_pdf_append_explicit_dest_to_uri(url, dest):
           r"""Low-level wrapper for `::pdf_append_explicit_dest_to_uri()`."""
>>>>>>     return _mupdf.ll_pdf_append_explicit_dest_to_uri(url, dest)
       
    1: def ll_pdf_append_named_dest_to_uri(url, name):
           r"""Low-level wrapper for `::pdf_append_named_dest_to_uri()`."""
>>>>>>     return _mupdf.ll_pdf_append_named_dest_to_uri(url, name)
       
    1: def ll_pdf_append_token(buf, tok, lex):
           r"""Low-level wrapper for `::pdf_append_token()`."""
>>>>>>     return _mupdf.ll_pdf_append_token(buf, tok, lex)
       
    1: def ll_pdf_apply_redaction(annot, opts):
           r"""Low-level wrapper for `::pdf_apply_redaction()`."""
>>>>>>     return _mupdf.ll_pdf_apply_redaction(annot, opts)
       
    1: def ll_pdf_array_contains(array, obj):
           r"""Low-level wrapper for `::pdf_array_contains()`."""
>>>>>>     return _mupdf.ll_pdf_array_contains(array, obj)
       
    1: def ll_pdf_array_delete(array, index):
           r"""Low-level wrapper for `::pdf_array_delete()`."""
>>>>>>     return _mupdf.ll_pdf_array_delete(array, index)
       
    1: def ll_pdf_array_find(array, obj):
           r"""Low-level wrapper for `::pdf_array_find()`."""
>>>>>>     return _mupdf.ll_pdf_array_find(array, obj)
       
    1: def ll_pdf_array_get(array, i):
           r"""Low-level wrapper for `::pdf_array_get()`."""
>>>>>>     return _mupdf.ll_pdf_array_get(array, i)
       
    1: def ll_pdf_array_get_bool(array, index):
           r"""Low-level wrapper for `::pdf_array_get_bool()`."""
>>>>>>     return _mupdf.ll_pdf_array_get_bool(array, index)
       
    1: def ll_pdf_array_get_int(array, index):
           r"""Low-level wrapper for `::pdf_array_get_int()`."""
>>>>>>     return _mupdf.ll_pdf_array_get_int(array, index)
       
    1: def ll_pdf_array_get_matrix(array, index):
           r"""Low-level wrapper for `::pdf_array_get_matrix()`."""
>>>>>>     return _mupdf.ll_pdf_array_get_matrix(array, index)
       
    1: def ll_pdf_array_get_name(array, index):
           r"""Low-level wrapper for `::pdf_array_get_name()`."""
>>>>>>     return _mupdf.ll_pdf_array_get_name(array, index)
       
    1: def ll_pdf_array_get_real(array, index):
           r"""Low-level wrapper for `::pdf_array_get_real()`."""
>>>>>>     return _mupdf.ll_pdf_array_get_real(array, index)
       
    1: def ll_pdf_array_get_rect(array, index):
           r"""Low-level wrapper for `::pdf_array_get_rect()`."""
>>>>>>     return _mupdf.ll_pdf_array_get_rect(array, index)
       
    1: def ll_pdf_array_get_string(array, index, sizep):
           r"""
            Low-level wrapper for `::pdf_array_get_string()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_array_get_string(::pdf_obj *array, int index)` => `(const char *, size_t sizep)`
           """
>>>>>>     return _mupdf.ll_pdf_array_get_string(array, index, sizep)
       
    1: def ll_pdf_array_get_text_string(array, index):
           r"""Low-level wrapper for `::pdf_array_get_text_string()`."""
>>>>>>     return _mupdf.ll_pdf_array_get_text_string(array, index)
       
    1: def ll_pdf_array_insert(array, obj, index):
           r"""Low-level wrapper for `::pdf_array_insert()`."""
>>>>>>     return _mupdf.ll_pdf_array_insert(array, obj, index)
       
    1: def ll_pdf_array_insert_drop(array, obj, index):
           r"""Low-level wrapper for `::pdf_array_insert_drop()`."""
>>>>>>     return _mupdf.ll_pdf_array_insert_drop(array, obj, index)
       
    1: def ll_pdf_array_len(array):
           r"""Low-level wrapper for `::pdf_array_len()`."""
>>>>>>     return _mupdf.ll_pdf_array_len(array)
       
    1: def ll_pdf_array_push(array, obj):
           r"""Low-level wrapper for `::pdf_array_push()`."""
>>>>>>     return _mupdf.ll_pdf_array_push(array, obj)
       
    1: def ll_pdf_array_push_array(array, initial):
           r"""Low-level wrapper for `::pdf_array_push_array()`."""
>>>>>>     return _mupdf.ll_pdf_array_push_array(array, initial)
       
    1: def ll_pdf_array_push_bool(array, x):
           r"""Low-level wrapper for `::pdf_array_push_bool()`."""
>>>>>>     return _mupdf.ll_pdf_array_push_bool(array, x)
       
    1: def ll_pdf_array_push_dict(array, initial):
           r"""Low-level wrapper for `::pdf_array_push_dict()`."""
>>>>>>     return _mupdf.ll_pdf_array_push_dict(array, initial)
       
    1: def ll_pdf_array_push_drop(array, obj):
           r"""Low-level wrapper for `::pdf_array_push_drop()`."""
>>>>>>     return _mupdf.ll_pdf_array_push_drop(array, obj)
       
    1: def ll_pdf_array_push_int(array, x):
           r"""Low-level wrapper for `::pdf_array_push_int()`."""
>>>>>>     return _mupdf.ll_pdf_array_push_int(array, x)
       
    1: def ll_pdf_array_push_name(array, x):
           r"""Low-level wrapper for `::pdf_array_push_name()`."""
>>>>>>     return _mupdf.ll_pdf_array_push_name(array, x)
       
    1: def ll_pdf_array_push_real(array, x):
           r"""Low-level wrapper for `::pdf_array_push_real()`."""
>>>>>>     return _mupdf.ll_pdf_array_push_real(array, x)
       
    1: def ll_pdf_array_push_string(array, x, n):
           r"""Low-level wrapper for `::pdf_array_push_string()`."""
>>>>>>     return _mupdf.ll_pdf_array_push_string(array, x, n)
       
    1: def ll_pdf_array_push_text_string(array, x):
           r"""Low-level wrapper for `::pdf_array_push_text_string()`."""
>>>>>>     return _mupdf.ll_pdf_array_push_text_string(array, x)
       
    1: def ll_pdf_array_put(array, i, obj):
           r"""Low-level wrapper for `::pdf_array_put()`."""
>>>>>>     return _mupdf.ll_pdf_array_put(array, i, obj)
       
    1: def ll_pdf_array_put_array(array, i, initial):
           r"""Low-level wrapper for `::pdf_array_put_array()`."""
>>>>>>     return _mupdf.ll_pdf_array_put_array(array, i, initial)
       
    1: def ll_pdf_array_put_bool(array, i, x):
           r"""Low-level wrapper for `::pdf_array_put_bool()`."""
>>>>>>     return _mupdf.ll_pdf_array_put_bool(array, i, x)
       
    1: def ll_pdf_array_put_dict(array, i, initial):
           r"""Low-level wrapper for `::pdf_array_put_dict()`."""
>>>>>>     return _mupdf.ll_pdf_array_put_dict(array, i, initial)
       
    1: def ll_pdf_array_put_drop(array, i, obj):
           r"""Low-level wrapper for `::pdf_array_put_drop()`."""
>>>>>>     return _mupdf.ll_pdf_array_put_drop(array, i, obj)
       
    1: def ll_pdf_array_put_int(array, i, x):
           r"""Low-level wrapper for `::pdf_array_put_int()`."""
>>>>>>     return _mupdf.ll_pdf_array_put_int(array, i, x)
       
    1: def ll_pdf_array_put_name(array, i, x):
           r"""Low-level wrapper for `::pdf_array_put_name()`."""
>>>>>>     return _mupdf.ll_pdf_array_put_name(array, i, x)
       
    1: def ll_pdf_array_put_real(array, i, x):
           r"""Low-level wrapper for `::pdf_array_put_real()`."""
>>>>>>     return _mupdf.ll_pdf_array_put_real(array, i, x)
       
    1: def ll_pdf_array_put_string(array, i, x, n):
           r"""Low-level wrapper for `::pdf_array_put_string()`."""
>>>>>>     return _mupdf.ll_pdf_array_put_string(array, i, x, n)
       
    1: def ll_pdf_array_put_text_string(array, i, x):
           r"""Low-level wrapper for `::pdf_array_put_text_string()`."""
>>>>>>     return _mupdf.ll_pdf_array_put_text_string(array, i, x)
       
    1: def ll_pdf_authenticate_password(doc, pw):
           r"""Low-level wrapper for `::pdf_authenticate_password()`."""
>>>>>>     return _mupdf.ll_pdf_authenticate_password(doc, pw)
       
    1: def ll_pdf_bake_document(doc, bake_annots, bake_widgets):
           r"""Low-level wrapper for `::pdf_bake_document()`."""
>>>>>>     return _mupdf.ll_pdf_bake_document(doc, bake_annots, bake_widgets)
       
    1: def ll_pdf_begin_implicit_operation(doc):
           r"""Low-level wrapper for `::pdf_begin_implicit_operation()`."""
>>>>>>     return _mupdf.ll_pdf_begin_implicit_operation(doc)
       
    1: def ll_pdf_begin_operation(doc, operation):
           r"""Low-level wrapper for `::pdf_begin_operation()`."""
>>>>>>     return _mupdf.ll_pdf_begin_operation(doc, operation)
       
    1: def ll_pdf_bound_annot(annot):
           r"""Low-level wrapper for `::pdf_bound_annot()`."""
>>>>>>     return _mupdf.ll_pdf_bound_annot(annot)
       
    1: def ll_pdf_bound_page(page, box):
           r"""Low-level wrapper for `::pdf_bound_page()`."""
>>>>>>     return _mupdf.ll_pdf_bound_page(page, box)
       
    1: def ll_pdf_bound_widget(widget):
           r"""Low-level wrapper for `::pdf_bound_widget()`."""
>>>>>>     return _mupdf.ll_pdf_bound_widget(widget)
       
    1: def ll_pdf_button_field_on_state(field):
           r"""Low-level wrapper for `::pdf_button_field_on_state()`."""
>>>>>>     return _mupdf.ll_pdf_button_field_on_state(field)
       
    1: def ll_pdf_cache_object(doc, num):
           r"""
           Low-level wrapper for `::pdf_cache_object()`.
           Retrieve the pdf_xref_entry for a given object.
       
           This can cause xref reorganisations (solidifications etc) due to
           repairs, so all held pdf_xref_entries should be considered
           invalid after this call (other than the returned one).
           """
>>>>>>     return _mupdf.ll_pdf_cache_object(doc, num)
       
    1: def ll_pdf_calculate_form(doc):
           r"""Low-level wrapper for `::pdf_calculate_form()`."""
>>>>>>     return _mupdf.ll_pdf_calculate_form(doc)
       
    1: def ll_pdf_can_be_saved_incrementally(doc):
           r"""Low-level wrapper for `::pdf_can_be_saved_incrementally()`."""
>>>>>>     return _mupdf.ll_pdf_can_be_saved_incrementally(doc)
       
    1: def ll_pdf_can_redo(doc):
           r"""Low-level wrapper for `::pdf_can_redo()`."""
>>>>>>     return _mupdf.ll_pdf_can_redo(doc)
       
    1: def ll_pdf_can_undo(doc):
           r"""Low-level wrapper for `::pdf_can_undo()`."""
>>>>>>     return _mupdf.ll_pdf_can_undo(doc)
       
    1: def ll_pdf_check_certificate(verifier, doc, signature):
           r"""Low-level wrapper for `::pdf_check_certificate()`."""
>>>>>>     return _mupdf.ll_pdf_check_certificate(verifier, doc, signature)
       
    1: def ll_pdf_check_digest(verifier, doc, signature):
           r"""Low-level wrapper for `::pdf_check_digest()`."""
>>>>>>     return _mupdf.ll_pdf_check_digest(verifier, doc, signature)
       
    1: def ll_pdf_check_widget_certificate(verifier, widget):
           r"""Low-level wrapper for `::pdf_check_widget_certificate()`."""
>>>>>>     return _mupdf.ll_pdf_check_widget_certificate(verifier, widget)
       
    1: def ll_pdf_check_widget_digest(verifier, widget):
           r"""Low-level wrapper for `::pdf_check_widget_digest()`."""
>>>>>>     return _mupdf.ll_pdf_check_widget_digest(verifier, widget)
       
    1: def ll_pdf_choice_field_option(field, exportval, i):
           r"""Low-level wrapper for `::pdf_choice_field_option()`."""
>>>>>>     return _mupdf.ll_pdf_choice_field_option(field, exportval, i)
       
    1: def ll_pdf_choice_field_option_count(field):
           r"""Low-level wrapper for `::pdf_choice_field_option_count()`."""
>>>>>>     return _mupdf.ll_pdf_choice_field_option_count(field)
       
    1: def ll_pdf_choice_widget_is_multiselect(tw):
           r"""Low-level wrapper for `::pdf_choice_widget_is_multiselect()`."""
>>>>>>     return _mupdf.ll_pdf_choice_widget_is_multiselect(tw)
       
    1: def ll_pdf_choice_widget_options(tw, exportval, opts):
           r"""Low-level wrapper for `::pdf_choice_widget_options()`."""
>>>>>>     return _mupdf.ll_pdf_choice_widget_options(tw, exportval, opts)
       
    1: def ll_pdf_choice_widget_options2(tw, exportval):
           r"""
            Low-level wrapper for `::pdf_choice_widget_options2()`.  Swig-friendly wrapper for pdf_choice_widget_options(), returns the
           options directly in a vector.
           """
>>>>>>     return _mupdf.ll_pdf_choice_widget_options2(tw, exportval)
       
    1: def ll_pdf_choice_widget_set_value(tw, n, opts):
           r"""Low-level wrapper for `::pdf_choice_widget_set_value()`."""
>>>>>>     return _mupdf.ll_pdf_choice_widget_set_value(tw, n, opts)
       
    1: def ll_pdf_choice_widget_value(tw, opts):
           r"""Low-level wrapper for `::pdf_choice_widget_value()`."""
>>>>>>     return _mupdf.ll_pdf_choice_widget_value(tw, opts)
       
    1: def ll_pdf_clean_file(infile, outfile, password, opts, retainlen):
           r"""Low-level wrapper for `::pdf_clean_file()`."""
>>>>>>     return _mupdf.ll_pdf_clean_file(infile, outfile, password, opts, retainlen)
       
    1: def ll_pdf_clean_font_name(fontname):
           r"""Low-level wrapper for `::pdf_clean_font_name()`."""
>>>>>>     return _mupdf.ll_pdf_clean_font_name(fontname)
       
    1: def ll_pdf_clean_obj(obj):
           r"""Low-level wrapper for `::pdf_clean_obj()`."""
>>>>>>     return _mupdf.ll_pdf_clean_obj(obj)
       
    1: def ll_pdf_clear_annot_border_dash(annot):
           r"""Low-level wrapper for `::pdf_clear_annot_border_dash()`."""
>>>>>>     return _mupdf.ll_pdf_clear_annot_border_dash(annot)
       
    1: def ll_pdf_clear_annot_ink_list(annot):
           r"""Low-level wrapper for `::pdf_clear_annot_ink_list()`."""
>>>>>>     return _mupdf.ll_pdf_clear_annot_ink_list(annot)
       
    1: def ll_pdf_clear_annot_quad_points(annot):
           r"""Low-level wrapper for `::pdf_clear_annot_quad_points()`."""
>>>>>>     return _mupdf.ll_pdf_clear_annot_quad_points(annot)
       
    1: def ll_pdf_clear_annot_vertices(annot):
           r"""Low-level wrapper for `::pdf_clear_annot_vertices()`."""
>>>>>>     return _mupdf.ll_pdf_clear_annot_vertices(annot)
       
    1: def ll_pdf_clear_signature(widget):
           r"""Low-level wrapper for `::pdf_clear_signature()`."""
>>>>>>     return _mupdf.ll_pdf_clear_signature(widget)
       
    1: def ll_pdf_clear_xref(doc):
           r"""Low-level wrapper for `::pdf_clear_xref()`."""
>>>>>>     return _mupdf.ll_pdf_clear_xref(doc)
       
    1: def ll_pdf_clear_xref_to_mark(doc):
           r"""Low-level wrapper for `::pdf_clear_xref_to_mark()`."""
>>>>>>     return _mupdf.ll_pdf_clear_xref_to_mark(doc)
       
    1: def ll_pdf_clip_page(page, clip):
           r"""Low-level wrapper for `::pdf_clip_page()`."""
>>>>>>     return _mupdf.ll_pdf_clip_page(page, clip)
       
    1: def ll_pdf_close_processor(proc):
           r"""Low-level wrapper for `::pdf_close_processor()`."""
>>>>>>     return _mupdf.ll_pdf_close_processor(proc)
       
    1: def ll_pdf_cmap_size(cmap):
           r"""Low-level wrapper for `::pdf_cmap_size()`."""
>>>>>>     return _mupdf.ll_pdf_cmap_size(cmap)
       
    1: def ll_pdf_cmap_wmode(cmap):
           r"""Low-level wrapper for `::pdf_cmap_wmode()`."""
>>>>>>     return _mupdf.ll_pdf_cmap_wmode(cmap)
       
    1: def ll_pdf_copy_array(array):
           r"""Low-level wrapper for `::pdf_copy_array()`."""
>>>>>>     return _mupdf.ll_pdf_copy_array(array)
       
    1: def ll_pdf_copy_dict(dict):
           r"""Low-level wrapper for `::pdf_copy_dict()`."""
>>>>>>     return _mupdf.ll_pdf_copy_dict(dict)
       
    1: def ll_pdf_count_document_associated_files(doc):
           r"""Low-level wrapper for `::pdf_count_document_associated_files()`."""
>>>>>>     return _mupdf.ll_pdf_count_document_associated_files(doc)
       
    1: def ll_pdf_count_layer_config_ui(doc):
           r"""Low-level wrapper for `::pdf_count_layer_config_ui()`."""
>>>>>>     return _mupdf.ll_pdf_count_layer_config_ui(doc)
       
    1: def ll_pdf_count_layer_configs(doc):
           r"""Low-level wrapper for `::pdf_count_layer_configs()`."""
>>>>>>     return _mupdf.ll_pdf_count_layer_configs(doc)
       
    1: def ll_pdf_count_layers(doc):
           r"""Low-level wrapper for `::pdf_count_layers()`."""
>>>>>>     return _mupdf.ll_pdf_count_layers(doc)
       
    1: def ll_pdf_count_objects(doc):
           r"""Low-level wrapper for `::pdf_count_objects()`."""
>>>>>>     return _mupdf.ll_pdf_count_objects(doc)
       
    1: def ll_pdf_count_page_associated_files(page):
           r"""Low-level wrapper for `::pdf_count_page_associated_files()`."""
>>>>>>     return _mupdf.ll_pdf_count_page_associated_files(page)
       
    1: def ll_pdf_count_pages(doc):
           r"""Low-level wrapper for `::pdf_count_pages()`."""
>>>>>>     return _mupdf.ll_pdf_count_pages(doc)
       
    1: def ll_pdf_count_pages_imp(doc, chapter):
           r"""Low-level wrapper for `::pdf_count_pages_imp()`."""
>>>>>>     return _mupdf.ll_pdf_count_pages_imp(doc, chapter)
       
    1: def ll_pdf_count_q_balance(doc, res, stm, prepend, append):
           r"""
            Low-level wrapper for `::pdf_count_q_balance()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_count_q_balance(::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm)` => `(int prepend, int append)`
           """
>>>>>>     return _mupdf.ll_pdf_count_q_balance(doc, res, stm, prepend, append)
       
    1: def ll_pdf_count_signatures(doc):
           r"""Low-level wrapper for `::pdf_count_signatures()`."""
>>>>>>     return _mupdf.ll_pdf_count_signatures(doc)
       
    1: def ll_pdf_count_unsaved_versions(doc):
           r"""Low-level wrapper for `::pdf_count_unsaved_versions()`."""
>>>>>>     return _mupdf.ll_pdf_count_unsaved_versions(doc)
       
    1: def ll_pdf_count_versions(doc):
           r"""Low-level wrapper for `::pdf_count_versions()`."""
>>>>>>     return _mupdf.ll_pdf_count_versions(doc)
       
    1: def ll_pdf_create_annot(page, type):
           r"""Low-level wrapper for `::pdf_create_annot()`."""
>>>>>>     return _mupdf.ll_pdf_create_annot(page, type)
       
    1: def ll_pdf_create_annot_raw(page, type):
           r"""Low-level wrapper for `::pdf_create_annot_raw()`."""
>>>>>>     return _mupdf.ll_pdf_create_annot_raw(page, type)
       
    1: def ll_pdf_create_document():
           r"""Low-level wrapper for `::pdf_create_document()`."""
>>>>>>     return _mupdf.ll_pdf_create_document()
       
    1: def ll_pdf_create_field_name(doc, prefix, buf, len):
           r"""Low-level wrapper for `::pdf_create_field_name()`."""
>>>>>>     return _mupdf.ll_pdf_create_field_name(doc, prefix, buf, len)
       
    1: def ll_pdf_create_link(page, bbox, uri):
           r"""Low-level wrapper for `::pdf_create_link()`."""
>>>>>>     return _mupdf.ll_pdf_create_link(page, bbox, uri)
       
    1: def ll_pdf_create_object(doc):
           r"""Low-level wrapper for `::pdf_create_object()`."""
>>>>>>     return _mupdf.ll_pdf_create_object(doc)
       
    1: def ll_pdf_create_signature_widget(page, name):
           r"""Low-level wrapper for `::pdf_create_signature_widget()`."""
>>>>>>     return _mupdf.ll_pdf_create_signature_widget(page, name)
       
    1: def ll_pdf_crypt_encrypt_metadata(crypt):
           r"""Low-level wrapper for `::pdf_crypt_encrypt_metadata()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_encrypt_metadata(crypt)
       
    1: def ll_pdf_crypt_key(crypt):
           r"""Low-level wrapper for `::pdf_crypt_key()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_key(crypt)
       
    1: def ll_pdf_crypt_length(crypt):
           r"""Low-level wrapper for `::pdf_crypt_length()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_length(crypt)
       
    1: def ll_pdf_crypt_method(crypt):
           r"""Low-level wrapper for `::pdf_crypt_method()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_method(crypt)
       
    1: def ll_pdf_crypt_obj(crypt, obj, num, gen):
           r"""Low-level wrapper for `::pdf_crypt_obj()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_obj(crypt, obj, num, gen)
       
    1: def ll_pdf_crypt_owner_encryption(crypt):
           r"""Low-level wrapper for `::pdf_crypt_owner_encryption()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_owner_encryption(crypt)
       
    1: def ll_pdf_crypt_owner_password(crypt):
           r"""Low-level wrapper for `::pdf_crypt_owner_password()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_owner_password(crypt)
       
    1: def ll_pdf_crypt_permissions(crypt):
           r"""Low-level wrapper for `::pdf_crypt_permissions()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_permissions(crypt)
       
    1: def ll_pdf_crypt_permissions_encryption(crypt):
           r"""Low-level wrapper for `::pdf_crypt_permissions_encryption()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_permissions_encryption(crypt)
       
    1: def ll_pdf_crypt_revision(crypt):
           r"""Low-level wrapper for `::pdf_crypt_revision()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_revision(crypt)
       
    1: def ll_pdf_crypt_stream_method(crypt):
           r"""Low-level wrapper for `::pdf_crypt_stream_method()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_stream_method(crypt)
       
    1: def ll_pdf_crypt_string_method(crypt):
           r"""Low-level wrapper for `::pdf_crypt_string_method()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_string_method(crypt)
       
    1: def ll_pdf_crypt_user_encryption(crypt):
           r"""Low-level wrapper for `::pdf_crypt_user_encryption()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_user_encryption(crypt)
       
    1: def ll_pdf_crypt_user_password(crypt):
           r"""Low-level wrapper for `::pdf_crypt_user_password()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_user_password(crypt)
       
    1: def ll_pdf_crypt_version(crypt):
           r"""Low-level wrapper for `::pdf_crypt_version()`."""
>>>>>>     return _mupdf.ll_pdf_crypt_version(crypt)
       
    1: def ll_pdf_cycle(here, prev, obj):
           r"""Low-level wrapper for `::pdf_cycle()`."""
>>>>>>     return _mupdf.ll_pdf_cycle(here, prev, obj)
       
    1: def ll_pdf_debug_doc_changes(doc):
           r"""Low-level wrapper for `::pdf_debug_doc_changes()`."""
>>>>>>     return _mupdf.ll_pdf_debug_doc_changes(doc)
       
    1: def ll_pdf_debug_obj(obj):
           r"""Low-level wrapper for `::pdf_debug_obj()`."""
>>>>>>     return _mupdf.ll_pdf_debug_obj(obj)
       
    1: def ll_pdf_debug_ref(obj):
           r"""Low-level wrapper for `::pdf_debug_ref()`."""
>>>>>>     return _mupdf.ll_pdf_debug_ref(obj)
       
    1: def ll_pdf_decode_cmap(cmap, s, e, cpt):
           r"""
            Low-level wrapper for `::pdf_decode_cmap()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_decode_cmap(::pdf_cmap *cmap, unsigned char *s, unsigned char *e)` => `(int, unsigned int cpt)`
           """
>>>>>>     return _mupdf.ll_pdf_decode_cmap(cmap, s, e, cpt)
       
    1: def ll_pdf_deep_copy_obj(obj):
           r"""Low-level wrapper for `::pdf_deep_copy_obj()`."""
>>>>>>     return _mupdf.ll_pdf_deep_copy_obj(obj)
       
    1: def ll_pdf_delete_annot(page, annot):
           r"""Low-level wrapper for `::pdf_delete_annot()`."""
>>>>>>     return _mupdf.ll_pdf_delete_annot(page, annot)
       
    1: def ll_pdf_delete_link(page, link):
           r"""Low-level wrapper for `::pdf_delete_link()`."""
>>>>>>     return _mupdf.ll_pdf_delete_link(page, link)
       
    1: def ll_pdf_delete_object(doc, num):
           r"""Low-level wrapper for `::pdf_delete_object()`."""
>>>>>>     return _mupdf.ll_pdf_delete_object(doc, num)
       
    1: def ll_pdf_delete_page(doc, number):
           r"""Low-level wrapper for `::pdf_delete_page()`."""
>>>>>>     return _mupdf.ll_pdf_delete_page(doc, number)
       
    1: def ll_pdf_delete_page_labels(doc, index):
           r"""Low-level wrapper for `::pdf_delete_page_labels()`."""
>>>>>>     return _mupdf.ll_pdf_delete_page_labels(doc, index)
       
    1: def ll_pdf_delete_page_range(doc, start, end):
           r"""Low-level wrapper for `::pdf_delete_page_range()`."""
>>>>>>     return _mupdf.ll_pdf_delete_page_range(doc, start, end)
       
    1: def ll_pdf_deselect_layer_config_ui(doc, ui):
           r"""Low-level wrapper for `::pdf_deselect_layer_config_ui()`."""
>>>>>>     return _mupdf.ll_pdf_deselect_layer_config_ui(doc, ui)
       
    1: def ll_pdf_deserialise_journal(doc, stm):
           r"""Low-level wrapper for `::pdf_deserialise_journal()`."""
>>>>>>     return _mupdf.ll_pdf_deserialise_journal(doc, stm)
       
    1: def ll_pdf_dict_del(dict, key):
           r"""Low-level wrapper for `::pdf_dict_del()`."""
>>>>>>     return _mupdf.ll_pdf_dict_del(dict, key)
       
    1: def ll_pdf_dict_dels(dict, key):
           r"""Low-level wrapper for `::pdf_dict_dels()`."""
>>>>>>     return _mupdf.ll_pdf_dict_dels(dict, key)
       
    1: def ll_pdf_dict_get(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get(dict, key)
       
    1: def ll_pdf_dict_get_bool(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_bool()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_bool(dict, key)
       
    1: def ll_pdf_dict_get_bool_default(dict, key, _def):
           r"""Low-level wrapper for `::pdf_dict_get_bool_default()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_bool_default(dict, key, _def)
       
    1: def ll_pdf_dict_get_date(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_date()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_date(dict, key)
       
    1: def ll_pdf_dict_get_inheritable(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_inheritable()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_inheritable(dict, key)
       
    1: def ll_pdf_dict_get_inheritable_bool(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_inheritable_bool()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_inheritable_bool(dict, key)
       
    1: def ll_pdf_dict_get_inheritable_date(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_inheritable_date()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_inheritable_date(dict, key)
       
    1: def ll_pdf_dict_get_inheritable_int(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_inheritable_int()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_inheritable_int(dict, key)
       
    1: def ll_pdf_dict_get_inheritable_int64(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_inheritable_int64()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_inheritable_int64(dict, key)
       
    1: def ll_pdf_dict_get_inheritable_matrix(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_inheritable_matrix()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_inheritable_matrix(dict, key)
       
    1: def ll_pdf_dict_get_inheritable_name(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_inheritable_name()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_inheritable_name(dict, key)
       
    1: def ll_pdf_dict_get_inheritable_real(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_inheritable_real()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_inheritable_real(dict, key)
       
    1: def ll_pdf_dict_get_inheritable_rect(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_inheritable_rect()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_inheritable_rect(dict, key)
       
    1: def ll_pdf_dict_get_inheritable_string(dict, key, sizep):
           r"""
            Low-level wrapper for `::pdf_dict_get_inheritable_string()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_dict_get_inheritable_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
           """
>>>>>>     return _mupdf.ll_pdf_dict_get_inheritable_string(dict, key, sizep)
       
    1: def ll_pdf_dict_get_inheritable_text_string(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_inheritable_text_string()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_inheritable_text_string(dict, key)
       
    1: def ll_pdf_dict_get_int(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_int()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_int(dict, key)
       
    1: def ll_pdf_dict_get_int64(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_int64()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_int64(dict, key)
       
    1: def ll_pdf_dict_get_int_default(dict, key, _def):
           r"""Low-level wrapper for `::pdf_dict_get_int_default()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_int_default(dict, key, _def)
       
    1: def ll_pdf_dict_get_key(dict, idx):
           r"""Low-level wrapper for `::pdf_dict_get_key()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_key(dict, idx)
       
    1: def ll_pdf_dict_get_matrix(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_matrix()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_matrix(dict, key)
       
    1: def ll_pdf_dict_get_name(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_name()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_name(dict, key)
       
    1: def ll_pdf_dict_get_point(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_point()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_point(dict, key)
       
    1: def ll_pdf_dict_get_put_drop(dict, key, val, old_val):
           r"""
            Low-level wrapper for `::pdf_dict_get_put_drop()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_dict_get_put_drop(::pdf_obj *dict, ::pdf_obj *key, ::pdf_obj *val, ::pdf_obj **old_val)` =>
           """
>>>>>>     return _mupdf.ll_pdf_dict_get_put_drop(dict, key, val, old_val)
       
    1: def ll_pdf_dict_get_real(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_real()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_real(dict, key)
       
    1: def ll_pdf_dict_get_real_default(dict, key, _def):
           r"""Low-level wrapper for `::pdf_dict_get_real_default()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_real_default(dict, key, _def)
       
    1: def ll_pdf_dict_get_rect(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_rect()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_rect(dict, key)
       
    1: def ll_pdf_dict_get_string(dict, key, sizep):
           r"""
            Low-level wrapper for `::pdf_dict_get_string()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_dict_get_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
           """
>>>>>>     return _mupdf.ll_pdf_dict_get_string(dict, key, sizep)
       
    1: def ll_pdf_dict_get_text_string(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_text_string()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_text_string(dict, key)
       
    1: def ll_pdf_dict_get_text_string_opt(dict, key):
           r"""Low-level wrapper for `::pdf_dict_get_text_string_opt()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_text_string_opt(dict, key)
       
    1: def ll_pdf_dict_get_val(dict, idx):
           r"""Low-level wrapper for `::pdf_dict_get_val()`."""
>>>>>>     return _mupdf.ll_pdf_dict_get_val(dict, idx)
       
    1: def ll_pdf_dict_geta(dict, key, abbrev):
           r"""Low-level wrapper for `::pdf_dict_geta()`."""
>>>>>>     return _mupdf.ll_pdf_dict_geta(dict, key, abbrev)
       
    1: def ll_pdf_dict_getp(dict, path):
           r"""Low-level wrapper for `::pdf_dict_getp()`."""
>>>>>>     return _mupdf.ll_pdf_dict_getp(dict, path)
       
    1: def ll_pdf_dict_getp_inheritable(dict, path):
           r"""Low-level wrapper for `::pdf_dict_getp_inheritable()`."""
>>>>>>     return _mupdf.ll_pdf_dict_getp_inheritable(dict, path)
       
    1: def ll_pdf_dict_gets(dict, key):
           r"""Low-level wrapper for `::pdf_dict_gets()`."""
>>>>>>     return _mupdf.ll_pdf_dict_gets(dict, key)
       
    1: def ll_pdf_dict_gets_inheritable(dict, key):
           r"""Low-level wrapper for `::pdf_dict_gets_inheritable()`."""
>>>>>>     return _mupdf.ll_pdf_dict_gets_inheritable(dict, key)
       
    1: def ll_pdf_dict_getsa(dict, key, abbrev):
           r"""Low-level wrapper for `::pdf_dict_getsa()`."""
>>>>>>     return _mupdf.ll_pdf_dict_getsa(dict, key, abbrev)
       
    1: def ll_pdf_dict_len(dict):
           r"""Low-level wrapper for `::pdf_dict_len()`."""
>>>>>>     return _mupdf.ll_pdf_dict_len(dict)
       
    1: def ll_pdf_dict_put(dict, key, val):
           r"""Low-level wrapper for `::pdf_dict_put()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put(dict, key, val)
       
    1: def ll_pdf_dict_put_array(dict, key, initial):
           r"""Low-level wrapper for `::pdf_dict_put_array()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_array(dict, key, initial)
       
    1: def ll_pdf_dict_put_bool(dict, key, x):
           r"""Low-level wrapper for `::pdf_dict_put_bool()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_bool(dict, key, x)
       
    1: def ll_pdf_dict_put_date(dict, key, time):
           r"""Low-level wrapper for `::pdf_dict_put_date()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_date(dict, key, time)
       
    1: def ll_pdf_dict_put_dict(dict, key, initial):
           r"""Low-level wrapper for `::pdf_dict_put_dict()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_dict(dict, key, initial)
       
    1: def ll_pdf_dict_put_drop(dict, key, val):
           r"""Low-level wrapper for `::pdf_dict_put_drop()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_drop(dict, key, val)
       
    1: def ll_pdf_dict_put_indirect(dict, key, num):
           r"""Low-level wrapper for `::pdf_dict_put_indirect()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_indirect(dict, key, num)
       
    1: def ll_pdf_dict_put_int(dict, key, x):
           r"""Low-level wrapper for `::pdf_dict_put_int()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_int(dict, key, x)
       
    1: def ll_pdf_dict_put_matrix(dict, key, x):
           r"""Low-level wrapper for `::pdf_dict_put_matrix()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_matrix(dict, key, x)
       
    1: def ll_pdf_dict_put_name(dict, key, x):
           r"""Low-level wrapper for `::pdf_dict_put_name()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_name(dict, key, x)
       
    1: def ll_pdf_dict_put_point(dict, key, x):
           r"""Low-level wrapper for `::pdf_dict_put_point()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_point(dict, key, x)
       
    1: def ll_pdf_dict_put_real(dict, key, x):
           r"""Low-level wrapper for `::pdf_dict_put_real()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_real(dict, key, x)
       
    1: def ll_pdf_dict_put_rect(dict, key, x):
           r"""Low-level wrapper for `::pdf_dict_put_rect()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_rect(dict, key, x)
       
    1: def ll_pdf_dict_put_string(dict, key, x, n):
           r"""Low-level wrapper for `::pdf_dict_put_string()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_string(dict, key, x, n)
       
    1: def ll_pdf_dict_put_text_string(dict, key, x):
           r"""Low-level wrapper for `::pdf_dict_put_text_string()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_text_string(dict, key, x)
       
    1: def ll_pdf_dict_put_val_null(obj, idx):
           r"""Low-level wrapper for `::pdf_dict_put_val_null()`."""
>>>>>>     return _mupdf.ll_pdf_dict_put_val_null(obj, idx)
       
    1: def ll_pdf_dict_putp(dict, path, val):
           r"""Low-level wrapper for `::pdf_dict_putp()`."""
>>>>>>     return _mupdf.ll_pdf_dict_putp(dict, path, val)
       
    1: def ll_pdf_dict_putp_drop(dict, path, val):
           r"""Low-level wrapper for `::pdf_dict_putp_drop()`."""
>>>>>>     return _mupdf.ll_pdf_dict_putp_drop(dict, path, val)
       
    1: def ll_pdf_dict_puts(dict, key, val):
           r"""Low-level wrapper for `::pdf_dict_puts()`."""
>>>>>>     return _mupdf.ll_pdf_dict_puts(dict, key, val)
       
    1: def ll_pdf_dict_puts_dict(dict, key, initial):
           r"""Low-level wrapper for `::pdf_dict_puts_dict()`."""
>>>>>>     return _mupdf.ll_pdf_dict_puts_dict(dict, key, initial)
       
    1: def ll_pdf_dict_puts_drop(dict, key, val):
           r"""Low-level wrapper for `::pdf_dict_puts_drop()`."""
>>>>>>     return _mupdf.ll_pdf_dict_puts_drop(dict, key, val)
       
    1: def ll_pdf_dirty_annot(annot):
           r"""Low-level wrapper for `::pdf_dirty_annot()`."""
>>>>>>     return _mupdf.ll_pdf_dirty_annot(annot)
       
    1: def ll_pdf_dirty_obj(obj):
           r"""Low-level wrapper for `::pdf_dirty_obj()`."""
>>>>>>     return _mupdf.ll_pdf_dirty_obj(obj)
       
    1: def ll_pdf_disable_js(doc):
           r"""Low-level wrapper for `::pdf_disable_js()`."""
>>>>>>     return _mupdf.ll_pdf_disable_js(doc)
       
    1: def ll_pdf_discard_journal(journal):
           r"""Low-level wrapper for `::pdf_discard_journal()`."""
>>>>>>     return _mupdf.ll_pdf_discard_journal(journal)
       
    1: def ll_pdf_doc_was_linearized(doc):
           r"""Low-level wrapper for `::pdf_doc_was_linearized()`."""
>>>>>>     return _mupdf.ll_pdf_doc_was_linearized(doc)
       
    1: def ll_pdf_document_associated_file(doc, idx):
           r"""Low-level wrapper for `::pdf_document_associated_file()`."""
>>>>>>     return _mupdf.ll_pdf_document_associated_file(doc, idx)
       
    1: def ll_pdf_document_event_did_print(doc):
           r"""Low-level wrapper for `::pdf_document_event_did_print()`."""
>>>>>>     return _mupdf.ll_pdf_document_event_did_print(doc)
       
    1: def ll_pdf_document_event_did_save(doc):
           r"""Low-level wrapper for `::pdf_document_event_did_save()`."""
>>>>>>     return _mupdf.ll_pdf_document_event_did_save(doc)
       
    1: def ll_pdf_document_event_will_close(doc):
           r"""Low-level wrapper for `::pdf_document_event_will_close()`."""
>>>>>>     return _mupdf.ll_pdf_document_event_will_close(doc)
       
    1: def ll_pdf_document_event_will_print(doc):
           r"""Low-level wrapper for `::pdf_document_event_will_print()`."""
>>>>>>     return _mupdf.ll_pdf_document_event_will_print(doc)
       
    1: def ll_pdf_document_event_will_save(doc):
           r"""Low-level wrapper for `::pdf_document_event_will_save()`."""
>>>>>>     return _mupdf.ll_pdf_document_event_will_save(doc)
       
    1: def ll_pdf_document_from_fz_document(ptr):
           r"""Low-level wrapper for `::pdf_document_from_fz_document()`."""
>>>>>>     return _mupdf.ll_pdf_document_from_fz_document(ptr)
       
    1: def ll_pdf_document_language(doc):
           r"""Low-level wrapper for `::pdf_document_language()`."""
>>>>>>     return _mupdf.ll_pdf_document_language(doc)
       
    1: def ll_pdf_document_output_intent(doc):
           r"""Low-level wrapper for `::pdf_document_output_intent()`."""
>>>>>>     return _mupdf.ll_pdf_document_output_intent(doc)
       
    1: def ll_pdf_document_permissions(doc):
           r"""Low-level wrapper for `::pdf_document_permissions()`."""
>>>>>>     return _mupdf.ll_pdf_document_permissions(doc)
       
    1: def ll_pdf_drop_annot(annot):
           r"""Low-level wrapper for `::pdf_drop_annot()`."""
>>>>>>     return _mupdf.ll_pdf_drop_annot(annot)
       
    1: def ll_pdf_drop_cmap(cmap):
           r"""Low-level wrapper for `::pdf_drop_cmap()`."""
>>>>>>     return _mupdf.ll_pdf_drop_cmap(cmap)
       
    1: def ll_pdf_drop_cmap_imp(cmap):
           r"""Low-level wrapper for `::pdf_drop_cmap_imp()`."""
>>>>>>     return _mupdf.ll_pdf_drop_cmap_imp(cmap)
       
    1: def ll_pdf_drop_crypt(crypt):
           r"""Low-level wrapper for `::pdf_drop_crypt()`."""
>>>>>>     return _mupdf.ll_pdf_drop_crypt(crypt)
       
    1: def ll_pdf_drop_document(doc):
           r"""Low-level wrapper for `::pdf_drop_document()`."""
>>>>>>     return _mupdf.ll_pdf_drop_document(doc)
       
    1: def ll_pdf_drop_font(font):
           r"""Low-level wrapper for `::pdf_drop_font()`."""
>>>>>>     return _mupdf.ll_pdf_drop_font(font)
       
    1: def ll_pdf_drop_function(func):
           r"""Low-level wrapper for `::pdf_drop_function()`."""
>>>>>>     return _mupdf.ll_pdf_drop_function(func)
       
    1: def ll_pdf_drop_graft_map(map):
           r"""Low-level wrapper for `::pdf_drop_graft_map()`."""
>>>>>>     return _mupdf.ll_pdf_drop_graft_map(map)
       
    1: def ll_pdf_drop_journal(journal):
           r"""Low-level wrapper for `::pdf_drop_journal()`."""
>>>>>>     return _mupdf.ll_pdf_drop_journal(journal)
       
    1: def ll_pdf_drop_js(js):
           r"""Low-level wrapper for `::pdf_drop_js()`."""
>>>>>>     return _mupdf.ll_pdf_drop_js(js)
       
    1: def ll_pdf_drop_local_xref(xref):
           r"""Low-level wrapper for `::pdf_drop_local_xref()`."""
>>>>>>     return _mupdf.ll_pdf_drop_local_xref(xref)
       
    1: def ll_pdf_drop_local_xref_and_resources(doc):
           r"""Low-level wrapper for `::pdf_drop_local_xref_and_resources()`."""
>>>>>>     return _mupdf.ll_pdf_drop_local_xref_and_resources(doc)
       
    1: def ll_pdf_drop_locked_fields(locked):
           r"""Low-level wrapper for `::pdf_drop_locked_fields()`."""
>>>>>>     return _mupdf.ll_pdf_drop_locked_fields(locked)
       
    1: def ll_pdf_drop_mark_bits(marks):
           r"""Low-level wrapper for `::pdf_drop_mark_bits()`."""
>>>>>>     return _mupdf.ll_pdf_drop_mark_bits(marks)
       
    1: def ll_pdf_drop_obj(obj):
           r"""Low-level wrapper for `::pdf_drop_obj()`."""
>>>>>>     return _mupdf.ll_pdf_drop_obj(obj)
       
    1: def ll_pdf_drop_object_labels(g):
           r"""Low-level wrapper for `::pdf_drop_object_labels()`."""
>>>>>>     return _mupdf.ll_pdf_drop_object_labels(g)
       
    1: def ll_pdf_drop_ocg(doc):
           r"""Low-level wrapper for `::pdf_drop_ocg()`."""
>>>>>>     return _mupdf.ll_pdf_drop_ocg(doc)
       
    1: def ll_pdf_drop_page(page):
           r"""Low-level wrapper for `::pdf_drop_page()`."""
>>>>>>     return _mupdf.ll_pdf_drop_page(page)
       
    1: def ll_pdf_drop_page_tree(doc):
           r"""Low-level wrapper for `::pdf_drop_page_tree()`."""
>>>>>>     return _mupdf.ll_pdf_drop_page_tree(doc)
       
    1: def ll_pdf_drop_page_tree_internal(doc):
           r"""Low-level wrapper for `::pdf_drop_page_tree_internal()`."""
>>>>>>     return _mupdf.ll_pdf_drop_page_tree_internal(doc)
       
    1: def ll_pdf_drop_pattern(pat):
           r"""Low-level wrapper for `::pdf_drop_pattern()`."""
>>>>>>     return _mupdf.ll_pdf_drop_pattern(pat)
       
    1: def ll_pdf_drop_processor(proc):
           r"""Low-level wrapper for `::pdf_drop_processor()`."""
>>>>>>     return _mupdf.ll_pdf_drop_processor(proc)
       
    1: def ll_pdf_drop_resource_tables(doc):
           r"""Low-level wrapper for `::pdf_drop_resource_tables()`."""
>>>>>>     return _mupdf.ll_pdf_drop_resource_tables(doc)
       
    1: def ll_pdf_drop_signer(signer):
           r"""Low-level wrapper for `::pdf_drop_signer()`."""
>>>>>>     return _mupdf.ll_pdf_drop_signer(signer)
       
    1: def ll_pdf_drop_singleton_obj(obj):
           r"""Low-level wrapper for `::pdf_drop_singleton_obj()`."""
>>>>>>     return _mupdf.ll_pdf_drop_singleton_obj(obj)
       
    1: def ll_pdf_drop_verifier(verifier):
           r"""Low-level wrapper for `::pdf_drop_verifier()`."""
>>>>>>     return _mupdf.ll_pdf_drop_verifier(verifier)
       
    1: def ll_pdf_drop_widget(widget):
           r"""Low-level wrapper for `::pdf_drop_widget()`."""
>>>>>>     return _mupdf.ll_pdf_drop_widget(widget)
       
    1: def ll_pdf_edit_text_field_value(widget, value, change, selStart, selEnd, newvalue):
           r"""
            Low-level wrapper for `::pdf_edit_text_field_value()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_edit_text_field_value(::pdf_annot *widget, const char *value, const char *change)` => `(int, int selStart, int selEnd, char *newvalue)`
           """
>>>>>>     return _mupdf.ll_pdf_edit_text_field_value(widget, value, change, selStart, selEnd, newvalue)
       
    1: def ll_pdf_empty_store(doc):
           r"""Low-level wrapper for `::pdf_empty_store()`."""
>>>>>>     return _mupdf.ll_pdf_empty_store(doc)
       
    1: def ll_pdf_enable_journal(doc):
           r"""Low-level wrapper for `::pdf_enable_journal()`."""
>>>>>>     return _mupdf.ll_pdf_enable_journal(doc)
       
    1: def ll_pdf_enable_js(doc):
           r"""Low-level wrapper for `::pdf_enable_js()`."""
>>>>>>     return _mupdf.ll_pdf_enable_js(doc)
       
    1: def ll_pdf_enable_layer(doc, layer, enabled):
           r"""Low-level wrapper for `::pdf_enable_layer()`."""
>>>>>>     return _mupdf.ll_pdf_enable_layer(doc, layer, enabled)
       
    1: def ll_pdf_encrypt_data(crypt, num, gen, fmt_str_out, arg, s, n):
           r"""Low-level wrapper for `::pdf_encrypt_data()`."""
>>>>>>     return _mupdf.ll_pdf_encrypt_data(crypt, num, gen, fmt_str_out, arg, s, n)
       
    1: def ll_pdf_encrypted_len(crypt, num, gen, len):
           r"""Low-level wrapper for `::pdf_encrypted_len()`."""
>>>>>>     return _mupdf.ll_pdf_encrypted_len(crypt, num, gen, len)
       
    1: def ll_pdf_end_hmtx(font):
           r"""Low-level wrapper for `::pdf_end_hmtx()`."""
>>>>>>     return _mupdf.ll_pdf_end_hmtx(font)
       
    1: def ll_pdf_end_operation(doc):
           r"""Low-level wrapper for `::pdf_end_operation()`."""
>>>>>>     return _mupdf.ll_pdf_end_operation(doc)
       
    1: def ll_pdf_end_vmtx(font):
           r"""Low-level wrapper for `::pdf_end_vmtx()`."""
>>>>>>     return _mupdf.ll_pdf_end_vmtx(font)
       
    1: def ll_pdf_ensure_solid_xref(doc, num):
           r"""Low-level wrapper for `::pdf_ensure_solid_xref()`."""
>>>>>>     return _mupdf.ll_pdf_ensure_solid_xref(doc, num)
       
    1: def ll_pdf_eval_function(func, _in, inlen, out, outlen):
           r"""
            Low-level wrapper for `::pdf_eval_function()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_eval_function(::pdf_function *func, const float *in, int inlen, int outlen)` => float out
           """
>>>>>>     return _mupdf.ll_pdf_eval_function(func, _in, inlen, out, outlen)
       
    1: def ll_pdf_event_issue_alert(doc, evt):
           r"""Low-level wrapper for `::pdf_event_issue_alert()`."""
>>>>>>     return _mupdf.ll_pdf_event_issue_alert(doc, evt)
       
    1: def ll_pdf_event_issue_exec_menu_item(doc, item):
           r"""Low-level wrapper for `::pdf_event_issue_exec_menu_item()`."""
>>>>>>     return _mupdf.ll_pdf_event_issue_exec_menu_item(doc, item)
       
    1: def ll_pdf_event_issue_launch_url(doc, url, new_frame):
           r"""Low-level wrapper for `::pdf_event_issue_launch_url()`."""
>>>>>>     return _mupdf.ll_pdf_event_issue_launch_url(doc, url, new_frame)
       
    1: def ll_pdf_event_issue_mail_doc(doc, evt):
           r"""Low-level wrapper for `::pdf_event_issue_mail_doc()`."""
>>>>>>     return _mupdf.ll_pdf_event_issue_mail_doc(doc, evt)
       
    1: def ll_pdf_event_issue_print(doc):
           r"""Low-level wrapper for `::pdf_event_issue_print()`."""
>>>>>>     return _mupdf.ll_pdf_event_issue_print(doc)
       
    1: def ll_pdf_field_border_style(field):
           r"""Low-level wrapper for `::pdf_field_border_style()`."""
>>>>>>     return _mupdf.ll_pdf_field_border_style(field)
       
    1: def ll_pdf_field_display(field):
           r"""Low-level wrapper for `::pdf_field_display()`."""
>>>>>>     return _mupdf.ll_pdf_field_display(field)
       
    1: def ll_pdf_field_event_calculate(doc, field):
           r"""Low-level wrapper for `::pdf_field_event_calculate()`."""
>>>>>>     return _mupdf.ll_pdf_field_event_calculate(doc, field)
       
    1: def ll_pdf_field_event_format(doc, field):
           r"""Low-level wrapper for `::pdf_field_event_format()`."""
>>>>>>     return _mupdf.ll_pdf_field_event_format(doc, field)
       
    1: def ll_pdf_field_event_keystroke(doc, field, evt):
           r"""Low-level wrapper for `::pdf_field_event_keystroke()`."""
>>>>>>     return _mupdf.ll_pdf_field_event_keystroke(doc, field, evt)
       
    1: def ll_pdf_field_event_validate(doc, field, value, newvalue):
           r"""
            Low-level wrapper for `::pdf_field_event_validate()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_field_event_validate(::pdf_document *doc, ::pdf_obj *field, const char *value)` => `(int, char *newvalue)`
           """
>>>>>>     return _mupdf.ll_pdf_field_event_validate(doc, field, value, newvalue)
       
    1: def ll_pdf_field_flags(field):
           r"""Low-level wrapper for `::pdf_field_flags()`."""
>>>>>>     return _mupdf.ll_pdf_field_flags(field)
       
    1: def ll_pdf_field_label(field):
           r"""Low-level wrapper for `::pdf_field_label()`."""
>>>>>>     return _mupdf.ll_pdf_field_label(field)
       
    1: def ll_pdf_field_reset(doc, field):
           r"""Low-level wrapper for `::pdf_field_reset()`."""
>>>>>>     return _mupdf.ll_pdf_field_reset(doc, field)
       
    1: def ll_pdf_field_set_border_style(field, text):
           r"""Low-level wrapper for `::pdf_field_set_border_style()`."""
>>>>>>     return _mupdf.ll_pdf_field_set_border_style(field, text)
       
    1: def ll_pdf_field_set_button_caption(field, text):
           r"""Low-level wrapper for `::pdf_field_set_button_caption()`."""
>>>>>>     return _mupdf.ll_pdf_field_set_button_caption(field, text)
       
    1: def ll_pdf_field_set_display(field, d):
           r"""Low-level wrapper for `::pdf_field_set_display()`."""
>>>>>>     return _mupdf.ll_pdf_field_set_display(field, d)
       
    1: def ll_pdf_field_set_fill_color(field, col):
           r"""Low-level wrapper for `::pdf_field_set_fill_color()`."""
>>>>>>     return _mupdf.ll_pdf_field_set_fill_color(field, col)
       
    1: def ll_pdf_field_set_text_color(field, col):
           r"""Low-level wrapper for `::pdf_field_set_text_color()`."""
>>>>>>     return _mupdf.ll_pdf_field_set_text_color(field, col)
       
    1: def ll_pdf_field_type(field):
           r"""Low-level wrapper for `::pdf_field_type()`."""
>>>>>>     return _mupdf.ll_pdf_field_type(field)
       
    1: def ll_pdf_field_type_string(field):
           r"""Low-level wrapper for `::pdf_field_type_string()`."""
>>>>>>     return _mupdf.ll_pdf_field_type_string(field)
       
    1: def ll_pdf_field_value(field):
           r"""Low-level wrapper for `::pdf_field_value()`."""
>>>>>>     return _mupdf.ll_pdf_field_value(field)
       
    1: def ll_pdf_filter_annot_contents(doc, annot, options):
           r"""Low-level wrapper for `::pdf_filter_annot_contents()`."""
>>>>>>     return _mupdf.ll_pdf_filter_annot_contents(doc, annot, options)
       
    1: def ll_pdf_filter_page_contents(doc, page, options):
           r"""Low-level wrapper for `::pdf_filter_page_contents()`."""
>>>>>>     return _mupdf.ll_pdf_filter_page_contents(doc, page, options)
       
    1: def ll_pdf_filter_xobject_instance(old_xobj, page_res, ctm, options, cycle_up):
           r"""Low-level wrapper for `::pdf_filter_xobject_instance()`."""
>>>>>>     return _mupdf.ll_pdf_filter_xobject_instance(old_xobj, page_res, ctm, options, cycle_up)
       
    1: def ll_pdf_find_colorspace_resource(doc, item, key):
           r"""Low-level wrapper for `::pdf_find_colorspace_resource()`."""
>>>>>>     return _mupdf.ll_pdf_find_colorspace_resource(doc, item, key)
       
    1: def ll_pdf_find_font_resource(doc, type, encoding, item, key):
           r"""Low-level wrapper for `::pdf_find_font_resource()`."""
>>>>>>     return _mupdf.ll_pdf_find_font_resource(doc, type, encoding, item, key)
       
    1: def ll_pdf_find_item(drop, key):
           r"""Low-level wrapper for `::pdf_find_item()`."""
>>>>>>     return _mupdf.ll_pdf_find_item(drop, key)
       
    1: def ll_pdf_find_locked_fields(doc, version):
           r"""Low-level wrapper for `::pdf_find_locked_fields()`."""
>>>>>>     return _mupdf.ll_pdf_find_locked_fields(doc, version)
       
    1: def ll_pdf_find_locked_fields_for_sig(doc, sig):
           r"""Low-level wrapper for `::pdf_find_locked_fields_for_sig()`."""
>>>>>>     return _mupdf.ll_pdf_find_locked_fields_for_sig(doc, sig)
       
    1: def ll_pdf_find_version_for_obj(doc, obj):
           r"""Low-level wrapper for `::pdf_find_version_for_obj()`."""
>>>>>>     return _mupdf.ll_pdf_find_version_for_obj(doc, obj)
       
    1: def ll_pdf_first_annot(page):
           r"""Low-level wrapper for `::pdf_first_annot()`."""
>>>>>>     return _mupdf.ll_pdf_first_annot(page)
       
    1: def ll_pdf_first_widget(page):
           r"""Low-level wrapper for `::pdf_first_widget()`."""
>>>>>>     return _mupdf.ll_pdf_first_widget(page)
       
    1: def ll_pdf_flatten_inheritable_page_items(page):
           r"""Low-level wrapper for `::pdf_flatten_inheritable_page_items()`."""
>>>>>>     return _mupdf.ll_pdf_flatten_inheritable_page_items(page)
       
    1: def ll_pdf_font_cid_to_gid(fontdesc, cid):
           r"""Low-level wrapper for `::pdf_font_cid_to_gid()`."""
>>>>>>     return _mupdf.ll_pdf_font_cid_to_gid(fontdesc, cid)
       
    1: def ll_pdf_font_writing_supported(font):
           r"""Low-level wrapper for `::pdf_font_writing_supported()`."""
>>>>>>     return _mupdf.ll_pdf_font_writing_supported(font)
       
    1: def ll_pdf_forget_xref(doc):
           r"""Low-level wrapper for `::pdf_forget_xref()`."""
>>>>>>     return _mupdf.ll_pdf_forget_xref(doc)
       
    1: def ll_pdf_format_date(time, s, n):
           r"""Low-level wrapper for `::pdf_format_date()`."""
>>>>>>     return _mupdf.ll_pdf_format_date(time, s, n)
       
    1: def ll_pdf_format_write_options(buffer, buffer_len, opts):
           r"""Low-level wrapper for `::pdf_format_write_options()`."""
>>>>>>     return _mupdf.ll_pdf_format_write_options(buffer, buffer_len, opts)
       
    1: def ll_pdf_function_size(func):
           r"""Low-level wrapper for `::pdf_function_size()`."""
>>>>>>     return _mupdf.ll_pdf_function_size(func)
       
    1: def ll_pdf_get_bound_document(obj):
           r"""Low-level wrapper for `::pdf_get_bound_document()`."""
>>>>>>     return _mupdf.ll_pdf_get_bound_document(obj)
       
    1: def ll_pdf_get_doc_event_callback_data(doc):
           r"""Low-level wrapper for `::pdf_get_doc_event_callback_data()`."""
>>>>>>     return _mupdf.ll_pdf_get_doc_event_callback_data(doc)
       
    1: def ll_pdf_get_filespec_params(fs, out):
           r"""Low-level wrapper for `::pdf_get_filespec_params()`."""
>>>>>>     return _mupdf.ll_pdf_get_filespec_params(fs, out)
       
    1: def ll_pdf_get_incremental_xref_entry(doc, i):
           r"""Low-level wrapper for `::pdf_get_incremental_xref_entry()`."""
>>>>>>     return _mupdf.ll_pdf_get_incremental_xref_entry(doc, i)
       
    1: def ll_pdf_get_indirect_document(obj):
           r"""Low-level wrapper for `::pdf_get_indirect_document()`."""
>>>>>>     return _mupdf.ll_pdf_get_indirect_document(obj)
       
    1: def ll_pdf_get_populating_xref_entry(doc, i):
           r"""Low-level wrapper for `::pdf_get_populating_xref_entry()`."""
>>>>>>     return _mupdf.ll_pdf_get_populating_xref_entry(doc, i)
       
    1: def ll_pdf_get_widget_editing_state(widget):
           r"""Low-level wrapper for `::pdf_get_widget_editing_state()`."""
>>>>>>     return _mupdf.ll_pdf_get_widget_editing_state(widget)
       
    1: def ll_pdf_get_xref_entry(doc, i):
           r"""Low-level wrapper for `::pdf_get_xref_entry()`."""
>>>>>>     return _mupdf.ll_pdf_get_xref_entry(doc, i)
       
    1: def ll_pdf_get_xref_entry_no_change(doc, i):
           r"""Low-level wrapper for `::pdf_get_xref_entry_no_change()`."""
>>>>>>     return _mupdf.ll_pdf_get_xref_entry_no_change(doc, i)
       
    1: def ll_pdf_get_xref_entry_no_null(doc, i):
           r"""Low-level wrapper for `::pdf_get_xref_entry_no_null()`."""
>>>>>>     return _mupdf.ll_pdf_get_xref_entry_no_null(doc, i)
       
    1: def ll_pdf_graft_mapped_object(map, obj):
           r"""Low-level wrapper for `::pdf_graft_mapped_object()`."""
>>>>>>     return _mupdf.ll_pdf_graft_mapped_object(map, obj)
       
    1: def ll_pdf_graft_mapped_page(map, page_to, src, page_from):
           r"""Low-level wrapper for `::pdf_graft_mapped_page()`."""
>>>>>>     return _mupdf.ll_pdf_graft_mapped_page(map, page_to, src, page_from)
       
    1: def ll_pdf_graft_object(dst, obj):
           r"""Low-level wrapper for `::pdf_graft_object()`."""
>>>>>>     return _mupdf.ll_pdf_graft_object(dst, obj)
       
    1: def ll_pdf_graft_page(dst, page_to, src, page_from):
           r"""Low-level wrapper for `::pdf_graft_page()`."""
>>>>>>     return _mupdf.ll_pdf_graft_page(dst, page_to, src, page_from)
       
    1: def ll_pdf_has_permission(doc, p):
           r"""Low-level wrapper for `::pdf_has_permission()`."""
>>>>>>     return _mupdf.ll_pdf_has_permission(doc, p)
       
    1: def ll_pdf_has_unsaved_changes(doc):
           r"""Low-level wrapper for `::pdf_has_unsaved_changes()`."""
>>>>>>     return _mupdf.ll_pdf_has_unsaved_changes(doc)
       
    1: def ll_pdf_has_unsaved_sigs(doc):
           r"""Low-level wrapper for `::pdf_has_unsaved_sigs()`."""
>>>>>>     return _mupdf.ll_pdf_has_unsaved_sigs(doc)
       
    1: def ll_pdf_incremental_change_since_signing_widget(widget):
           r"""Low-level wrapper for `::pdf_incremental_change_since_signing_widget()`."""
>>>>>>     return _mupdf.ll_pdf_incremental_change_since_signing_widget(widget)
       
    1: def ll_pdf_insert_colorspace_resource(doc, key, obj):
           r"""Low-level wrapper for `::pdf_insert_colorspace_resource()`."""
>>>>>>     return _mupdf.ll_pdf_insert_colorspace_resource(doc, key, obj)
       
    1: def ll_pdf_insert_font_resource(doc, key, obj):
           r"""Low-level wrapper for `::pdf_insert_font_resource()`."""
>>>>>>     return _mupdf.ll_pdf_insert_font_resource(doc, key, obj)
       
    1: def ll_pdf_insert_page(doc, at, page):
           r"""Low-level wrapper for `::pdf_insert_page()`."""
>>>>>>     return _mupdf.ll_pdf_insert_page(doc, at, page)
       
    1: def ll_pdf_intent_from_name(obj):
           r"""Low-level wrapper for `::pdf_intent_from_name()`."""
>>>>>>     return _mupdf.ll_pdf_intent_from_name(obj)
       
    1: def ll_pdf_intent_from_string(str):
           r"""Low-level wrapper for `::pdf_intent_from_string()`."""
>>>>>>     return _mupdf.ll_pdf_intent_from_string(str)
       
    1: def ll_pdf_invalidate_xfa(doc):
           r"""Low-level wrapper for `::pdf_invalidate_xfa()`."""
>>>>>>     return _mupdf.ll_pdf_invalidate_xfa(doc)
       
    1: def ll_pdf_is_array(obj):
           r"""Low-level wrapper for `::pdf_is_array()`."""
>>>>>>     return _mupdf.ll_pdf_is_array(obj)
       
    1: def ll_pdf_is_bool(obj):
           r"""Low-level wrapper for `::pdf_is_bool()`."""
>>>>>>     return _mupdf.ll_pdf_is_bool(obj)
       
    1: def ll_pdf_is_dict(obj):
           r"""Low-level wrapper for `::pdf_is_dict()`."""
>>>>>>     return _mupdf.ll_pdf_is_dict(obj)
       
    1: def ll_pdf_is_embedded_file(fs):
           r"""Low-level wrapper for `::pdf_is_embedded_file()`."""
>>>>>>     return _mupdf.ll_pdf_is_embedded_file(fs)
       
    1: def ll_pdf_is_field_locked(locked, name):
           r"""Low-level wrapper for `::pdf_is_field_locked()`."""
>>>>>>     return _mupdf.ll_pdf_is_field_locked(locked, name)
       
    1: def ll_pdf_is_filespec(fs):
           r"""Low-level wrapper for `::pdf_is_filespec()`."""
>>>>>>     return _mupdf.ll_pdf_is_filespec(fs)
       
    1: def ll_pdf_is_image_stream(obj):
           r"""Low-level wrapper for `::pdf_is_image_stream()`."""
>>>>>>     return _mupdf.ll_pdf_is_image_stream(obj)
       
    1: def ll_pdf_is_indirect(obj):
           r"""Low-level wrapper for `::pdf_is_indirect()`."""
>>>>>>     return _mupdf.ll_pdf_is_indirect(obj)
       
    1: def ll_pdf_is_int(obj):
           r"""Low-level wrapper for `::pdf_is_int()`."""
>>>>>>     return _mupdf.ll_pdf_is_int(obj)
       
    1: def ll_pdf_is_jpx_image(dict):
           r"""Low-level wrapper for `::pdf_is_jpx_image()`."""
>>>>>>     return _mupdf.ll_pdf_is_jpx_image(dict)
       
    1: def ll_pdf_is_local_object(doc, obj):
           r"""Low-level wrapper for `::pdf_is_local_object()`."""
>>>>>>     return _mupdf.ll_pdf_is_local_object(doc, obj)
       
    1: def ll_pdf_is_name(obj):
           r"""Low-level wrapper for `::pdf_is_name()`."""
>>>>>>     return _mupdf.ll_pdf_is_name(obj)
       
    1: def ll_pdf_is_null(obj):
           r"""Low-level wrapper for `::pdf_is_null()`."""
>>>>>>     return _mupdf.ll_pdf_is_null(obj)
       
    1: def ll_pdf_is_number(obj):
           r"""Low-level wrapper for `::pdf_is_number()`."""
>>>>>>     return _mupdf.ll_pdf_is_number(obj)
       
    1: def ll_pdf_is_ocg_hidden(doc, rdb, usage, ocg):
           r"""Low-level wrapper for `::pdf_is_ocg_hidden()`."""
>>>>>>     return _mupdf.ll_pdf_is_ocg_hidden(doc, rdb, usage, ocg)
       
    1: def ll_pdf_is_real(obj):
           r"""Low-level wrapper for `::pdf_is_real()`."""
>>>>>>     return _mupdf.ll_pdf_is_real(obj)
       
    1: def ll_pdf_is_stream(obj):
           r"""Low-level wrapper for `::pdf_is_stream()`."""
>>>>>>     return _mupdf.ll_pdf_is_stream(obj)
       
    1: def ll_pdf_is_string(obj):
           r"""Low-level wrapper for `::pdf_is_string()`."""
>>>>>>     return _mupdf.ll_pdf_is_string(obj)
       
    1: def ll_pdf_is_tint_colorspace(cs):
           r"""Low-level wrapper for `::pdf_is_tint_colorspace()`."""
>>>>>>     return _mupdf.ll_pdf_is_tint_colorspace(cs)
       
    1: def ll_pdf_js_event_init(js, target, value, willCommit):
           r"""Low-level wrapper for `::pdf_js_event_init()`."""
>>>>>>     return _mupdf.ll_pdf_js_event_init(js, target, value, willCommit)
       
    1: def ll_pdf_js_event_init_keystroke(js, target, evt):
           r"""Low-level wrapper for `::pdf_js_event_init_keystroke()`."""
>>>>>>     return _mupdf.ll_pdf_js_event_init_keystroke(js, target, evt)
       
    1: def ll_pdf_js_event_result(js):
           r"""Low-level wrapper for `::pdf_js_event_result()`."""
>>>>>>     return _mupdf.ll_pdf_js_event_result(js)
       
    1: def ll_pdf_js_event_result_keystroke(js, evt):
           r"""Low-level wrapper for `::pdf_js_event_result_keystroke()`."""
>>>>>>     return _mupdf.ll_pdf_js_event_result_keystroke(js, evt)
       
    1: def ll_pdf_js_event_result_validate(js, newvalue):
           r"""
            Low-level wrapper for `::pdf_js_event_result_validate()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_js_event_result_validate(::pdf_js *js)` => `(int, char *newvalue)`
           """
>>>>>>     return _mupdf.ll_pdf_js_event_result_validate(js, newvalue)
       
    1: def ll_pdf_js_event_value(js):
           r"""Low-level wrapper for `::pdf_js_event_value()`."""
>>>>>>     return _mupdf.ll_pdf_js_event_value(js)
       
    1: def ll_pdf_js_execute(js, name, code, result):
           r"""
            Low-level wrapper for `::pdf_js_execute()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_js_execute(::pdf_js *js, const char *name, const char *code)` => char *result
           """
>>>>>>     return _mupdf.ll_pdf_js_execute(js, name, code, result)
       
    1: def ll_pdf_js_get_console(doc):
           r"""Low-level wrapper for `::pdf_js_get_console()`."""
>>>>>>     return _mupdf.ll_pdf_js_get_console(doc)
       
    1: def ll_pdf_js_set_console(doc, console, user):
           r"""Low-level wrapper for `::pdf_js_set_console()`."""
>>>>>>     return _mupdf.ll_pdf_js_set_console(doc, console, user)
       
    1: def ll_pdf_js_supported(doc):
           r"""Low-level wrapper for `::pdf_js_supported()`."""
>>>>>>     return _mupdf.ll_pdf_js_supported(doc)
       
    1: def ll_pdf_keep_annot(annot):
           r"""Low-level wrapper for `::pdf_keep_annot()`."""
>>>>>>     return _mupdf.ll_pdf_keep_annot(annot)
       
    1: def ll_pdf_keep_cmap(cmap):
           r"""Low-level wrapper for `::pdf_keep_cmap()`."""
>>>>>>     return _mupdf.ll_pdf_keep_cmap(cmap)
       
    1: def ll_pdf_keep_document(doc):
           r"""Low-level wrapper for `::pdf_keep_document()`."""
>>>>>>     return _mupdf.ll_pdf_keep_document(doc)
       
    1: def ll_pdf_keep_font(fontdesc):
           r"""Low-level wrapper for `::pdf_keep_font()`."""
>>>>>>     return _mupdf.ll_pdf_keep_font(fontdesc)
       
    1: def ll_pdf_keep_function(func):
           r"""Low-level wrapper for `::pdf_keep_function()`."""
>>>>>>     return _mupdf.ll_pdf_keep_function(func)
       
    1: def ll_pdf_keep_graft_map(map):
           r"""Low-level wrapper for `::pdf_keep_graft_map()`."""
>>>>>>     return _mupdf.ll_pdf_keep_graft_map(map)
       
    1: def ll_pdf_keep_obj(obj):
           r"""Low-level wrapper for `::pdf_keep_obj()`."""
>>>>>>     return _mupdf.ll_pdf_keep_obj(obj)
       
    1: def ll_pdf_keep_page(page):
           r"""Low-level wrapper for `::pdf_keep_page()`."""
>>>>>>     return _mupdf.ll_pdf_keep_page(page)
       
    1: def ll_pdf_keep_pattern(pat):
           r"""Low-level wrapper for `::pdf_keep_pattern()`."""
>>>>>>     return _mupdf.ll_pdf_keep_pattern(pat)
       
    1: def ll_pdf_keep_processor(proc):
           r"""Low-level wrapper for `::pdf_keep_processor()`."""
>>>>>>     return _mupdf.ll_pdf_keep_processor(proc)
       
    1: def ll_pdf_keep_widget(widget):
           r"""Low-level wrapper for `::pdf_keep_widget()`."""
>>>>>>     return _mupdf.ll_pdf_keep_widget(widget)
       
    1: def ll_pdf_label_object(g, num, callback, arg):
           r"""Low-level wrapper for `::pdf_label_object()`."""
>>>>>>     return _mupdf.ll_pdf_label_object(g, num, callback, arg)
       
    1: def ll_pdf_layer_config_info(doc, config_num, info):
           r"""Low-level wrapper for `::pdf_layer_config_info()`."""
>>>>>>     return _mupdf.ll_pdf_layer_config_info(doc, config_num, info)
       
    1: def ll_pdf_layer_config_ui_info(doc, ui, info):
           r"""Low-level wrapper for `::pdf_layer_config_ui_info()`."""
>>>>>>     return _mupdf.ll_pdf_layer_config_ui_info(doc, ui, info)
       
    1: def ll_pdf_layer_is_enabled(doc, layer):
           r"""Low-level wrapper for `::pdf_layer_is_enabled()`."""
>>>>>>     return _mupdf.ll_pdf_layer_is_enabled(doc, layer)
       
    1: def ll_pdf_layer_name(doc, layer):
           r"""Low-level wrapper for `::pdf_layer_name()`."""
>>>>>>     return _mupdf.ll_pdf_layer_name(doc, layer)
       
    1: def ll_pdf_layout_fit_text(font, lang, str, bounds):
           r"""Low-level wrapper for `::pdf_layout_fit_text()`."""
>>>>>>     return _mupdf.ll_pdf_layout_fit_text(font, lang, str, bounds)
       
    1: def ll_pdf_layout_text_widget(annot):
           r"""Low-level wrapper for `::pdf_layout_text_widget()`."""
>>>>>>     return _mupdf.ll_pdf_layout_text_widget(annot)
       
    1: def ll_pdf_lex(f, lexbuf):
           r"""Low-level wrapper for `::pdf_lex()`."""
>>>>>>     return _mupdf.ll_pdf_lex(f, lexbuf)
       
    1: def ll_pdf_lex_no_string(f, lexbuf):
           r"""Low-level wrapper for `::pdf_lex_no_string()`."""
>>>>>>     return _mupdf.ll_pdf_lex_no_string(f, lexbuf)
       
    1: def ll_pdf_lexbuf_fin(lexbuf):
           r"""Low-level wrapper for `::pdf_lexbuf_fin()`."""
>>>>>>     return _mupdf.ll_pdf_lexbuf_fin(lexbuf)
       
    1: def ll_pdf_lexbuf_grow(lexbuf):
           r"""Low-level wrapper for `::pdf_lexbuf_grow()`."""
>>>>>>     return _mupdf.ll_pdf_lexbuf_grow(lexbuf)
       
    1: def ll_pdf_lexbuf_init(lexbuf, size):
           r"""Low-level wrapper for `::pdf_lexbuf_init()`."""
>>>>>>     return _mupdf.ll_pdf_lexbuf_init(lexbuf, size)
       
    1: def ll_pdf_line_ending_from_name(end):
           r"""Low-level wrapper for `::pdf_line_ending_from_name()`."""
>>>>>>     return _mupdf.ll_pdf_line_ending_from_name(end)
       
    1: def ll_pdf_line_ending_from_string(end):
           r"""Low-level wrapper for `::pdf_line_ending_from_string()`."""
>>>>>>     return _mupdf.ll_pdf_line_ending_from_string(end)
       
    1: def ll_pdf_load_builtin_cmap(name):
           r"""Low-level wrapper for `::pdf_load_builtin_cmap()`."""
>>>>>>     return _mupdf.ll_pdf_load_builtin_cmap(name)
       
    1: def ll_pdf_load_cmap(file):
           r"""Low-level wrapper for `::pdf_load_cmap()`."""
>>>>>>     return _mupdf.ll_pdf_load_cmap(file)
       
    1: def ll_pdf_load_colorspace(obj):
           r"""Low-level wrapper for `::pdf_load_colorspace()`."""
>>>>>>     return _mupdf.ll_pdf_load_colorspace(obj)
       
    1: def ll_pdf_load_compressed_inline_image(doc, dict, length, cstm, indexed, image):
           r"""Low-level wrapper for `::pdf_load_compressed_inline_image()`."""
>>>>>>     return _mupdf.ll_pdf_load_compressed_inline_image(doc, dict, length, cstm, indexed, image)
       
    1: def ll_pdf_load_compressed_stream(doc, num, worst_case):
           r"""Low-level wrapper for `::pdf_load_compressed_stream()`."""
>>>>>>     return _mupdf.ll_pdf_load_compressed_stream(doc, num, worst_case)
       
    1: def ll_pdf_load_default_colorspaces(doc, page):
           r"""Low-level wrapper for `::pdf_load_default_colorspaces()`."""
>>>>>>     return _mupdf.ll_pdf_load_default_colorspaces(doc, page)
       
    1: def ll_pdf_load_embedded_cmap(doc, ref):
           r"""Low-level wrapper for `::pdf_load_embedded_cmap()`."""
>>>>>>     return _mupdf.ll_pdf_load_embedded_cmap(doc, ref)
       
    1: def ll_pdf_load_embedded_file_contents(fs):
           r"""Low-level wrapper for `::pdf_load_embedded_file_contents()`."""
>>>>>>     return _mupdf.ll_pdf_load_embedded_file_contents(fs)
       
    1: def ll_pdf_load_encoding(estrings, encoding):
           r"""
            Low-level wrapper for `::pdf_load_encoding()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_load_encoding(const char *encoding)` => const char *estrings
           """
>>>>>>     return _mupdf.ll_pdf_load_encoding(estrings, encoding)
       
    1: def ll_pdf_load_field_name(field):
           r"""Low-level wrapper for `::pdf_load_field_name()`."""
>>>>>>     return _mupdf.ll_pdf_load_field_name(field)
       
    1: def ll_pdf_load_field_name2(field):
           r"""Alternative to `ll_pdf_load_field_name()` that returns a std::string."""
>>>>>>     return _mupdf.ll_pdf_load_field_name2(field)
       
    1: def ll_pdf_load_font(doc, rdb, obj):
           r"""Low-level wrapper for `::pdf_load_font()`."""
>>>>>>     return _mupdf.ll_pdf_load_font(doc, rdb, obj)
       
    1: def ll_pdf_load_function(ref, _in, out):
           r"""Low-level wrapper for `::pdf_load_function()`."""
>>>>>>     return _mupdf.ll_pdf_load_function(ref, _in, out)
       
    1: def ll_pdf_load_hail_mary_font(doc):
           r"""Low-level wrapper for `::pdf_load_hail_mary_font()`."""
>>>>>>     return _mupdf.ll_pdf_load_hail_mary_font(doc)
       
    1: def ll_pdf_load_image(doc, obj):
           r"""Low-level wrapper for `::pdf_load_image()`."""
>>>>>>     return _mupdf.ll_pdf_load_image(doc, obj)
       
    1: def ll_pdf_load_inline_image(doc, rdb, dict, file):
           r"""Low-level wrapper for `::pdf_load_inline_image()`."""
>>>>>>     return _mupdf.ll_pdf_load_inline_image(doc, rdb, dict, file)
       
    1: def ll_pdf_load_journal(doc, filename):
           r"""Low-level wrapper for `::pdf_load_journal()`."""
>>>>>>     return _mupdf.ll_pdf_load_journal(doc, filename)
       
    1: def ll_pdf_load_link_annots(arg_1, arg_2, annots, pagenum, page_ctm):
           r"""Low-level wrapper for `::pdf_load_link_annots()`."""
>>>>>>     return _mupdf.ll_pdf_load_link_annots(arg_1, arg_2, annots, pagenum, page_ctm)
       
    1: def ll_pdf_load_links(page):
           r"""Low-level wrapper for `::pdf_load_links()`."""
>>>>>>     return _mupdf.ll_pdf_load_links(page)
       
    1: def ll_pdf_load_name_tree(doc, which):
           r"""Low-level wrapper for `::pdf_load_name_tree()`."""
>>>>>>     return _mupdf.ll_pdf_load_name_tree(doc, which)
       
    1: def ll_pdf_load_object(doc, num):
           r"""
           Low-level wrapper for `::pdf_load_object()`.
           Load a given object.
       
           This can cause xref reorganisations (solidifications etc) due to
           repairs, so all held pdf_xref_entries should be considered
           invalid after this call (other than the returned one).
           """
>>>>>>     return _mupdf.ll_pdf_load_object(doc, num)
       
    1: def ll_pdf_load_object_labels(doc):
           r"""Low-level wrapper for `::pdf_load_object_labels()`."""
>>>>>>     return _mupdf.ll_pdf_load_object_labels(doc)
       
    1: def ll_pdf_load_outline(doc):
           r"""Low-level wrapper for `::pdf_load_outline()`."""
>>>>>>     return _mupdf.ll_pdf_load_outline(doc)
       
    1: def ll_pdf_load_page(doc, number):
           r"""Low-level wrapper for `::pdf_load_page()`."""
>>>>>>     return _mupdf.ll_pdf_load_page(doc, number)
       
    1: def ll_pdf_load_page_imp(doc, chapter, number):
           r"""Low-level wrapper for `::pdf_load_page_imp()`."""
>>>>>>     return _mupdf.ll_pdf_load_page_imp(doc, chapter, number)
       
    1: def ll_pdf_load_page_tree(doc):
           r"""Low-level wrapper for `::pdf_load_page_tree()`."""
>>>>>>     return _mupdf.ll_pdf_load_page_tree(doc)
       
    1: def ll_pdf_load_pattern(doc, obj):
           r"""Low-level wrapper for `::pdf_load_pattern()`."""
>>>>>>     return _mupdf.ll_pdf_load_pattern(doc, obj)
       
    1: def ll_pdf_load_raw_stream(ref):
           r"""Low-level wrapper for `::pdf_load_raw_stream()`."""
>>>>>>     return _mupdf.ll_pdf_load_raw_stream(ref)
       
    1: def ll_pdf_load_raw_stream_number(doc, num):
           r"""Low-level wrapper for `::pdf_load_raw_stream_number()`."""
>>>>>>     return _mupdf.ll_pdf_load_raw_stream_number(doc, num)
       
    1: def ll_pdf_load_shading(doc, obj):
           r"""Low-level wrapper for `::pdf_load_shading()`."""
>>>>>>     return _mupdf.ll_pdf_load_shading(doc, obj)
       
    1: def ll_pdf_load_stream(ref):
           r"""Low-level wrapper for `::pdf_load_stream()`."""
>>>>>>     return _mupdf.ll_pdf_load_stream(ref)
       
    1: def ll_pdf_load_stream_number(doc, num):
           r"""Low-level wrapper for `::pdf_load_stream_number()`."""
>>>>>>     return _mupdf.ll_pdf_load_stream_number(doc, num)
       
    1: def ll_pdf_load_stream_or_string_as_utf8(src):
           r"""Low-level wrapper for `::pdf_load_stream_or_string_as_utf8()`."""
>>>>>>     return _mupdf.ll_pdf_load_stream_or_string_as_utf8(src)
       
    1: def ll_pdf_load_system_cmap(name):
           r"""Low-level wrapper for `::pdf_load_system_cmap()`."""
>>>>>>     return _mupdf.ll_pdf_load_system_cmap(name)
       
    1: def ll_pdf_load_to_unicode(doc, font, strings, collection, cmapstm):
           r"""
            Low-level wrapper for `::pdf_load_to_unicode()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_load_to_unicode(::pdf_document *doc, ::pdf_font_desc *font, char *collection, ::pdf_obj *cmapstm)` => const char *strings
           """
>>>>>>     return _mupdf.ll_pdf_load_to_unicode(doc, font, strings, collection, cmapstm)
       
    1: def ll_pdf_load_type3_font(doc, rdb, obj):
           r"""Low-level wrapper for `::pdf_load_type3_font()`."""
>>>>>>     return _mupdf.ll_pdf_load_type3_font(doc, rdb, obj)
       
    1: def ll_pdf_load_type3_glyphs(doc, fontdesc):
           r"""Low-level wrapper for `::pdf_load_type3_glyphs()`."""
>>>>>>     return _mupdf.ll_pdf_load_type3_glyphs(doc, fontdesc)
       
    1: def ll_pdf_load_unencrypted_object(doc, num):
           r"""Low-level wrapper for `::pdf_load_unencrypted_object()`."""
>>>>>>     return _mupdf.ll_pdf_load_unencrypted_object(doc, num)
       
    1: def ll_pdf_lookup_cmap(cmap, cpt):
           r"""Low-level wrapper for `::pdf_lookup_cmap()`."""
>>>>>>     return _mupdf.ll_pdf_lookup_cmap(cmap, cpt)
       
    1: def ll_pdf_lookup_cmap_full(cmap, cpt, out):
           r"""
            Low-level wrapper for `::pdf_lookup_cmap_full()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_lookup_cmap_full(::pdf_cmap *cmap, unsigned int cpt)` => `(int, int out)`
           """
>>>>>>     return _mupdf.ll_pdf_lookup_cmap_full(cmap, cpt, out)
       
    1: def ll_pdf_lookup_dest(doc, needle):
           r"""Low-level wrapper for `::pdf_lookup_dest()`."""
>>>>>>     return _mupdf.ll_pdf_lookup_dest(doc, needle)
       
    1: def ll_pdf_lookup_field(form, name):
           r"""Low-level wrapper for `::pdf_lookup_field()`."""
>>>>>>     return _mupdf.ll_pdf_lookup_field(form, name)
       
    1: def ll_pdf_lookup_hmtx(font, cid):
           r"""Low-level wrapper for `::pdf_lookup_hmtx()`."""
>>>>>>     return _mupdf.ll_pdf_lookup_hmtx(font, cid)
       
    1: def ll_pdf_lookup_metadata(doc, key, ptr, size):
           r"""Low-level wrapper for `::pdf_lookup_metadata()`."""
>>>>>>     return _mupdf.ll_pdf_lookup_metadata(doc, key, ptr, size)
       
    1: def ll_pdf_lookup_metadata2(doc, key):
           r"""
            Low-level wrapper for `::pdf_lookup_metadata2()`.
           C++ alternative to `pdf_lookup_metadata()` that returns a `std::string`
           or calls `fz_throw()` if not found.
           """
>>>>>>     return _mupdf.ll_pdf_lookup_metadata2(doc, key)
       
    1: def ll_pdf_lookup_name(doc, which, needle):
           r"""Low-level wrapper for `::pdf_lookup_name()`."""
>>>>>>     return _mupdf.ll_pdf_lookup_name(doc, which, needle)
       
    1: def ll_pdf_lookup_number(root, needle):
           r"""Low-level wrapper for `::pdf_lookup_number()`."""
>>>>>>     return _mupdf.ll_pdf_lookup_number(root, needle)
       
    1: def ll_pdf_lookup_page_loc(doc, needle, parentp, indexp):
           r"""
            Low-level wrapper for `::pdf_lookup_page_loc()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_lookup_page_loc(::pdf_document *doc, int needle, ::pdf_obj **parentp)` => `(pdf_obj *, int indexp)`
           """
>>>>>>     return _mupdf.ll_pdf_lookup_page_loc(doc, needle, parentp, indexp)
       
    1: def ll_pdf_lookup_page_number(doc, pageobj):
           r"""Low-level wrapper for `::pdf_lookup_page_number()`."""
>>>>>>     return _mupdf.ll_pdf_lookup_page_number(doc, pageobj)
       
    1: def ll_pdf_lookup_page_obj(doc, needle):
           r"""Low-level wrapper for `::pdf_lookup_page_obj()`."""
>>>>>>     return _mupdf.ll_pdf_lookup_page_obj(doc, needle)
       
    1: def ll_pdf_lookup_resource(stack, type, name):
           r"""Low-level wrapper for `::pdf_lookup_resource()`."""
>>>>>>     return _mupdf.ll_pdf_lookup_resource(stack, type, name)
       
    1: def ll_pdf_lookup_substitute_font(mono, serif, bold, italic, len):
           r"""
            Low-level wrapper for `::pdf_lookup_substitute_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_lookup_substitute_font(int mono, int serif, int bold, int italic)` => `(const unsigned char *, int len)`
           """
>>>>>>     return _mupdf.ll_pdf_lookup_substitute_font(mono, serif, bold, italic, len)
       
    1: def ll_pdf_lookup_vmtx(font, cid):
           r"""Low-level wrapper for `::pdf_lookup_vmtx()`."""
>>>>>>     return _mupdf.ll_pdf_lookup_vmtx(font, cid)
       
    1: def ll_pdf_map_one_to_many(cmap, one, many, len):
           r"""
            Low-level wrapper for `::pdf_map_one_to_many()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_map_one_to_many(::pdf_cmap *cmap, unsigned int one, size_t len)` => int many
           """
>>>>>>     return _mupdf.ll_pdf_map_one_to_many(cmap, one, many, len)
       
    1: def ll_pdf_map_range_to_range(cmap, srclo, srchi, dstlo):
           r"""Low-level wrapper for `::pdf_map_range_to_range()`."""
>>>>>>     return _mupdf.ll_pdf_map_range_to_range(cmap, srclo, srchi, dstlo)
       
    1: def ll_pdf_mark_bits_reset(marks):
           r"""Low-level wrapper for `::pdf_mark_bits_reset()`."""
>>>>>>     return _mupdf.ll_pdf_mark_bits_reset(marks)
       
    1: def ll_pdf_mark_bits_set(marks, obj):
           r"""Low-level wrapper for `::pdf_mark_bits_set()`."""
>>>>>>     return _mupdf.ll_pdf_mark_bits_set(marks, obj)
       
    1: def ll_pdf_mark_list_check(list, obj):
           r"""Low-level wrapper for `::pdf_mark_list_check()`."""
>>>>>>     return _mupdf.ll_pdf_mark_list_check(list, obj)
       
    1: def ll_pdf_mark_list_free(list):
           r"""Low-level wrapper for `::pdf_mark_list_free()`."""
>>>>>>     return _mupdf.ll_pdf_mark_list_free(list)
       
    1: def ll_pdf_mark_list_init(list):
           r"""Low-level wrapper for `::pdf_mark_list_init()`."""
>>>>>>     return _mupdf.ll_pdf_mark_list_init(list)
       
    1: def ll_pdf_mark_list_pop(list):
           r"""Low-level wrapper for `::pdf_mark_list_pop()`."""
>>>>>>     return _mupdf.ll_pdf_mark_list_pop(list)
       
    1: def ll_pdf_mark_list_push(list, obj):
           r"""Low-level wrapper for `::pdf_mark_list_push()`."""
>>>>>>     return _mupdf.ll_pdf_mark_list_push(list, obj)
       
    1: def ll_pdf_mark_obj(obj):
           r"""Low-level wrapper for `::pdf_mark_obj()`."""
>>>>>>     return _mupdf.ll_pdf_mark_obj(obj)
       
    1: def ll_pdf_mark_xref(doc):
           r"""Low-level wrapper for `::pdf_mark_xref()`."""
>>>>>>     return _mupdf.ll_pdf_mark_xref(doc)
       
    1: def ll_pdf_metadata(doc):
           r"""Low-level wrapper for `::pdf_metadata()`."""
>>>>>>     return _mupdf.ll_pdf_metadata(doc)
       
    1: def ll_pdf_minimize_document(doc):
           r"""Low-level wrapper for `::pdf_minimize_document()`."""
>>>>>>     return _mupdf.ll_pdf_minimize_document(doc)
       
    1: def ll_pdf_name_eq(a, b):
           r"""Low-level wrapper for `::pdf_name_eq()`."""
>>>>>>     return _mupdf.ll_pdf_name_eq(a, b)
       
    1: def ll_pdf_name_from_intent(intent):
           r"""Low-level wrapper for `::pdf_name_from_intent()`."""
>>>>>>     return _mupdf.ll_pdf_name_from_intent(intent)
       
    1: def ll_pdf_name_from_line_ending(end):
           r"""Low-level wrapper for `::pdf_name_from_line_ending()`."""
>>>>>>     return _mupdf.ll_pdf_name_from_line_ending(end)
       
    1: def ll_pdf_needs_password(doc):
           r"""Low-level wrapper for `::pdf_needs_password()`."""
>>>>>>     return _mupdf.ll_pdf_needs_password(doc)
       
    1: def ll_pdf_new_action_from_link(doc, uri):
           r"""Low-level wrapper for `::pdf_new_action_from_link()`."""
>>>>>>     return _mupdf.ll_pdf_new_action_from_link(doc, uri)
       
    1: def ll_pdf_new_array(doc, initialcap):
           r"""Low-level wrapper for `::pdf_new_array()`."""
>>>>>>     return _mupdf.ll_pdf_new_array(doc, initialcap)
       
    1: def ll_pdf_new_buffer_processor(buffer, ahxencode, newlines):
           r"""Low-level wrapper for `::pdf_new_buffer_processor()`."""
>>>>>>     return _mupdf.ll_pdf_new_buffer_processor(buffer, ahxencode, newlines)
       
    1: def ll_pdf_new_cmap():
           r"""Low-level wrapper for `::pdf_new_cmap()`."""
>>>>>>     return _mupdf.ll_pdf_new_cmap()
       
    1: def ll_pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts):
           r"""Low-level wrapper for `::pdf_new_color_filter()`."""
>>>>>>     return _mupdf.ll_pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts)
       
    1: def ll_pdf_new_crypt(enc, id):
           r"""Low-level wrapper for `::pdf_new_crypt()`."""
>>>>>>     return _mupdf.ll_pdf_new_crypt(enc, id)
       
    1: def ll_pdf_new_date(doc, time):
           r"""Low-level wrapper for `::pdf_new_date()`."""
>>>>>>     return _mupdf.ll_pdf_new_date(doc, time)
       
    1: def ll_pdf_new_dest_from_link(doc, uri, is_remote):
           r"""Low-level wrapper for `::pdf_new_dest_from_link()`."""
>>>>>>     return _mupdf.ll_pdf_new_dest_from_link(doc, uri, is_remote)
       
    1: def ll_pdf_new_dict(doc, initialcap):
           r"""Low-level wrapper for `::pdf_new_dict()`."""
>>>>>>     return _mupdf.ll_pdf_new_dict(doc, initialcap)
       
    1: def ll_pdf_new_display_list_from_annot(annot):
           r"""Low-level wrapper for `::pdf_new_display_list_from_annot()`."""
>>>>>>     return _mupdf.ll_pdf_new_display_list_from_annot(annot)
       
    1: def ll_pdf_new_encrypt(opwd_utf8, upwd_utf8, id, permissions, algorithm):
           r"""Low-level wrapper for `::pdf_new_encrypt()`."""
>>>>>>     return _mupdf.ll_pdf_new_encrypt(opwd_utf8, upwd_utf8, id, permissions, algorithm)
       
    1: def ll_pdf_new_font_desc():
           r"""Low-level wrapper for `::pdf_new_font_desc()`."""
>>>>>>     return _mupdf.ll_pdf_new_font_desc()
       
    1: def ll_pdf_new_graft_map(dst):
           r"""Low-level wrapper for `::pdf_new_graft_map()`."""
>>>>>>     return _mupdf.ll_pdf_new_graft_map(dst)
       
    1: def ll_pdf_new_identity_cmap(wmode, bytes):
           r"""Low-level wrapper for `::pdf_new_identity_cmap()`."""
>>>>>>     return _mupdf.ll_pdf_new_identity_cmap(wmode, bytes)
       
    1: def ll_pdf_new_indirect(doc, num, gen):
           r"""Low-level wrapper for `::pdf_new_indirect()`."""
>>>>>>     return _mupdf.ll_pdf_new_indirect(doc, num, gen)
       
    1: def ll_pdf_new_int(i):
           r"""Low-level wrapper for `::pdf_new_int()`."""
>>>>>>     return _mupdf.ll_pdf_new_int(i)
       
    1: def ll_pdf_new_link(page, rect, uri, obj):
           r"""Low-level wrapper for `::pdf_new_link()`."""
>>>>>>     return _mupdf.ll_pdf_new_link(page, rect, uri, obj)
       
    1: def ll_pdf_new_local_xref(doc):
           r"""Low-level wrapper for `::pdf_new_local_xref()`."""
>>>>>>     return _mupdf.ll_pdf_new_local_xref(doc)
       
    1: def ll_pdf_new_mark_bits(doc):
           r"""Low-level wrapper for `::pdf_new_mark_bits()`."""
>>>>>>     return _mupdf.ll_pdf_new_mark_bits(doc)
       
    1: def ll_pdf_new_matrix(doc, mtx):
           r"""Low-level wrapper for `::pdf_new_matrix()`."""
>>>>>>     return _mupdf.ll_pdf_new_matrix(doc, mtx)
       
    1: def ll_pdf_new_name(str):
           r"""Low-level wrapper for `::pdf_new_name()`."""
>>>>>>     return _mupdf.ll_pdf_new_name(str)
       
    1: def ll_pdf_new_outline_iterator(doc):
           r"""Low-level wrapper for `::pdf_new_outline_iterator()`."""
>>>>>>     return _mupdf.ll_pdf_new_outline_iterator(doc)
       
    1: def ll_pdf_new_output_processor(out, ahxencode, newlines):
           r"""Low-level wrapper for `::pdf_new_output_processor()`."""
>>>>>>     return _mupdf.ll_pdf_new_output_processor(out, ahxencode, newlines)
       
    1: def ll_pdf_new_pdf_device(doc, topctm, resources, contents):
           r"""Low-level wrapper for `::pdf_new_pdf_device()`."""
>>>>>>     return _mupdf.ll_pdf_new_pdf_device(doc, topctm, resources, contents)
       
    1: def ll_pdf_new_pixmap_from_annot(annot, ctm, cs, seps, alpha):
           r"""Low-level wrapper for `::pdf_new_pixmap_from_annot()`."""
>>>>>>     return _mupdf.ll_pdf_new_pixmap_from_annot(annot, ctm, cs, seps, alpha)
       
    1: def ll_pdf_new_pixmap_from_page_contents_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
           r"""Low-level wrapper for `::pdf_new_pixmap_from_page_contents_with_separations_and_usage()`."""
>>>>>>     return _mupdf.ll_pdf_new_pixmap_from_page_contents_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)
       
    1: def ll_pdf_new_pixmap_from_page_contents_with_usage(page, ctm, cs, alpha, usage, box):
           r"""Low-level wrapper for `::pdf_new_pixmap_from_page_contents_with_usage()`."""
>>>>>>     return _mupdf.ll_pdf_new_pixmap_from_page_contents_with_usage(page, ctm, cs, alpha, usage, box)
       
    1: def ll_pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
           r"""Low-level wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`."""
>>>>>>     return _mupdf.ll_pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)
       
    1: def ll_pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box):
           r"""Low-level wrapper for `::pdf_new_pixmap_from_page_with_usage()`."""
>>>>>>     return _mupdf.ll_pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box)
       
    1: def ll_pdf_new_point(doc, point):
           r"""Low-level wrapper for `::pdf_new_point()`."""
>>>>>>     return _mupdf.ll_pdf_new_point(doc, point)
       
    1: def ll_pdf_new_processor(size):
           r"""Low-level wrapper for `::pdf_new_processor()`."""
>>>>>>     return _mupdf.ll_pdf_new_processor(size)
       
    1: def ll_pdf_new_real(f):
           r"""Low-level wrapper for `::pdf_new_real()`."""
>>>>>>     return _mupdf.ll_pdf_new_real(f)
       
    1: def ll_pdf_new_rect(doc, rect):
           r"""Low-level wrapper for `::pdf_new_rect()`."""
>>>>>>     return _mupdf.ll_pdf_new_rect(doc, rect)
       
    1: def ll_pdf_new_run_processor(doc, dev, ctm, struct_parent, usage, gstate, default_cs, cookie, fill_gstate, stroke_gstate):
           r"""Low-level wrapper for `::pdf_new_run_processor()`."""
>>>>>>     return _mupdf.ll_pdf_new_run_processor(doc, dev, ctm, struct_parent, usage, gstate, default_cs, cookie, fill_gstate, stroke_gstate)
       
    1: def ll_pdf_new_sanitize_filter(doc, chain, struct_parents, transform, options, sopts):
           r"""Low-level wrapper for `::pdf_new_sanitize_filter()`."""
>>>>>>     return _mupdf.ll_pdf_new_sanitize_filter(doc, chain, struct_parents, transform, options, sopts)
       
    1: def ll_pdf_new_stext_page_from_annot(annot, options):
           r"""Low-level wrapper for `::pdf_new_stext_page_from_annot()`."""
>>>>>>     return _mupdf.ll_pdf_new_stext_page_from_annot(annot, options)
       
    1: def ll_pdf_new_string(str, len):
           r"""Low-level wrapper for `::pdf_new_string()`."""
>>>>>>     return _mupdf.ll_pdf_new_string(str, len)
       
    1: def ll_pdf_new_text_string(s):
           r"""Low-level wrapper for `::pdf_new_text_string()`."""
>>>>>>     return _mupdf.ll_pdf_new_text_string(s)
       
    1: def ll_pdf_new_uri_from_explicit_dest(dest):
           r"""Low-level wrapper for `::pdf_new_uri_from_explicit_dest()`."""
>>>>>>     return _mupdf.ll_pdf_new_uri_from_explicit_dest(dest)
       
    1: def ll_pdf_new_uri_from_path_and_explicit_dest(path, dest):
           r"""Low-level wrapper for `::pdf_new_uri_from_path_and_explicit_dest()`."""
>>>>>>     return _mupdf.ll_pdf_new_uri_from_path_and_explicit_dest(path, dest)
       
    1: def ll_pdf_new_uri_from_path_and_named_dest(path, name):
           r"""Low-level wrapper for `::pdf_new_uri_from_path_and_named_dest()`."""
>>>>>>     return _mupdf.ll_pdf_new_uri_from_path_and_named_dest(path, name)
       
    1: def ll_pdf_new_utf8_from_pdf_stream_obj(src):
           r"""Low-level wrapper for `::pdf_new_utf8_from_pdf_stream_obj()`."""
>>>>>>     return _mupdf.ll_pdf_new_utf8_from_pdf_stream_obj(src)
       
    1: def ll_pdf_new_utf8_from_pdf_string(srcptr, srclen):
           r"""Low-level wrapper for `::pdf_new_utf8_from_pdf_string()`."""
>>>>>>     return _mupdf.ll_pdf_new_utf8_from_pdf_string(srcptr, srclen)
       
    1: def ll_pdf_new_utf8_from_pdf_string_obj(src):
           r"""Low-level wrapper for `::pdf_new_utf8_from_pdf_string_obj()`."""
>>>>>>     return _mupdf.ll_pdf_new_utf8_from_pdf_string_obj(src)
       
    1: def ll_pdf_new_xobject(doc, bbox, matrix, res, buffer):
           r"""Low-level wrapper for `::pdf_new_xobject()`."""
>>>>>>     return _mupdf.ll_pdf_new_xobject(doc, bbox, matrix, res, buffer)
       
    1: def ll_pdf_next_annot(annot):
           r"""Low-level wrapper for `::pdf_next_annot()`."""
>>>>>>     return _mupdf.ll_pdf_next_annot(annot)
       
    1: def ll_pdf_next_widget(previous):
           r"""Low-level wrapper for `::pdf_next_widget()`."""
>>>>>>     return _mupdf.ll_pdf_next_widget(previous)
       
    1: def ll_pdf_nuke_annots(page):
           r"""Low-level wrapper for `::pdf_nuke_annots()`."""
>>>>>>     return _mupdf.ll_pdf_nuke_annots(page)
       
    1: def ll_pdf_nuke_links(page):
           r"""Low-level wrapper for `::pdf_nuke_links()`."""
>>>>>>     return _mupdf.ll_pdf_nuke_links(page)
       
    1: def ll_pdf_nuke_page(page):
           r"""Low-level wrapper for `::pdf_nuke_page()`."""
>>>>>>     return _mupdf.ll_pdf_nuke_page(page)
       
    1: def ll_pdf_obj_is_dirty(obj):
           r"""Low-level wrapper for `::pdf_obj_is_dirty()`."""
>>>>>>     return _mupdf.ll_pdf_obj_is_dirty(obj)
       
    1: def ll_pdf_obj_is_incremental(obj):
           r"""Low-level wrapper for `::pdf_obj_is_incremental()`."""
>>>>>>     return _mupdf.ll_pdf_obj_is_incremental(obj)
       
    1: def ll_pdf_obj_marked(obj):
           r"""Low-level wrapper for `::pdf_obj_marked()`."""
>>>>>>     return _mupdf.ll_pdf_obj_marked(obj)
       
    1: def ll_pdf_obj_memo(obj, bit, memo):
           r"""
            Low-level wrapper for `::pdf_obj_memo()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_obj_memo(::pdf_obj *obj, int bit)` => `(int, int memo)`
           """
>>>>>>     return _mupdf.ll_pdf_obj_memo(obj, bit, memo)
       
    1: def ll_pdf_obj_num_is_stream(doc, num):
           r"""Low-level wrapper for `::pdf_obj_num_is_stream()`."""
>>>>>>     return _mupdf.ll_pdf_obj_num_is_stream(doc, num)
       
    1: def ll_pdf_obj_parent_num(obj):
           r"""Low-level wrapper for `::pdf_obj_parent_num()`."""
>>>>>>     return _mupdf.ll_pdf_obj_parent_num(obj)
       
    1: def ll_pdf_obj_refs(ref):
           r"""Low-level wrapper for `::pdf_obj_refs()`."""
>>>>>>     return _mupdf.ll_pdf_obj_refs(ref)
       
    1: def ll_pdf_objcmp(a, b):
           r"""Low-level wrapper for `::pdf_objcmp()`."""
>>>>>>     return _mupdf.ll_pdf_objcmp(a, b)
       
    1: def ll_pdf_objcmp_deep(a, b):
           r"""Low-level wrapper for `::pdf_objcmp_deep()`."""
>>>>>>     return _mupdf.ll_pdf_objcmp_deep(a, b)
       
    1: def ll_pdf_objcmp_resolve(a, b):
           r"""Low-level wrapper for `::pdf_objcmp_resolve()`."""
>>>>>>     return _mupdf.ll_pdf_objcmp_resolve(a, b)
       
    1: def ll_pdf_object_exists(doc, num):
           r"""Low-level wrapper for `::pdf_object_exists()`."""
>>>>>>     return _mupdf.ll_pdf_object_exists(doc, num)
       
    1: def ll_pdf_open_contents_stream(doc, obj):
           r"""Low-level wrapper for `::pdf_open_contents_stream()`."""
>>>>>>     return _mupdf.ll_pdf_open_contents_stream(doc, obj)
       
    1: def ll_pdf_open_crypt(chain, crypt, num, gen):
           r"""Low-level wrapper for `::pdf_open_crypt()`."""
>>>>>>     return _mupdf.ll_pdf_open_crypt(chain, crypt, num, gen)
       
    1: def ll_pdf_open_crypt_with_filter(chain, crypt, name, num, gen):
           r"""Low-level wrapper for `::pdf_open_crypt_with_filter()`."""
>>>>>>     return _mupdf.ll_pdf_open_crypt_with_filter(chain, crypt, name, num, gen)
       
    1: def ll_pdf_open_document(filename):
           r"""Low-level wrapper for `::pdf_open_document()`."""
>>>>>>     return _mupdf.ll_pdf_open_document(filename)
       
    1: def ll_pdf_open_document_with_stream(file):
           r"""Low-level wrapper for `::pdf_open_document_with_stream()`."""
>>>>>>     return _mupdf.ll_pdf_open_document_with_stream(file)
       
    1: def ll_pdf_open_inline_stream(doc, stmobj, length, chain, params):
           r"""Low-level wrapper for `::pdf_open_inline_stream()`."""
>>>>>>     return _mupdf.ll_pdf_open_inline_stream(doc, stmobj, length, chain, params)
       
    1: def ll_pdf_open_raw_stream(ref):
           r"""Low-level wrapper for `::pdf_open_raw_stream()`."""
>>>>>>     return _mupdf.ll_pdf_open_raw_stream(ref)
       
    1: def ll_pdf_open_raw_stream_number(doc, num):
           r"""Low-level wrapper for `::pdf_open_raw_stream_number()`."""
>>>>>>     return _mupdf.ll_pdf_open_raw_stream_number(doc, num)
       
    1: def ll_pdf_open_stream(ref):
           r"""Low-level wrapper for `::pdf_open_stream()`."""
>>>>>>     return _mupdf.ll_pdf_open_stream(ref)
       
    1: def ll_pdf_open_stream_number(doc, num):
           r"""Low-level wrapper for `::pdf_open_stream_number()`."""
>>>>>>     return _mupdf.ll_pdf_open_stream_number(doc, num)
       
    1: def ll_pdf_open_stream_with_offset(doc, num, dict, stm_ofs):
           r"""Low-level wrapper for `::pdf_open_stream_with_offset()`."""
>>>>>>     return _mupdf.ll_pdf_open_stream_with_offset(doc, num, dict, stm_ofs)
       
    1: def ll_pdf_page_associated_file(page, idx):
           r"""Low-level wrapper for `::pdf_page_associated_file()`."""
>>>>>>     return _mupdf.ll_pdf_page_associated_file(page, idx)
       
    1: def ll_pdf_page_contents(page):
           r"""Low-level wrapper for `::pdf_page_contents()`."""
>>>>>>     return _mupdf.ll_pdf_page_contents(page)
       
    1: def ll_pdf_page_event_close(page):
           r"""Low-level wrapper for `::pdf_page_event_close()`."""
>>>>>>     return _mupdf.ll_pdf_page_event_close(page)
       
    1: def ll_pdf_page_event_open(page):
           r"""Low-level wrapper for `::pdf_page_event_open()`."""
>>>>>>     return _mupdf.ll_pdf_page_event_open(page)
       
    1: def ll_pdf_page_from_fz_page(ptr):
           r"""Low-level wrapper for `::pdf_page_from_fz_page()`."""
>>>>>>     return _mupdf.ll_pdf_page_from_fz_page(ptr)
       
    1: def ll_pdf_page_group(page):
           r"""Low-level wrapper for `::pdf_page_group()`."""
>>>>>>     return _mupdf.ll_pdf_page_group(page)
       
    1: def ll_pdf_page_has_transparency(page):
           r"""Low-level wrapper for `::pdf_page_has_transparency()`."""
>>>>>>     return _mupdf.ll_pdf_page_has_transparency(page)
       
    1: def ll_pdf_page_label(doc, page, buf, size):
           r"""Low-level wrapper for `::pdf_page_label()`."""
>>>>>>     return _mupdf.ll_pdf_page_label(doc, page, buf, size)
       
    1: def ll_pdf_page_label_imp(doc, chapter, page, buf, size):
           r"""Low-level wrapper for `::pdf_page_label_imp()`."""
>>>>>>     return _mupdf.ll_pdf_page_label_imp(doc, chapter, page, buf, size)
       
    1: def ll_pdf_page_obj_transform(pageobj, outbox, outctm):
           r"""Low-level wrapper for `::pdf_page_obj_transform()`."""
>>>>>>     return _mupdf.ll_pdf_page_obj_transform(pageobj, outbox, outctm)
       
    1: def ll_pdf_page_obj_transform_box(pageobj, outbox, out, box):
           r"""Low-level wrapper for `::pdf_page_obj_transform_box()`."""
>>>>>>     return _mupdf.ll_pdf_page_obj_transform_box(pageobj, outbox, out, box)
       
    1: def ll_pdf_page_presentation(page, transition, duration):
           r"""
            Low-level wrapper for `::pdf_page_presentation()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_page_presentation(::pdf_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`
           """
>>>>>>     return _mupdf.ll_pdf_page_presentation(page, transition, duration)
       
    1: def ll_pdf_page_resources(page):
           r"""Low-level wrapper for `::pdf_page_resources()`."""
>>>>>>     return _mupdf.ll_pdf_page_resources(page)
       
    1: def ll_pdf_page_separations(page):
           r"""Low-level wrapper for `::pdf_page_separations()`."""
>>>>>>     return _mupdf.ll_pdf_page_separations(page)
       
    1: def ll_pdf_page_transform(page, mediabox, ctm):
           r"""Low-level wrapper for `::pdf_page_transform()`."""
>>>>>>     return _mupdf.ll_pdf_page_transform(page, mediabox, ctm)
       
    1: def ll_pdf_page_transform_box(page, mediabox, ctm, box):
           r"""Low-level wrapper for `::pdf_page_transform_box()`."""
>>>>>>     return _mupdf.ll_pdf_page_transform_box(page, mediabox, ctm, box)
       
    1: def ll_pdf_page_write(doc, mediabox, presources, pcontents):
           r"""
            Low-level wrapper for `::pdf_page_write()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_page_write(::pdf_document *doc, ::fz_rect mediabox, ::pdf_obj **presources, ::fz_buffer **pcontents)` => `(fz_device *)`
           """
>>>>>>     return _mupdf.ll_pdf_page_write(doc, mediabox, presources, pcontents)
       
    1: def ll_pdf_parse_array(doc, f, buf):
           r"""Low-level wrapper for `::pdf_parse_array()`."""
>>>>>>     return _mupdf.ll_pdf_parse_array(doc, f, buf)
       
    1: def ll_pdf_parse_date(s):
           r"""Low-level wrapper for `::pdf_parse_date()`."""
>>>>>>     return _mupdf.ll_pdf_parse_date(s)
       
    1: def ll_pdf_parse_default_appearance(da, font, size, n, color):
           r"""
            Low-level wrapper for `::pdf_parse_default_appearance()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_parse_default_appearance(const char *da, float color[4])` => `(const char *font, float size, int n)`
           """
>>>>>>     return _mupdf.ll_pdf_parse_default_appearance(da, font, size, n, color)
       
    1: def ll_pdf_parse_default_appearance_unmapped(da, font_name, font_name_len, size, n, color):
           r"""
            Low-level wrapper for `::pdf_parse_default_appearance_unmapped()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_parse_default_appearance_unmapped(const char *da, char *font_name, int font_name_len, float color[4])` => `(float size, int n)`
           """
>>>>>>     return _mupdf.ll_pdf_parse_default_appearance_unmapped(da, font_name, font_name_len, size, n, color)
       
    1: def ll_pdf_parse_dict(doc, f, buf):
           r"""Low-level wrapper for `::pdf_parse_dict()`."""
>>>>>>     return _mupdf.ll_pdf_parse_dict(doc, f, buf)
       
    1: def ll_pdf_parse_ind_obj(doc, f, num, gen, stm_ofs, try_repair):
           r"""
            Low-level wrapper for `::pdf_parse_ind_obj()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_parse_ind_obj(::pdf_document *doc, ::fz_stream *f)` => `(pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair)`
           """
>>>>>>     return _mupdf.ll_pdf_parse_ind_obj(doc, f, num, gen, stm_ofs, try_repair)
       
    1: def ll_pdf_parse_journal_obj(doc, stm, onum, ostm, newobj):
           r"""
            Low-level wrapper for `::pdf_parse_journal_obj()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_parse_journal_obj(::pdf_document *doc, ::fz_stream *stm, ::fz_buffer **ostm)` => `(pdf_obj *, int onum, int newobj)`
           """
>>>>>>     return _mupdf.ll_pdf_parse_journal_obj(doc, stm, onum, ostm, newobj)
       
    1: def ll_pdf_parse_stm_obj(doc, f, buf):
           r"""Low-level wrapper for `::pdf_parse_stm_obj()`."""
>>>>>>     return _mupdf.ll_pdf_parse_stm_obj(doc, f, buf)
       
    1: def ll_pdf_parse_write_options(opts, args):
           r"""Low-level wrapper for `::pdf_parse_write_options()`."""
>>>>>>     return _mupdf.ll_pdf_parse_write_options(opts, args)
       
    1: def ll_pdf_pin_document(obj):
           r"""Low-level wrapper for `::pdf_pin_document()`."""
>>>>>>     return _mupdf.ll_pdf_pin_document(obj)
       
    1: def ll_pdf_preview_signature_as_display_list(w, h, lang, signer, appearance_flags, graphic, reason, location):
           r"""Low-level wrapper for `::pdf_preview_signature_as_display_list()`."""
>>>>>>     return _mupdf.ll_pdf_preview_signature_as_display_list(w, h, lang, signer, appearance_flags, graphic, reason, location)
       
    1: def ll_pdf_preview_signature_as_pixmap(w, h, lang, signer, appearance_flags, graphic, reason, location):
           r"""Low-level wrapper for `::pdf_preview_signature_as_pixmap()`."""
>>>>>>     return _mupdf.ll_pdf_preview_signature_as_pixmap(w, h, lang, signer, appearance_flags, graphic, reason, location)
       
    1: def ll_pdf_print_crypt(out, crypt):
           r"""Low-level wrapper for `::pdf_print_crypt()`."""
>>>>>>     return _mupdf.ll_pdf_print_crypt(out, crypt)
       
    1: def ll_pdf_print_default_appearance(buf, nbuf, font, size, n, color):
           r"""Low-level wrapper for `::pdf_print_default_appearance()`."""
>>>>>>     return _mupdf.ll_pdf_print_default_appearance(buf, nbuf, font, size, n, color)
       
    1: def ll_pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen, sep):
           r"""
            Low-level wrapper for `::pdf_print_encrypted_obj()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_print_encrypted_obj(::fz_output *out, ::pdf_obj *obj, int tight, int ascii, ::pdf_crypt *crypt, int num, int gen)` => int sep
           """
>>>>>>     return _mupdf.ll_pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen, sep)
       
    1: def ll_pdf_print_font(out, fontdesc):
           r"""Low-level wrapper for `::pdf_print_font()`."""
>>>>>>     return _mupdf.ll_pdf_print_font(out, fontdesc)
       
    1: def ll_pdf_print_obj(out, obj, tight, ascii):
           r"""Low-level wrapper for `::pdf_print_obj()`."""
>>>>>>     return _mupdf.ll_pdf_print_obj(out, obj, tight, ascii)
       
    1: def ll_pdf_process_annot(proc, annot, cookie):
           r"""Low-level wrapper for `::pdf_process_annot()`."""
>>>>>>     return _mupdf.ll_pdf_process_annot(proc, annot, cookie)
       
    1: def ll_pdf_process_contents(proc, doc, res, stm, cookie, out_res):
           r"""
            Low-level wrapper for `::pdf_process_contents()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_process_contents(::pdf_processor *proc, ::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, ::fz_cookie *cookie, ::pdf_obj **out_res)` =>
           """
>>>>>>     return _mupdf.ll_pdf_process_contents(proc, doc, res, stm, cookie, out_res)
       
    1: def ll_pdf_process_glyph(proc, doc, resources, contents):
           r"""Low-level wrapper for `::pdf_process_glyph()`."""
>>>>>>     return _mupdf.ll_pdf_process_glyph(proc, doc, resources, contents)
       
    1: def ll_pdf_process_raw_contents(proc, doc, stmobj, cookie):
           r"""Low-level wrapper for `::pdf_process_raw_contents()`."""
>>>>>>     return _mupdf.ll_pdf_process_raw_contents(proc, doc, stmobj, cookie)
       
    1: def ll_pdf_processor_pop_resources(proc):
           r"""Low-level wrapper for `::pdf_processor_pop_resources()`."""
>>>>>>     return _mupdf.ll_pdf_processor_pop_resources(proc)
       
    1: def ll_pdf_processor_push_resources(proc, res):
           r"""Low-level wrapper for `::pdf_processor_push_resources()`."""
>>>>>>     return _mupdf.ll_pdf_processor_push_resources(proc, res)
       
    1: def ll_pdf_progressive_advance(doc, pagenum):
           r"""Low-level wrapper for `::pdf_progressive_advance()`."""
>>>>>>     return _mupdf.ll_pdf_progressive_advance(doc, pagenum)
       
    1: def ll_pdf_purge_local_resources(doc):
           r"""Low-level wrapper for `::pdf_purge_local_resources()`."""
>>>>>>     return _mupdf.ll_pdf_purge_local_resources(doc)
       
    1: def ll_pdf_purge_locals_from_store(doc):
           r"""Low-level wrapper for `::pdf_purge_locals_from_store()`."""
>>>>>>     return _mupdf.ll_pdf_purge_locals_from_store(doc)
       
    1: def ll_pdf_purge_object_from_store(doc, num):
           r"""Low-level wrapper for `::pdf_purge_object_from_store()`."""
>>>>>>     return _mupdf.ll_pdf_purge_object_from_store(doc, num)
       
    1: def ll_pdf_read_journal(doc, stm):
           r"""Low-level wrapper for `::pdf_read_journal()`."""
>>>>>>     return _mupdf.ll_pdf_read_journal(doc, stm)
       
    1: def ll_pdf_read_ocg(doc):
           r"""Low-level wrapper for `::pdf_read_ocg()`."""
>>>>>>     return _mupdf.ll_pdf_read_ocg(doc)
       
    1: def ll_pdf_rearrange_pages(doc, count, pages, structure):
           r"""Low-level wrapper for `::pdf_rearrange_pages()`."""
>>>>>>     return _mupdf.ll_pdf_rearrange_pages(doc, count, pages, structure)
       
    1: def ll_pdf_rearrange_pages2(doc, pages, structure):
           r"""Low-level wrapper for `::pdf_rearrange_pages2()`.  Swig-friendly wrapper for pdf_rearrange_pages()."""
>>>>>>     return _mupdf.ll_pdf_rearrange_pages2(doc, pages, structure)
       
    1: def ll_pdf_recolor_page(doc, pagenum, opts):
           r"""Low-level wrapper for `::pdf_recolor_page()`."""
>>>>>>     return _mupdf.ll_pdf_recolor_page(doc, pagenum, opts)
       
    1: def ll_pdf_recolor_shade(shade, reshade, opaque):
           r"""
           Low-level wrapper for `::pdf_recolor_shade()`.
           Recolor a shade.
           """
>>>>>>     return _mupdf.ll_pdf_recolor_shade(shade, reshade, opaque)
       
    1: def ll_pdf_redact_page(doc, page, opts):
           r"""Low-level wrapper for `::pdf_redact_page()`."""
>>>>>>     return _mupdf.ll_pdf_redact_page(doc, page, opts)
       
    1: def ll_pdf_redo(doc):
           r"""Low-level wrapper for `::pdf_redo()`."""
>>>>>>     return _mupdf.ll_pdf_redo(doc)
       
    1: def ll_pdf_remove_item(drop, key):
           r"""Low-level wrapper for `::pdf_remove_item()`."""
>>>>>>     return _mupdf.ll_pdf_remove_item(drop, key)
       
    1: def ll_pdf_remove_output_intents(doc):
           r"""Low-level wrapper for `::pdf_remove_output_intents()`."""
>>>>>>     return _mupdf.ll_pdf_remove_output_intents(doc)
       
    1: def ll_pdf_repair_obj(doc, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root):
           r"""
            Low-level wrapper for `::pdf_repair_obj()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_repair_obj(::pdf_document *doc, ::pdf_lexbuf *buf, ::pdf_obj **encrypt, ::pdf_obj **id, ::pdf_obj **page, ::pdf_obj **root)` => `(int, int64_t stmofsp, int64_t stmlenp, int64_t tmpofs)`
           """
>>>>>>     return _mupdf.ll_pdf_repair_obj(doc, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root)
       
    1: def ll_pdf_repair_xref(doc):
           r"""Low-level wrapper for `::pdf_repair_xref()`."""
>>>>>>     return _mupdf.ll_pdf_repair_xref(doc)
       
    1: def ll_pdf_replace_xref(doc, entries, n):
           r"""Low-level wrapper for `::pdf_replace_xref()`."""
>>>>>>     return _mupdf.ll_pdf_replace_xref(doc, entries, n)
       
    1: def ll_pdf_reset_form(doc, fields, exclude):
           r"""Low-level wrapper for `::pdf_reset_form()`."""
>>>>>>     return _mupdf.ll_pdf_reset_form(doc, fields, exclude)
       
    1: def ll_pdf_reset_processor(proc):
           r"""Low-level wrapper for `::pdf_reset_processor()`."""
>>>>>>     return _mupdf.ll_pdf_reset_processor(proc)
       
    1: def ll_pdf_resolve_indirect(ref):
           r"""
           Low-level wrapper for `::pdf_resolve_indirect()`.
           Resolve an indirect object (or chain of objects).
       
           This can cause xref reorganisations (solidifications etc) due to
           repairs, so all held pdf_xref_entries should be considered
           invalid after this call (other than the returned one).
           """
>>>>>>     return _mupdf.ll_pdf_resolve_indirect(ref)
       
    1: def ll_pdf_resolve_indirect_chain(ref):
           r"""Low-level wrapper for `::pdf_resolve_indirect_chain()`."""
>>>>>>     return _mupdf.ll_pdf_resolve_indirect_chain(ref)
       
    1: def ll_pdf_resolve_link(doc, uri, xp, yp):
           r"""
            Low-level wrapper for `::pdf_resolve_link()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_resolve_link(::pdf_document *doc, const char *uri)` => `(int, float xp, float yp)`
           """
>>>>>>     return _mupdf.ll_pdf_resolve_link(doc, uri, xp, yp)
       
    1: def ll_pdf_resolve_link_dest(doc, uri):
           r"""Low-level wrapper for `::pdf_resolve_link_dest()`."""
>>>>>>     return _mupdf.ll_pdf_resolve_link_dest(doc, uri)
       
    1: def ll_pdf_rewrite_images(doc, opts):
           r"""Low-level wrapper for `::pdf_rewrite_images()`."""
>>>>>>     return _mupdf.ll_pdf_rewrite_images(doc, opts)
       
    1: def ll_pdf_run_annot(annot, dev, ctm, cookie):
           r"""Low-level wrapper for `::pdf_run_annot()`."""
>>>>>>     return _mupdf.ll_pdf_run_annot(annot, dev, ctm, cookie)
       
    1: def ll_pdf_run_document_structure(doc, dev, cookie):
           r"""Low-level wrapper for `::pdf_run_document_structure()`."""
>>>>>>     return _mupdf.ll_pdf_run_document_structure(doc, dev, cookie)
       
    1: def ll_pdf_run_glyph(doc, resources, contents, dev, ctm, gstate, default_cs, fill_gstate, stroke_gstate):
           r"""Low-level wrapper for `::pdf_run_glyph()`."""
>>>>>>     return _mupdf.ll_pdf_run_glyph(doc, resources, contents, dev, ctm, gstate, default_cs, fill_gstate, stroke_gstate)
       
    1: def ll_pdf_run_page(page, dev, ctm, cookie):
           r"""Low-level wrapper for `::pdf_run_page()`."""
>>>>>>     return _mupdf.ll_pdf_run_page(page, dev, ctm, cookie)
       
    1: def ll_pdf_run_page_annots(page, dev, ctm, cookie):
           r"""Low-level wrapper for `::pdf_run_page_annots()`."""
>>>>>>     return _mupdf.ll_pdf_run_page_annots(page, dev, ctm, cookie)
       
    1: def ll_pdf_run_page_annots_with_usage(page, dev, ctm, usage, cookie):
           r"""Low-level wrapper for `::pdf_run_page_annots_with_usage()`."""
>>>>>>     return _mupdf.ll_pdf_run_page_annots_with_usage(page, dev, ctm, usage, cookie)
       
    1: def ll_pdf_run_page_contents(page, dev, ctm, cookie):
           r"""Low-level wrapper for `::pdf_run_page_contents()`."""
>>>>>>     return _mupdf.ll_pdf_run_page_contents(page, dev, ctm, cookie)
       
    1: def ll_pdf_run_page_contents_with_usage(page, dev, ctm, usage, cookie):
           r"""Low-level wrapper for `::pdf_run_page_contents_with_usage()`."""
>>>>>>     return _mupdf.ll_pdf_run_page_contents_with_usage(page, dev, ctm, usage, cookie)
       
    1: def ll_pdf_run_page_widgets(page, dev, ctm, cookie):
           r"""Low-level wrapper for `::pdf_run_page_widgets()`."""
>>>>>>     return _mupdf.ll_pdf_run_page_widgets(page, dev, ctm, cookie)
       
    1: def ll_pdf_run_page_widgets_with_usage(page, dev, ctm, usage, cookie):
           r"""Low-level wrapper for `::pdf_run_page_widgets_with_usage()`."""
>>>>>>     return _mupdf.ll_pdf_run_page_widgets_with_usage(page, dev, ctm, usage, cookie)
       
    1: def ll_pdf_run_page_with_usage(page, dev, ctm, usage, cookie):
           r"""Low-level wrapper for `::pdf_run_page_with_usage()`."""
>>>>>>     return _mupdf.ll_pdf_run_page_with_usage(page, dev, ctm, usage, cookie)
       
    1: def ll_pdf_sample_shade_function(samples, n, funcs, func, t0, t1):
           r"""
            Low-level wrapper for `::pdf_sample_shade_function()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_sample_shade_function(int n, int funcs, ::pdf_function **func, float t0, float t1)` => `(float samples)`
           """
>>>>>>     return _mupdf.ll_pdf_sample_shade_function(samples, n, funcs, func, t0, t1)
       
    1: def ll_pdf_save_document(doc, filename, opts):
           r"""Low-level wrapper for `::pdf_save_document()`."""
>>>>>>     return _mupdf.ll_pdf_save_document(doc, filename, opts)
       
    1: def ll_pdf_save_journal(doc, filename):
           r"""Low-level wrapper for `::pdf_save_journal()`."""
>>>>>>     return _mupdf.ll_pdf_save_journal(doc, filename)
       
    1: def ll_pdf_save_snapshot(doc, filename):
           r"""Low-level wrapper for `::pdf_save_snapshot()`."""
>>>>>>     return _mupdf.ll_pdf_save_snapshot(doc, filename)
       
    1: def ll_pdf_select_layer_config(doc, config_num):
           r"""Low-level wrapper for `::pdf_select_layer_config()`."""
>>>>>>     return _mupdf.ll_pdf_select_layer_config(doc, config_num)
       
    1: def ll_pdf_select_layer_config_ui(doc, ui):
           r"""Low-level wrapper for `::pdf_select_layer_config_ui()`."""
>>>>>>     return _mupdf.ll_pdf_select_layer_config_ui(doc, ui)
       
    1: def ll_pdf_serialise_journal(doc, out):
           r"""Low-level wrapper for `::pdf_serialise_journal()`."""
>>>>>>     return _mupdf.ll_pdf_serialise_journal(doc, out)
       
    1: def ll_pdf_set_annot_active(annot, active):
           r"""Low-level wrapper for `::pdf_set_annot_active()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_active(annot, active)
       
    1: def ll_pdf_set_annot_appearance(annot, appearance, state, ctm, bbox, res, contents):
           r"""Low-level wrapper for `::pdf_set_annot_appearance()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_appearance(annot, appearance, state, ctm, bbox, res, contents)
       
    1: def ll_pdf_set_annot_appearance_from_display_list(annot, appearance, state, ctm, list):
           r"""Low-level wrapper for `::pdf_set_annot_appearance_from_display_list()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_appearance_from_display_list(annot, appearance, state, ctm, list)
       
    1: def ll_pdf_set_annot_author(annot, author):
           r"""Low-level wrapper for `::pdf_set_annot_author()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_author(annot, author)
       
    1: def ll_pdf_set_annot_border(annot, width):
           r"""Low-level wrapper for `::pdf_set_annot_border()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_border(annot, width)
       
    1: def ll_pdf_set_annot_border_effect(annot, effect):
           r"""Low-level wrapper for `::pdf_set_annot_border_effect()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_border_effect(annot, effect)
       
    1: def ll_pdf_set_annot_border_effect_intensity(annot, intensity):
           r"""Low-level wrapper for `::pdf_set_annot_border_effect_intensity()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_border_effect_intensity(annot, intensity)
       
    1: def ll_pdf_set_annot_border_style(annot, style):
           r"""Low-level wrapper for `::pdf_set_annot_border_style()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_border_style(annot, style)
       
    1: def ll_pdf_set_annot_border_width(annot, width):
           r"""Low-level wrapper for `::pdf_set_annot_border_width()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_border_width(annot, width)
       
    1: def ll_pdf_set_annot_callout_line(annot, callout, n):
           r"""Low-level wrapper for `::pdf_set_annot_callout_line()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_callout_line(annot, callout, n)
       
    1: def ll_pdf_set_annot_callout_line2(annot, callout):
           r"""Low-level wrapper for `::pdf_set_annot_callout_line2()`.  SWIG-friendly wrapper for pdf_set_annot_callout_line()."""
>>>>>>     return _mupdf.ll_pdf_set_annot_callout_line2(annot, callout)
       
    1: def ll_pdf_set_annot_callout_point(annot, p):
           r"""Low-level wrapper for `::pdf_set_annot_callout_point()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_callout_point(annot, p)
       
    1: def ll_pdf_set_annot_callout_style(annot, style):
           r"""Low-level wrapper for `::pdf_set_annot_callout_style()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_callout_style(annot, style)
       
    1: def ll_pdf_set_annot_color(annot, n, color):
           r"""Low-level wrapper for `::pdf_set_annot_color()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_color(annot, n, color)
       
    1: def ll_pdf_set_annot_contents(annot, text):
           r"""Low-level wrapper for `::pdf_set_annot_contents()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_contents(annot, text)
       
    1: def ll_pdf_set_annot_creation_date(annot, time):
           r"""Low-level wrapper for `::pdf_set_annot_creation_date()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_creation_date(annot, time)
       
    1: def ll_pdf_set_annot_default_appearance(annot, font, size, n, color):
           r"""Low-level wrapper for `::pdf_set_annot_default_appearance()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_default_appearance(annot, font, size, n, color)
       
    1: def ll_pdf_set_annot_field_value(doc, widget, text, ignore_trigger_events):
           r"""Low-level wrapper for `::pdf_set_annot_field_value()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_field_value(doc, widget, text, ignore_trigger_events)
       
    1: def ll_pdf_set_annot_filespec(annot, obj):
           r"""Low-level wrapper for `::pdf_set_annot_filespec()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_filespec(annot, obj)
       
    1: def ll_pdf_set_annot_flags(annot, flags):
           r"""Low-level wrapper for `::pdf_set_annot_flags()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_flags(annot, flags)
       
    1: def ll_pdf_set_annot_hidden_for_editing(annot, hidden):
           r"""Low-level wrapper for `::pdf_set_annot_hidden_for_editing()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_hidden_for_editing(annot, hidden)
       
    1: def ll_pdf_set_annot_hot(annot, hot):
           r"""Low-level wrapper for `::pdf_set_annot_hot()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_hot(annot, hot)
       
    1: def ll_pdf_set_annot_icon_name(annot, name):
           r"""Low-level wrapper for `::pdf_set_annot_icon_name()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_icon_name(annot, name)
       
    1: def ll_pdf_set_annot_ink_list(annot, n, count, v):
           r"""Low-level wrapper for `::pdf_set_annot_ink_list()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_ink_list(annot, n, count, v)
       
    1: def ll_pdf_set_annot_intent(annot, it):
           r"""Low-level wrapper for `::pdf_set_annot_intent()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_intent(annot, it)
       
    1: def ll_pdf_set_annot_interior_color(annot, n, color):
           r"""Low-level wrapper for `::pdf_set_annot_interior_color()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_interior_color(annot, n, color)
       
    1: def ll_pdf_set_annot_is_open(annot, is_open):
           r"""Low-level wrapper for `::pdf_set_annot_is_open()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_is_open(annot, is_open)
       
    1: def ll_pdf_set_annot_language(annot, lang):
           r"""Low-level wrapper for `::pdf_set_annot_language()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_language(annot, lang)
       
    1: def ll_pdf_set_annot_line(annot, a, b):
           r"""Low-level wrapper for `::pdf_set_annot_line()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_line(annot, a, b)
       
    1: def ll_pdf_set_annot_line_caption(annot, cap):
           r"""Low-level wrapper for `::pdf_set_annot_line_caption()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_line_caption(annot, cap)
       
    1: def ll_pdf_set_annot_line_caption_offset(annot, offset):
           r"""Low-level wrapper for `::pdf_set_annot_line_caption_offset()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_line_caption_offset(annot, offset)
       
    1: def ll_pdf_set_annot_line_end_style(annot, e):
           r"""Low-level wrapper for `::pdf_set_annot_line_end_style()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_line_end_style(annot, e)
       
    1: def ll_pdf_set_annot_line_ending_styles(annot, start_style, end_style):
           r"""Low-level wrapper for `::pdf_set_annot_line_ending_styles()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_line_ending_styles(annot, start_style, end_style)
       
    1: def ll_pdf_set_annot_line_leader(annot, ll):
           r"""Low-level wrapper for `::pdf_set_annot_line_leader()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_line_leader(annot, ll)
       
    1: def ll_pdf_set_annot_line_leader_extension(annot, lle):
           r"""Low-level wrapper for `::pdf_set_annot_line_leader_extension()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_line_leader_extension(annot, lle)
       
    1: def ll_pdf_set_annot_line_leader_offset(annot, llo):
           r"""Low-level wrapper for `::pdf_set_annot_line_leader_offset()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_line_leader_offset(annot, llo)
       
    1: def ll_pdf_set_annot_line_start_style(annot, s):
           r"""Low-level wrapper for `::pdf_set_annot_line_start_style()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_line_start_style(annot, s)
       
    1: def ll_pdf_set_annot_modification_date(annot, time):
           r"""Low-level wrapper for `::pdf_set_annot_modification_date()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_modification_date(annot, time)
       
    1: def ll_pdf_set_annot_opacity(annot, opacity):
           r"""Low-level wrapper for `::pdf_set_annot_opacity()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_opacity(annot, opacity)
       
    1: def ll_pdf_set_annot_popup(annot, rect):
           r"""Low-level wrapper for `::pdf_set_annot_popup()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_popup(annot, rect)
       
    1: def ll_pdf_set_annot_quad_points(annot, n, qv):
           r"""Low-level wrapper for `::pdf_set_annot_quad_points()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_quad_points(annot, n, qv)
       
    1: def ll_pdf_set_annot_quadding(annot, q):
           r"""Low-level wrapper for `::pdf_set_annot_quadding()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_quadding(annot, q)
       
    1: def ll_pdf_set_annot_rect(annot, rect):
           r"""Low-level wrapper for `::pdf_set_annot_rect()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_rect(annot, rect)
       
    1: def ll_pdf_set_annot_resynthesised(annot):
           r"""Low-level wrapper for `::pdf_set_annot_resynthesised()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_resynthesised(annot)
       
    1: def ll_pdf_set_annot_rich_contents(annot, plain, rich):
           r"""Low-level wrapper for `::pdf_set_annot_rich_contents()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_rich_contents(annot, plain, rich)
       
    1: def ll_pdf_set_annot_rich_defaults(annot, style):
           r"""Low-level wrapper for `::pdf_set_annot_rich_defaults()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_rich_defaults(annot, style)
       
    1: def ll_pdf_set_annot_stamp_image(annot, image):
           r"""Low-level wrapper for `::pdf_set_annot_stamp_image()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_stamp_image(annot, image)
       
    1: def ll_pdf_set_annot_stamp_image_obj(annot, ref):
           r"""Low-level wrapper for `::pdf_set_annot_stamp_image_obj()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_stamp_image_obj(annot, ref)
       
    1: def ll_pdf_set_annot_vertex(annot, i, p):
           r"""Low-level wrapper for `::pdf_set_annot_vertex()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_vertex(annot, i, p)
       
    1: def ll_pdf_set_annot_vertices(annot, n, v):
           r"""Low-level wrapper for `::pdf_set_annot_vertices()`."""
>>>>>>     return _mupdf.ll_pdf_set_annot_vertices(annot, n, v)
       
    1: def ll_pdf_set_choice_field_value(widget, value):
           r"""Low-level wrapper for `::pdf_set_choice_field_value()`."""
>>>>>>     return _mupdf.ll_pdf_set_choice_field_value(widget, value)
       
    1: def ll_pdf_set_cmap_wmode(cmap, wmode):
           r"""Low-level wrapper for `::pdf_set_cmap_wmode()`."""
>>>>>>     return _mupdf.ll_pdf_set_cmap_wmode(cmap, wmode)
       
    1: def ll_pdf_set_default_hmtx(font, w):
           r"""Low-level wrapper for `::pdf_set_default_hmtx()`."""
>>>>>>     return _mupdf.ll_pdf_set_default_hmtx(font, w)
       
    1: def ll_pdf_set_default_vmtx(font, y, w):
           r"""Low-level wrapper for `::pdf_set_default_vmtx()`."""
>>>>>>     return _mupdf.ll_pdf_set_default_vmtx(font, y, w)
       
    1: def ll_pdf_set_doc_event_callback(doc, event_cb, free_event_data_cb, data):
           r"""Low-level wrapper for `::pdf_set_doc_event_callback()`."""
>>>>>>     return _mupdf.ll_pdf_set_doc_event_callback(doc, event_cb, free_event_data_cb, data)
       
    1: def ll_pdf_set_document_language(doc, lang):
           r"""Low-level wrapper for `::pdf_set_document_language()`."""
>>>>>>     return _mupdf.ll_pdf_set_document_language(doc, lang)
       
    1: def ll_pdf_set_field_value(doc, field, text, ignore_trigger_events):
           r"""Low-level wrapper for `::pdf_set_field_value()`."""
>>>>>>     return _mupdf.ll_pdf_set_field_value(doc, field, text, ignore_trigger_events)
       
    1: def ll_pdf_set_font_wmode(font, wmode):
           r"""Low-level wrapper for `::pdf_set_font_wmode()`."""
>>>>>>     return _mupdf.ll_pdf_set_font_wmode(font, wmode)
       
    1: def ll_pdf_set_int(obj, i):
           r"""Low-level wrapper for `::pdf_set_int()`."""
>>>>>>     return _mupdf.ll_pdf_set_int(obj, i)
       
    1: def ll_pdf_set_layer_config_as_default(doc):
           r"""Low-level wrapper for `::pdf_set_layer_config_as_default()`."""
>>>>>>     return _mupdf.ll_pdf_set_layer_config_as_default(doc)
       
    1: def ll_pdf_set_obj_memo(obj, bit, memo):
           r"""Low-level wrapper for `::pdf_set_obj_memo()`."""
>>>>>>     return _mupdf.ll_pdf_set_obj_memo(obj, bit, memo)
       
    1: def ll_pdf_set_obj_parent(obj, num):
           r"""Low-level wrapper for `::pdf_set_obj_parent()`."""
>>>>>>     return _mupdf.ll_pdf_set_obj_parent(obj, num)
       
    1: def ll_pdf_set_page_box(page, box, rect):
           r"""Low-level wrapper for `::pdf_set_page_box()`."""
>>>>>>     return _mupdf.ll_pdf_set_page_box(page, box, rect)
       
    1: def ll_pdf_set_page_labels(doc, index, style, prefix, start):
           r"""Low-level wrapper for `::pdf_set_page_labels()`."""
>>>>>>     return _mupdf.ll_pdf_set_page_labels(doc, index, style, prefix, start)
       
    1: def ll_pdf_set_populating_xref_trailer(doc, trailer):
           r"""Low-level wrapper for `::pdf_set_populating_xref_trailer()`."""
>>>>>>     return _mupdf.ll_pdf_set_populating_xref_trailer(doc, trailer)
       
    1: def ll_pdf_set_str_len(obj, newlen):
           r"""Low-level wrapper for `::pdf_set_str_len()`."""
>>>>>>     return _mupdf.ll_pdf_set_str_len(obj, newlen)
       
    1: def ll_pdf_set_text_field_value(widget, value):
           r"""Low-level wrapper for `::pdf_set_text_field_value()`."""
>>>>>>     return _mupdf.ll_pdf_set_text_field_value(widget, value)
       
    1: def ll_pdf_set_usecmap(cmap, usecmap):
           r"""Low-level wrapper for `::pdf_set_usecmap()`."""
>>>>>>     return _mupdf.ll_pdf_set_usecmap(cmap, usecmap)
       
    1: def ll_pdf_set_widget_editing_state(widget, editing):
           r"""Low-level wrapper for `::pdf_set_widget_editing_state()`."""
>>>>>>     return _mupdf.ll_pdf_set_widget_editing_state(widget, editing)
       
    1: def ll_pdf_sign_signature(widget, signer, appearance_flags, graphic, reason, location):
           r"""Low-level wrapper for `::pdf_sign_signature()`."""
>>>>>>     return _mupdf.ll_pdf_sign_signature(widget, signer, appearance_flags, graphic, reason, location)
       
    1: def ll_pdf_sign_signature_with_appearance(widget, signer, date, disp_list):
           r"""Low-level wrapper for `::pdf_sign_signature_with_appearance()`."""
>>>>>>     return _mupdf.ll_pdf_sign_signature_with_appearance(widget, signer, date, disp_list)
       
    1: def ll_pdf_signature_appearance_signed(rect, lang, img, left_text, right_text, include_logo):
           r"""Low-level wrapper for `::pdf_signature_appearance_signed()`."""
>>>>>>     return _mupdf.ll_pdf_signature_appearance_signed(rect, lang, img, left_text, right_text, include_logo)
       
    1: def ll_pdf_signature_appearance_unsigned(rect, lang):
           r"""Low-level wrapper for `::pdf_signature_appearance_unsigned()`."""
>>>>>>     return _mupdf.ll_pdf_signature_appearance_unsigned(rect, lang)
       
    1: def ll_pdf_signature_byte_range(doc, signature, byte_range):
           r"""Low-level wrapper for `::pdf_signature_byte_range()`."""
>>>>>>     return _mupdf.ll_pdf_signature_byte_range(doc, signature, byte_range)
       
    1: def ll_pdf_signature_contents(doc, signature, contents):
           r"""
            Low-level wrapper for `::pdf_signature_contents()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_signature_contents(::pdf_document *doc, ::pdf_obj *signature)` => `(size_t, char *contents)`
           """
>>>>>>     return _mupdf.ll_pdf_signature_contents(doc, signature, contents)
       
    1: def ll_pdf_signature_drop_distinguished_name(name):
           r"""Low-level wrapper for `::pdf_signature_drop_distinguished_name()`."""
>>>>>>     return _mupdf.ll_pdf_signature_drop_distinguished_name(name)
       
    1: def ll_pdf_signature_error_description(err):
           r"""Low-level wrapper for `::pdf_signature_error_description()`."""
>>>>>>     return _mupdf.ll_pdf_signature_error_description(err)
       
    1: def ll_pdf_signature_format_distinguished_name(name):
           r"""Low-level wrapper for `::pdf_signature_format_distinguished_name()`."""
>>>>>>     return _mupdf.ll_pdf_signature_format_distinguished_name(name)
       
    1: def ll_pdf_signature_get_signatory(verifier, doc, signature):
           r"""Low-level wrapper for `::pdf_signature_get_signatory()`."""
>>>>>>     return _mupdf.ll_pdf_signature_get_signatory(verifier, doc, signature)
       
    1: def ll_pdf_signature_get_widget_signatory(verifier, widget):
           r"""Low-level wrapper for `::pdf_signature_get_widget_signatory()`."""
>>>>>>     return _mupdf.ll_pdf_signature_get_widget_signatory(verifier, widget)
       
    1: def ll_pdf_signature_hash_bytes(doc, signature):
           r"""Low-level wrapper for `::pdf_signature_hash_bytes()`."""
>>>>>>     return _mupdf.ll_pdf_signature_hash_bytes(doc, signature)
       
    1: def ll_pdf_signature_incremental_change_since_signing(doc, signature):
           r"""Low-level wrapper for `::pdf_signature_incremental_change_since_signing()`."""
>>>>>>     return _mupdf.ll_pdf_signature_incremental_change_since_signing(doc, signature)
       
    1: def ll_pdf_signature_info(name, dn, reason, location, date, include_labels):
           r"""Low-level wrapper for `::pdf_signature_info()`."""
>>>>>>     return _mupdf.ll_pdf_signature_info(name, dn, reason, location, date, include_labels)
       
    1: def ll_pdf_signature_is_signed(doc, field):
           r"""Low-level wrapper for `::pdf_signature_is_signed()`."""
>>>>>>     return _mupdf.ll_pdf_signature_is_signed(doc, field)
       
    1: def ll_pdf_signature_set_value(doc, field, signer, stime):
           r"""Low-level wrapper for `::pdf_signature_set_value()`."""
>>>>>>     return _mupdf.ll_pdf_signature_set_value(doc, field, signer, stime)
       
    1: def ll_pdf_sort_cmap(cmap):
           r"""Low-level wrapper for `::pdf_sort_cmap()`."""
>>>>>>     return _mupdf.ll_pdf_sort_cmap(cmap)
       
    1: def ll_pdf_sort_dict(dict):
           r"""Low-level wrapper for `::pdf_sort_dict()`."""
>>>>>>     return _mupdf.ll_pdf_sort_dict(dict)
       
    1: def ll_pdf_specifics(doc):
           r"""Low-level wrapper for `::pdf_specifics()`."""
>>>>>>     return _mupdf.ll_pdf_specifics(doc)
       
    1: def ll_pdf_sprint_obj(buf, cap, len, obj, tight, ascii):
           r"""
            Low-level wrapper for `::pdf_sprint_obj()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_sprint_obj(char *buf, size_t cap, ::pdf_obj *obj, int tight, int ascii)` => `(char *, size_t len)`
           """
>>>>>>     return _mupdf.ll_pdf_sprint_obj(buf, cap, len, obj, tight, ascii)
       
    1: def ll_pdf_store_item(key, val, itemsize):
           r"""Low-level wrapper for `::pdf_store_item()`."""
>>>>>>     return _mupdf.ll_pdf_store_item(key, val, itemsize)
       
    1: def ll_pdf_string_from_annot_type(type):
           r"""Low-level wrapper for `::pdf_string_from_annot_type()`."""
>>>>>>     return _mupdf.ll_pdf_string_from_annot_type(type)
       
    1: def ll_pdf_string_from_intent(intent):
           r"""Low-level wrapper for `::pdf_string_from_intent()`."""
>>>>>>     return _mupdf.ll_pdf_string_from_intent(intent)
       
    1: def ll_pdf_string_from_line_ending(end):
           r"""Low-level wrapper for `::pdf_string_from_line_ending()`."""
>>>>>>     return _mupdf.ll_pdf_string_from_line_ending(end)
       
    1: def ll_pdf_structure_type(role_map, tag):
           r"""Low-level wrapper for `::pdf_structure_type()`."""
>>>>>>     return _mupdf.ll_pdf_structure_type(role_map, tag)
       
    1: def ll_pdf_subset_fonts(doc, pages_len, pages):
           r"""Low-level wrapper for `::pdf_subset_fonts()`."""
>>>>>>     return _mupdf.ll_pdf_subset_fonts(doc, pages_len, pages)
       
    1: def ll_pdf_subset_fonts2(doc, pages):
           r"""Low-level wrapper for `::pdf_subset_fonts2()`.  Swig-friendly wrapper for pdf_subset_fonts()."""
>>>>>>     return _mupdf.ll_pdf_subset_fonts2(doc, pages)
       
    1: def ll_pdf_sync_annots(page):
           r"""Low-level wrapper for `::pdf_sync_annots()`."""
>>>>>>     return _mupdf.ll_pdf_sync_annots(page)
       
    1: def ll_pdf_sync_links(page):
           r"""Low-level wrapper for `::pdf_sync_links()`."""
>>>>>>     return _mupdf.ll_pdf_sync_links(page)
       
    1: def ll_pdf_sync_open_pages(doc):
           r"""Low-level wrapper for `::pdf_sync_open_pages()`."""
>>>>>>     return _mupdf.ll_pdf_sync_open_pages(doc)
       
    1: def ll_pdf_sync_page(page):
           r"""Low-level wrapper for `::pdf_sync_page()`."""
>>>>>>     return _mupdf.ll_pdf_sync_page(page)
       
    1: def ll_pdf_text_widget_format(tw):
           r"""Low-level wrapper for `::pdf_text_widget_format()`."""
>>>>>>     return _mupdf.ll_pdf_text_widget_format(tw)
       
    1: def ll_pdf_text_widget_max_len(tw):
           r"""Low-level wrapper for `::pdf_text_widget_max_len()`."""
>>>>>>     return _mupdf.ll_pdf_text_widget_max_len(tw)
       
    1: def ll_pdf_to_bool(obj):
           r"""Low-level wrapper for `::pdf_to_bool()`."""
>>>>>>     return _mupdf.ll_pdf_to_bool(obj)
       
    1: def ll_pdf_to_bool_default(obj, _def):
           r"""Low-level wrapper for `::pdf_to_bool_default()`."""
>>>>>>     return _mupdf.ll_pdf_to_bool_default(obj, _def)
       
    1: def ll_pdf_to_date(time):
           r"""Low-level wrapper for `::pdf_to_date()`."""
>>>>>>     return _mupdf.ll_pdf_to_date(time)
       
    1: def ll_pdf_to_gen(obj):
           r"""Low-level wrapper for `::pdf_to_gen()`."""
>>>>>>     return _mupdf.ll_pdf_to_gen(obj)
       
    1: def ll_pdf_to_int(obj):
           r"""Low-level wrapper for `::pdf_to_int()`."""
>>>>>>     return _mupdf.ll_pdf_to_int(obj)
       
    1: def ll_pdf_to_int64(obj):
           r"""Low-level wrapper for `::pdf_to_int64()`."""
>>>>>>     return _mupdf.ll_pdf_to_int64(obj)
       
    1: def ll_pdf_to_int_default(obj, _def):
           r"""Low-level wrapper for `::pdf_to_int_default()`."""
>>>>>>     return _mupdf.ll_pdf_to_int_default(obj, _def)
       
    1: def ll_pdf_to_matrix(array):
           r"""Low-level wrapper for `::pdf_to_matrix()`."""
>>>>>>     return _mupdf.ll_pdf_to_matrix(array)
       
    1: def ll_pdf_to_name(obj):
           r"""Low-level wrapper for `::pdf_to_name()`."""
>>>>>>     return _mupdf.ll_pdf_to_name(obj)
       
    1: def ll_pdf_to_num(obj):
           r"""Low-level wrapper for `::pdf_to_num()`."""
>>>>>>     return _mupdf.ll_pdf_to_num(obj)
       
    1: def ll_pdf_to_point(array, offset):
           r"""Low-level wrapper for `::pdf_to_point()`."""
>>>>>>     return _mupdf.ll_pdf_to_point(array, offset)
       
    1: def ll_pdf_to_quad(array, offset):
           r"""Low-level wrapper for `::pdf_to_quad()`."""
>>>>>>     return _mupdf.ll_pdf_to_quad(array, offset)
       
    1: def ll_pdf_to_real(obj):
           r"""Low-level wrapper for `::pdf_to_real()`."""
>>>>>>     return _mupdf.ll_pdf_to_real(obj)
       
    1: def ll_pdf_to_real_default(obj, _def):
           r"""Low-level wrapper for `::pdf_to_real_default()`."""
>>>>>>     return _mupdf.ll_pdf_to_real_default(obj, _def)
       
    1: def ll_pdf_to_rect(array):
           r"""Low-level wrapper for `::pdf_to_rect()`."""
>>>>>>     return _mupdf.ll_pdf_to_rect(array)
       
    1: def ll_pdf_to_str_buf(obj):
           r"""Low-level wrapper for `::pdf_to_str_buf()`."""
>>>>>>     return _mupdf.ll_pdf_to_str_buf(obj)
       
    1: def ll_pdf_to_str_len(obj):
           r"""Low-level wrapper for `::pdf_to_str_len()`."""
>>>>>>     return _mupdf.ll_pdf_to_str_len(obj)
       
    1: def ll_pdf_to_string(obj, sizep):
           r"""
            Low-level wrapper for `::pdf_to_string()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_to_string(::pdf_obj *obj)` => `(const char *, size_t sizep)`
           """
>>>>>>     return _mupdf.ll_pdf_to_string(obj, sizep)
       
    1: def ll_pdf_to_text_string(obj):
           r"""Low-level wrapper for `::pdf_to_text_string()`."""
>>>>>>     return _mupdf.ll_pdf_to_text_string(obj)
       
    1: def ll_pdf_toggle_layer_config_ui(doc, ui):
           r"""Low-level wrapper for `::pdf_toggle_layer_config_ui()`."""
>>>>>>     return _mupdf.ll_pdf_toggle_layer_config_ui(doc, ui)
       
    1: def ll_pdf_toggle_widget(widget):
           r"""Low-level wrapper for `::pdf_toggle_widget()`."""
>>>>>>     return _mupdf.ll_pdf_toggle_widget(widget)
       
    1: def ll_pdf_tos_get_text(tos):
           r"""Low-level wrapper for `::pdf_tos_get_text()`."""
>>>>>>     return _mupdf.ll_pdf_tos_get_text(tos)
       
    1: def ll_pdf_tos_make_trm(tos, text, fontdesc, cid, trm, adv):
           r"""
            Low-level wrapper for `::pdf_tos_make_trm()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_tos_make_trm(::pdf_text_object_state *tos, ::pdf_text_state *text, ::pdf_font_desc *fontdesc, int cid, ::fz_matrix *trm)` => `(int, float adv)`
           """
>>>>>>     return _mupdf.ll_pdf_tos_make_trm(tos, text, fontdesc, cid, trm, adv)
       
    1: def ll_pdf_tos_move_after_char(tos):
           r"""Low-level wrapper for `::pdf_tos_move_after_char()`."""
>>>>>>     return _mupdf.ll_pdf_tos_move_after_char(tos)
       
    1: def ll_pdf_tos_newline(tos, leading):
           r"""Low-level wrapper for `::pdf_tos_newline()`."""
>>>>>>     return _mupdf.ll_pdf_tos_newline(tos, leading)
       
    1: def ll_pdf_tos_reset(tos, render):
           r"""Low-level wrapper for `::pdf_tos_reset()`."""
>>>>>>     return _mupdf.ll_pdf_tos_reset(tos, render)
       
    1: def ll_pdf_tos_restore(tos, save):
           r"""Low-level wrapper for `::pdf_tos_restore()`."""
>>>>>>     return _mupdf.ll_pdf_tos_restore(tos, save)
       
    1: def ll_pdf_tos_save(tos, save):
           r"""Low-level wrapper for `::pdf_tos_save()`."""
>>>>>>     return _mupdf.ll_pdf_tos_save(tos, save)
       
    1: def ll_pdf_tos_set_matrix(tos, a, b, c, d, e, f):
           r"""Low-level wrapper for `::pdf_tos_set_matrix()`."""
>>>>>>     return _mupdf.ll_pdf_tos_set_matrix(tos, a, b, c, d, e, f)
       
    1: def ll_pdf_tos_translate(tos, tx, ty):
           r"""Low-level wrapper for `::pdf_tos_translate()`."""
>>>>>>     return _mupdf.ll_pdf_tos_translate(tos, tx, ty)
       
    1: def ll_pdf_trailer(doc):
           r"""Low-level wrapper for `::pdf_trailer()`."""
>>>>>>     return _mupdf.ll_pdf_trailer(doc)
       
    1: def ll_pdf_undo(doc):
           r"""Low-level wrapper for `::pdf_undo()`."""
>>>>>>     return _mupdf.ll_pdf_undo(doc)
       
    1: def ll_pdf_undoredo_state(doc, steps):
           r"""
            Low-level wrapper for `::pdf_undoredo_state()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_undoredo_state(::pdf_document *doc)` => `(int, int steps)`
           """
>>>>>>     return _mupdf.ll_pdf_undoredo_state(doc, steps)
       
    1: def ll_pdf_undoredo_step(doc, step):
           r"""Low-level wrapper for `::pdf_undoredo_step()`."""
>>>>>>     return _mupdf.ll_pdf_undoredo_step(doc, step)
       
    1: def ll_pdf_unmark_obj(obj):
           r"""Low-level wrapper for `::pdf_unmark_obj()`."""
>>>>>>     return _mupdf.ll_pdf_unmark_obj(obj)
       
    1: def ll_pdf_update_annot(annot):
           r"""Low-level wrapper for `::pdf_update_annot()`."""
>>>>>>     return _mupdf.ll_pdf_update_annot(annot)
       
    1: def ll_pdf_update_default_colorspaces(old_cs, res):
           r"""Low-level wrapper for `::pdf_update_default_colorspaces()`."""
>>>>>>     return _mupdf.ll_pdf_update_default_colorspaces(old_cs, res)
       
    1: def ll_pdf_update_object(doc, num, obj):
           r"""Low-level wrapper for `::pdf_update_object()`."""
>>>>>>     return _mupdf.ll_pdf_update_object(doc, num, obj)
       
    1: def ll_pdf_update_page(page):
           r"""Low-level wrapper for `::pdf_update_page()`."""
>>>>>>     return _mupdf.ll_pdf_update_page(page)
       
    1: def ll_pdf_update_stream(doc, ref, buf, compressed):
           r"""Low-level wrapper for `::pdf_update_stream()`."""
>>>>>>     return _mupdf.ll_pdf_update_stream(doc, ref, buf, compressed)
       
    1: def ll_pdf_update_widget(widget):
           r"""Low-level wrapper for `::pdf_update_widget()`."""
>>>>>>     return _mupdf.ll_pdf_update_widget(widget)
       
    1: def ll_pdf_update_xobject(doc, xobj, bbox, mat, res, buffer):
           r"""Low-level wrapper for `::pdf_update_xobject()`."""
>>>>>>     return _mupdf.ll_pdf_update_xobject(doc, xobj, bbox, mat, res, buffer)
       
    1: def ll_pdf_validate_change_history(doc):
           r"""Low-level wrapper for `::pdf_validate_change_history()`."""
>>>>>>     return _mupdf.ll_pdf_validate_change_history(doc)
       
    1: def ll_pdf_validate_changes(doc, version):
           r"""Low-level wrapper for `::pdf_validate_changes()`."""
>>>>>>     return _mupdf.ll_pdf_validate_changes(doc, version)
       
    1: def ll_pdf_validate_signature(widget):
           r"""Low-level wrapper for `::pdf_validate_signature()`."""
>>>>>>     return _mupdf.ll_pdf_validate_signature(widget)
       
    1: def ll_pdf_verify_embedded_file_checksum(fs):
           r"""Low-level wrapper for `::pdf_verify_embedded_file_checksum()`."""
>>>>>>     return _mupdf.ll_pdf_verify_embedded_file_checksum(fs)
       
    1: def ll_pdf_version(doc):
           r"""Low-level wrapper for `::pdf_version()`."""
>>>>>>     return _mupdf.ll_pdf_version(doc)
       
    1: def ll_pdf_walk_tree(tree, kid_name, arrive, leave, arg, names, values):
           r"""
            Low-level wrapper for `::pdf_walk_tree()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_walk_tree(::pdf_obj *tree, ::pdf_obj *kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, ::pdf_obj **names, ::pdf_obj **values)` => `()`
           """
>>>>>>     return _mupdf.ll_pdf_walk_tree(tree, kid_name, arrive, leave, arg, names, values)
       
    1: def ll_pdf_was_pure_xfa(doc):
           r"""Low-level wrapper for `::pdf_was_pure_xfa()`."""
>>>>>>     return _mupdf.ll_pdf_was_pure_xfa(doc)
       
    1: def ll_pdf_was_repaired(doc):
           r"""Low-level wrapper for `::pdf_was_repaired()`."""
>>>>>>     return _mupdf.ll_pdf_was_repaired(doc)
       
    1: def ll_pdf_widget_is_readonly(widget):
           r"""Low-level wrapper for `::pdf_widget_is_readonly()`."""
>>>>>>     return _mupdf.ll_pdf_widget_is_readonly(widget)
       
    1: def ll_pdf_widget_is_signed(widget):
           r"""Low-level wrapper for `::pdf_widget_is_signed()`."""
>>>>>>     return _mupdf.ll_pdf_widget_is_signed(widget)
       
    1: def ll_pdf_widget_type(widget):
           r"""Low-level wrapper for `::pdf_widget_type()`."""
>>>>>>     return _mupdf.ll_pdf_widget_type(widget)
       
    1: def ll_pdf_write_digest(out, byte_range, field, digest_offset, digest_length, signer):
           r"""Low-level wrapper for `::pdf_write_digest()`."""
>>>>>>     return _mupdf.ll_pdf_write_digest(out, byte_range, field, digest_offset, digest_length, signer)
       
    1: def ll_pdf_write_document(doc, out, opts):
           r"""Low-level wrapper for `::pdf_write_document()`."""
>>>>>>     return _mupdf.ll_pdf_write_document(doc, out, opts)
       
    1: def ll_pdf_write_journal(doc, out):
           r"""Low-level wrapper for `::pdf_write_journal()`."""
>>>>>>     return _mupdf.ll_pdf_write_journal(doc, out)
       
    1: def ll_pdf_write_snapshot(doc, out):
           r"""Low-level wrapper for `::pdf_write_snapshot()`."""
>>>>>>     return _mupdf.ll_pdf_write_snapshot(doc, out)
       
    1: def ll_pdf_xobject_bbox(xobj):
           r"""Low-level wrapper for `::pdf_xobject_bbox()`."""
>>>>>>     return _mupdf.ll_pdf_xobject_bbox(xobj)
       
    1: def ll_pdf_xobject_colorspace(xobj):
           r"""Low-level wrapper for `::pdf_xobject_colorspace()`."""
>>>>>>     return _mupdf.ll_pdf_xobject_colorspace(xobj)
       
    1: def ll_pdf_xobject_isolated(xobj):
           r"""Low-level wrapper for `::pdf_xobject_isolated()`."""
>>>>>>     return _mupdf.ll_pdf_xobject_isolated(xobj)
       
    1: def ll_pdf_xobject_knockout(xobj):
           r"""Low-level wrapper for `::pdf_xobject_knockout()`."""
>>>>>>     return _mupdf.ll_pdf_xobject_knockout(xobj)
       
    1: def ll_pdf_xobject_matrix(xobj):
           r"""Low-level wrapper for `::pdf_xobject_matrix()`."""
>>>>>>     return _mupdf.ll_pdf_xobject_matrix(xobj)
       
    1: def ll_pdf_xobject_resources(xobj):
           r"""Low-level wrapper for `::pdf_xobject_resources()`."""
>>>>>>     return _mupdf.ll_pdf_xobject_resources(xobj)
       
    1: def ll_pdf_xobject_transparency(xobj):
           r"""Low-level wrapper for `::pdf_xobject_transparency()`."""
>>>>>>     return _mupdf.ll_pdf_xobject_transparency(xobj)
       
    1: def ll_pdf_xref_ensure_incremental_object(doc, num):
           r"""Low-level wrapper for `::pdf_xref_ensure_incremental_object()`."""
>>>>>>     return _mupdf.ll_pdf_xref_ensure_incremental_object(doc, num)
       
    1: def ll_pdf_xref_ensure_local_object(doc, num):
           r"""Low-level wrapper for `::pdf_xref_ensure_local_object()`."""
>>>>>>     return _mupdf.ll_pdf_xref_ensure_local_object(doc, num)
       
    1: def ll_pdf_xref_entry_map(doc, fn, arg):
           r"""Low-level wrapper for `::pdf_xref_entry_map()`."""
>>>>>>     return _mupdf.ll_pdf_xref_entry_map(doc, fn, arg)
       
    1: def ll_pdf_xref_is_incremental(doc, num):
           r"""Low-level wrapper for `::pdf_xref_is_incremental()`."""
>>>>>>     return _mupdf.ll_pdf_xref_is_incremental(doc, num)
       
    1: def ll_pdf_xref_len(doc):
           r"""Low-level wrapper for `::pdf_xref_len()`."""
>>>>>>     return _mupdf.ll_pdf_xref_len(doc)
       
    1: def ll_pdf_xref_obj_is_unsaved_signature(doc, obj):
           r"""Low-level wrapper for `::pdf_xref_obj_is_unsaved_signature()`."""
>>>>>>     return _mupdf.ll_pdf_xref_obj_is_unsaved_signature(doc, obj)
       
    1: def ll_pdf_xref_remove_unsaved_signature(doc, field):
           r"""Low-level wrapper for `::pdf_xref_remove_unsaved_signature()`."""
>>>>>>     return _mupdf.ll_pdf_xref_remove_unsaved_signature(doc, field)
       
    1: def ll_pdf_xref_store_unsaved_signature(doc, field, signer):
           r"""Low-level wrapper for `::pdf_xref_store_unsaved_signature()`."""
>>>>>>     return _mupdf.ll_pdf_xref_store_unsaved_signature(doc, field, signer)
       
    1: def ll_pdf_zugferd_profile(doc, version):
           r"""
            Low-level wrapper for `::pdf_zugferd_profile()`.
       
           This function has out-params. Python/C# wrappers look like:
               `ll_pdf_zugferd_profile(::pdf_document *doc)` => `(enum pdf_zugferd_profile, float version)`
           """
>>>>>>     return _mupdf.ll_pdf_zugferd_profile(doc, version)
       
    1: def ll_pdf_zugferd_profile_to_string(profile):
           r"""Low-level wrapper for `::pdf_zugferd_profile_to_string()`."""
>>>>>>     return _mupdf.ll_pdf_zugferd_profile_to_string(profile)
       
    1: def ll_pdf_zugferd_xml(doc):
           r"""Low-level wrapper for `::pdf_zugferd_xml()`."""
>>>>>>     return _mupdf.ll_pdf_zugferd_xml(doc)
       
    1: def to_string_fz_aa_context(s):
           r"""Returns string containing a fz_aa_context's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_aa_context(s)
       
    1: def to_string_fz_color_params(s):
           r"""Returns string containing a fz_color_params's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_color_params(s)
       
    1: def to_string_fz_cookie(s):
           r"""Returns string containing a fz_cookie's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_cookie(s)
       
    1: def to_string_fz_draw_options(s):
           r"""Returns string containing a fz_draw_options's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_draw_options(s)
       
    1: def to_string_fz_install_load_system_font_funcs_args(s):
           r"""Returns string containing a fz_install_load_system_font_funcs_args's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_install_load_system_font_funcs_args(s)
       
    1: def to_string_fz_irect(s):
           r"""Returns string containing a fz_irect's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_irect(s)
       
    1: def to_string_fz_location(s):
           r"""Returns string containing a fz_location's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_location(s)
       
    1: def to_string_fz_matrix(s):
           r"""Returns string containing a fz_matrix's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_matrix(s)
       
    1: def to_string_fz_md5(s):
           r"""Returns string containing a fz_md5's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_md5(s)
       
    1: def to_string_fz_outline_item(s):
           r"""Returns string containing a fz_outline_item's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_outline_item(s)
       
    1: def to_string_fz_pdfocr_options(s):
           r"""Returns string containing a fz_pdfocr_options's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_pdfocr_options(s)
       
    1: def to_string_fz_point(s):
           r"""Returns string containing a fz_point's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_point(s)
       
    1: def to_string_fz_pwg_options(s):
           r"""Returns string containing a fz_pwg_options's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_pwg_options(s)
       
    1: def to_string_fz_quad(s):
           r"""Returns string containing a fz_quad's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_quad(s)
       
    1: def to_string_fz_rect(s):
           r"""Returns string containing a fz_rect's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_rect(s)
       
    1: def to_string_fz_stext_options(s):
           r"""Returns string containing a fz_stext_options's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_stext_options(s)
       
    1: def to_string_fz_story_element_position(s):
           r"""Returns string containing a fz_story_element_position's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_story_element_position(s)
       
    1: def to_string_fz_transition(s):
           r"""Returns string containing a fz_transition's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_fz_transition(s)
       
    1: def to_string_pdf_clean_options(s):
           r"""Returns string containing a pdf_clean_options's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_pdf_clean_options(s)
       
    1: def to_string_pdf_filter_factory(s):
           r"""Returns string containing a pdf_filter_factory's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_pdf_filter_factory(s)
       
    1: def to_string_pdf_filter_options(s):
           r"""Returns string containing a pdf_filter_options's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_pdf_filter_options(s)
       
    1: def to_string_pdf_image_rewriter_options(s):
           r"""Returns string containing a pdf_image_rewriter_options's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_pdf_image_rewriter_options(s)
       
    1: def to_string_pdf_layer_config(s):
           r"""Returns string containing a pdf_layer_config's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_pdf_layer_config(s)
       
    1: def to_string_pdf_layer_config_ui(s):
           r"""Returns string containing a pdf_layer_config_ui's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_pdf_layer_config_ui(s)
       
    1: def to_string_pdf_recolor_options(s):
           r"""Returns string containing a pdf_recolor_options's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_pdf_recolor_options(s)
       
    1: def to_string_pdf_redact_options(s):
           r"""Returns string containing a pdf_redact_options's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_pdf_redact_options(s)
       
    1: def to_string_pdf_sanitize_filter_options(s):
           r"""Returns string containing a pdf_sanitize_filter_options's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_pdf_sanitize_filter_options(s)
       
    1: def to_string_pdf_write_options(s):
           r"""Returns string containing a pdf_write_options's members, labelled and inside (...), using operator<<."""
>>>>>>     return _mupdf.to_string_pdf_write_options(s)
       
    1: def to_string(*args):
           r"""
           *Overload 1:*
            Returns string containing a fz_aa_context's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 2:*
            Returns string containing a fz_color_params's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 3:*
            Returns string containing a fz_cookie's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 4:*
            Returns string containing a fz_draw_options's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 5:*
            Returns string containing a fz_install_load_system_font_funcs_args's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 6:*
            Returns string containing a fz_irect's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 7:*
            Returns string containing a fz_location's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 8:*
            Returns string containing a fz_matrix's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 9:*
            Returns string containing a fz_md5's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 10:*
            Returns string containing a fz_outline_item's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 11:*
            Returns string containing a fz_pdfocr_options's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 12:*
            Returns string containing a fz_point's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 13:*
            Returns string containing a fz_pwg_options's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 14:*
            Returns string containing a fz_quad's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 15:*
            Returns string containing a fz_rect's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 16:*
            Returns string containing a fz_stext_options's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 17:*
            Returns string containing a fz_story_element_position's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 18:*
            Returns string containing a fz_transition's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 19:*
            Returns string containing a pdf_clean_options's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 20:*
            Returns string containing a pdf_filter_factory's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 21:*
            Returns string containing a pdf_filter_options's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 22:*
            Returns string containing a pdf_image_rewriter_options's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 23:*
            Returns string containing a pdf_layer_config's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 24:*
            Returns string containing a pdf_layer_config_ui's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 25:*
            Returns string containing a pdf_recolor_options's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 26:*
            Returns string containing a pdf_redact_options's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 27:*
            Returns string containing a pdf_sanitize_filter_options's members, labelled and inside (...), using operator<<.
           (Convenience overload).
       
           |
       
           *Overload 28:*
            Returns string containing a pdf_write_options's members, labelled and inside (...), using operator<<.
           (Convenience overload).
           """
>>>>>>     return _mupdf.to_string(*args)
       
    1: def reinit_singlethreaded():
           r"""
            Reinitializes the MuPDF context for single-threaded use, which
           is slightly faster when calling code is single threaded.
       
           This should be called before any other use of MuPDF.
           """
    1:     return _mupdf.reinit_singlethreaded()
    2: class FzAaContext(object):
    1:     r"""Wrapper class for struct `fz_aa_context`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_aa_context`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_aa_context`.
               """
>>>>>>         _mupdf.FzAaContext_swiginit(self, _mupdf.new_FzAaContext(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.FzAaContext_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_FzAaContext
    1:     hscale = property(_mupdf.FzAaContext_hscale_get, _mupdf.FzAaContext_hscale_set)
    1:     vscale = property(_mupdf.FzAaContext_vscale_get, _mupdf.FzAaContext_vscale_set)
    1:     scale = property(_mupdf.FzAaContext_scale_get, _mupdf.FzAaContext_scale_set)
    1:     bits = property(_mupdf.FzAaContext_bits_get, _mupdf.FzAaContext_bits_set)
    1:     text_bits = property(_mupdf.FzAaContext_text_bits_get, _mupdf.FzAaContext_text_bits_set)
    1:     min_line_width = property(_mupdf.FzAaContext_min_line_width_get, _mupdf.FzAaContext_min_line_width_set)
    1:     s_num_instances = property(_mupdf.FzAaContext_s_num_instances_get, _mupdf.FzAaContext_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzAaContext_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzAaContext___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzAaContext___ne__(self, rhs)
       
       # Register FzAaContext in _mupdf:
    1: _mupdf.FzAaContext_swigregister(FzAaContext)
    1: metadata_keys = cvar.metadata_keys
       
    2: class FzActivityContext(object):
    1:     r"""Wrapper class for struct `fz_activity_context`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_activity_context`.
               """
>>>>>>         _mupdf.FzActivityContext_swiginit(self, _mupdf.new_FzActivityContext(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzActivityContext
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzActivityContext_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzActivityContext___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzActivityContext_m_internal_get, _mupdf.FzActivityContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzActivityContext_s_num_instances_get, _mupdf.FzActivityContext_s_num_instances_set)
       
       # Register FzActivityContext in _mupdf:
    1: _mupdf.FzActivityContext_swigregister(FzActivityContext)
    2: class FzAes(object):
    1:     r"""
           Wrapper class for struct `fz_aes`. Not copyable or assignable.
           Structure definitions are public to enable stack
           based allocation. Do not access the members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_aes_crypt_cbc(self, mode, length, iv, input, output):
               r"""
               Class-aware wrapper for `::fz_aes_crypt_cbc()`.
                       AES block processing. Encrypts or Decrypts (according to mode,
                       which must match what was initially set up) length bytes (which
                       must be a multiple of 16), using (and modifying) the insertion
                       vector iv, reading from input, and writing to output.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzAes_fz_aes_crypt_cbc(self, mode, length, iv, input, output)
       
    1:     def fz_aes_setkey_dec(self, key, keysize):
               r"""
               Class-aware wrapper for `::fz_aes_setkey_dec()`.
                       AES decryption initialization. Fills in the supplied context
                       and prepares for decryption using the given key.
       
                       Returns non-zero for error (key size other than 128/192/256).
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzAes_fz_aes_setkey_dec(self, key, keysize)
       
    1:     def fz_aes_setkey_enc(self, key, keysize):
               r"""
               Class-aware wrapper for `::fz_aes_setkey_enc()`.
                       AES encryption initialization. Fills in the supplied context
                       and prepares for encryption using the given key.
       
                       Returns non-zero for error (key size other than 128/192/256).
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzAes_fz_aes_setkey_enc(self, key, keysize)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_aes`.
               """
>>>>>>         _mupdf.FzAes_swiginit(self, _mupdf.new_FzAes(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzAes
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzAes_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzAes___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzAes_m_internal_get, _mupdf.FzAes_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzAes_s_num_instances_get, _mupdf.FzAes_s_num_instances_set)
       
       # Register FzAes in _mupdf:
    1: _mupdf.FzAes_swigregister(FzAes)
    2: class FzAllocContext(object):
    1:     r"""
           Wrapper class for struct `fz_alloc_context`. Not copyable or assignable.
           Allocator structure; holds callbacks and private data pointer.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_alloc_context`.
               """
>>>>>>         _mupdf.FzAllocContext_swiginit(self, _mupdf.new_FzAllocContext(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzAllocContext
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzAllocContext_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzAllocContext___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzAllocContext_m_internal_get, _mupdf.FzAllocContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzAllocContext_s_num_instances_get, _mupdf.FzAllocContext_s_num_instances_set)
       
       # Register FzAllocContext in _mupdf:
    1: _mupdf.FzAllocContext_swigregister(FzAllocContext)
    2: class FzArc4(object):
    1:     r"""
           Wrapper class for struct `fz_arc4`. Not copyable or assignable.
           Structure definition is public to enable stack
           based allocation. Do not access the members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_arc4_encrypt(self, dest, src, len):
               r"""
               Class-aware wrapper for `::fz_arc4_encrypt()`.
                       RC4 block encrypt operation; encrypt src into dst (both of
                       length len) updating the RC4 state as we go.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzArc4_fz_arc4_encrypt(self, dest, src, len)
       
    1:     def fz_arc4_final(self):
               r"""
               Class-aware wrapper for `::fz_arc4_final()`.
                       RC4 finalization. Zero the context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzArc4_fz_arc4_final(self)
       
    1:     def fz_arc4_init(self, key, len):
               r"""
               Class-aware wrapper for `::fz_arc4_init()`.
                       RC4 initialization. Begins an RC4 operation, writing a new
                       context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzArc4_fz_arc4_init(self, key, len)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_arc4`.
               """
>>>>>>         _mupdf.FzArc4_swiginit(self, _mupdf.new_FzArc4(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzArc4
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzArc4_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzArc4___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzArc4_m_internal_get, _mupdf.FzArc4_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzArc4_s_num_instances_get, _mupdf.FzArc4_s_num_instances_set)
       
       # Register FzArc4 in _mupdf:
    1: _mupdf.FzArc4_swigregister(FzArc4)
    2: class FzArchive(object):
    1:     r"""
           Wrapper class for struct `fz_archive`.
           fz_archive:
       
           fz_archive provides methods for accessing "archive" files.
           An archive file is a conceptual entity that contains multiple
           files, which can be counted, enumerated, and read.
       
           Implementations of fz_archive based upon directories, zip
           and tar files are included.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_archive_format(self):
               r"""
               Class-aware wrapper for `::fz_archive_format()`.
                       Return a pointer to a string describing the format of the
                       archive.
       
                       The lifetime of the string is unspecified (in current
                       implementations the string will persist until the archive
                       is closed, but this is not guaranteed).
               """
>>>>>>         return _mupdf.FzArchive_fz_archive_format(self)
       
    1:     def fz_count_archive_entries(self):
               r"""
               Class-aware wrapper for `::fz_count_archive_entries()`.
                       Number of entries in archive.
       
                       Will always return a value >= 0.
       
                       May throw an exception if this type of archive cannot count the
                       entries (such as a directory).
               """
>>>>>>         return _mupdf.FzArchive_fz_count_archive_entries(self)
       
    1:     def fz_has_archive_entry(self, name):
               r"""
               Class-aware wrapper for `::fz_has_archive_entry()`.
                       Check if entry by given name exists.
       
                       If named entry does not exist 0 will be returned, if it does
                       exist 1 is returned.
       
                       name: Entry name to look for, this must be an exact match to
                       the entry name in the archive.
               """
>>>>>>         return _mupdf.FzArchive_fz_has_archive_entry(self, name)
       
    1:     def fz_list_archive_entry(self, idx):
               r"""
               Class-aware wrapper for `::fz_list_archive_entry()`.
                       Get listed name of entry position idx.
       
                       idx: Must be a value >= 0 < return value from
                       fz_count_archive_entries. If not in range NULL will be
                       returned.
       
                       May throw an exception if this type of archive cannot list the
                       entries (such as a directory).
               """
>>>>>>         return _mupdf.FzArchive_fz_list_archive_entry(self, idx)
       
    1:     def fz_mount_multi_archive(self, sub, path):
               r"""
               Class-aware wrapper for `::fz_mount_multi_archive()`.
                       Add an archive to the set of archives handled by a multi
                       archive.
       
                       If path is NULL, then the archive contents will appear at the
                       top level, otherwise, the archives contents will appear prefixed
                       by path.
               """
>>>>>>         return _mupdf.FzArchive_fz_mount_multi_archive(self, sub, path)
       
    1:     def fz_open_archive_entry(self, name):
               r"""
               Class-aware wrapper for `::fz_open_archive_entry()`.
                       Opens an archive entry as a stream.
       
                       name: Entry name to look for, this must be an exact match to
                       the entry name in the archive.
       
                       Throws an exception if a matching entry cannot be found.
               """
>>>>>>         return _mupdf.FzArchive_fz_open_archive_entry(self, name)
       
    1:     def fz_parse_xml_archive_entry(self, filename, preserve_white):
               r"""
               Class-aware wrapper for `::fz_parse_xml_archive_entry()`.
                       Parse the contents of an archive entry into a tree of xml nodes.
       
                       preserve_white: whether to keep or delete all-whitespace nodes.
               """
>>>>>>         return _mupdf.FzArchive_fz_parse_xml_archive_entry(self, filename, preserve_white)
       
    1:     def fz_read_archive_entry(self, name):
               r"""
               Class-aware wrapper for `::fz_read_archive_entry()`.
                       Reads all bytes in an archive entry
                       into a buffer.
       
                       name: Entry name to look for, this must be an exact match to
                       the entry name in the archive.
       
                       Throws an exception if a matching entry cannot be found.
               """
>>>>>>         return _mupdf.FzArchive_fz_read_archive_entry(self, name)
       
    1:     def fz_tree_archive_add_buffer(self, name, buf):
               r"""
               Class-aware wrapper for `::fz_tree_archive_add_buffer()`.
                       Add a named buffer to an existing tree archive.
       
                       The tree will take a new reference to the buffer. Ownership
                       is not transferred.
               """
>>>>>>         return _mupdf.FzArchive_fz_tree_archive_add_buffer(self, name, buf)
       
    1:     def fz_tree_archive_add_data(self, name, data, size):
               r"""
               Class-aware wrapper for `::fz_tree_archive_add_data()`.
                       Add a named block of data to an existing tree archive.
       
                       The data will be copied into a buffer, and so the caller
                       may free it as soon as this returns.
               """
>>>>>>         return _mupdf.FzArchive_fz_tree_archive_add_data(self, name, data, size)
       
    1:     def fz_try_open_archive_entry(self, name):
               r"""
               Class-aware wrapper for `::fz_try_open_archive_entry()`.
                       Opens an archive entry as a stream.
       
                       Returns NULL if a matching entry cannot be found, otherwise
                       behaves exactly as fz_open_archive_entry.
               """
>>>>>>         return _mupdf.FzArchive_fz_try_open_archive_entry(self, name)
       
    1:     def fz_try_parse_xml_archive_entry(self, filename, preserve_white):
               r"""
               Class-aware wrapper for `::fz_try_parse_xml_archive_entry()`.
                       Try and parse the contents of an archive entry into a tree of xml nodes.
       
                       preserve_white: whether to keep or delete all-whitespace nodes.
       
                       Will return NULL if the archive entry can't be found. Otherwise behaves
                       the same as fz_parse_xml_archive_entry. May throw exceptions.
               """
>>>>>>         return _mupdf.FzArchive_fz_try_parse_xml_archive_entry(self, filename, preserve_white)
       
    1:     def fz_try_read_archive_entry(self, name):
               r"""
               Class-aware wrapper for `::fz_try_read_archive_entry()`.
                       Reads all bytes in an archive entry
                       into a buffer.
       
                       name: Entry name to look for, this must be an exact match to
                       the entry name in the archive.
       
                       Returns NULL if a matching entry cannot be found. Otherwise behaves
                       the same as fz_read_archive_entry. Exceptions may be thrown.
               """
>>>>>>         return _mupdf.FzArchive_fz_try_read_archive_entry(self, name)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_archive_of_size()`.
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_multi_archive()`.
                               Create a new multi archive (initially empty).
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_tree_archive()`.
                               Create an archive that holds named buffers.
       
                               tree can either be a preformed tree with fz_buffers as values,
                               or it can be NULL for an empty tree.
       
       
               |
       
               *Overload 4:*
                Copy constructor using `fz_keep_archive()`.
       
               |
       
               *Overload 5:*
                Constructor using raw copy of pre-existing `::fz_archive`.
               """
>>>>>>         _mupdf.FzArchive_swiginit(self, _mupdf.new_FzArchive(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzArchive
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzArchive_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzArchive___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzArchive_m_internal_get, _mupdf.FzArchive_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzArchive_s_num_instances_get, _mupdf.FzArchive_s_num_instances_set)
       
       # Register FzArchive in _mupdf:
    1: _mupdf.FzArchive_swigregister(FzArchive)
    2: class FzArchiveHandler(object):
    1:     r"""Wrapper class for struct `fz_archive_handler`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_register_archive_handler(self):
               r"""Class-aware wrapper for `::fz_register_archive_handler()`."""
>>>>>>         return _mupdf.FzArchiveHandler_fz_register_archive_handler(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_archive_handler`.
               """
>>>>>>         _mupdf.FzArchiveHandler_swiginit(self, _mupdf.new_FzArchiveHandler(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzArchiveHandler
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzArchiveHandler_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzArchiveHandler___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzArchiveHandler_m_internal_get, _mupdf.FzArchiveHandler_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzArchiveHandler_s_num_instances_get, _mupdf.FzArchiveHandler_s_num_instances_set)
       
       # Register FzArchiveHandler in _mupdf:
    1: _mupdf.FzArchiveHandler_swigregister(FzArchiveHandler)
    2: class FzArchiveHandlerContext(object):
    1:     r"""Wrapper class for struct `fz_archive_handler_context`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_archive_handler_context`.
               """
>>>>>>         _mupdf.FzArchiveHandlerContext_swiginit(self, _mupdf.new_FzArchiveHandlerContext(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzArchiveHandlerContext
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzArchiveHandlerContext_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzArchiveHandlerContext___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzArchiveHandlerContext_m_internal_get, _mupdf.FzArchiveHandlerContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzArchiveHandlerContext_s_num_instances_get, _mupdf.FzArchiveHandlerContext_s_num_instances_set)
       
       # Register FzArchiveHandlerContext in _mupdf:
    1: _mupdf.FzArchiveHandlerContext_swigregister(FzArchiveHandlerContext)
    2: class FzBandWriter(object):
    1:     r"""
           Wrapper class for struct `fz_band_writer`. Not copyable or assignable.
           fz_band_writer
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     MONO = _mupdf.FzBandWriter_MONO
    1:     COLOR = _mupdf.FzBandWriter_COLOR
    1:     PNG = _mupdf.FzBandWriter_PNG
    1:     PNM = _mupdf.FzBandWriter_PNM
    1:     PAM = _mupdf.FzBandWriter_PAM
    1:     PBM = _mupdf.FzBandWriter_PBM
    1:     PKM = _mupdf.FzBandWriter_PKM
    1:     PS = _mupdf.FzBandWriter_PS
    1:     PSD = _mupdf.FzBandWriter_PSD
       
    1:     def fz_close_band_writer(self):
               r"""
               Class-aware wrapper for `::fz_close_band_writer()`.
                       Finishes up the output and closes the band writer. After this
                       call no more headers or bands may be written.
               """
>>>>>>         return _mupdf.FzBandWriter_fz_close_band_writer(self)
       
    1:     def fz_pdfocr_band_writer_set_progress(self, progress_fn, progress_arg):
               r"""
               Class-aware wrapper for `::fz_pdfocr_band_writer_set_progress()`.
                       Set the progress callback for a pdfocr bandwriter.
               """
>>>>>>         return _mupdf.FzBandWriter_fz_pdfocr_band_writer_set_progress(self, progress_fn, progress_arg)
       
    1:     def fz_write_band(self, stride, band_height, samples):
               r"""
               Class-aware wrapper for `::fz_write_band()`.
                       Cause a band writer to write the next band
                       of data for an image.
       
                       stride: The byte offset from the first byte of the data
                       for a pixel to the first byte of the data for the same pixel
                       on the row below.
       
                       band_height: The number of lines in this band.
       
                       samples: Pointer to first byte of the data.
               """
>>>>>>         return _mupdf.FzBandWriter_fz_write_band(self, stride, band_height, samples)
       
    1:     def fz_write_header(self, w, h, n, alpha, xres, yres, pagenum, cs, seps):
               r"""
               Class-aware wrapper for `::fz_write_header()`.
                       Cause a band writer to write the header for
                       a banded image with the given properties/dimensions etc. This
                       also configures the bandwriter for the format of the data to be
                       passed in future calls.
       
                       w, h: Width and Height of the entire page.
       
                       n: Number of components (including spots and alphas).
       
                       alpha: Number of alpha components.
       
                       xres, yres: X and Y resolutions in dpi.
       
                       cs: Colorspace (NULL for bitmaps)
       
                       seps: Separation details (or NULL).
               """
>>>>>>         return _mupdf.FzBandWriter_fz_write_header(self, w, h, n, alpha, xres, yres, pagenum, cs, seps)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_band_writer_of_size()`.
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_color_pcl_band_writer()`.
                               Create a new band writer, outputting color pcl.
                        Constructor using `fz_new_mono_pcl_band_writer()`.
                               Create a new band writer, outputting monochrome pcl.
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_mono_pwg_band_writer()`.
                               Create a new monochrome pwg band writer.
       
       
               |
       
               *Overload 4:*
                Constructor using `fz_new_pam_band_writer()`.
                               Create a band writer targeting pnm (greyscale, rgb or cmyk,
                               with or without alpha).
                        Constructor using `fz_new_pbm_band_writer()`.
                               Create a new band writer, targeting pbm.
                        Constructor using `fz_new_pclm_band_writer()`.
                               Create a new band writer, outputting pclm
       
       
               |
       
               *Overload 5:*
                Constructor using `fz_new_pdfocr_band_writer()`.
                               Create a new band writer, outputting pdfocr.
       
                               Ownership of output stays with the caller, the band writer
                               borrows the reference. The caller must keep the output around
                               for the duration of the band writer, and then close/drop as
                               appropriate.
       
       
               |
       
               *Overload 6:*
                Constructor using `fz_new_pkm_band_writer()`.
                               Create a new pkm band writer for CMYK pixmaps.
                        Constructor using `fz_new_png_band_writer()`.
                               Create a new png band writer (greyscale or RGB, with or without
                               alpha).
       
       
               |
       
               *Overload 7:*
                Constructor using `fz_new_pnm_band_writer()`.
                               Create a band writer targeting pnm (greyscale or rgb, no
                               alpha).
                        Constructor using `fz_new_ps_band_writer()`.
                               Create a postscript band writer for gray, rgb, or cmyk, no
                               alpha.
                        Constructor using `fz_new_psd_band_writer()`.
                               Open a PSD band writer.
                        Constructor using `fz_new_pwg_band_writer()`.
                               Create a new color pwg band writer.
                        Constructor using fz_new_mono_pcl_band_writer() or fz_new_color_pcl_band_writer().
       
               |
       
               *Overload 8:*
                Constructor using fz_new_p*_band_writer().
       
               |
       
               *Overload 9:*
                Constructor using fz_new_mono_pwg_band_writer() or fz_new_pwg_band_writer().
       
               |
       
               *Overload 10:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 11:*
                Constructor using raw copy of pre-existing `::fz_band_writer`.
               """
>>>>>>         _mupdf.FzBandWriter_swiginit(self, _mupdf.new_FzBandWriter(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzBandWriter
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzBandWriter_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzBandWriter___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzBandWriter_m_internal_get, _mupdf.FzBandWriter_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzBandWriter_s_num_instances_get, _mupdf.FzBandWriter_s_num_instances_set)
       
       # Register FzBandWriter in _mupdf:
    1: _mupdf.FzBandWriter_swigregister(FzBandWriter)
    2: class FzBitmap(object):
    1:     r"""
           Wrapper class for struct `fz_bitmap`.
           Bitmaps have 1 bit per component. Only used for creating
           halftoned versions of contone buffers, and saving out. Samples
           are stored msb first, akin to pbms.
       
           The internals of this struct are considered implementation
           details and subject to change. Where possible, accessor
           functions should be used in preference.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_bitmap_details(self, w, h, n, stride):
               r"""
               Class-aware wrapper for `::fz_bitmap_details()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_bitmap_details()` => `(int w, int h, int n, int stride)`
       
                       Retrieve details of a given bitmap.
       
                       bitmap: The bitmap to query.
       
                       w: Pointer to storage to retrieve width (or NULL).
       
                       h: Pointer to storage to retrieve height (or NULL).
       
                       n: Pointer to storage to retrieve number of color components (or
                       NULL).
       
                       stride: Pointer to storage to retrieve bitmap stride (or NULL).
               """
>>>>>>         return _mupdf.FzBitmap_fz_bitmap_details(self, w, h, n, stride)
       
    1:     def fz_clear_bitmap(self):
               r"""
               Class-aware wrapper for `::fz_clear_bitmap()`.
                       Set the entire bitmap to 0.
       
                       Never throws exceptions.
               """
>>>>>>         return _mupdf.FzBitmap_fz_clear_bitmap(self)
       
    1:     def fz_invert_bitmap(self):
               r"""
               Class-aware wrapper for `::fz_invert_bitmap()`.
                       Invert bitmap.
       
                       Never throws exceptions.
               """
>>>>>>         return _mupdf.FzBitmap_fz_invert_bitmap(self)
       
    1:     def fz_save_bitmap_as_pbm(self, filename):
               r"""
               Class-aware wrapper for `::fz_save_bitmap_as_pbm()`.
                       Save a bitmap as a pbm.
               """
>>>>>>         return _mupdf.FzBitmap_fz_save_bitmap_as_pbm(self, filename)
       
    1:     def fz_save_bitmap_as_pcl(self, filename, append, pcl):
               r"""
               Class-aware wrapper for `::fz_save_bitmap_as_pcl()`.
                       Save a bitmap as mono PCL.
               """
>>>>>>         return _mupdf.FzBitmap_fz_save_bitmap_as_pcl(self, filename, append, pcl)
       
    1:     def fz_save_bitmap_as_pkm(self, filename):
               r"""
               Class-aware wrapper for `::fz_save_bitmap_as_pkm()`.
                       Save a CMYK bitmap as a pkm.
               """
>>>>>>         return _mupdf.FzBitmap_fz_save_bitmap_as_pkm(self, filename)
       
    1:     def fz_save_bitmap_as_pwg(self, filename, append, pwg):
               r"""
               Class-aware wrapper for `::fz_save_bitmap_as_pwg()`.
                       Save a bitmap as a PWG.
               """
>>>>>>         return _mupdf.FzBitmap_fz_save_bitmap_as_pwg(self, filename, append, pwg)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_bitmap()`.
                               Create a new bitmap.
       
                               w, h: Width and Height for the bitmap
       
                               n: Number of color components (assumed to be a divisor of 8)
       
                               xres, yres: X and Y resolutions (in pixels per inch).
       
                               Returns pointer to created bitmap structure. The bitmap
                               data is uninitialised.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_bitmap_from_image()`.
                               Make a bitmap from a pixmap and a halftone.
       
                               img: The image to generate from. Currently must be a single
                               color component with no alpha.
       
                               ht: The halftone to use. NULL implies the default halftone.
       
                               Returns the resultant bitmap. Throws exceptions in the case of
                               failure to allocate.
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_bitmap_from_pixmap()`.
                               Make a bitmap from a pixmap and a halftone.
       
                               pix: The pixmap to generate from. Currently must be a single
                               color component with no alpha.
       
                               ht: The halftone to use. NULL implies the default halftone.
       
                               Returns the resultant bitmap. Throws exceptions in the case of
                               failure to allocate.
       
       
               |
       
               *Overload 4:*
                Constructor using `fz_new_bitmap_from_pixmap_band()`.
                               Make a bitmap from a pixmap and a
                               halftone, allowing for the position of the pixmap within an
                               overall banded rendering.
       
                               pix: The pixmap to generate from. Currently must be a single
                               color component with no alpha.
       
                               ht: The halftone to use. NULL implies the default halftone.
       
                               band_start: Vertical offset within the overall banded rendering
                               (in pixels)
       
                               Returns the resultant bitmap. Throws exceptions in the case of
                               failure to allocate.
       
       
               |
       
               *Overload 5:*
                Copy constructor using `fz_keep_bitmap()`.
       
               |
       
               *Overload 6:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 7:*
                Constructor using raw copy of pre-existing `::fz_bitmap`.
               """
>>>>>>         _mupdf.FzBitmap_swiginit(self, _mupdf.new_FzBitmap(*args))
       
    1:     def refs(self):
>>>>>>         return _mupdf.FzBitmap_refs(self)
       
    1:     def w(self):
>>>>>>         return _mupdf.FzBitmap_w(self)
       
    1:     def h(self):
>>>>>>         return _mupdf.FzBitmap_h(self)
       
    1:     def stride(self):
>>>>>>         return _mupdf.FzBitmap_stride(self)
       
    1:     def n(self):
>>>>>>         return _mupdf.FzBitmap_n(self)
       
    1:     def xres(self):
>>>>>>         return _mupdf.FzBitmap_xres(self)
       
    1:     def yres(self):
>>>>>>         return _mupdf.FzBitmap_yres(self)
       
    1:     def samples(self):
>>>>>>         return _mupdf.FzBitmap_samples(self)
    1:     __swig_destroy__ = _mupdf.delete_FzBitmap
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzBitmap_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzBitmap___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzBitmap_m_internal_get, _mupdf.FzBitmap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzBitmap_s_num_instances_get, _mupdf.FzBitmap_s_num_instances_set)
       
       # Register FzBitmap in _mupdf:
    1: _mupdf.FzBitmap_swigregister(FzBitmap)
    2: class FzBuffer(object):
    1:     r"""
           Wrapper class for struct `fz_buffer`.
           fz_buffer is a wrapper around a dynamically allocated array of
           bytes.
       
           Buffers have a capacity (the number of bytes storage immediately
           available) and a current size.
       
           The contents of the structure are considered implementation
           details and are subject to change. Users should use the accessor
           functions in preference.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    2:     @staticmethod
    2:     def fz_new_buffer_from_copied_data(data, size):
               r"""
               Class-aware wrapper for `::fz_new_buffer_from_copied_data()`.
                       Create a new buffer containing a copy of the passed data.
               """
>>>>>>         return _mupdf.FzBuffer_fz_new_buffer_from_copied_data(data, size)
       
    2:     @staticmethod
    2:     def fz_new_buffer_from_image_as_pbm(image, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pbm()`."""
>>>>>>         return _mupdf.FzBuffer_fz_new_buffer_from_image_as_pbm(image, color_params)
       
    2:     @staticmethod
    2:     def fz_new_buffer_from_image_as_pkm(image, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pkm()`."""
>>>>>>         return _mupdf.FzBuffer_fz_new_buffer_from_image_as_pkm(image, color_params)
       
    2:     @staticmethod
    2:     def fz_new_buffer_from_image_as_pnm(image, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pnm()`."""
>>>>>>         return _mupdf.FzBuffer_fz_new_buffer_from_image_as_pnm(image, color_params)
       
    2:     @staticmethod
    2:     def fz_new_buffer_from_image_as_pam(image, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pam()`."""
>>>>>>         return _mupdf.FzBuffer_fz_new_buffer_from_image_as_pam(image, color_params)
       
    2:     @staticmethod
    2:     def fz_new_buffer_from_image_as_psd(image, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_psd()`."""
>>>>>>         return _mupdf.FzBuffer_fz_new_buffer_from_image_as_psd(image, color_params)
       
    2:     @staticmethod
    2:     def fz_new_buffer_from_pixmap_as_pbm(pixmap, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pbm()`."""
>>>>>>         return _mupdf.FzBuffer_fz_new_buffer_from_pixmap_as_pbm(pixmap, color_params)
       
    2:     @staticmethod
    2:     def fz_new_buffer_from_pixmap_as_pkm(pixmap, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pkm()`."""
>>>>>>         return _mupdf.FzBuffer_fz_new_buffer_from_pixmap_as_pkm(pixmap, color_params)
       
    2:     @staticmethod
    2:     def fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`."""
>>>>>>         return _mupdf.FzBuffer_fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params)
       
    2:     @staticmethod
    2:     def fz_new_buffer_from_pixmap_as_pam(pixmap, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pam()`."""
>>>>>>         return _mupdf.FzBuffer_fz_new_buffer_from_pixmap_as_pam(pixmap, color_params)
       
    2:     @staticmethod
    2:     def fz_new_buffer_from_pixmap_as_psd(pix, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_psd()`."""
>>>>>>         return _mupdf.FzBuffer_fz_new_buffer_from_pixmap_as_psd(pix, color_params)
       
    1:     def fz_append_base64(self, data, size, newline):
               r"""
               Class-aware wrapper for `::fz_append_base64()`.
                       Write a base64 encoded data block, optionally with periodic newlines.
               """
>>>>>>         return _mupdf.FzBuffer_fz_append_base64(self, data, size, newline)
       
    1:     def fz_append_base64_buffer(self, data, newline):
               r"""
               Class-aware wrapper for `::fz_append_base64_buffer()`.
                       Append a base64 encoded fz_buffer, optionally with periodic newlines.
               """
>>>>>>         return _mupdf.FzBuffer_fz_append_base64_buffer(self, data, newline)
       
    1:     def fz_append_bits(self, value, count):
               r"""Class-aware wrapper for `::fz_append_bits()`."""
>>>>>>         return _mupdf.FzBuffer_fz_append_bits(self, value, count)
       
    1:     def fz_append_bits_pad(self):
               r"""Class-aware wrapper for `::fz_append_bits_pad()`."""
>>>>>>         return _mupdf.FzBuffer_fz_append_bits_pad(self)
       
    1:     def fz_append_buffer(self, source):
               r"""
               Class-aware wrapper for `::fz_append_buffer()`.
                       Append the contents of the source buffer onto the end of the
                       destination buffer, extending automatically as required.
       
                       Ownership of buffers does not change.
               """
>>>>>>         return _mupdf.FzBuffer_fz_append_buffer(self, source)
       
    1:     def fz_append_byte(self, c):
               r"""Class-aware wrapper for `::fz_append_byte()`."""
>>>>>>         return _mupdf.FzBuffer_fz_append_byte(self, c)
       
    1:     def fz_append_data(self, data, len):
               r"""
               Class-aware wrapper for `::fz_append_data()`.
                       fz_append_*: Append data to a buffer.
       
                       The buffer will automatically grow as required.
               """
>>>>>>         return _mupdf.FzBuffer_fz_append_data(self, data, len)
       
    1:     def fz_append_image_as_data_uri(self, image):
               r"""Class-aware wrapper for `::fz_append_image_as_data_uri()`."""
>>>>>>         return _mupdf.FzBuffer_fz_append_image_as_data_uri(self, image)
       
    1:     def fz_append_int16_be(self, x):
               r"""Class-aware wrapper for `::fz_append_int16_be()`."""
>>>>>>         return _mupdf.FzBuffer_fz_append_int16_be(self, x)
       
    1:     def fz_append_int16_le(self, x):
               r"""Class-aware wrapper for `::fz_append_int16_le()`."""
>>>>>>         return _mupdf.FzBuffer_fz_append_int16_le(self, x)
       
    1:     def fz_append_int32_be(self, x):
               r"""Class-aware wrapper for `::fz_append_int32_be()`."""
>>>>>>         return _mupdf.FzBuffer_fz_append_int32_be(self, x)
       
    1:     def fz_append_int32_le(self, x):
               r"""Class-aware wrapper for `::fz_append_int32_le()`."""
>>>>>>         return _mupdf.FzBuffer_fz_append_int32_le(self, x)
       
    1:     def fz_append_json(self, value):
               r"""Class-aware wrapper for `::fz_append_json()`."""
>>>>>>         return _mupdf.FzBuffer_fz_append_json(self, value)
       
    1:     def fz_append_pdf_string(self, text):
               r"""
               Class-aware wrapper for `::fz_append_pdf_string()`.
                       fz_append_pdf_string: Append a string with PDF syntax quotes and
                       escapes.
       
                       The buffer will automatically grow as required.
               """
>>>>>>         return _mupdf.FzBuffer_fz_append_pdf_string(self, text)
       
    1:     def fz_append_pixmap_as_data_uri(self, pixmap):
               r"""Class-aware wrapper for `::fz_append_pixmap_as_data_uri()`."""
>>>>>>         return _mupdf.FzBuffer_fz_append_pixmap_as_data_uri(self, pixmap)
       
    1:     def fz_append_rune(self, c):
               r"""Class-aware wrapper for `::fz_append_rune()`."""
>>>>>>         return _mupdf.FzBuffer_fz_append_rune(self, c)
       
    1:     def fz_append_string(self, data):
               r"""Class-aware wrapper for `::fz_append_string()`."""
>>>>>>         return _mupdf.FzBuffer_fz_append_string(self, data)
       
    1:     def fz_buffer_extract(self, data):
               r"""
               Class-aware wrapper for `::fz_buffer_extract()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_buffer_extract()` => `(size_t, unsigned char *data)`
       
                       Take ownership of buffer contents.
       
                       Performs the same task as fz_buffer_storage, but ownership of
                       the data buffer returns with this call. The buffer is left
                       empty.
       
                       Note: Bad things may happen if this is called on a buffer with
                       multiple references that is being used from multiple threads.
       
                       data: Pointer to place to retrieve data pointer.
       
                       Returns length of stream.
               """
>>>>>>         return _mupdf.FzBuffer_fz_buffer_extract(self, data)
       
    1:     def fz_buffer_storage(self, datap):
               r"""
               Class-aware wrapper for `::fz_buffer_storage()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_buffer_storage()` => `(size_t, unsigned char *datap)`
       
                       Retrieve internal memory of buffer.
       
                       datap: Output parameter that will be pointed to the data.
       
                       Returns the current size of the data in bytes.
               """
>>>>>>         return _mupdf.FzBuffer_fz_buffer_storage(self, datap)
       
    1:     def fz_clear_buffer(self):
               r"""
               Class-aware wrapper for `::fz_clear_buffer()`.
                       Empties the buffer. Storage is not freed, but is held ready
                       to be reused as the buffer is refilled.
       
                       Never throws exceptions.
               """
>>>>>>         return _mupdf.FzBuffer_fz_clear_buffer(self)
       
    1:     def fz_clone_buffer(self):
               r"""
               Class-aware wrapper for `::fz_clone_buffer()`.
                       Make a new buffer, containing a copy of the data used in
                       the original.
               """
>>>>>>         return _mupdf.FzBuffer_fz_clone_buffer(self)
       
    1:     def fz_grow_buffer(self):
               r"""
               Class-aware wrapper for `::fz_grow_buffer()`.
                       Make some space within a buffer (i.e. ensure that
                       capacity > size).
               """
>>>>>>         return _mupdf.FzBuffer_fz_grow_buffer(self)
       
    1:     def fz_load_jbig2_globals(self):
               r"""
               Class-aware wrapper for `::fz_load_jbig2_globals()`.
                       Create a jbig2 globals record from a buffer.
       
                       Immutable once created.
               """
>>>>>>         return _mupdf.FzBuffer_fz_load_jbig2_globals(self)
       
    1:     def fz_md5_buffer(self, digest):
               r"""
               Class-aware wrapper for `::fz_md5_buffer()`.
                       Create an MD5 digest from buffer contents.
       
                       Never throws exceptions.
               """
>>>>>>         return _mupdf.FzBuffer_fz_md5_buffer(self, digest)
       
    1:     def fz_new_display_list_from_svg(self, base_uri, dir, w, h):
               r"""
               Class-aware wrapper for `::fz_new_display_list_from_svg()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_new_display_list_from_svg(const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`
       
                       Parse an SVG document into a display-list.
               """
>>>>>>         return _mupdf.FzBuffer_fz_new_display_list_from_svg(self, base_uri, dir, w, h)
       
    1:     def fz_new_image_from_buffer(self):
               r"""
               Class-aware wrapper for `::fz_new_image_from_buffer()`.
                       Create a new image from a
                       buffer of data, inferring its type from the format
                       of the data.
               """
>>>>>>         return _mupdf.FzBuffer_fz_new_image_from_buffer(self)
       
    1:     def fz_new_image_from_svg(self, base_uri, dir):
               r"""
               Class-aware wrapper for `::fz_new_image_from_svg()`.
                       Create a scalable image from an SVG document.
               """
>>>>>>         return _mupdf.FzBuffer_fz_new_image_from_svg(self, base_uri, dir)
       
    1:     def fz_open_buffer(self):
               r"""
               Class-aware wrapper for `::fz_open_buffer()`.
                       Open a buffer as a stream.
       
                       buf: The buffer to open. Ownership of the buffer is NOT passed
                       in (this function takes its own reference).
       
                       Returns pointer to newly created stream. May throw exceptions on
                       failure to allocate.
               """
>>>>>>         return _mupdf.FzBuffer_fz_open_buffer(self)
       
    1:     def fz_parse_xml(self, preserve_white):
               r"""
               Class-aware wrapper for `::fz_parse_xml()`.
                       Parse the contents of buffer into a tree of xml nodes.
       
                       preserve_white: whether to keep or delete all-whitespace nodes.
               """
>>>>>>         return _mupdf.FzBuffer_fz_parse_xml(self, preserve_white)
       
    1:     def fz_parse_xml_from_html5(self):
               r"""
               Class-aware wrapper for `::fz_parse_xml_from_html5()`.
                       Parse the contents of a buffer into a tree of XML nodes,
                       using the HTML5 parsing algorithm.
               """
>>>>>>         return _mupdf.FzBuffer_fz_parse_xml_from_html5(self)
       
    1:     def fz_resize_buffer(self, capacity):
               r"""
               Class-aware wrapper for `::fz_resize_buffer()`.
                       Ensure that a buffer has a given capacity,
                       truncating data if required.
       
                       capacity: The desired capacity for the buffer. If the current
                       size of the buffer contents is smaller than capacity, it is
                       truncated.
               """
>>>>>>         return _mupdf.FzBuffer_fz_resize_buffer(self, capacity)
       
    1:     def fz_save_buffer(self, filename):
               r"""
               Class-aware wrapper for `::fz_save_buffer()`.
                       Save the contents of a buffer to a file.
               """
>>>>>>         return _mupdf.FzBuffer_fz_save_buffer(self, filename)
       
    1:     def fz_slice_buffer(self, start, end):
               r"""
               Class-aware wrapper for `::fz_slice_buffer()`.
                       Create a new buffer with a (subset of) the data from the buffer.
       
                       start: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.
       
                       end: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.
       
               """
>>>>>>         return _mupdf.FzBuffer_fz_slice_buffer(self, start, end)
       
    1:     def fz_string_from_buffer(self):
               r"""
               Class-aware wrapper for `::fz_string_from_buffer()`.
                       Ensure that a buffer's data ends in a
                       0 byte, and return a pointer to it.
               """
>>>>>>         return _mupdf.FzBuffer_fz_string_from_buffer(self)
       
    1:     def fz_subset_cff_for_gids(self, gids, num_gids, symbolic, cidfont):
               r"""
               Class-aware wrapper for `::fz_subset_cff_for_gids()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_subset_cff_for_gids(int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
               """
>>>>>>         return _mupdf.FzBuffer_fz_subset_cff_for_gids(self, gids, num_gids, symbolic, cidfont)
       
    1:     def fz_subset_ttf_for_gids(self, gids, num_gids, symbolic, cidfont):
               r"""
               Class-aware wrapper for `::fz_subset_ttf_for_gids()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_subset_ttf_for_gids(int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
               """
>>>>>>         return _mupdf.FzBuffer_fz_subset_ttf_for_gids(self, gids, num_gids, symbolic, cidfont)
       
    1:     def fz_terminate_buffer(self):
               r"""
               Class-aware wrapper for `::fz_terminate_buffer()`.
                       Zero-terminate buffer in order to use as a C string.
       
                       This byte is invisible and does not affect the length of the
                       buffer as returned by fz_buffer_storage. The zero byte is
                       written *after* the data, and subsequent writes will overwrite
                       the terminating byte.
       
                       Subsequent changes to the size of the buffer (such as by
                       fz_buffer_trim, fz_buffer_grow, fz_resize_buffer, etc) may
                       invalidate this.
               """
>>>>>>         return _mupdf.FzBuffer_fz_terminate_buffer(self)
       
    1:     def fz_trim_buffer(self):
               r"""
               Class-aware wrapper for `::fz_trim_buffer()`.
                       Trim wasted capacity from a buffer by resizing internal memory.
               """
>>>>>>         return _mupdf.FzBuffer_fz_trim_buffer(self)
       
    1:     def pdf_append_token(self, tok, lex):
               r"""Class-aware wrapper for `::pdf_append_token()`."""
>>>>>>         return _mupdf.FzBuffer_pdf_append_token(self, tok, lex)
       
    1:     def pdf_new_buffer_processor(self, ahxencode, newlines):
               r"""Class-aware wrapper for `::pdf_new_buffer_processor()`."""
>>>>>>         return _mupdf.FzBuffer_pdf_new_buffer_processor(self, ahxencode, newlines)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_buffer()`.
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_buffer_from_base64()`.
                               Create a new buffer with data decoded from a base64 input string.
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_buffer_from_data()`.
                               Create a new buffer with existing data.
       
                               data: Pointer to existing data.
                               size: Size of existing data.
       
                               Takes ownership of data. Does not make a copy. Calls fz_free on
                               the data when the buffer is deallocated. Do not use 'data' after
                               passing to this function.
       
                               Returns pointer to new buffer. Throws exception on allocation
                               failure.
       
       
               |
       
               *Overload 4:*
                Constructor using `fz_new_buffer_from_display_list()`.
       
               |
       
               *Overload 5:*
                Constructor using `fz_new_buffer_from_image_as_jpeg()`.
       
               |
       
               *Overload 6:*
                Constructor using `fz_new_buffer_from_image_as_jpx()`.
       
               |
       
               *Overload 7:*
                Constructor using `fz_new_buffer_from_image_as_png()`.
                               Re-encode a given image as a PNG into a buffer.
       
                               Ownership of the buffer is returned.
       
       
               |
       
               *Overload 8:*
                Constructor using `fz_new_buffer_from_page()`.
       
               |
       
               *Overload 9:*
                Constructor using `fz_new_buffer_from_page_number()`.
       
               |
       
               *Overload 10:*
                Constructor using `fz_new_buffer_from_page_with_format()`.
                               Returns an fz_buffer containing a page after conversion to specified format.
       
                               page: The page to convert.
                               format, options: Passed to fz_new_document_writer_with_output() internally.
                               transform, cookie: Passed to fz_run_page() internally.
       
       
               |
       
               *Overload 11:*
                Constructor using `fz_new_buffer_from_pixmap_as_jpeg()`.
       
               |
       
               *Overload 12:*
                Constructor using `fz_new_buffer_from_pixmap_as_jpx()`.
       
               |
       
               *Overload 13:*
                Constructor using `fz_new_buffer_from_pixmap_as_png()`.
                               Re-encode a given pixmap as a PNG into a buffer.
       
                               Ownership of the buffer is returned.
       
       
               |
       
               *Overload 14:*
                Constructor using `fz_new_buffer_from_shared_data()`.
                               Like fz_new_buffer, but does not take ownership.
       
       
               |
       
               *Overload 15:*
                Constructor using `fz_new_buffer_from_stext_page()`.
                               Convert structured text into plain text.
       
       
               |
       
               *Overload 16:*
                Constructor using `fz_read_file()`.
                               Read all the contents of a file into a buffer.
       
       
               |
       
               *Overload 17:*
                Copy constructor using `fz_keep_buffer()`.
       
               |
       
               *Overload 18:*
                Constructor using raw copy of pre-existing `::fz_buffer`.
       
               |
       
               *Overload 19:*
                Constructor using raw copy of pre-existing `::fz_buffer`.
               """
>>>>>>         _mupdf.FzBuffer_swiginit(self, _mupdf.new_FzBuffer(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzBuffer
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzBuffer_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzBuffer___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzBuffer_m_internal_get, _mupdf.FzBuffer_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzBuffer_s_num_instances_get, _mupdf.FzBuffer_s_num_instances_set)
       
       # Register FzBuffer in _mupdf:
    1: _mupdf.FzBuffer_swigregister(FzBuffer)
    2: class FzColorParams(object):
    1:     r"""Wrapper class for struct `fz_color_params`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Equivalent to fz_default_color_params.
       
               |
       
               *Overload 2:*
               We use default copy constructor and operator=.  Constructor using raw copy of pre-existing `::fz_color_params`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_color_params`.
               """
>>>>>>         _mupdf.FzColorParams_swiginit(self, _mupdf.new_FzColorParams(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.FzColorParams_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_FzColorParams
    1:     ri = property(_mupdf.FzColorParams_ri_get, _mupdf.FzColorParams_ri_set)
    1:     bp = property(_mupdf.FzColorParams_bp_get, _mupdf.FzColorParams_bp_set)
    1:     op = property(_mupdf.FzColorParams_op_get, _mupdf.FzColorParams_op_set)
    1:     opm = property(_mupdf.FzColorParams_opm_get, _mupdf.FzColorParams_opm_set)
    1:     s_num_instances = property(_mupdf.FzColorParams_s_num_instances_get, _mupdf.FzColorParams_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzColorParams_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzColorParams___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzColorParams___ne__(self, rhs)
       
       # Register FzColorParams in _mupdf:
    1: _mupdf.FzColorParams_swigregister(FzColorParams)
    2: class FzColorspace(object):
    1:     r"""
           Wrapper class for struct `fz_colorspace`.
           Describes a given colorspace.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     Fixed_GRAY = _mupdf.FzColorspace_Fixed_GRAY
    1:     Fixed_RGB = _mupdf.FzColorspace_Fixed_RGB
    1:     Fixed_BGR = _mupdf.FzColorspace_Fixed_BGR
    1:     Fixed_CMYK = _mupdf.FzColorspace_Fixed_CMYK
    1:     Fixed_LAB = _mupdf.FzColorspace_Fixed_LAB
       
    1:     def fz_base_colorspace(self):
               r"""
               Class-aware wrapper for `::fz_base_colorspace()`.
                       Get the 'base' colorspace for a colorspace.
       
                       For indexed colorspaces, this is the colorspace the index
                       decodes into. For all other colorspaces, it is the colorspace
                       itself.
       
                       The returned colorspace is 'borrowed' (i.e. no additional
                       references are taken or dropped).
               """
>>>>>>         return _mupdf.FzColorspace_fz_base_colorspace(self)
       
    1:     def fz_clamp_color(self, _in, out):
               r"""
               Class-aware wrapper for `::fz_clamp_color()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_clamp_color(const float *in)` => float out
       
                       Clamp the samples in a color to the correct ranges for a
                       given colorspace.
               """
>>>>>>         return _mupdf.FzColorspace_fz_clamp_color(self, _in, out)
       
    1:     def fz_colorspace_colorant(self, n):
               r"""
               Class-aware wrapper for `::fz_colorspace_colorant()`.
                       Retrieve a the name for a colorant.
       
                       Returns a pointer with the same lifespan as the colorspace.
               """
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_colorant(self, n)
       
    1:     def fz_colorspace_device_n_has_cmyk(self):
               r"""
               Class-aware wrapper for `::fz_colorspace_device_n_has_cmyk()`.
                       True if DeviceN color space has cyan magenta yellow or black as
                       one of its colorants.
               """
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_device_n_has_cmyk(self)
       
    1:     def fz_colorspace_device_n_has_only_cmyk(self):
               r"""
               Class-aware wrapper for `::fz_colorspace_device_n_has_only_cmyk()`.
                       True if DeviceN color space has only colorants from the CMYK set.
               """
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_device_n_has_only_cmyk(self)
       
    1:     def fz_colorspace_digest(self, digest):
               r"""
               Class-aware wrapper for `::fz_colorspace_digest()`.
                       Get checksum of underlying ICC profile.
               """
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_digest(self, digest)
       
    1:     def fz_colorspace_is_cmyk(self):
               r"""Class-aware wrapper for `::fz_colorspace_is_cmyk()`."""
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_is_cmyk(self)
       
    1:     def fz_colorspace_is_device(self):
               r"""Class-aware wrapper for `::fz_colorspace_is_device()`."""
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_is_device(self)
       
    1:     def fz_colorspace_is_device_cmyk(self):
               r"""Class-aware wrapper for `::fz_colorspace_is_device_cmyk()`."""
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_is_device_cmyk(self)
       
    1:     def fz_colorspace_is_device_gray(self):
               r"""Class-aware wrapper for `::fz_colorspace_is_device_gray()`."""
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_is_device_gray(self)
       
    1:     def fz_colorspace_is_device_n(self):
               r"""Class-aware wrapper for `::fz_colorspace_is_device_n()`."""
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_is_device_n(self)
       
    1:     def fz_colorspace_is_gray(self):
               r"""
               Class-aware wrapper for `::fz_colorspace_is_gray()`.
                       Tests for particular types of colorspaces
               """
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_is_gray(self)
       
    1:     def fz_colorspace_is_icc(self):
               r"""Class-aware wrapper for `::fz_colorspace_is_icc()`."""
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_is_icc(self)
       
    1:     def fz_colorspace_is_indexed(self):
               r"""Class-aware wrapper for `::fz_colorspace_is_indexed()`."""
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_is_indexed(self)
       
    1:     def fz_colorspace_is_lab(self):
               r"""Class-aware wrapper for `::fz_colorspace_is_lab()`."""
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_is_lab(self)
       
    1:     def fz_colorspace_is_lab_icc(self):
               r"""Class-aware wrapper for `::fz_colorspace_is_lab_icc()`."""
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_is_lab_icc(self)
       
    1:     def fz_colorspace_is_rgb(self):
               r"""Class-aware wrapper for `::fz_colorspace_is_rgb()`."""
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_is_rgb(self)
       
    1:     def fz_colorspace_is_subtractive(self):
               r"""
               Class-aware wrapper for `::fz_colorspace_is_subtractive()`.
                       True for CMYK, Separation and DeviceN colorspaces.
               """
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_is_subtractive(self)
       
    1:     def fz_colorspace_n(self):
               r"""
               Class-aware wrapper for `::fz_colorspace_n()`.
                       Query the number of colorants in a colorspace.
               """
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_n(self)
       
    1:     def fz_colorspace_name(self):
               r"""
               Class-aware wrapper for `::fz_colorspace_name()`.
                       Query the name of a colorspace.
       
                       The returned string has the same lifespan as the colorspace
                       does. Caller should not free it.
               """
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_name(self)
       
    1:     def fz_colorspace_name_colorant(self, n, name):
               r"""
               Class-aware wrapper for `::fz_colorspace_name_colorant()`.
                       Assign a name for a given colorant in a colorspace.
       
                       Used while initially setting up a colorspace. The string is
                       copied into local storage, so need not be retained by the
                       caller.
               """
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_name_colorant(self, n, name)
       
    1:     def fz_colorspace_type(self):
               r"""
               Class-aware wrapper for `::fz_colorspace_type()`.
                       Query the type of colorspace.
               """
>>>>>>         return _mupdf.FzColorspace_fz_colorspace_type(self)
       
    1:     def fz_convert_color(self, sv, ds, dv, _is, params):
               r"""
               Class-aware wrapper for `::fz_convert_color()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_convert_color(const float *sv, ::fz_colorspace *ds, ::fz_colorspace *is, ::fz_color_params params)` => float dv
       
                       Convert color values sv from colorspace ss into colorvalues dv
                       for colorspace ds, via an optional intervening space is,
                       respecting the given color_params.
               """
>>>>>>         return _mupdf.FzColorspace_fz_convert_color(self, sv, ds, dv, _is, params)
       
    1:     def fz_convert_separation_colors(self, src_color, dst_seps, dst_cs, dst_color, color_params):
               r"""
               Class-aware wrapper for `::fz_convert_separation_colors()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_convert_separation_colors(const float *src_color, ::fz_separations *dst_seps, ::fz_colorspace *dst_cs, ::fz_color_params color_params)` => float dst_color
       
                       Convert a color given in terms of one colorspace,
                       to a color in terms of another colorspace/separations.
               """
>>>>>>         return _mupdf.FzColorspace_fz_convert_separation_colors(self, src_color, dst_seps, dst_cs, dst_color, color_params)
       
    1:     def fz_is_valid_blend_colorspace(self):
               r"""
               Class-aware wrapper for `::fz_is_valid_blend_colorspace()`.
                       Check to see that a colorspace is appropriate to be used as
                       a blending space (i.e. only grey, rgb or cmyk).
               """
>>>>>>         return _mupdf.FzColorspace_fz_is_valid_blend_colorspace(self)
       
    1:     def fz_new_indexed_colorspace(self, high, lookup):
               r"""
               Class-aware wrapper for `::fz_new_indexed_colorspace()`.
                       Create an indexed colorspace.
       
                       The supplied lookup table is high palette entries long. Each
                       entry is n bytes long, where n is given by the number of
                       colorants in the base colorspace, one byte per colorant.
       
                       Ownership of lookup is passed it; it will be freed on
                       destruction, so must be heap allocated.
       
                       The colorspace will keep an additional reference to the base
                       colorspace that will be dropped on destruction.
       
                       The returned reference should be dropped when it is finished
                       with.
       
                       Colorspaces are immutable once created.
               """
>>>>>>         return _mupdf.FzColorspace_fz_new_indexed_colorspace(self, high, lookup)
       
    1:     def fz_new_pixmap(self, w, h, seps, alpha):
               r"""
               Class-aware wrapper for `::fz_new_pixmap()`.
                       Create a new pixmap, with its origin at (0,0)
       
                       cs: The colorspace to use for the pixmap, or NULL for an alpha
                       plane/mask.
       
                       w: The width of the pixmap (in pixels)
       
                       h: The height of the pixmap (in pixels)
       
                       seps: Details of separations.
       
                       alpha: 0 for no alpha, 1 for alpha.
       
                       Returns a pointer to the new pixmap. Throws exception on failure
                       to allocate.
               """
>>>>>>         return _mupdf.FzColorspace_fz_new_pixmap(self, w, h, seps, alpha)
       
    1:     def fz_new_pixmap_with_bbox(self, bbox, seps, alpha):
               r"""
               Class-aware wrapper for `::fz_new_pixmap_with_bbox()`.
                       Create a pixmap of a given size, location and pixel format.
       
                       The bounding box specifies the size of the created pixmap and
                       where it will be located. The colorspace determines the number
                       of components per pixel. Alpha is always present. Pixmaps are
                       reference counted, so drop references using fz_drop_pixmap.
       
                       colorspace: Colorspace format used for the created pixmap. The
                       pixmap will keep a reference to the colorspace.
       
                       bbox: Bounding box specifying location/size of created pixmap.
       
                       seps: Details of separations.
       
                       alpha: 0 for no alpha, 1 for alpha.
       
                       Returns a pointer to the new pixmap. Throws exception on failure
                       to allocate.
               """
>>>>>>         return _mupdf.FzColorspace_fz_new_pixmap_with_bbox(self, bbox, seps, alpha)
       
    1:     def fz_new_pixmap_with_bbox_and_data(self, rect, seps, alpha, samples):
               r"""
               Class-aware wrapper for `::fz_new_pixmap_with_bbox_and_data()`.
                       Create a pixmap of a given size, location and pixel format,
                       using the supplied data block.
       
                       The bounding box specifies the size of the created pixmap and
                       where it will be located. The colorspace determines the number
                       of components per pixel. Alpha is always present. Pixmaps are
                       reference counted, so drop references using fz_drop_pixmap.
       
                       colorspace: Colorspace format used for the created pixmap. The
                       pixmap will keep a reference to the colorspace.
       
                       rect: Bounding box specifying location/size of created pixmap.
       
                       seps: Details of separations.
       
                       alpha: Number of alpha planes (0 or 1).
       
                       samples: The data block to keep the samples in.
       
                       Returns a pointer to the new pixmap. Throws exception on failure
                       to allocate.
               """
>>>>>>         return _mupdf.FzColorspace_fz_new_pixmap_with_bbox_and_data(self, rect, seps, alpha, samples)
       
    1:     def fz_new_pixmap_with_data(self, w, h, seps, alpha, stride, samples):
               r"""
               Class-aware wrapper for `::fz_new_pixmap_with_data()`.
                       Create a new pixmap, with its origin at
                       (0,0) using the supplied data block.
       
                       cs: The colorspace to use for the pixmap, or NULL for an alpha
                       plane/mask.
       
                       w: The width of the pixmap (in pixels)
       
                       h: The height of the pixmap (in pixels)
       
                       seps: Details of separations.
       
                       alpha: 0 for no alpha, 1 for alpha.
       
                       stride: The byte offset from the pixel data in a row to the
                       pixel data in the next row.
       
                       samples: The data block to keep the samples in.
       
                       Returns a pointer to the new pixmap. Throws exception on failure to
                       allocate.
               """
>>>>>>         return _mupdf.FzColorspace_fz_new_pixmap_with_data(self, w, h, seps, alpha, stride, samples)
       
    1:     def pdf_is_tint_colorspace(self):
               r"""Class-aware wrapper for `::pdf_is_tint_colorspace()`."""
>>>>>>         return _mupdf.FzColorspace_pdf_is_tint_colorspace(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_cal_gray_colorspace()`.
                               Create a calibrated gray colorspace.
       
                               The returned reference should be dropped when it is finished
                               with.
       
                               Colorspaces are immutable once created.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_cal_rgb_colorspace()`.
                               Create a calibrated rgb colorspace.
       
                               The returned reference should be dropped when it is finished
                               with.
       
                               Colorspaces are immutable once created.
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_colorspace()`.
                               Creates a new colorspace instance and returns a reference.
       
                               No internal checking is done that the colorspace type (e.g.
                               CMYK) matches with the flags (e.g. FZ_COLORSPACE_HAS_CMYK) or
                               colorant count (n) or name.
       
                               The reference should be dropped when it is finished with.
       
                               Colorspaces are immutable once created (with the exception of
                               setting up colorant names for separation spaces).
       
       
               |
       
               *Overload 4:*
                Constructor using `fz_new_icc_colorspace()`.
                               Create a colorspace from an ICC profile supplied in buf.
       
                               Limited checking is done to ensure that the colorspace type is
                               appropriate for the supplied ICC profile.
       
                               An additional reference is taken to buf, which will be dropped
                               on destruction. Ownership is NOT passed in.
       
                               The returned reference should be dropped when it is finished
                               with.
       
                               Colorspaces are immutable once created.
       
       
               |
       
               *Overload 5:*
                Constructor using `fz_new_indexed_colorspace()`.
                               Create an indexed colorspace.
       
                               The supplied lookup table is high palette entries long. Each
                               entry is n bytes long, where n is given by the number of
                               colorants in the base colorspace, one byte per colorant.
       
                               Ownership of lookup is passed it; it will be freed on
                               destruction, so must be heap allocated.
       
                               The colorspace will keep an additional reference to the base
                               colorspace that will be dropped on destruction.
       
                               The returned reference should be dropped when it is finished
                               with.
       
                               Colorspaces are immutable once created.
       
       
               |
       
               *Overload 6:*
                Construct using one of: fz_device_gray(), fz_device_rgb(), fz_device_bgr(), fz_device_cmyk(), fz_device_lab().
       
               |
       
               *Overload 7:*
                Copy constructor using `fz_keep_colorspace()`.
       
               |
       
               *Overload 8:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 9:*
                Constructor using raw copy of pre-existing `::fz_colorspace`.
               """
    3:         _mupdf.FzColorspace_swiginit(self, _mupdf.new_FzColorspace(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzColorspace
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzColorspace_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzColorspace___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzColorspace_m_internal_get, _mupdf.FzColorspace_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzColorspace_s_num_instances_get, _mupdf.FzColorspace_s_num_instances_set)
       
       # Register FzColorspace in _mupdf:
    1: _mupdf.FzColorspace_swigregister(FzColorspace)
    2: class FzColorspaceContext(object):
    1:     r"""Wrapper class for struct `fz_colorspace_context`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_colorspace_context`.
               """
>>>>>>         _mupdf.FzColorspaceContext_swiginit(self, _mupdf.new_FzColorspaceContext(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzColorspaceContext
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzColorspaceContext_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzColorspaceContext___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzColorspaceContext_m_internal_get, _mupdf.FzColorspaceContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzColorspaceContext_s_num_instances_get, _mupdf.FzColorspaceContext_s_num_instances_set)
       
       # Register FzColorspaceContext in _mupdf:
    1: _mupdf.FzColorspaceContext_swigregister(FzColorspaceContext)
    2: class FzCompressedBuffer(object):
    1:     r"""
           Wrapper class for struct `fz_compressed_buffer`.
           Buffers of compressed data; typically for the source data
           for images.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_compressed_buffer_size(self):
               r"""
               Class-aware wrapper for `::fz_compressed_buffer_size()`.
                       Return the storage size used for a buffer and its data.
                       Used in implementing store handling.
       
                       Never throws exceptions.
               """
>>>>>>         return _mupdf.FzCompressedBuffer_fz_compressed_buffer_size(self)
       
    1:     def fz_open_compressed_buffer(self):
               r"""
               Class-aware wrapper for `::fz_open_compressed_buffer()`.
                       Open a stream to read the decompressed version of a buffer.
               """
>>>>>>         return _mupdf.FzCompressedBuffer_fz_open_compressed_buffer(self)
       
    1:     def fz_open_image_decomp_stream_from_buffer(self, l2factor):
               r"""
               Class-aware wrapper for `::fz_open_image_decomp_stream_from_buffer()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_open_image_decomp_stream_from_buffer()` => `(fz_stream *, int l2factor)`
       
                       Open a stream to read the decompressed version of a buffer,
                       with optional log2 subsampling.
       
                       l2factor = NULL for no subsampling, or a pointer to an integer
                       containing the maximum log2 subsample factor acceptable (0 =
                       none, 1 = halve dimensions, 2 = quarter dimensions etc). If
                       non-NULL, then *l2factor will be updated on exit with the actual
                       log2 subsample factor achieved.
               """
>>>>>>         return _mupdf.FzCompressedBuffer_fz_open_image_decomp_stream_from_buffer(self, l2factor)
       
    1:     def get_buffer(self):
               r"""Returns wrapper class for fz_buffer *m_internal.buffer."""
>>>>>>         return _mupdf.FzCompressedBuffer_get_buffer(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_compressed_buffer()`.
                               Create a new, UNKNOWN format, compressed_buffer.
       
       
               |
       
               *Overload 2:*
                Copy constructor using `fz_keep_compressed_buffer()`.
       
               |
       
               *Overload 3:*
                Constructor using raw copy of pre-existing `::fz_compressed_buffer`.
               """
>>>>>>         _mupdf.FzCompressedBuffer_swiginit(self, _mupdf.new_FzCompressedBuffer(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzCompressedBuffer
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzCompressedBuffer_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzCompressedBuffer___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzCompressedBuffer_m_internal_get, _mupdf.FzCompressedBuffer_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzCompressedBuffer_s_num_instances_get, _mupdf.FzCompressedBuffer_s_num_instances_set)
       
       # Register FzCompressedBuffer in _mupdf:
    1: _mupdf.FzCompressedBuffer_swigregister(FzCompressedBuffer)
    2: class FzCompressedImage(object):
    1:     r"""Wrapper class for struct `fz_compressed_image`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_set_compressed_image_buffer(self, buf):
               r"""Class-aware wrapper for `::fz_set_compressed_image_buffer()`."""
>>>>>>         return _mupdf.FzCompressedImage_fz_set_compressed_image_buffer(self, buf)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_compressed_image`.
               """
>>>>>>         _mupdf.FzCompressedImage_swiginit(self, _mupdf.new_FzCompressedImage(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzCompressedImage
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzCompressedImage_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzCompressedImage___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzCompressedImage_m_internal_get, _mupdf.FzCompressedImage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzCompressedImage_s_num_instances_get, _mupdf.FzCompressedImage_s_num_instances_set)
       
       # Register FzCompressedImage in _mupdf:
    1: _mupdf.FzCompressedImage_swigregister(FzCompressedImage)
    2: class FzCompressionParams(object):
    1:     r"""
           Wrapper class for struct `fz_compression_params`. Not copyable or assignable.
           Compression parameters used for buffers of compressed data;
           typically for the source data for images.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_compression_params`.
               """
>>>>>>         _mupdf.FzCompressionParams_swiginit(self, _mupdf.new_FzCompressionParams(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzCompressionParams
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzCompressionParams_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzCompressionParams___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzCompressionParams_m_internal_get, _mupdf.FzCompressionParams_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzCompressionParams_s_num_instances_get, _mupdf.FzCompressionParams_s_num_instances_set)
       
       # Register FzCompressionParams in _mupdf:
    1: _mupdf.FzCompressionParams_swigregister(FzCompressionParams)
    2: class FzContext(object):
    1:     r"""Wrapper class for struct `fz_context`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `fz_new_context_imp()`.
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_context`.
               """
>>>>>>         _mupdf.FzContext_swiginit(self, _mupdf.new_FzContext(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzContext
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzContext_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzContext___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzContext_m_internal_get, _mupdf.FzContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzContext_s_num_instances_get, _mupdf.FzContext_s_num_instances_set)
       
       # Register FzContext in _mupdf:
    1: _mupdf.FzContext_swigregister(FzContext)
    2: class FzCookie(object):
    1:     r"""
           Wrapper class for struct `fz_cookie`. Not copyable or assignable.
           Provide two-way communication between application and library.
           Intended for multi-threaded applications where one thread is
           rendering pages and another thread wants to read progress
           feedback or abort a job that takes a long time to finish. The
           communication is unsynchronized without locking.
       
           abort: The application should set this field to 0 before
           calling fz_run_page to render a page. At any point when the
           page is being rendered the application my set this field to 1
           which will cause the rendering to finish soon. This field is
           checked periodically when the page is rendered, but exactly
           when is not known, therefore there is no upper bound on
           exactly when the rendering will abort. If the application
           did not provide a set of locks to fz_new_context, it must also
           await the completion of fz_run_page before issuing another
           call to fz_run_page. Note that once the application has set
           this field to 1 after it called fz_run_page it may not change
           the value again.
       
           progress: Communicates rendering progress back to the
           application and is read only. Increments as a page is being
           rendered. The value starts out at 0 and is limited to less
           than or equal to progress_max, unless progress_max is -1.
       
           progress_max: Communicates the known upper bound of rendering
           back to the application and is read only. The maximum value
           that the progress field may take. If there is no known upper
           bound on how long the rendering may take this value is -1 and
           progress is not limited. Note that the value of progress_max
           may change from -1 to a positive value once an upper bound is
           known, so take this into consideration when comparing the
           value of progress to that of progress_max.
       
           errors: count of errors during current rendering.
       
           incomplete: Initially should be set to 0. Will be set to
           non-zero if a TRYLATER error is thrown during rendering.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self):
               r"""Default constructor sets all fields to default values."""
>>>>>>         _mupdf.FzCookie_swiginit(self, _mupdf.new_FzCookie())
       
    1:     def set_abort(self):
               r"""Sets m_internal.abort to 1."""
>>>>>>         return _mupdf.FzCookie_set_abort(self)
       
    1:     def increment_errors(self, delta):
               r"""Increments m_internal.errors by <delta>."""
>>>>>>         return _mupdf.FzCookie_increment_errors(self, delta)
       
    1:     def abort(self):
>>>>>>         return _mupdf.FzCookie_abort(self)
       
    1:     def progress(self):
>>>>>>         return _mupdf.FzCookie_progress(self)
       
    1:     def progress_max(self):
>>>>>>         return _mupdf.FzCookie_progress_max(self)
       
    1:     def errors(self):
>>>>>>         return _mupdf.FzCookie_errors(self)
       
    1:     def incomplete(self):
>>>>>>         return _mupdf.FzCookie_incomplete(self)
    1:     __swig_destroy__ = _mupdf.delete_FzCookie
    1:     m_internal = property(_mupdf.FzCookie_m_internal_get, _mupdf.FzCookie_m_internal_set)
    1:     s_num_instances = property(_mupdf.FzCookie_s_num_instances_get, _mupdf.FzCookie_s_num_instances_set, doc=r"""Wrapped data is held by value.""")
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzCookie_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzCookie___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzCookie___ne__(self, rhs)
       
       # Register FzCookie in _mupdf:
    1: _mupdf.FzCookie_swigregister(FzCookie)
    2: class FzDefaultColorspaces(object):
    1:     r"""
           Wrapper class for struct `fz_default_colorspaces`.
           Structure to hold default colorspaces.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_clone_default_colorspaces(self):
               r"""
               Class-aware wrapper for `::fz_clone_default_colorspaces()`.
                       Returns a reference to a newly cloned default colorspaces
                       structure.
       
                       The new clone may safely be altered without fear of race
                       conditions as the caller is the only reference holder.
               """
>>>>>>         return _mupdf.FzDefaultColorspaces_fz_clone_default_colorspaces(self)
       
    1:     def fz_default_cmyk(self):
               r"""Class-aware wrapper for `::fz_default_cmyk()`."""
>>>>>>         return _mupdf.FzDefaultColorspaces_fz_default_cmyk(self)
       
    1:     def fz_default_gray(self):
               r"""
               Class-aware wrapper for `::fz_default_gray()`.
                       Retrieve default colorspaces (typically page local).
       
                       If default_cs is non NULL, the default is retrieved from there,
                       otherwise the global default is retrieved.
       
                       These return borrowed references that should not be dropped,
                       unless they are kept first.
               """
>>>>>>         return _mupdf.FzDefaultColorspaces_fz_default_gray(self)
       
    1:     def fz_default_output_intent(self):
               r"""Class-aware wrapper for `::fz_default_output_intent()`."""
>>>>>>         return _mupdf.FzDefaultColorspaces_fz_default_output_intent(self)
       
    1:     def fz_default_rgb(self):
               r"""Class-aware wrapper for `::fz_default_rgb()`."""
>>>>>>         return _mupdf.FzDefaultColorspaces_fz_default_rgb(self)
       
    1:     def fz_set_default_cmyk(self, cs):
               r"""Class-aware wrapper for `::fz_set_default_cmyk()`."""
>>>>>>         return _mupdf.FzDefaultColorspaces_fz_set_default_cmyk(self, cs)
       
    1:     def fz_set_default_gray(self, cs):
               r"""
               Class-aware wrapper for `::fz_set_default_gray()`.
                       Set new defaults within the default colorspace structure.
       
                       New references are taken to the new default, and references to
                       the old defaults dropped.
       
                       Never throws exceptions.
               """
>>>>>>         return _mupdf.FzDefaultColorspaces_fz_set_default_gray(self, cs)
       
    1:     def fz_set_default_output_intent(self, cs):
               r"""Class-aware wrapper for `::fz_set_default_output_intent()`."""
>>>>>>         return _mupdf.FzDefaultColorspaces_fz_set_default_output_intent(self, cs)
       
    1:     def fz_set_default_rgb(self, cs):
               r"""Class-aware wrapper for `::fz_set_default_rgb()`."""
>>>>>>         return _mupdf.FzDefaultColorspaces_fz_set_default_rgb(self, cs)
       
    1:     def pdf_update_default_colorspaces(self, res):
               r"""Class-aware wrapper for `::pdf_update_default_colorspaces()`."""
>>>>>>         return _mupdf.FzDefaultColorspaces_pdf_update_default_colorspaces(self, res)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_default_colorspaces()`.
                               Create a new default colorspace structure with values inherited
                               from the context, and return a reference to it.
       
                               These can be overridden using fz_set_default_xxxx.
       
                               These should not be overridden while more than one caller has
                               the reference for fear of race conditions.
       
                               The caller should drop this reference once finished with it.
       
       
               |
       
               *Overload 2:*
                Copy constructor using `fz_keep_default_colorspaces()`.
       
               |
       
               *Overload 3:*
                Constructor using raw copy of pre-existing `::fz_default_colorspaces`.
               """
>>>>>>         _mupdf.FzDefaultColorspaces_swiginit(self, _mupdf.new_FzDefaultColorspaces(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzDefaultColorspaces
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzDefaultColorspaces_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzDefaultColorspaces___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzDefaultColorspaces_m_internal_get, _mupdf.FzDefaultColorspaces_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzDefaultColorspaces_s_num_instances_get, _mupdf.FzDefaultColorspaces_s_num_instances_set)
       
       # Register FzDefaultColorspaces in _mupdf:
    1: _mupdf.FzDefaultColorspaces_swigregister(FzDefaultColorspaces)
    2: class FzDevice(object):
    1:     r"""
           Wrapper class for struct `fz_device`.
           The different format handlers (pdf, xps etc) interpret pages to
           a device. These devices can then process the stream of calls
           they receive in various ways:
               The trace device outputs debugging information for the calls.
               The draw device will render them.
               The list device stores them in a list to play back later.
               The text device performs text extraction and searching.
               The bbox device calculates the bounding box for the page.
           Other devices can (and will) be written in the future.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    2:     @staticmethod
    2:     def fz_new_xmltext_device(out):
               r"""
               Class-aware wrapper for `::fz_new_xmltext_device()`.
                       Create a device to output raw information.
               """
>>>>>>         return _mupdf.FzDevice_fz_new_xmltext_device(out)
       
    2:     @staticmethod
    2:     def fz_new_draw_device_type3(transform, dest):
               r"""Class-aware wrapper for `::fz_new_draw_device_type3()`."""
>>>>>>         return _mupdf.FzDevice_fz_new_draw_device_type3(transform, dest)
       
    1:     def fz_begin_group(self, area, cs, isolated, knockout, blendmode, alpha):
               r"""Class-aware wrapper for `::fz_begin_group()`."""
>>>>>>         return _mupdf.FzDevice_fz_begin_group(self, area, cs, isolated, knockout, blendmode, alpha)
       
    1:     def fz_begin_layer(self, layer_name):
               r"""Class-aware wrapper for `::fz_begin_layer()`."""
>>>>>>         return _mupdf.FzDevice_fz_begin_layer(self, layer_name)
       
    1:     def fz_begin_mask(self, area, luminosity, colorspace, bc, color_params):
               r"""Class-aware wrapper for `::fz_begin_mask()`."""
>>>>>>         return _mupdf.FzDevice_fz_begin_mask(self, area, luminosity, colorspace, bc, color_params)
       
    1:     def fz_begin_metatext(self, meta, text):
               r"""Class-aware wrapper for `::fz_begin_metatext()`."""
>>>>>>         return _mupdf.FzDevice_fz_begin_metatext(self, meta, text)
       
    1:     def fz_begin_structure(self, standard, raw, idx):
               r"""Class-aware wrapper for `::fz_begin_structure()`."""
>>>>>>         return _mupdf.FzDevice_fz_begin_structure(self, standard, raw, idx)
       
    1:     def fz_begin_tile(self, area, view, xstep, ystep, ctm):
               r"""Class-aware wrapper for `::fz_begin_tile()`."""
>>>>>>         return _mupdf.FzDevice_fz_begin_tile(self, area, view, xstep, ystep, ctm)
       
    1:     def fz_begin_tile_id(self, area, view, xstep, ystep, ctm, id):
               r"""Class-aware wrapper for `::fz_begin_tile_id()`."""
>>>>>>         return _mupdf.FzDevice_fz_begin_tile_id(self, area, view, xstep, ystep, ctm, id)
       
    1:     def fz_begin_tile_tid(self, area, view, xstep, ystep, ctm, id, doc_id):
               r"""Class-aware wrapper for `::fz_begin_tile_tid()`."""
>>>>>>         return _mupdf.FzDevice_fz_begin_tile_tid(self, area, view, xstep, ystep, ctm, id, doc_id)
       
    1:     def fz_clip_image_mask(self, image, ctm, scissor):
               r"""Class-aware wrapper for `::fz_clip_image_mask()`."""
>>>>>>         return _mupdf.FzDevice_fz_clip_image_mask(self, image, ctm, scissor)
       
    1:     def fz_clip_path(self, path, even_odd, ctm, scissor):
               r"""Class-aware wrapper for `::fz_clip_path()`."""
>>>>>>         return _mupdf.FzDevice_fz_clip_path(self, path, even_odd, ctm, scissor)
       
    1:     def fz_clip_stroke_path(self, path, stroke, ctm, scissor):
               r"""Class-aware wrapper for `::fz_clip_stroke_path()`."""
>>>>>>         return _mupdf.FzDevice_fz_clip_stroke_path(self, path, stroke, ctm, scissor)
       
    1:     def fz_clip_stroke_text(self, text, stroke, ctm, scissor):
               r"""Class-aware wrapper for `::fz_clip_stroke_text()`."""
>>>>>>         return _mupdf.FzDevice_fz_clip_stroke_text(self, text, stroke, ctm, scissor)
       
    1:     def fz_clip_text(self, text, ctm, scissor):
               r"""Class-aware wrapper for `::fz_clip_text()`."""
>>>>>>         return _mupdf.FzDevice_fz_clip_text(self, text, ctm, scissor)
       
    1:     def fz_close_device(self):
               r"""
               Class-aware wrapper for `::fz_close_device()`.
                       Signal the end of input, and flush any buffered output.
                       This is NOT called implicitly on fz_drop_device. This
                       may throw exceptions.
               """
>>>>>>         return _mupdf.FzDevice_fz_close_device(self)
       
    1:     def fz_device_current_scissor(self):
               r"""
               Class-aware wrapper for `::fz_device_current_scissor()`.
                       Find current scissor region as tracked by the device.
               """
>>>>>>         return _mupdf.FzDevice_fz_device_current_scissor(self)
       
    1:     def fz_disable_device_hints(self, hints):
               r"""
               Class-aware wrapper for `::fz_disable_device_hints()`.
                       Disable (clear) hint bits within the hint bitfield for a device.
               """
>>>>>>         return _mupdf.FzDevice_fz_disable_device_hints(self, hints)
       
    1:     def fz_enable_device_hints(self, hints):
               r"""
               Class-aware wrapper for `::fz_enable_device_hints()`.
                       Enable (set) hint bits within the hint bitfield for a device.
               """
>>>>>>         return _mupdf.FzDevice_fz_enable_device_hints(self, hints)
       
    1:     def fz_end_group(self):
               r"""Class-aware wrapper for `::fz_end_group()`."""
>>>>>>         return _mupdf.FzDevice_fz_end_group(self)
       
    1:     def fz_end_layer(self):
               r"""Class-aware wrapper for `::fz_end_layer()`."""
>>>>>>         return _mupdf.FzDevice_fz_end_layer(self)
       
    1:     def fz_end_mask(self):
               r"""Class-aware wrapper for `::fz_end_mask()`."""
>>>>>>         return _mupdf.FzDevice_fz_end_mask(self)
       
    1:     def fz_end_mask_tr(self, fn):
               r"""Class-aware wrapper for `::fz_end_mask_tr()`."""
>>>>>>         return _mupdf.FzDevice_fz_end_mask_tr(self, fn)
       
    1:     def fz_end_metatext(self):
               r"""Class-aware wrapper for `::fz_end_metatext()`."""
>>>>>>         return _mupdf.FzDevice_fz_end_metatext(self)
       
    1:     def fz_end_structure(self):
               r"""Class-aware wrapper for `::fz_end_structure()`."""
>>>>>>         return _mupdf.FzDevice_fz_end_structure(self)
       
    1:     def fz_end_tile(self):
               r"""Class-aware wrapper for `::fz_end_tile()`."""
>>>>>>         return _mupdf.FzDevice_fz_end_tile(self)
       
    1:     def fz_fill_image(self, image, ctm, alpha, color_params):
               r"""Class-aware wrapper for `::fz_fill_image()`."""
>>>>>>         return _mupdf.FzDevice_fz_fill_image(self, image, ctm, alpha, color_params)
       
    1:     def fz_fill_image_mask(self, image, ctm, colorspace, color, alpha, color_params):
               r"""Class-aware wrapper for `::fz_fill_image_mask()`."""
>>>>>>         return _mupdf.FzDevice_fz_fill_image_mask(self, image, ctm, colorspace, color, alpha, color_params)
       
    1:     def fz_fill_path(self, path, even_odd, ctm, colorspace, color, alpha, color_params):
               r"""
               Class-aware wrapper for `::fz_fill_path()`.
                       Device calls; graphics primitives and containers.
               """
>>>>>>         return _mupdf.FzDevice_fz_fill_path(self, path, even_odd, ctm, colorspace, color, alpha, color_params)
       
    1:     def fz_fill_shade(self, shade, ctm, alpha, color_params):
               r"""Class-aware wrapper for `::fz_fill_shade()`."""
>>>>>>         return _mupdf.FzDevice_fz_fill_shade(self, shade, ctm, alpha, color_params)
       
    1:     def fz_fill_text(self, text, ctm, colorspace, color, alpha, color_params):
               r"""Class-aware wrapper for `::fz_fill_text()`."""
>>>>>>         return _mupdf.FzDevice_fz_fill_text(self, text, ctm, colorspace, color, alpha, color_params)
       
    1:     def fz_ignore_text(self, text, ctm):
               r"""Class-aware wrapper for `::fz_ignore_text()`."""
>>>>>>         return _mupdf.FzDevice_fz_ignore_text(self, text, ctm)
       
    1:     def fz_new_ocr_device(self, ctm, mediabox, with_list, language, datadir, progress, progress_arg):
               r"""
               Class-aware wrapper for `::fz_new_ocr_device()`.
                       Create a device to OCR the text on the page.
       
                       Renders the page internally to a bitmap that is then OCRd. Text
                       is then forwarded onto the target device.
       
                       target: The target device to receive the OCRd text.
       
                       ctm: The transform to apply to the mediabox to get the size for
                       the rendered page image. Also used to calculate the resolution
                       for the page image. In general, this will be the same as the CTM
                       that you pass to fz_run_page (or fz_run_display_list) to feed
                       this device.
       
                       mediabox: The mediabox (in points). Combined with the CTM to get
                       the bounds of the pixmap used internally for the rendered page
                       image.
       
                       with_list: If with_list is false, then all non-text operations
                       are forwarded instantly to the target device. This results in
                       the target device seeing all NON-text operations, followed by
                       all the text operations (derived from OCR).
       
                       If with_list is true, then all the marking operations are
                       collated into a display list which is then replayed to the
                       target device at the end.
       
                       language: NULL (for "eng"), or a pointer to a string to describe
                       the languages/scripts that should be used for OCR (e.g.
                       "eng,ara").
       
                       datadir: NULL (for ""), or a pointer to a path string otherwise
                       provided to Tesseract in the TESSDATA_PREFIX environment variable.
       
                       progress: NULL, or function to be called periodically to indicate
                       progress. Return 0 to continue, or 1 to cancel. progress_arg is
                       returned as the void *. The int is a value between 0 and 100 to
                       indicate progress.
       
                       progress_arg: A void * value to be parrotted back to the progress
                       function.
               """
>>>>>>         return _mupdf.FzDevice_fz_new_ocr_device(self, ctm, mediabox, with_list, language, datadir, progress, progress_arg)
       
    1:     def fz_pop_clip(self):
               r"""Class-aware wrapper for `::fz_pop_clip()`."""
>>>>>>         return _mupdf.FzDevice_fz_pop_clip(self)
       
    1:     def fz_render_flags(self, set, clear):
               r"""Class-aware wrapper for `::fz_render_flags()`."""
>>>>>>         return _mupdf.FzDevice_fz_render_flags(self, set, clear)
       
    1:     def fz_render_t3_glyph_direct(self, font, gid, trm, gstate, def_cs, fill_gstate, stroke_gstate):
               r"""
               Class-aware wrapper for `::fz_render_t3_glyph_direct()`.
                       Nasty PDF interpreter specific hernia, required to allow the
                       interpreter to replay glyphs from a type3 font directly into
                       the target device.
       
                       This is only used in exceptional circumstances (such as type3
                       glyphs that inherit current graphics state, or nested type3
                       glyphs).
               """
>>>>>>         return _mupdf.FzDevice_fz_render_t3_glyph_direct(self, font, gid, trm, gstate, def_cs, fill_gstate, stroke_gstate)
       
    1:     def fz_set_default_colorspaces(self, default_cs):
               r"""Class-aware wrapper for `::fz_set_default_colorspaces()`."""
>>>>>>         return _mupdf.FzDevice_fz_set_default_colorspaces(self, default_cs)
       
    1:     def fz_stroke_path(self, path, stroke, ctm, colorspace, color, alpha, color_params):
               r"""Class-aware wrapper for `::fz_stroke_path()`."""
>>>>>>         return _mupdf.FzDevice_fz_stroke_path(self, path, stroke, ctm, colorspace, color, alpha, color_params)
       
    1:     def fz_stroke_text(self, text, stroke, ctm, colorspace, color, alpha, color_params):
               r"""Class-aware wrapper for `::fz_stroke_text()`."""
>>>>>>         return _mupdf.FzDevice_fz_stroke_text(self, text, stroke, ctm, colorspace, color, alpha, color_params)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_bbox_device()`.
                               Create a device to compute the bounding
                               box of all marks on a page.
       
                               The returned bounding box will be the union of all bounding
                               boxes of all objects on a page.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_device_of_size()`.
                               Devices are created by calls to device implementations, for
                               instance: foo_new_device(). These will be implemented by calling
                               fz_new_derived_device(ctx, foo_device) where foo_device is a
                               structure "derived from" fz_device, for instance
                               typedef struct { fz_device base;  ...extras...} foo_device;
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_draw_device()`.
                               Create a device to draw on a pixmap.
       
                               dest: Target pixmap for the draw device. See fz_new_pixmap*
                               for how to obtain a pixmap. The pixmap is not cleared by the
                               draw device, see fz_clear_pixmap* for how to clear it prior to
                               calling fz_new_draw_device. Free the device by calling
                               fz_drop_device.
       
                               transform: Transform from user space in points to device space
                               in pixels.
       
       
               |
       
               *Overload 4:*
                Constructor using `fz_new_draw_device_with_bbox()`.
                               Create a device to draw on a pixmap.
       
                               dest: Target pixmap for the draw device. See fz_new_pixmap*
                               for how to obtain a pixmap. The pixmap is not cleared by the
                               draw device, see fz_clear_pixmap* for how to clear it prior to
                               calling fz_new_draw_device. Free the device by calling
                               fz_drop_device.
       
                               transform: Transform from user space in points to device space
                               in pixels.
       
                               clip: Bounding box to restrict any marking operations of the
                               draw device.
       
       
               |
       
               *Overload 5:*
                Constructor using `fz_new_draw_device_with_bbox_proof()`.
                               Create a device to draw on a pixmap.
       
                               dest: Target pixmap for the draw device. See fz_new_pixmap*
                               for how to obtain a pixmap. The pixmap is not cleared by the
                               draw device, see fz_clear_pixmap* for how to clear it prior to
                               calling fz_new_draw_device. Free the device by calling
                               fz_drop_device.
       
                               transform: Transform from user space in points to device space
                               in pixels.
       
                               clip: Bounding box to restrict any marking operations of the
                               draw device.
       
                               proof_cs: Color space to render to prior to mapping to color
                               space defined by pixmap.
       
       
               |
       
               *Overload 6:*
                Constructor using `fz_new_draw_device_with_options()`.
                               Create a new pixmap and draw device, using the specified options.
       
                               options: Options to configure the draw device, and choose the
                               resolution and colorspace.
       
                               mediabox: The bounds of the page in points.
       
                               pixmap: An out parameter containing the newly created pixmap.
       
       
               |
       
               *Overload 7:*
                Constructor using `fz_new_draw_device_with_proof()`.
                               Create a device to draw on a pixmap.
       
                               dest: Target pixmap for the draw device. See fz_new_pixmap*
                               for how to obtain a pixmap. The pixmap is not cleared by the
                               draw device, see fz_clear_pixmap* for how to clear it prior to
                               calling fz_new_draw_device. Free the device by calling
                               fz_drop_device.
       
                               transform: Transform from user space in points to device space
                               in pixels.
       
                               proof_cs: Intermediate color space to map though when mapping to
                               color space defined by pixmap.
       
       
               |
       
               *Overload 8:*
                Constructor using `fz_new_list_device()`.
                               Create a rendering device for a display list.
       
                               When the device is rendering a page it will populate the
                               display list with drawing commands (text, images, etc.). The
                               display list can later be reused to render a page many times
                               without having to re-interpret the page from the document file
                               for each rendering. Once the device is no longer needed, free
                               it with fz_drop_device.
       
                               list: A display list that the list device takes a reference to.
       
       
               |
       
               *Overload 9:*
                Constructor using `fz_new_ocr_device()`.
                               Create a device to OCR the text on the page.
       
                               Renders the page internally to a bitmap that is then OCRd. Text
                               is then forwarded onto the target device.
       
                               target: The target device to receive the OCRd text.
       
                               ctm: The transform to apply to the mediabox to get the size for
                               the rendered page image. Also used to calculate the resolution
                               for the page image. In general, this will be the same as the CTM
                               that you pass to fz_run_page (or fz_run_display_list) to feed
                               this device.
       
                               mediabox: The mediabox (in points). Combined with the CTM to get
                               the bounds of the pixmap used internally for the rendered page
                               image.
       
                               with_list: If with_list is false, then all non-text operations
                               are forwarded instantly to the target device. This results in
                               the target device seeing all NON-text operations, followed by
                               all the text operations (derived from OCR).
       
                               If with_list is true, then all the marking operations are
                               collated into a display list which is then replayed to the
                               target device at the end.
       
                               language: NULL (for "eng"), or a pointer to a string to describe
                               the languages/scripts that should be used for OCR (e.g.
                               "eng,ara").
       
                               datadir: NULL (for ""), or a pointer to a path string otherwise
                               provided to Tesseract in the TESSDATA_PREFIX environment variable.
       
                               progress: NULL, or function to be called periodically to indicate
                               progress. Return 0 to continue, or 1 to cancel. progress_arg is
                               returned as the void *. The int is a value between 0 and 100 to
                               indicate progress.
       
                               progress_arg: A void * value to be parrotted back to the progress
                               function.
       
       
               |
       
               *Overload 10:*
                Constructor using `fz_new_stext_device()`.
                               Create a device to extract the text on a page.
       
                               Gather the text on a page into blocks and lines.
       
                               The reading order is taken from the order the text is drawn in
                               the source file, so may not be accurate.
       
                               page: The text page to which content should be added. This will
                               usually be a newly created (empty) text page, but it can be one
                               containing data already (for example when merging multiple
                               pages, or watermarking).
       
                               options: Options to configure the stext device.
       
       
               |
       
               *Overload 11:*
                Constructor using `fz_new_stext_device_for_page()`.
                               Create a device to extract the text on a page into an existing
                               fz_stext_page structure.
       
                               Gather the text on a page into blocks and lines.
       
                               The reading order is taken from the order the text is drawn in
                               the source file, so may not be accurate.
       
                               stext_page: The text page to which content should be added. This will
                               usually be a newly created (empty) text page, but it can be one
                               containing data already (for example when merging multiple
                               pages, or watermarking).
       
                               options: Options to configure the stext device.
       
                               The next 2 parameters are copied into the fz_stext_page structure's
                               ids section, so only have to be valid if you expect to interrogate
                               that section later.
       
                               chapter_num: The chapter number that this page came from.
       
                               page_num: The page number that this page came from.
       
                               The final parameter is copied into the fz_stext_page structure's
                               ids section. The mediabox for the enture fz_stext_page is unioned
                               with this, so pass fz_empty_bbox if you don't care about getting
                               a valid value back from the ids section, but you don't want to
                               upset the value in the page->mediabox field.
       
                               mediabox: The mediabox for this page.
       
       
               |
       
               *Overload 12:*
                Constructor using `fz_new_svg_device()`.
                               Create a device that outputs (single page) SVG files to
                               the given output stream.
       
                               Equivalent to fz_new_svg_device_with_id passing id = NULL.
       
       
               |
       
               *Overload 13:*
                Constructor using `fz_new_svg_device_with_id()`.
                               Create a device that outputs (single page) SVG files to
                               the given output stream.
       
                               output: The output stream to send the constructed SVG page to.
       
                               page_width, page_height: The page dimensions to use (in points).
       
                               text_format: How to emit text. One of the following values:
                                       FZ_SVG_TEXT_AS_TEXT: As <text> elements with possible
                                       layout errors and mismatching fonts.
                                       FZ_SVG_TEXT_AS_PATH: As <path> elements with exact
                                       visual appearance.
       
                               reuse_images: Share image resources using <symbol> definitions.
       
                               id: ID parameter to keep generated IDs unique across SVG files.
       
       
               |
       
               *Overload 14:*
                Constructor using `fz_new_test_device()`.
                               Create a device to test for features.
       
                               Currently only tests for the presence of non-grayscale colors.
       
                               is_color: Possible values returned:
                                       0: Definitely greyscale
                                       1: Probably color (all colors were grey, but there
                                       were images or shadings in a non grey colorspace).
                                       2: Definitely color
       
                               threshold: The difference from grayscale that will be tolerated.
                               Typical values to use are either 0 (be exact) and 0.02 (allow an
                               imperceptible amount of slop).
       
                               options: A set of bitfield options, from the FZ_TEST_OPT set.
       
                               passthrough: A device to pass all calls through to, or NULL.
                               If set, then the test device can both test and pass through to
                               an underlying device (like, say, the display list device). This
                               means that a display list can be created and at the end we'll
                               know if it's colored or not.
       
                               In the absence of a passthrough device, the device will throw
                               an exception to stop page interpretation when color is found.
       
       
               |
       
               *Overload 15:*
                Constructor using `fz_new_trace_device()`.
                               Create a device to print a debug trace of all device calls.
       
       
               |
       
               *Overload 16:*
                Constructor using `pdf_new_pdf_device()`.
       
               |
       
               *Overload 17:*
                Copy constructor using `fz_keep_device()`.
       
               |
       
               *Overload 18:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 19:*
                Constructor using raw copy of pre-existing `::fz_device`.
               """
>>>>>>         _mupdf.FzDevice_swiginit(self, _mupdf.new_FzDevice(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzDevice
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzDevice_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzDevice___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzDevice_m_internal_get, _mupdf.FzDevice_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzDevice_s_num_instances_get, _mupdf.FzDevice_s_num_instances_set)
       
       # Register FzDevice in _mupdf:
    1: _mupdf.FzDevice_swigregister(FzDevice)
    2: class FzDevice2(FzDevice):
    1:     r"""Wrapper class for struct fz_device with virtual fns for each fnptr; this is for use as a SWIG Director class."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self):
               r"""== Constructor."""
>>>>>>         if self.__class__ == FzDevice2:
>>>>>>             _self = None
               else:
>>>>>>             _self = self
>>>>>>         _mupdf.FzDevice2_swiginit(self, _mupdf.new_FzDevice2(_self, ))
    1:     __swig_destroy__ = _mupdf.delete_FzDevice2
       
    1:     def use_virtual_close_device(self, use=True):
               r"""
               These methods set the function pointers in *m_internal
               to point to internal callbacks that call our virtual methods.
               """
>>>>>>         return _mupdf.FzDevice2_use_virtual_close_device(self, use)
       
    1:     def use_virtual_drop_device(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_drop_device(self, use)
       
    1:     def use_virtual_fill_path(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_fill_path(self, use)
       
    1:     def use_virtual_stroke_path(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_stroke_path(self, use)
       
    1:     def use_virtual_clip_path(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_clip_path(self, use)
       
    1:     def use_virtual_clip_stroke_path(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_clip_stroke_path(self, use)
       
    1:     def use_virtual_fill_text(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_fill_text(self, use)
       
    1:     def use_virtual_stroke_text(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_stroke_text(self, use)
       
    1:     def use_virtual_clip_text(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_clip_text(self, use)
       
    1:     def use_virtual_clip_stroke_text(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_clip_stroke_text(self, use)
       
    1:     def use_virtual_ignore_text(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_ignore_text(self, use)
       
    1:     def use_virtual_fill_shade(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_fill_shade(self, use)
       
    1:     def use_virtual_fill_image(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_fill_image(self, use)
       
    1:     def use_virtual_fill_image_mask(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_fill_image_mask(self, use)
       
    1:     def use_virtual_clip_image_mask(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_clip_image_mask(self, use)
       
    1:     def use_virtual_pop_clip(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_pop_clip(self, use)
       
    1:     def use_virtual_begin_mask(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_begin_mask(self, use)
       
    1:     def use_virtual_end_mask(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_end_mask(self, use)
       
    1:     def use_virtual_begin_group(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_begin_group(self, use)
       
    1:     def use_virtual_end_group(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_end_group(self, use)
       
    1:     def use_virtual_begin_tile(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_begin_tile(self, use)
       
    1:     def use_virtual_end_tile(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_end_tile(self, use)
       
    1:     def use_virtual_render_flags(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_render_flags(self, use)
       
    1:     def use_virtual_set_default_colorspaces(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_set_default_colorspaces(self, use)
       
    1:     def use_virtual_begin_layer(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_begin_layer(self, use)
       
    1:     def use_virtual_end_layer(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_end_layer(self, use)
       
    1:     def use_virtual_begin_structure(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_begin_structure(self, use)
       
    1:     def use_virtual_end_structure(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_end_structure(self, use)
       
    1:     def use_virtual_begin_metatext(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_begin_metatext(self, use)
       
    1:     def use_virtual_end_metatext(self, use=True):
>>>>>>         return _mupdf.FzDevice2_use_virtual_end_metatext(self, use)
       
    1:     def close_device(self, arg_0):
               r"""Default virtual method implementations; these all throw an exception."""
>>>>>>         return _mupdf.FzDevice2_close_device(self, arg_0)
       
    1:     def drop_device(self, arg_0):
>>>>>>         return _mupdf.FzDevice2_drop_device(self, arg_0)
       
    1:     def fill_path(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8):
>>>>>>         return _mupdf.FzDevice2_fill_path(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8)
       
    1:     def stroke_path(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8):
>>>>>>         return _mupdf.FzDevice2_stroke_path(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8)
       
    1:     def clip_path(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.FzDevice2_clip_path(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def clip_stroke_path(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.FzDevice2_clip_stroke_path(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def fill_text(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
>>>>>>         return _mupdf.FzDevice2_fill_text(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)
       
    1:     def stroke_text(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8):
>>>>>>         return _mupdf.FzDevice2_stroke_text(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8)
       
    1:     def clip_text(self, arg_0, arg_2, arg_3, arg_4):
>>>>>>         return _mupdf.FzDevice2_clip_text(self, arg_0, arg_2, arg_3, arg_4)
       
    1:     def clip_stroke_text(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.FzDevice2_clip_stroke_text(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def ignore_text(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.FzDevice2_ignore_text(self, arg_0, arg_2, arg_3)
       
    1:     def fill_shade(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.FzDevice2_fill_shade(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def fill_image(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.FzDevice2_fill_image(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def fill_image_mask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
>>>>>>         return _mupdf.FzDevice2_fill_image_mask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)
       
    1:     def clip_image_mask(self, arg_0, arg_2, arg_3, arg_4):
>>>>>>         return _mupdf.FzDevice2_clip_image_mask(self, arg_0, arg_2, arg_3, arg_4)
       
    1:     def pop_clip(self, arg_0):
>>>>>>         return _mupdf.FzDevice2_pop_clip(self, arg_0)
       
    1:     def begin_mask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6):
>>>>>>         return _mupdf.FzDevice2_begin_mask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6)
       
    1:     def end_mask(self, arg_0, arg_2):
>>>>>>         return _mupdf.FzDevice2_end_mask(self, arg_0, arg_2)
       
    1:     def begin_group(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
>>>>>>         return _mupdf.FzDevice2_begin_group(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)
       
    1:     def end_group(self, arg_0):
>>>>>>         return _mupdf.FzDevice2_end_group(self, arg_0)
       
    1:     def begin_tile(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8):
>>>>>>         return _mupdf.FzDevice2_begin_tile(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8)
       
    1:     def end_tile(self, arg_0):
>>>>>>         return _mupdf.FzDevice2_end_tile(self, arg_0)
       
    1:     def render_flags(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.FzDevice2_render_flags(self, arg_0, arg_2, arg_3)
       
    1:     def set_default_colorspaces(self, arg_0, arg_2):
>>>>>>         return _mupdf.FzDevice2_set_default_colorspaces(self, arg_0, arg_2)
       
    1:     def begin_layer(self, arg_0, arg_2):
>>>>>>         return _mupdf.FzDevice2_begin_layer(self, arg_0, arg_2)
       
    1:     def end_layer(self, arg_0):
>>>>>>         return _mupdf.FzDevice2_end_layer(self, arg_0)
       
    1:     def begin_structure(self, arg_0, arg_2, arg_3, arg_4):
>>>>>>         return _mupdf.FzDevice2_begin_structure(self, arg_0, arg_2, arg_3, arg_4)
       
    1:     def end_structure(self, arg_0):
>>>>>>         return _mupdf.FzDevice2_end_structure(self, arg_0)
       
    1:     def begin_metatext(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.FzDevice2_begin_metatext(self, arg_0, arg_2, arg_3)
       
    1:     def end_metatext(self, arg_0):
>>>>>>         return _mupdf.FzDevice2_end_metatext(self, arg_0)
    1:     def __disown__(self):
>>>>>>         self.this.disown()
>>>>>>         _mupdf.disown_FzDevice2(self)
>>>>>>         return weakref.proxy(self)
       
       # Register FzDevice2 in _mupdf:
    1: _mupdf.FzDevice2_swigregister(FzDevice2)
    2: class FzDeviceContainerStack(object):
    1:     r"""
           Wrapper class for struct `fz_device_container_stack`. Not copyable or assignable.
           Devices can keep track of containers (clips/masks/groups/tiles)
           as they go to save callers having to do it.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_device_container_stack`.
               """
>>>>>>         _mupdf.FzDeviceContainerStack_swiginit(self, _mupdf.new_FzDeviceContainerStack(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzDeviceContainerStack
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzDeviceContainerStack_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzDeviceContainerStack___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzDeviceContainerStack_m_internal_get, _mupdf.FzDeviceContainerStack_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzDeviceContainerStack_s_num_instances_get, _mupdf.FzDeviceContainerStack_s_num_instances_set)
       
       # Register FzDeviceContainerStack in _mupdf:
    1: _mupdf.FzDeviceContainerStack_swigregister(FzDeviceContainerStack)
    2: class FzDisplayList(object):
    1:     r"""
           Wrapper class for struct `fz_display_list`.
           fz_display_list is a list containing drawing commands (text,
           images, etc.). The intent is two-fold: as a caching-mechanism
           to reduce parsing of a page, and to be used as a data
           structure in multi-threading where one thread parses the page
           and another renders pages.
       
           Create a display list with fz_new_display_list, hand it over to
           fz_new_list_device to have it populated, and later replay the
           list (once or many times) by calling fz_run_display_list. When
           the list is no longer needed drop it with fz_drop_display_list.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    2:     @staticmethod
    2:     def fz_new_display_list_from_page_contents(page):
               r"""
               Class-aware wrapper for `::fz_new_display_list_from_page_contents()`.
                       Create a display list from page contents (no annotations).
       
                       Ownership of the display list is returned to the caller.
               """
>>>>>>         return _mupdf.FzDisplayList_fz_new_display_list_from_page_contents(page)
       
    1:     def fz_bound_display_list(self):
               r"""
               Class-aware wrapper for `::fz_bound_display_list()`.
                       Return the bounding box of the page recorded in a display list.
               """
>>>>>>         return _mupdf.FzDisplayList_fz_bound_display_list(self)
       
    1:     def fz_display_list_is_empty(self):
               r"""
               Class-aware wrapper for `::fz_display_list_is_empty()`.
                       Check for a display list being empty
       
                       list: The list to check.
       
                       Returns true if empty, false otherwise.
               """
>>>>>>         return _mupdf.FzDisplayList_fz_display_list_is_empty(self)
       
    1:     def fz_fill_pixmap_from_display_list(self, ctm, pix):
               r"""Class-aware wrapper for `::fz_fill_pixmap_from_display_list()`."""
>>>>>>         return _mupdf.FzDisplayList_fz_fill_pixmap_from_display_list(self, ctm, pix)
       
    1:     def fz_new_buffer_from_display_list(self, options):
               r"""Class-aware wrapper for `::fz_new_buffer_from_display_list()`."""
>>>>>>         return _mupdf.FzDisplayList_fz_new_buffer_from_display_list(self, options)
       
    1:     def fz_new_list_device(self):
               r"""
               Class-aware wrapper for `::fz_new_list_device()`.
                       Create a rendering device for a display list.
       
                       When the device is rendering a page it will populate the
                       display list with drawing commands (text, images, etc.). The
                       display list can later be reused to render a page many times
                       without having to re-interpret the page from the document file
                       for each rendering. Once the device is no longer needed, free
                       it with fz_drop_device.
       
                       list: A display list that the list device takes a reference to.
               """
>>>>>>         return _mupdf.FzDisplayList_fz_new_list_device(self)
       
    1:     def fz_new_pixmap_from_display_list(self, ctm, cs, alpha):
               r"""
               Class-aware wrapper for `::fz_new_pixmap_from_display_list()`.
                       Render the page to a pixmap using the transform and colorspace.
       
                       Ownership of the pixmap is returned to the caller.
               """
>>>>>>         return _mupdf.FzDisplayList_fz_new_pixmap_from_display_list(self, ctm, cs, alpha)
       
    1:     def fz_new_pixmap_from_display_list_with_separations(self, ctm, cs, seps, alpha):
               r"""
               Class-aware wrapper for `::fz_new_pixmap_from_display_list_with_separations()`.
                       Render the page contents with control over spot colors.
       
                       Ownership of the pixmap is returned to the caller.
               """
>>>>>>         return _mupdf.FzDisplayList_fz_new_pixmap_from_display_list_with_separations(self, ctm, cs, seps, alpha)
       
    1:     def fz_run_display_list(self, dev, ctm, scissor, cookie):
               r"""
               Class-aware wrapper for `::fz_run_display_list()`.
                       (Re)-run a display list through a device.
       
                       list: A display list, created by fz_new_display_list and
                       populated with objects from a page by running fz_run_page on a
                       device obtained from fz_new_list_device.
       
                       ctm: Transform to apply to display list contents. May include
                       for example scaling and rotation, see fz_scale, fz_rotate and
                       fz_concat. Set to fz_identity if no transformation is desired.
       
                       scissor: Only the part of the contents of the display list
                       visible within this area will be considered when the list is
                       run through the device. This does not imply for tile objects
                       contained in the display list.
       
                       cookie: Communication mechanism between caller and library
                       running the page. Intended for multi-threaded applications,
                       while single-threaded applications set cookie to NULL. The
                       caller may abort an ongoing page run. Cookie also communicates
                       progress information back to the caller. The fields inside
                       cookie are continually updated while the page is being run.
               """
>>>>>>         return _mupdf.FzDisplayList_fz_run_display_list(self, dev, ctm, scissor, cookie)
       
    1:     def fz_search_display_list(self, needle, hit_mark, hit_bbox, hit_max):
               r"""
               Class-aware wrapper for `::fz_search_display_list()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_search_display_list(const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
               """
>>>>>>         return _mupdf.FzDisplayList_fz_search_display_list(self, needle, hit_mark, hit_bbox, hit_max)
       
    1:     def fz_search_display_list_cb(self, needle, cb, opaque):
               r"""Class-aware wrapper for `::fz_search_display_list_cb()`."""
>>>>>>         return _mupdf.FzDisplayList_fz_search_display_list_cb(self, needle, cb, opaque)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_display_list()`.
                               Create an empty display list.
       
                               A display list contains drawing commands (text, images, etc.).
                               Use fz_new_list_device for populating the list.
       
                               mediabox: Bounds of the page (in points) represented by the
                               display list.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_display_list_from_page()`.
                               Create a display list.
       
                               Ownership of the display list is returned to the caller.
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_display_list_from_page_number()`.
       
               |
       
               *Overload 4:*
                Constructor using `fz_new_display_list_from_svg()`.
                               Parse an SVG document into a display-list.
       
       
               |
       
               *Overload 5:*
                Constructor using `fz_new_display_list_from_svg_xml()`.
                               Parse an SVG document into a display-list.
       
       
               |
       
               *Overload 6:*
                Constructor using `pdf_new_display_list_from_annot()`.
       
               |
       
               *Overload 7:*
                Copy constructor using `fz_keep_display_list()`.
       
               |
       
               *Overload 8:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 9:*
                Constructor using raw copy of pre-existing `::fz_display_list`.
               """
>>>>>>         _mupdf.FzDisplayList_swiginit(self, _mupdf.new_FzDisplayList(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzDisplayList
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzDisplayList_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzDisplayList___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzDisplayList_m_internal_get, _mupdf.FzDisplayList_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzDisplayList_s_num_instances_get, _mupdf.FzDisplayList_s_num_instances_set)
       
       # Register FzDisplayList in _mupdf:
    1: _mupdf.FzDisplayList_swigregister(FzDisplayList)
    2: class FzDocument(object):
    1:     r"""Wrapper class for struct `fz_document`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_authenticate_password(self, password):
               r"""
               Class-aware wrapper for `::fz_authenticate_password()`.
                       Test if the given password can decrypt the document.
       
                       password: The password string to be checked. Some document
                       specifications do not specify any particular text encoding, so
                       neither do we.
       
                       Returns 0 for failure to authenticate, non-zero for success.
       
                       For PDF documents, further information can be given by examining
                       the bits in the return code.
       
                               Bit 0 => No password required
                               Bit 1 => User password authenticated
                               Bit 2 => Owner password authenticated
               """
>>>>>>         return _mupdf.FzDocument_fz_authenticate_password(self, password)
       
    1:     def fz_clamp_location(self, loc):
               r"""
               Class-aware wrapper for `::fz_clamp_location()`.
                       Clamps a location into valid chapter/page range. (First clamps
                       the chapter into range, then the page into range).
               """
>>>>>>         return _mupdf.FzDocument_fz_clamp_location(self, loc)
       
    1:     def fz_count_chapter_pages(self, chapter):
               r"""
               Class-aware wrapper for `::fz_count_chapter_pages()`.
                       Return the number of pages in a chapter.
                       May return 0.
               """
>>>>>>         return _mupdf.FzDocument_fz_count_chapter_pages(self, chapter)
       
    1:     def fz_count_chapters(self):
               r"""
               Class-aware wrapper for `::fz_count_chapters()`.
                       Return the number of chapters in the document.
                       At least 1.
               """
>>>>>>         return _mupdf.FzDocument_fz_count_chapters(self)
       
    1:     def fz_count_pages(self):
               r"""
               Class-aware wrapper for `::fz_count_pages()`.
                       Return the number of pages in document
       
                       May return 0 for documents with no pages.
               """
>>>>>>         return _mupdf.FzDocument_fz_count_pages(self)
       
    1:     def fz_document_output_intent(self):
               r"""
               Class-aware wrapper for `::fz_document_output_intent()`.
                       Find the output intent colorspace if the document has defined
                       one.
       
                       Returns a borrowed reference that should not be dropped, unless
                       it is kept first.
               """
>>>>>>         return _mupdf.FzDocument_fz_document_output_intent(self)
       
    1:     def fz_document_supports_accelerator(self):
               r"""
               Class-aware wrapper for `::fz_document_supports_accelerator()`.
                       Query if the document supports the saving of accelerator data.
               """
>>>>>>         return _mupdf.FzDocument_fz_document_supports_accelerator(self)
       
    1:     def fz_format_link_uri(self, dest):
               r"""
               Class-aware wrapper for `::fz_format_link_uri()`.
                       Format an internal link to a page number, location, and possible viewing parameters,
                       suitable for use with fz_create_link.
       
                       Returns a newly allocated string that the caller must free.
               """
>>>>>>         return _mupdf.FzDocument_fz_format_link_uri(self, dest)
       
    1:     def fz_has_permission(self, p):
               r"""
               Class-aware wrapper for `::fz_has_permission()`.
                       Check permission flags on document.
               """
>>>>>>         return _mupdf.FzDocument_fz_has_permission(self, p)
       
    1:     def fz_is_document_reflowable(self):
               r"""
               Class-aware wrapper for `::fz_is_document_reflowable()`.
                       Is the document reflowable.
       
                       Returns 1 to indicate reflowable documents, otherwise 0.
               """
>>>>>>         return _mupdf.FzDocument_fz_is_document_reflowable(self)
       
    1:     def fz_last_page(self):
               r"""
               Class-aware wrapper for `::fz_last_page()`.
                       Function to get the location for the last page in the document.
                       Using this can be far more efficient in some cases than calling
                       fz_count_pages and using the page number.
               """
>>>>>>         return _mupdf.FzDocument_fz_last_page(self)
       
    1:     def fz_layout_document(self, w, h, em):
               r"""
               Class-aware wrapper for `::fz_layout_document()`.
                       Layout reflowable document types.
       
                       w, h: Page size in points.
                       em: Default font size in points.
               """
>>>>>>         return _mupdf.FzDocument_fz_layout_document(self, w, h, em)
       
    1:     def fz_load_chapter_page(self, chapter, page):
               r"""
               Class-aware wrapper for `::fz_load_chapter_page()`.
                       Load a page.
       
                       After fz_load_page is it possible to retrieve the size of the
                       page using fz_bound_page, or to render the page using
                       fz_run_page_*. Free the page by calling fz_drop_page.
       
                       chapter: chapter number, 0 is the first chapter of the document.
                       number: page number, 0 is the first page of the chapter.
               """
>>>>>>         return _mupdf.FzDocument_fz_load_chapter_page(self, chapter, page)
       
    1:     def fz_load_outline(self):
               r"""
               Class-aware wrapper for `::fz_load_outline()`.
                       Load the hierarchical document outline.
       
                       Should be freed by fz_drop_outline.
               """
>>>>>>         return _mupdf.FzDocument_fz_load_outline(self)
       
    1:     def fz_load_page(self, number):
               r"""
               Class-aware wrapper for `::fz_load_page()`.
                       Load a given page number from a document. This may be much less
                       efficient than loading by location (chapter+page) for some
                       document types.
               """
>>>>>>         return _mupdf.FzDocument_fz_load_page(self, number)
       
    1:     def fz_location_from_page_number(self, number):
               r"""
               Class-aware wrapper for `::fz_location_from_page_number()`.
                       Converts from page number to chapter+page. This may cause many
                       chapters to be laid out in order to calculate the number of
                       pages within those chapters.
               """
>>>>>>         return _mupdf.FzDocument_fz_location_from_page_number(self, number)
       
    1:     def fz_lookup_bookmark(self, mark):
               r"""
               Class-aware wrapper for `::fz_lookup_bookmark()`.
                       Find a bookmark and return its page number.
               """
>>>>>>         return _mupdf.FzDocument_fz_lookup_bookmark(self, mark)
       
    1:     def fz_lookup_metadata(self, key, buf, size):
               r"""
               Class-aware wrapper for `::fz_lookup_metadata()`.
                       Retrieve document meta data strings.
       
                       doc: The document to query.
       
                       key: Which meta data key to retrieve...
       
                       Basic information:
                               'format'        -- Document format and version.
                               'encryption'    -- Description of the encryption used.
       
                       From the document information dictionary:
                               'info:Title'
                               'info:Author'
                               'info:Subject'
                               'info:Keywords'
                               'info:Creator'
                               'info:Producer'
                               'info:CreationDate'
                               'info:ModDate'
       
                       buf: The buffer to hold the results (a nul-terminated UTF-8
                       string).
       
                       size: Size of 'buf'.
       
                       Returns the number of bytes need to store the string plus terminator
                       (will be larger than 'size' if the output was truncated), or -1 if the
                       key is not recognized or found.
               """
>>>>>>         return _mupdf.FzDocument_fz_lookup_metadata(self, key, buf, size)
       
    1:     def fz_lookup_metadata2(self, key):
               r"""
               Class-aware wrapper for `::fz_lookup_metadata2()`.
               C++ alternative to `fz_lookup_metadata()` that returns a `std::string`
               or calls `fz_throw()` if not found.
               """
>>>>>>         return _mupdf.FzDocument_fz_lookup_metadata2(self, key)
       
    1:     def fz_needs_password(self):
               r"""
               Class-aware wrapper for `::fz_needs_password()`.
                       Check if a document is encrypted with a
                       non-blank password.
               """
>>>>>>         return _mupdf.FzDocument_fz_needs_password(self)
       
    1:     def fz_new_buffer_from_page_number(self, number, options):
               r"""Class-aware wrapper for `::fz_new_buffer_from_page_number()`."""
>>>>>>         return _mupdf.FzDocument_fz_new_buffer_from_page_number(self, number, options)
       
    1:     def fz_new_display_list_from_page_number(self, number):
               r"""Class-aware wrapper for `::fz_new_display_list_from_page_number()`."""
>>>>>>         return _mupdf.FzDocument_fz_new_display_list_from_page_number(self, number)
       
    1:     def fz_new_pdf_document_from_fz_document(self):
               r"""Class-aware wrapper for `::fz_new_pdf_document_from_fz_document()`."""
>>>>>>         return _mupdf.FzDocument_fz_new_pdf_document_from_fz_document(self)
       
    1:     def fz_new_pixmap_from_page_number(self, number, ctm, cs, alpha):
               r"""Class-aware wrapper for `::fz_new_pixmap_from_page_number()`."""
>>>>>>         return _mupdf.FzDocument_fz_new_pixmap_from_page_number(self, number, ctm, cs, alpha)
       
    1:     def fz_new_pixmap_from_page_number_with_separations(self, number, ctm, cs, seps, alpha):
               r"""Class-aware wrapper for `::fz_new_pixmap_from_page_number_with_separations()`."""
>>>>>>         return _mupdf.FzDocument_fz_new_pixmap_from_page_number_with_separations(self, number, ctm, cs, seps, alpha)
       
    1:     def fz_new_xhtml_document_from_document(self, *args):
               r"""
               *Overload 1:*
                Class-aware wrapper for `::fz_new_xhtml_document_from_document()`.
                               Use text extraction to convert the input document into XHTML,
                               then open the result as a new document that can be reflowed.
       
       
               |
       
               *Overload 2:*
                Class-aware wrapper for `::fz_new_xhtml_document_from_document()`.
                               Use text extraction to convert the input document into XHTML,
                               then open the result as a new document that can be reflowed.
               """
>>>>>>         return _mupdf.FzDocument_fz_new_xhtml_document_from_document(self, *args)
       
    1:     def fz_next_page(self, loc):
               r"""
               Class-aware wrapper for `::fz_next_page()`.
                       Function to get the location of the next page (allowing for the
                       end of chapters etc). If at the end of the document, returns the
                       current location.
               """
>>>>>>         return _mupdf.FzDocument_fz_next_page(self, loc)
       
    1:     def fz_open_reflowed_document(self, opts):
               r"""Class-aware wrapper for `::fz_open_reflowed_document()`."""
>>>>>>         return _mupdf.FzDocument_fz_open_reflowed_document(self, opts)
       
    1:     def fz_output_accelerator(self, accel):
               r"""
               Class-aware wrapper for `::fz_output_accelerator()`.
                       Output accelerator data for the document to a given output
                       stream.
               """
>>>>>>         return _mupdf.FzDocument_fz_output_accelerator(self, accel)
       
    1:     def fz_page_number_from_location(self, loc):
               r"""
               Class-aware wrapper for `::fz_page_number_from_location()`.
                       Converts from chapter+page to page number. This may cause many
                       chapters to be laid out in order to calculate the number of
                       pages within those chapters.
               """
>>>>>>         return _mupdf.FzDocument_fz_page_number_from_location(self, loc)
       
    1:     def fz_previous_page(self, loc):
               r"""
               Class-aware wrapper for `::fz_previous_page()`.
                       Function to get the location of the previous page (allowing for
                       the end of chapters etc). If already at the start of the
                       document, returns the current page.
               """
>>>>>>         return _mupdf.FzDocument_fz_previous_page(self, loc)
       
    1:     def fz_process_opened_pages(self, process_openend_page, state):
               r"""
               Class-aware wrapper for `::fz_process_opened_pages()`.
                       Iterates over all opened pages of the document, calling the
                       provided callback for each page for processing. If the callback
                       returns non-NULL then the iteration stops and that value is returned
                       to the called of fz_process_opened_pages().
       
                       The state pointer provided to fz_process_opened_pages() is
                       passed on to the callback but is owned by the caller.
       
                       Returns the first non-NULL value returned by the callback,
                       or NULL if the callback returned NULL for all opened pages.
               """
>>>>>>         return _mupdf.FzDocument_fz_process_opened_pages(self, process_openend_page, state)
       
    1:     def fz_resolve_link(self, uri, xp, yp):
               r"""
               Class-aware wrapper for `::fz_resolve_link()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_resolve_link(const char *uri)` => `(fz_location, float xp, float yp)`
       
                       Resolve an internal link to a page number.
       
                       xp, yp: Pointer to store coordinate of destination on the page.
       
                       Returns (-1,-1) if the URI cannot be resolved.
               """
>>>>>>         return _mupdf.FzDocument_fz_resolve_link(self, uri, xp, yp)
       
    1:     def fz_run_document_structure(self, dev, cookie):
               r"""
               Class-aware wrapper for `::fz_run_document_structure()`.
                       Run the document structure through a device.
       
                       doc: Document in question.
       
                       dev: Device obtained from fz_new_*_device.
       
                       cookie: Communication mechanism between caller and library.
                       Intended for multi-threaded applications, while
                       single-threaded applications set cookie to NULL. The
                       caller may abort an ongoing rendering of a page. Cookie also
                       communicates progress information back to the caller. The
                       fields inside cookie are continually updated while the page is
                       rendering.
               """
>>>>>>         return _mupdf.FzDocument_fz_run_document_structure(self, dev, cookie)
       
    1:     def fz_save_accelerator(self, accel):
               r"""
               Class-aware wrapper for `::fz_save_accelerator()`.
                       Save accelerator data for the document to a given file.
               """
>>>>>>         return _mupdf.FzDocument_fz_save_accelerator(self, accel)
       
    1:     def fz_search_chapter_page_number(self, chapter, page, needle, hit_mark, hit_bbox, hit_max):
               r"""
               Class-aware wrapper for `::fz_search_chapter_page_number()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_search_chapter_page_number(int chapter, int page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
               """
>>>>>>         return _mupdf.FzDocument_fz_search_chapter_page_number(self, chapter, page, needle, hit_mark, hit_bbox, hit_max)
       
    1:     def fz_search_chapter_page_number_cb(self, chapter, page, needle, cb, opaque):
               r"""Class-aware wrapper for `::fz_search_chapter_page_number_cb()`."""
>>>>>>         return _mupdf.FzDocument_fz_search_chapter_page_number_cb(self, chapter, page, needle, cb, opaque)
       
    1:     def fz_search_page2(self, number, needle, hit_max):
               r"""
               Class-aware wrapper for `::fz_search_page2()`.
               C++ alternative to fz_search_page() that returns information in a std::vector.
               """
>>>>>>         return _mupdf.FzDocument_fz_search_page2(self, number, needle, hit_max)
       
    1:     def fz_search_page_number(self, number, needle, hit_mark, hit_bbox, hit_max):
               r"""
               Class-aware wrapper for `::fz_search_page_number()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_search_page_number(int number, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
               """
>>>>>>         return _mupdf.FzDocument_fz_search_page_number(self, number, needle, hit_mark, hit_bbox, hit_max)
       
    1:     def fz_search_page_number_cb(self, number, needle, cb, opaque):
               r"""Class-aware wrapper for `::fz_search_page_number_cb()`."""
>>>>>>         return _mupdf.FzDocument_fz_search_page_number_cb(self, number, needle, cb, opaque)
       
    1:     def fz_set_metadata(self, key, value):
               r"""Class-aware wrapper for `::fz_set_metadata()`."""
>>>>>>         return _mupdf.FzDocument_fz_set_metadata(self, key, value)
       
    1:     def pdf_count_pages_imp(self, chapter):
               r"""Class-aware wrapper for `::pdf_count_pages_imp()`."""
>>>>>>         return _mupdf.FzDocument_pdf_count_pages_imp(self, chapter)
       
    1:     def pdf_document_from_fz_document(self):
               r"""Class-aware wrapper for `::pdf_document_from_fz_document()`."""
>>>>>>         return _mupdf.FzDocument_pdf_document_from_fz_document(self)
       
    1:     def pdf_load_page_imp(self, chapter, number):
               r"""Class-aware wrapper for `::pdf_load_page_imp()`."""
>>>>>>         return _mupdf.FzDocument_pdf_load_page_imp(self, chapter, number)
       
    1:     def pdf_page_label_imp(self, chapter, page, buf, size):
               r"""Class-aware wrapper for `::pdf_page_label_imp()`."""
>>>>>>         return _mupdf.FzDocument_pdf_page_label_imp(self, chapter, page, buf, size)
       
    1:     def pdf_specifics(self):
               r"""Class-aware wrapper for `::pdf_specifics()`."""
>>>>>>         return _mupdf.FzDocument_pdf_specifics(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_open_accelerated_document()`.
                               Open a document file and read its basic structure so pages and
                               objects can be located. MuPDF will try to repair broken
                               documents (without actually changing the file contents).
       
                               The returned fz_document is used when calling most other
                               document related functions.
       
                               filename: a path to a file as it would be given to open(2).
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_open_accelerated_document_with_stream()`.
                               Open a document using the specified stream object rather than
                               opening a file on disk.
       
                               magic: a string used to detect document type; either a file name
                               or mime-type.
       
                               stream: a stream of the document contents.
       
                               accel: NULL, or a stream of the 'accelerator' contents for this document.
       
                               NOTE: The caller retains ownership of 'stream' and 'accel' - the document will
                               take its own references if required.
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_open_accelerated_document_with_stream_and_dir()`.
                               Open a document using the specified stream object rather than
                               opening a file on disk.
       
                               magic: a string used to detect document type; either a file name
                               or mime-type.
       
                               stream: a stream of the document contents.
       
                               accel: NULL, or a stream of the 'accelerator' contents for this document.
       
                               dir: NULL, or the 'directory context' for the stream contents.
       
                               NOTE: The caller retains ownership of 'stream', 'accel' and 'dir' - the document will
                               take its own references if required.
       
       
               |
       
               *Overload 4:*
                Constructor using `fz_open_document()`.
                               Open a document file and read its basic structure so pages and
                               objects can be located. MuPDF will try to repair broken
                               documents (without actually changing the file contents).
       
                               The returned fz_document is used when calling most other
                               document related functions.
       
                               filename: a path to a file as it would be given to open(2).
       
       
               |
       
               *Overload 5:*
                Constructor using `fz_open_document_with_buffer()`.
                               Open a document using a buffer rather than opening a file on disk.
       
       
               |
       
               *Overload 6:*
                Constructor using `fz_open_document_with_stream()`.
                               Open a document using the specified stream object rather than
                               opening a file on disk.
       
                               magic: a string used to detect document type; either a file name
                               or mime-type.
       
                               stream: a stream representing the contents of the document file.
       
                               NOTE: The caller retains ownership of 'stream' - the document will take its
                               own reference if required.
       
       
               |
       
               *Overload 7:*
                Constructor using `fz_open_document_with_stream_and_dir()`.
                               Open a document using the specified stream object rather than
                               opening a file on disk.
       
                               magic: a string used to detect document type; either a file name
                               or mime-type.
       
                               stream: a stream representing the contents of the document file.
       
                               dir: a 'directory context' for those filetypes that need it.
       
                               NOTE: The caller retains ownership of 'stream' and 'dir' - the document will
                               take its own references if required.
       
       
               |
       
               *Overload 8:*
                Returns a FzDocument for pdfdocument.m_internal.super.
       
               |
       
               *Overload 9:*
                Copy constructor using `fz_keep_document()`.
       
               |
       
               *Overload 10:*
                Constructor using raw copy of pre-existing `::fz_document`.
       
               |
       
               *Overload 11:*
                Constructor using raw copy of pre-existing `::fz_document`.
               """
>>>>>>         _mupdf.FzDocument_swiginit(self, _mupdf.new_FzDocument(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzDocument
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzDocument_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzDocument___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzDocument_m_internal_get, _mupdf.FzDocument_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzDocument_s_num_instances_get, _mupdf.FzDocument_s_num_instances_set)
       
       # Register FzDocument in _mupdf:
    1: _mupdf.FzDocument_swigregister(FzDocument)
    2: class FzDocumentHandler(object):
    1:     r"""Wrapper class for struct `fz_document_handler`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_document_handler_open(self, stream, accel, dir, recognize_state):
               r"""
               Class-aware wrapper for `::fz_document_handler_open()`.   Helper for calling `fz_document_handler::open` function pointer via
               Swig from Python/C#.
               """
>>>>>>         return _mupdf.FzDocumentHandler_fz_document_handler_open(self, stream, accel, dir, recognize_state)
       
    1:     def fz_document_handler_recognize(self, magic):
               r"""
               Class-aware wrapper for `::fz_document_handler_recognize()`.   Helper for calling a `fz_document_handler::recognize` function
               pointer via Swig from Python/C#.
               """
>>>>>>         return _mupdf.FzDocumentHandler_fz_document_handler_recognize(self, magic)
       
    1:     def fz_register_document_handler(self):
               r"""
               Class-aware wrapper for `::fz_register_document_handler()`.
                       Register a handler for a document type.
       
                       handler: The handler to register. This must live on for the duration of the
                       use of this handler. It will be passed back to the handler for calls so
                       the caller can use it to retrieve state.
               """
>>>>>>         return _mupdf.FzDocumentHandler_fz_register_document_handler(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_document_handler`.
               """
>>>>>>         _mupdf.FzDocumentHandler_swiginit(self, _mupdf.new_FzDocumentHandler(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzDocumentHandler
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzDocumentHandler_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzDocumentHandler___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzDocumentHandler_m_internal_get, _mupdf.FzDocumentHandler_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzDocumentHandler_s_num_instances_get, _mupdf.FzDocumentHandler_s_num_instances_set)
       
       # Register FzDocumentHandler in _mupdf:
    1: _mupdf.FzDocumentHandler_swigregister(FzDocumentHandler)
    2: class FzDocumentHandlerContext(object):
    1:     r"""Wrapper class for struct `fz_document_handler_context`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_document_handler_context`.
               """
>>>>>>         _mupdf.FzDocumentHandlerContext_swiginit(self, _mupdf.new_FzDocumentHandlerContext(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzDocumentHandlerContext
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzDocumentHandlerContext_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzDocumentHandlerContext___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzDocumentHandlerContext_m_internal_get, _mupdf.FzDocumentHandlerContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzDocumentHandlerContext_s_num_instances_get, _mupdf.FzDocumentHandlerContext_s_num_instances_set)
       
       # Register FzDocumentHandlerContext in _mupdf:
    1: _mupdf.FzDocumentHandlerContext_swigregister(FzDocumentHandlerContext)
    2: class FzDocumentWriter(object):
    1:     r"""Wrapper class for struct `fz_document_writer`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     PathType_CBZ = _mupdf.FzDocumentWriter_PathType_CBZ
    1:     PathType_DOCX = _mupdf.FzDocumentWriter_PathType_DOCX
    1:     PathType_ODT = _mupdf.FzDocumentWriter_PathType_ODT
    1:     PathType_PAM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PAM_PIXMAP
    1:     PathType_PBM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PBM_PIXMAP
    1:     PathType_PCL = _mupdf.FzDocumentWriter_PathType_PCL
    1:     PathType_PCLM = _mupdf.FzDocumentWriter_PathType_PCLM
    1:     PathType_PDF = _mupdf.FzDocumentWriter_PathType_PDF
    1:     PathType_PDFOCR = _mupdf.FzDocumentWriter_PathType_PDFOCR
    1:     PathType_PGM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PGM_PIXMAP
    1:     PathType_PKM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PKM_PIXMAP
    1:     PathType_PNG_PIXMAP = _mupdf.FzDocumentWriter_PathType_PNG_PIXMAP
    1:     PathType_PNM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PNM_PIXMAP
    1:     PathType_PPM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PPM_PIXMAP
    1:     PathType_PS = _mupdf.FzDocumentWriter_PathType_PS
    1:     PathType_PWG = _mupdf.FzDocumentWriter_PathType_PWG
    1:     PathType_SVG = _mupdf.FzDocumentWriter_PathType_SVG
    1:     OutputType_CBZ = _mupdf.FzDocumentWriter_OutputType_CBZ
    1:     OutputType_DOCX = _mupdf.FzDocumentWriter_OutputType_DOCX
    1:     OutputType_ODT = _mupdf.FzDocumentWriter_OutputType_ODT
    1:     OutputType_PCL = _mupdf.FzDocumentWriter_OutputType_PCL
    1:     OutputType_PCLM = _mupdf.FzDocumentWriter_OutputType_PCLM
    1:     OutputType_PDF = _mupdf.FzDocumentWriter_OutputType_PDF
    1:     OutputType_PDFOCR = _mupdf.FzDocumentWriter_OutputType_PDFOCR
    1:     OutputType_PS = _mupdf.FzDocumentWriter_OutputType_PS
    1:     OutputType_PWG = _mupdf.FzDocumentWriter_OutputType_PWG
    1:     FormatPathType_DOCUMENT = _mupdf.FzDocumentWriter_FormatPathType_DOCUMENT
    1:     FormatPathType_TEXT = _mupdf.FzDocumentWriter_FormatPathType_TEXT
       
    1:     def fz_begin_page(self, mediabox):
               r"""
               Class-aware wrapper for `::fz_begin_page()`.
                       Called to start the process of writing a page to
                       a document.
       
                       mediabox: page size rectangle in points.
       
                       Returns a borrowed fz_device to write page contents to. This
                       should be kept if required, and only dropped if it was kept.
               """
>>>>>>         return _mupdf.FzDocumentWriter_fz_begin_page(self, mediabox)
       
    1:     def fz_close_document_writer(self):
               r"""
               Class-aware wrapper for `::fz_close_document_writer()`.
                       Called to end the process of writing
                       pages to a document.
       
                       This writes any file level trailers required. After this
                       completes successfully the file is up to date and complete.
               """
>>>>>>         return _mupdf.FzDocumentWriter_fz_close_document_writer(self)
       
    1:     def fz_end_page(self):
               r"""
               Class-aware wrapper for `::fz_end_page()`.
                       Called to end the process of writing a page to a
                       document.
               """
>>>>>>         return _mupdf.FzDocumentWriter_fz_end_page(self)
       
    1:     def fz_pdfocr_writer_set_progress(self, progress, arg_2):
               r"""Class-aware wrapper for `::fz_pdfocr_writer_set_progress()`."""
>>>>>>         return _mupdf.FzDocumentWriter_fz_pdfocr_writer_set_progress(self, progress, arg_2)
       
    1:     def fz_write_document(self, doc):
               r"""
               Class-aware wrapper for `::fz_write_document()`.
                       Convenience function to feed all the pages of a document to
                       fz_begin_page/fz_run_page/fz_end_page.
               """
>>>>>>         return _mupdf.FzDocumentWriter_fz_write_document(self, doc)
       
    1:     def fz_write_stabilized_story(self, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir):
               r"""Class-aware wrapper for `::fz_write_stabilized_story()`."""
>>>>>>         return _mupdf.FzDocumentWriter_fz_write_stabilized_story(self, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir)
       
    1:     def fz_write_story(self, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref):
               r"""Class-aware wrapper for `::fz_write_story()`."""
>>>>>>         return _mupdf.FzDocumentWriter_fz_write_story(self, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_csv_writer()`.
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_csv_writer_with_output()`.  Constructor using `fz_new_document_writer_of_size()`.
                               Internal function to allocate a
                               block for a derived document_writer structure, with the base
                               structure's function pointers populated correctly, and the extra
                               space zero initialised.
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_document_writer_with_buffer()`.
       
               |
       
               *Overload 4:*
                Constructor using `fz_new_jpeg_pixmap_writer()`.  Constructor using `fz_new_pixmap_writer()`.
       
               |
       
               *Overload 5:*
                Constructor using `fz_new_svg_writer_with_output()`.
       
               |
       
               *Overload 6:*
                Constructor using one of:
                               fz_new_cbz_writer()
                               fz_new_docx_writer()
                               fz_new_odt_writer()
                               fz_new_pam_pixmap_writer()
                               fz_new_pbm_pixmap_writer()
                               fz_new_pcl_writer()
                               fz_new_pclm_writer()
                               fz_new_pdf_writer()
                               fz_new_pdfocr_writer()
                               fz_new_pgm_pixmap_writer()
                               fz_new_pkm_pixmap_writer()
                               fz_new_png_pixmap_writer()
                               fz_new_pnm_pixmap_writer()
                               fz_new_ppm_pixmap_writer()
                               fz_new_ps_writer()
                               fz_new_pwg_writer()
                               fz_new_svg_writer()
       
       
               |
       
               *Overload 7:*
                Constructor using one of:
                               fz_new_cbz_writer_with_output()
                               fz_new_docx_writer_with_output()
                               fz_new_odt_writer_with_output()
                               fz_new_pcl_writer_with_output()
                               fz_new_pclm_writer_with_output()
                               fz_new_pdf_writer_with_output()
                               fz_new_pdfocr_writer_with_output()
                               fz_new_ps_writer_with_output()
                               fz_new_pwg_writer_with_output()
       
                       This constructor takes ownership of <out> -
                       out.m_internal is set to NULL after this constructor
                       returns so <out> must not be used again.
       
       
               |
       
               *Overload 8:*
                Constructor using one of:
                               fz_new_document_writer()
                               fz_new_text_writer()
       
       
               |
       
               *Overload 9:*
                Constructor using fz_new_document_writer_with_output().
       
                       This constructor takes ownership of <out> -
                       out.m_internal is set to NULL after this constructor
                       returns so <out> must not be used again.
       
       
               |
       
               *Overload 10:*
                Constructor using fz_new_text_writer_with_output().
       
                       This constructor takes ownership of <out> -
                       out.m_internal is set to NULL after this constructor
                       returns so <out> must not be used again.
       
       
               |
       
               *Overload 11:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 12:*
                Constructor using raw copy of pre-existing `::fz_document_writer`.
               """
>>>>>>         _mupdf.FzDocumentWriter_swiginit(self, _mupdf.new_FzDocumentWriter(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzDocumentWriter
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzDocumentWriter_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzDocumentWriter___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzDocumentWriter_m_internal_get, _mupdf.FzDocumentWriter_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzDocumentWriter_s_num_instances_get, _mupdf.FzDocumentWriter_s_num_instances_set)
       
       # Register FzDocumentWriter in _mupdf:
    1: _mupdf.FzDocumentWriter_swigregister(FzDocumentWriter)
    2: class FzDrawOptions(object):
    1:     r"""
           Wrapper class for struct `fz_draw_options`. Not copyable or assignable.
           struct fz_draw_options: Options for creating a pixmap and draw
           device.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_parse_draw_options()`.
                               Parse draw device options from a comma separated key-value string.
       
       
               |
       
               *Overload 2:*
                Default constructor, sets each member to default value.
       
               |
       
               *Overload 3:*
                Constructor using raw copy of pre-existing `::fz_draw_options`.
       
               |
       
               *Overload 4:*
                Constructor using raw copy of pre-existing `::fz_draw_options`.
               """
>>>>>>         _mupdf.FzDrawOptions_swiginit(self, _mupdf.new_FzDrawOptions(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.FzDrawOptions_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_FzDrawOptions
    1:     rotate = property(_mupdf.FzDrawOptions_rotate_get, _mupdf.FzDrawOptions_rotate_set)
    1:     x_resolution = property(_mupdf.FzDrawOptions_x_resolution_get, _mupdf.FzDrawOptions_x_resolution_set)
    1:     y_resolution = property(_mupdf.FzDrawOptions_y_resolution_get, _mupdf.FzDrawOptions_y_resolution_set)
    1:     width = property(_mupdf.FzDrawOptions_width_get, _mupdf.FzDrawOptions_width_set)
    1:     height = property(_mupdf.FzDrawOptions_height_get, _mupdf.FzDrawOptions_height_set)
    1:     colorspace = property(_mupdf.FzDrawOptions_colorspace_get, _mupdf.FzDrawOptions_colorspace_set)
    1:     alpha = property(_mupdf.FzDrawOptions_alpha_get, _mupdf.FzDrawOptions_alpha_set)
    1:     graphics = property(_mupdf.FzDrawOptions_graphics_get, _mupdf.FzDrawOptions_graphics_set)
    1:     text = property(_mupdf.FzDrawOptions_text_get, _mupdf.FzDrawOptions_text_set)
    1:     s_num_instances = property(_mupdf.FzDrawOptions_s_num_instances_get, _mupdf.FzDrawOptions_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzDrawOptions_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzDrawOptions___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzDrawOptions___ne__(self, rhs)
       
       # Register FzDrawOptions in _mupdf:
    1: _mupdf.FzDrawOptions_swigregister(FzDrawOptions)
    2: class FzErrorContext(object):
    1:     r"""Wrapper class for struct `fz_error_context`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_error_context`.
               """
>>>>>>         _mupdf.FzErrorContext_swiginit(self, _mupdf.new_FzErrorContext(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorContext
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzErrorContext_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzErrorContext___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzErrorContext_m_internal_get, _mupdf.FzErrorContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzErrorContext_s_num_instances_get, _mupdf.FzErrorContext_s_num_instances_set)
       
       # Register FzErrorContext in _mupdf:
    1: _mupdf.FzErrorContext_swigregister(FzErrorContext)
    2: class FzErrorStackSlot(object):
    1:     r"""Wrapper class for struct `fz_error_stack_slot`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_error_stack_slot`.
               """
>>>>>>         _mupdf.FzErrorStackSlot_swiginit(self, _mupdf.new_FzErrorStackSlot(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorStackSlot
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzErrorStackSlot_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzErrorStackSlot___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzErrorStackSlot_m_internal_get, _mupdf.FzErrorStackSlot_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzErrorStackSlot_s_num_instances_get, _mupdf.FzErrorStackSlot_s_num_instances_set)
       
       # Register FzErrorStackSlot in _mupdf:
    1: _mupdf.FzErrorStackSlot_swigregister(FzErrorStackSlot)
    2: class FzFont(object):
    1:     r"""
           Wrapper class for struct `fz_font`.
           An abstract font handle.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_advance_glyph(self, glyph, wmode):
               r"""
               Class-aware wrapper for `::fz_advance_glyph()`.
                       Return the advance for a given glyph.
       
                       font: The font to look for the glyph in.
       
                       glyph: The glyph to find the advance for.
       
                       wmode: 1 for vertical mode, 0 for horizontal.
       
                       Returns the advance for the glyph.
               """
>>>>>>         return _mupdf.FzFont_fz_advance_glyph(self, glyph, wmode)
       
    1:     def fz_bound_glyph(self, gid, trm):
               r"""
               Class-aware wrapper for `::fz_bound_glyph()`.
                       Return a bbox for a given glyph in a font.
       
                       font: The font to look for the glyph in.
       
                       gid: The glyph to bound.
       
                       trm: The matrix to apply to the glyph before bounding.
       
                       Returns rectangle by value containing the bounds of the given
                       glyph.
               """
>>>>>>         return _mupdf.FzFont_fz_bound_glyph(self, gid, trm)
       
    1:     def fz_calculate_font_ascender_descender(self):
               r"""
               Class-aware wrapper for `::fz_calculate_font_ascender_descender()`.
                       Ensure that a font has its ascender/descender values calculated
                       from the actual bbox of the glyphs.
       
                       Note, that we combine the declared values from the font (or the
                       default values if those are not present) with the actual bbox to
                       get the final result. So this can only cause ascender/descender
                       to move further apart!
               """
>>>>>>         return _mupdf.FzFont_fz_calculate_font_ascender_descender(self)
       
    1:     def fz_decouple_type3_font(self, t3doc):
               r"""Class-aware wrapper for `::fz_decouple_type3_font()`."""
>>>>>>         return _mupdf.FzFont_fz_decouple_type3_font(self, t3doc)
       
    1:     def fz_encode_character(self, unicode):
               r"""
               Class-aware wrapper for `::fz_encode_character()`.
                       Find the glyph id for a given unicode
                       character within a font.
       
                       font: The font to look for the unicode character in.
       
                       unicode: The unicode character to encode.
       
                       Returns the glyph id for the given unicode value, or 0 if
                       unknown.
               """
>>>>>>         return _mupdf.FzFont_fz_encode_character(self, unicode)
       
    1:     def fz_encode_character_by_glyph_name(self, glyphname):
               r"""
               Class-aware wrapper for `::fz_encode_character_by_glyph_name()`.
                       Encode character.
       
                       Either by direct lookup of glyphname within a font, or, failing
                       that, by mapping glyphname to unicode and thence to the glyph
                       index within the given font.
       
                       Returns zero for type3 fonts.
               """
>>>>>>         return _mupdf.FzFont_fz_encode_character_by_glyph_name(self, glyphname)
       
    1:     def fz_encode_character_sc(self, unicode):
               r"""
               Class-aware wrapper for `::fz_encode_character_sc()`.
                       Encode character, preferring small-caps variant if available.
       
                       font: The font to look for the unicode character in.
       
                       unicode: The unicode character to encode.
       
                       Returns the glyph id for the given unicode value, or 0 if
                       unknown.
               """
>>>>>>         return _mupdf.FzFont_fz_encode_character_sc(self, unicode)
       
    1:     def fz_encode_character_with_fallback(self, unicode, script, language, out_font):
               r"""
               Class-aware wrapper for `::fz_encode_character_with_fallback()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_encode_character_with_fallback(int unicode, int script, int language, ::fz_font **out_font)` => `(int)`
       
                       Find the glyph id for
                       a given unicode character within a font, falling back to
                       an alternative if not found.
       
                       font: The font to look for the unicode character in.
       
                       unicode: The unicode character to encode.
       
                       script: The script in use.
       
                       language: The language in use.
       
                       out_font: The font handle in which the given glyph represents
                       the requested unicode character. The caller does not own the
                       reference it is passed, so should call fz_keep_font if it is
                       not simply to be used immediately.
       
                       Returns the glyph id for the given unicode value in the supplied
                       font (and sets *out_font to font) if it is present. Otherwise
                       an alternative fallback font (based on script/language) is
                       searched for. If the glyph is found therein, *out_font is set
                       to this reference, and the glyph reference is returned. If it
                       cannot be found anywhere, the function returns 0.
               """
>>>>>>         return _mupdf.FzFont_fz_encode_character_with_fallback(self, unicode, script, language, out_font)
       
    1:     def fz_enumerate_font_cmap(self, cb, opaque):
               r"""
               Class-aware wrapper for `::fz_enumerate_font_cmap()`.
                       Enumerate a cmap using a callback.
               """
>>>>>>         return _mupdf.FzFont_fz_enumerate_font_cmap(self, cb, opaque)
       
    1:     def fz_enumerate_font_cmap2(self):
               r"""Class-aware wrapper for `::fz_enumerate_font_cmap2()`.   SWIG-friendly wrapper for fz_enumerate_font_cmap()."""
>>>>>>         return _mupdf.FzFont_fz_enumerate_font_cmap2(self)
       
    1:     def fz_extract_ttf_from_ttc(self):
               r"""Class-aware wrapper for `::fz_extract_ttf_from_ttc()`."""
>>>>>>         return _mupdf.FzFont_fz_extract_ttf_from_ttc(self)
       
    1:     def fz_font_ascender(self):
               r"""
               Class-aware wrapper for `::fz_font_ascender()`.
                       Retrieve font ascender in ems.
               """
>>>>>>         return _mupdf.FzFont_fz_font_ascender(self)
       
    1:     def fz_font_bbox(self):
               r"""
               Class-aware wrapper for `::fz_font_bbox()`.
                       Retrieve the font bbox.
       
                       font: The font to query.
       
                       Returns the font bbox by value; it is valid only if
                       fz_font_flags(font)->invalid_bbox is zero.
               """
>>>>>>         return _mupdf.FzFont_fz_font_bbox(self)
       
    1:     def fz_font_descender(self):
               r"""
               Class-aware wrapper for `::fz_font_descender()`.
                       Retrieve font descender in ems.
               """
>>>>>>         return _mupdf.FzFont_fz_font_descender(self)
       
    1:     def fz_font_digest(self, digest):
               r"""
               Class-aware wrapper for `::fz_font_digest()`.
                       Retrieve the MD5 digest for the font's data.
               """
>>>>>>         return _mupdf.FzFont_fz_font_digest(self, digest)
       
    1:     def fz_font_ft_face(self):
               r"""
               Class-aware wrapper for `::fz_font_ft_face()`.
                       Retrieve the FT_Face handle
                       for the font.
       
                       font: The font to query
       
                       Returns the FT_Face handle for the font, or NULL
                       if not a freetype handled font. (Cast to void *
                       to avoid nasty header exposure).
               """
>>>>>>         return _mupdf.FzFont_fz_font_ft_face(self)
       
    1:     def fz_font_is_bold(self):
               r"""
               Class-aware wrapper for `::fz_font_is_bold()`.
                       Query whether the font flags say that this font is bold.
               """
>>>>>>         return _mupdf.FzFont_fz_font_is_bold(self)
       
    1:     def fz_font_is_italic(self):
               r"""
               Class-aware wrapper for `::fz_font_is_italic()`.
                       Query whether the font flags say that this font is italic.
               """
>>>>>>         return _mupdf.FzFont_fz_font_is_italic(self)
       
    1:     def fz_font_is_monospaced(self):
               r"""
               Class-aware wrapper for `::fz_font_is_monospaced()`.
                       Query whether the font flags say that this font is monospaced.
               """
>>>>>>         return _mupdf.FzFont_fz_font_is_monospaced(self)
       
    1:     def fz_font_is_serif(self):
               r"""
               Class-aware wrapper for `::fz_font_is_serif()`.
                       Query whether the font flags say that this font is serif.
               """
>>>>>>         return _mupdf.FzFont_fz_font_is_serif(self)
       
    1:     def fz_font_name(self):
               r"""
               Class-aware wrapper for `::fz_font_name()`.
                       Retrieve a pointer to the name of the font.
       
                       font: The font to query.
       
                       Returns a pointer to an internal copy of the font name.
                       Will never be NULL, but may be the empty string.
               """
>>>>>>         return _mupdf.FzFont_fz_font_name(self)
       
    1:     def fz_font_t3_procs(self):
               r"""
               Class-aware wrapper for `::fz_font_t3_procs()`.
                       Retrieve the Type3 procs
                       for a font.
       
                       font: The font to query
       
                       Returns the t3_procs pointer. Will be NULL for a
                       non type-3 font.
               """
>>>>>>         return _mupdf.FzFont_fz_font_t3_procs(self)
       
    1:     def fz_get_glyph_name(self, glyph, buf, size):
               r"""
               Class-aware wrapper for `::fz_get_glyph_name()`.
                       Find the name of a glyph
       
                       font: The font to look for the glyph in.
       
                       glyph: The glyph id to look for.
       
                       buf: Pointer to a buffer for the name to be inserted into.
       
                       size: The size of the buffer.
       
                       If a font contains a name table, then the name of the glyph
                       will be returned in the supplied buffer. Otherwise a name
                       is synthesised. The name will be truncated to fit in
                       the buffer.
               """
>>>>>>         return _mupdf.FzFont_fz_get_glyph_name(self, glyph, buf, size)
       
    1:     def fz_get_glyph_name2(self, glyph):
               r"""
               Class-aware wrapper for `::fz_get_glyph_name2()`.
               C++ alternative to fz_get_glyph_name() that returns information in a std::string.
               """
>>>>>>         return _mupdf.FzFont_fz_get_glyph_name2(self, glyph)
       
    1:     def fz_glyph_cacheable(self, gid):
               r"""
               Class-aware wrapper for `::fz_glyph_cacheable()`.
                       Determine if a given glyph in a font
                       is cacheable. Certain glyphs in a type 3 font cannot safely
                       be cached, as their appearance depends on the enclosing
                       graphic state.
       
                       font: The font to look for the glyph in.
       
                       gif: The glyph to query.
       
                       Returns non-zero if cacheable, 0 if not.
               """
>>>>>>         return _mupdf.FzFont_fz_glyph_cacheable(self, gid)
       
    1:     def fz_measure_string(self, trm, s, wmode, bidi_level, markup_dir, language):
               r"""
               Class-aware wrapper for `::fz_measure_string()`.
                       Measure the advance width of a UTF8 string should it be added to a text object.
       
                       This uses the same layout algorithms as fz_show_string, and can be used
                       to calculate text alignment adjustments.
               """
>>>>>>         return _mupdf.FzFont_fz_measure_string(self, trm, s, wmode, bidi_level, markup_dir, language)
       
    1:     def fz_outline_glyph(self, gid, ctm):
               r"""
               Class-aware wrapper for `::fz_outline_glyph()`.
                       Look a glyph up from a font, and return the outline of the
                       glyph using the given transform.
       
                       The caller owns the returned path, and so is responsible for
                       ensuring that it eventually gets dropped.
               """
>>>>>>         return _mupdf.FzFont_fz_outline_glyph(self, gid, ctm)
       
    1:     def fz_prepare_t3_glyph(self, gid):
               r"""
               Class-aware wrapper for `::fz_prepare_t3_glyph()`.
                       Force a type3 font to cache the displaylist for a given glyph
                       id.
       
                       This caching can involve reading the underlying file, so must
                       happen ahead of time, so we aren't suddenly forced to read the
                       file while playing a displaylist back.
               """
>>>>>>         return _mupdf.FzFont_fz_prepare_t3_glyph(self, gid)
       
    1:     def fz_render_glyph_pixmap(self, gid, ctm, scissor, aa):
               r"""
               Class-aware wrapper for `::fz_render_glyph_pixmap()`.
                       Create a pixmap containing a rendered glyph.
       
                       Lookup gid from font, clip it with scissor, and rendering it
                       with aa bits of antialiasing into a new pixmap.
       
                       The caller takes ownership of the pixmap and so must free it.
       
                       Note: This function is no longer used for normal rendering
                       operations, and is kept around just because we use it in the
                       app. It should be considered "at risk" of removal from the API.
               """
>>>>>>         return _mupdf.FzFont_fz_render_glyph_pixmap(self, gid, ctm, scissor, aa)
       
    1:     def fz_run_t3_glyph(self, gid, trm, dev):
               r"""
               Class-aware wrapper for `::fz_run_t3_glyph()`.
                       Run a glyph from a Type3 font to
                       a given device.
       
                       font: The font to find the glyph in.
       
                       gid: The glyph to run.
       
                       trm: The transform to apply.
       
                       dev: The device to render onto.
               """
>>>>>>         return _mupdf.FzFont_fz_run_t3_glyph(self, gid, trm, dev)
       
    1:     def fz_set_font_bbox(self, xmin, ymin, xmax, ymax):
               r"""
               Class-aware wrapper for `::fz_set_font_bbox()`.
                       Set the font bbox.
       
                       font: The font to set the bbox for.
       
                       xmin, ymin, xmax, ymax: The bounding box.
               """
>>>>>>         return _mupdf.FzFont_fz_set_font_bbox(self, xmin, ymin, xmax, ymax)
       
    1:     def fz_set_font_embedding(self, embed):
               r"""
               Class-aware wrapper for `::fz_set_font_embedding()`.
                       Control whether a given font should be embedded or not when writing.
               """
>>>>>>         return _mupdf.FzFont_fz_set_font_embedding(self, embed)
       
    1:     def pdf_font_writing_supported(self):
               r"""Class-aware wrapper for `::pdf_font_writing_supported()`."""
>>>>>>         return _mupdf.FzFont_pdf_font_writing_supported(self)
       
    1:     def pdf_layout_fit_text(self, lang, str, bounds):
               r"""Class-aware wrapper for `::pdf_layout_fit_text()`."""
>>>>>>         return _mupdf.FzFont_pdf_layout_fit_text(self, lang, str, bounds)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_base14_font()`.
                               Create a new font from one of the built-in fonts.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_builtin_font()`.
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_cjk_font()`.
       
               |
       
               *Overload 4:*
                Constructor using `fz_new_font_from_buffer()`.
                               Create a new font from a font file in a fz_buffer.
       
                               Fonts created in this way, will be eligible for embedding by default.
       
                               name: Name of font (leave NULL to use name from font).
       
                               buffer: Buffer to load from.
       
                               index: Which font from the file to load (0 for default).
       
                               use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.
       
                               Returns new font handle, or throws exception on error.
       
       
               |
       
               *Overload 5:*
                Constructor using `fz_new_font_from_file()`.
                               Create a new font from a font file.
       
                               Fonts created in this way, will be eligible for embedding by default.
       
                               name: Name of font (leave NULL to use name from font).
       
                               path: File path to load from.
       
                               index: Which font from the file to load (0 for default).
       
                               use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.
       
                               Returns new font handle, or throws exception on error.
       
       
               |
       
               *Overload 6:*
                Constructor using `fz_new_font_from_memory()`.
                               Create a new font from a font file in memory.
       
                               Fonts created in this way, will be eligible for embedding by default.
       
                               name: Name of font (leave NULL to use name from font).
       
                               data: Pointer to the font file data.
       
                               len: Length of the font file data.
       
                               index: Which font from the file to load (0 for default).
       
                               use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.
       
                               Returns new font handle, or throws exception on error.
       
       
               |
       
               *Overload 7:*
                Constructor using `fz_new_type3_font()`.
                               Create a new (empty) type3 font.
       
                               name: Name of font (or NULL).
       
                               matrix: Font matrix.
       
                               Returns a new font handle, or throws exception on
                               allocation failure.
       
       
               |
       
               *Overload 8:*
                Copy constructor using `fz_keep_font()`.
       
               |
       
               *Overload 9:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 10:*
                Constructor using raw copy of pre-existing `::fz_font`.
               """
>>>>>>         _mupdf.FzFont_swiginit(self, _mupdf.new_FzFont(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzFont
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzFont_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzFont___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzFont_m_internal_get, _mupdf.FzFont_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzFont_s_num_instances_get, _mupdf.FzFont_s_num_instances_set)
       
       # Register FzFont in _mupdf:
    1: _mupdf.FzFont_swigregister(FzFont)
    2: class FzFontContext(object):
    1:     r"""Wrapper class for struct `fz_font_context`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_font_context`.
               """
>>>>>>         _mupdf.FzFontContext_swiginit(self, _mupdf.new_FzFontContext(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzFontContext
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzFontContext_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzFontContext___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzFontContext_m_internal_get, _mupdf.FzFontContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzFontContext_s_num_instances_get, _mupdf.FzFontContext_s_num_instances_set)
       
       # Register FzFontContext in _mupdf:
    1: _mupdf.FzFontContext_swigregister(FzFontContext)
    2: class FzFontFlagsT(object):
    1:     r"""
           Wrapper class for struct `fz_font_flags_t`. Not copyable or assignable.
           Every fz_font carries a set of flags
           within it, in a fz_font_flags_t structure.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_font_flags_t`.
               """
>>>>>>         _mupdf.FzFontFlagsT_swiginit(self, _mupdf.new_FzFontFlagsT(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzFontFlagsT
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzFontFlagsT_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzFontFlagsT___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzFontFlagsT_m_internal_get, _mupdf.FzFontFlagsT_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzFontFlagsT_s_num_instances_get, _mupdf.FzFontFlagsT_s_num_instances_set)
       
       # Register FzFontFlagsT in _mupdf:
    1: _mupdf.FzFontFlagsT_swigregister(FzFontFlagsT)
    2: class FzFunction(object):
    1:     r"""Wrapper class for struct `fz_function`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_eval_function(self, _in, inlen, out, outlen):
               r"""
               Class-aware wrapper for `::fz_eval_function()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_eval_function(const float *in, int inlen, int outlen)` => float out
               """
>>>>>>         return _mupdf.FzFunction_fz_eval_function(self, _in, inlen, out, outlen)
       
    1:     def fz_function_size(self):
               r"""Class-aware wrapper for `::fz_function_size()`."""
>>>>>>         return _mupdf.FzFunction_fz_function_size(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `fz_new_function_of_size()`.
       
               |
       
               *Overload 2:*
               Copy constructor using `fz_keep_function()`.
       
               |
       
               *Overload 3:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 4:*
               Constructor using raw copy of pre-existing `::fz_function`.
               """
>>>>>>         _mupdf.FzFunction_swiginit(self, _mupdf.new_FzFunction(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzFunction
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzFunction_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzFunction___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzFunction_m_internal_get, _mupdf.FzFunction_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzFunction_s_num_instances_get, _mupdf.FzFunction_s_num_instances_set)
       
       # Register FzFunction in _mupdf:
    1: _mupdf.FzFunction_swigregister(FzFunction)
    2: class FzGetoptLongOptions(object):
    1:     r"""Wrapper class for struct `fz_getopt_long_options`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_getopt_long_options`.
               """
>>>>>>         _mupdf.FzGetoptLongOptions_swiginit(self, _mupdf.new_FzGetoptLongOptions(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzGetoptLongOptions
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzGetoptLongOptions_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzGetoptLongOptions___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzGetoptLongOptions_m_internal_get, _mupdf.FzGetoptLongOptions_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzGetoptLongOptions_s_num_instances_get, _mupdf.FzGetoptLongOptions_s_num_instances_set)
       
       # Register FzGetoptLongOptions in _mupdf:
    1: _mupdf.FzGetoptLongOptions_swigregister(FzGetoptLongOptions)
    2: class FzGlyph(object):
    1:     r"""
           Wrapper class for struct `fz_glyph`.
           Glyphs represent a run length encoded set of pixels for a 2
           dimensional region of a plane.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_glyph_bbox(self):
               r"""
               Class-aware wrapper for `::fz_glyph_bbox()`.
                       Return the bounding box of the glyph in pixels.
               """
>>>>>>         return _mupdf.FzGlyph_fz_glyph_bbox(self)
       
    1:     def fz_glyph_bbox_no_ctx(self):
               r"""Class-aware wrapper for `::fz_glyph_bbox_no_ctx()`."""
>>>>>>         return _mupdf.FzGlyph_fz_glyph_bbox_no_ctx(self)
       
    1:     def fz_glyph_height(self):
               r"""
               Class-aware wrapper for `::fz_glyph_height()`.
                       Return the height of the glyph in pixels.
               """
>>>>>>         return _mupdf.FzGlyph_fz_glyph_height(self)
       
    1:     def fz_glyph_width(self):
               r"""
               Class-aware wrapper for `::fz_glyph_width()`.
                       Return the width of the glyph in pixels.
               """
>>>>>>         return _mupdf.FzGlyph_fz_glyph_width(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Copy constructor using `fz_keep_glyph()`.
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_glyph`.
               """
>>>>>>         _mupdf.FzGlyph_swiginit(self, _mupdf.new_FzGlyph(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzGlyph
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzGlyph_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzGlyph___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzGlyph_m_internal_get, _mupdf.FzGlyph_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzGlyph_s_num_instances_get, _mupdf.FzGlyph_s_num_instances_set)
       
       # Register FzGlyph in _mupdf:
    1: _mupdf.FzGlyph_swigregister(FzGlyph)
    2: class FzGlyphCache(object):
    1:     r"""Wrapper class for struct `fz_glyph_cache`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_glyph_cache`.
               """
>>>>>>         _mupdf.FzGlyphCache_swiginit(self, _mupdf.new_FzGlyphCache(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzGlyphCache
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzGlyphCache_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzGlyphCache___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzGlyphCache_m_internal_get, _mupdf.FzGlyphCache_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzGlyphCache_s_num_instances_get, _mupdf.FzGlyphCache_s_num_instances_set)
       
       # Register FzGlyphCache in _mupdf:
    1: _mupdf.FzGlyphCache_swigregister(FzGlyphCache)
    2: class FzHalftone(object):
    1:     r"""
           Wrapper class for struct `fz_halftone`.
           A halftone is a set of threshold tiles, one per component. Each
           threshold tile is a pixmap, possibly of varying sizes and
           phases. Currently, we only provide one 'default' halftone tile
           for operating on 1 component plus alpha pixmaps (where the alpha
           is ignored). This is signified by a fz_halftone pointer to NULL.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Copy constructor using `fz_keep_halftone()`.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_halftone`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_halftone`.
               """
>>>>>>         _mupdf.FzHalftone_swiginit(self, _mupdf.new_FzHalftone(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzHalftone
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzHalftone_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzHalftone___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzHalftone_m_internal_get, _mupdf.FzHalftone_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzHalftone_s_num_instances_get, _mupdf.FzHalftone_s_num_instances_set)
       
       # Register FzHalftone in _mupdf:
    1: _mupdf.FzHalftone_swigregister(FzHalftone)
    2: class FzHashTable(object):
    1:     r"""
           Wrapper class for struct `fz_hash_table`. Not copyable or assignable.
           Generic hash-table with fixed-length keys.
       
           The keys and values are NOT reference counted by the hash table.
           Callers are responsible for taking care the reference counts are
           correct. Inserting a duplicate entry will NOT overwrite the old
           value, and will return the old value.
       
           The drop_val callback function is only used to release values
           when the hash table is destroyed.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_hash_filter(self, state, callback):
               r"""
               Class-aware wrapper for `::fz_hash_filter()`.
                       Iterate over the entries in a hash table, removing all the ones where callback returns true.
                       Does NOT free the value of the entry, so the caller is expected to take care of this.
               """
>>>>>>         return _mupdf.FzHashTable_fz_hash_filter(self, state, callback)
       
    1:     def fz_hash_find(self, key):
               r"""
               Class-aware wrapper for `::fz_hash_find()`.
                       Search for a matching hash within the table, and return the
                       associated value.
               """
>>>>>>         return _mupdf.FzHashTable_fz_hash_find(self, key)
       
    1:     def fz_hash_for_each(self, state, callback):
               r"""
               Class-aware wrapper for `::fz_hash_for_each()`.
                       Iterate over the entries in a hash table.
               """
>>>>>>         return _mupdf.FzHashTable_fz_hash_for_each(self, state, callback)
       
    1:     def fz_hash_insert(self, key, val):
               r"""
               Class-aware wrapper for `::fz_hash_insert()`.
                       Insert a new key/value pair into the hash table.
       
                       If an existing entry with the same key is found, no change is
                       made to the hash table, and a pointer to the existing value is
                       returned.
       
                       If no existing entry with the same key is found, ownership of
                       val passes in, key is copied, and NULL is returned.
               """
>>>>>>         return _mupdf.FzHashTable_fz_hash_insert(self, key, val)
       
    1:     def fz_hash_remove(self, key):
               r"""
               Class-aware wrapper for `::fz_hash_remove()`.
                       Remove the entry for a given key.
       
                       The value is NOT freed, so the caller is expected to take care
                       of this.
               """
>>>>>>         return _mupdf.FzHashTable_fz_hash_remove(self, key)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_hash_table()`.
                               Create a new hash table.
       
                               initialsize: The initial size of the hashtable. The hashtable
                               may grow (double in size) if it starts to get crowded (80%
                               full).
       
                               keylen: byte length for each key.
       
                               lock: -1 for no lock, otherwise the FZ_LOCK to use to protect
                               this table.
       
                               drop_val: Function to use to destroy values on table drop.
       
       
               |
       
               *Overload 2:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
                Constructor using raw copy of pre-existing `::fz_hash_table`.
               """
>>>>>>         _mupdf.FzHashTable_swiginit(self, _mupdf.new_FzHashTable(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzHashTable
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzHashTable_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzHashTable___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzHashTable_m_internal_get, _mupdf.FzHashTable_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzHashTable_s_num_instances_get, _mupdf.FzHashTable_s_num_instances_set)
       
       # Register FzHashTable in _mupdf:
    1: _mupdf.FzHashTable_swigregister(FzHashTable)
    2: class FzIccProfile(object):
    1:     r"""
           Wrapper class for struct `fz_icc_profile`. Not copyable or assignable.
           Opaque type for an ICC Profile.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_icc_profile`.
               """
>>>>>>         _mupdf.FzIccProfile_swiginit(self, _mupdf.new_FzIccProfile(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzIccProfile
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzIccProfile_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzIccProfile___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzIccProfile_m_internal_get, _mupdf.FzIccProfile_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzIccProfile_s_num_instances_get, _mupdf.FzIccProfile_s_num_instances_set)
       
       # Register FzIccProfile in _mupdf:
    1: _mupdf.FzIccProfile_swigregister(FzIccProfile)
    2: class FzImage(object):
    1:     r"""
           Wrapper class for struct `fz_image`.
           Images are storable objects from which we can obtain fz_pixmaps.
           These may be implemented as simple wrappers around a pixmap, or
           as more complex things that decode at different subsample
           settings on demand.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_compressed_image_buffer(self):
               r"""
               Class-aware wrapper for `::fz_compressed_image_buffer()`.
                       Retrieve the underlying compressed data for an image.
       
                       Returns a pointer to the underlying data buffer for an image,
                       or NULL if this image is not based upon a compressed data
                       buffer.
       
                       This is not a reference counted structure, so no reference is
                       returned. Lifespan is limited to that of the image itself.
               """
>>>>>>         return _mupdf.FzImage_fz_compressed_image_buffer(self)
       
    1:     def fz_compressed_image_type(self):
               r"""
               Class-aware wrapper for `::fz_compressed_image_type()`.
                       Return the type of a compressed image.
       
                       Any non-compressed image will have the type returned as UNKNOWN.
               """
>>>>>>         return _mupdf.FzImage_fz_compressed_image_type(self)
       
    1:     def fz_get_pixmap_from_image(self, subarea, ctm, w, h):
               r"""
               Class-aware wrapper for `::fz_get_pixmap_from_image()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_get_pixmap_from_image(const ::fz_irect *subarea, ::fz_matrix *ctm)` => `(fz_pixmap *, int w, int h)`
       
                       Called to get a handle to a pixmap from an image.
       
                       image: The image to retrieve a pixmap from.
       
                       subarea: The subarea of the image that we actually care about
                       (or NULL to indicate the whole image).
       
                       ctm: Optional, unless subarea is given. If given, then on
                       entry this is the transform that will be applied to the complete
                       image. It should be updated on exit to the transform to apply to
                       the given subarea of the image. This is used to calculate the
                       desired width/height for subsampling.
       
                       w: If non-NULL, a pointer to an int to be updated on exit to the
                       width (in pixels) that the scaled output will cover.
       
                       h: If non-NULL, a pointer to an int to be updated on exit to the
                       height (in pixels) that the scaled output will cover.
       
                       Returns a non NULL kept pixmap pointer. May throw exceptions.
               """
>>>>>>         return _mupdf.FzImage_fz_get_pixmap_from_image(self, subarea, ctm, w, h)
       
    1:     def fz_get_unscaled_pixmap_from_image(self):
               r"""
               Class-aware wrapper for `::fz_get_unscaled_pixmap_from_image()`.
                       Calls fz_get_pixmap_from_image() with ctm, subarea, w and h all set to NULL.
               """
>>>>>>         return _mupdf.FzImage_fz_get_unscaled_pixmap_from_image(self)
       
    1:     def fz_image_orientation(self):
               r"""
               Class-aware wrapper for `::fz_image_orientation()`.
                       Request the natural orientation of an image.
       
                       This is for images (such as JPEG) that can contain internal
                       specifications of rotation/flips. This is ignored by all the
                       internal decode/rendering routines, but can be used by callers
                       (such as the image document handler) to respect such
                       specifications.
       
                       The values used by MuPDF are as follows, with the equivalent
                       Exif specifications given for information:
       
                       0: Undefined
                       1: 0 degree ccw rotation. (Exif = 1)
                       2: 90 degree ccw rotation. (Exif = 8)
                       3: 180 degree ccw rotation. (Exif = 3)
                       4: 270 degree ccw rotation. (Exif = 6)
                       5: flip on X. (Exif = 2)
                       6: flip on X, then rotate ccw by 90 degrees. (Exif = 5)
                       7: flip on X, then rotate ccw by 180 degrees. (Exif = 4)
                       8: flip on X, then rotate ccw by 270 degrees. (Exif = 7)
               """
>>>>>>         return _mupdf.FzImage_fz_image_orientation(self)
       
    1:     def fz_image_orientation_matrix(self):
               r"""Class-aware wrapper for `::fz_image_orientation_matrix()`."""
>>>>>>         return _mupdf.FzImage_fz_image_orientation_matrix(self)
       
    1:     def fz_image_resolution(self, xres, yres):
               r"""
               Class-aware wrapper for `::fz_image_resolution()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_image_resolution()` => `(int xres, int yres)`
       
                       Request the natural resolution
                       of an image.
       
                       xres, yres: Pointers to ints to be updated with the
                       natural resolution of an image (or a sensible default
                       if not encoded).
               """
>>>>>>         return _mupdf.FzImage_fz_image_resolution(self, xres, yres)
       
    1:     def fz_image_size(self):
               r"""
               Class-aware wrapper for `::fz_image_size()`.
                       Return the size of the storage used by an image.
               """
>>>>>>         return _mupdf.FzImage_fz_image_size(self)
       
    1:     def fz_is_lossy_image(self):
               r"""Class-aware wrapper for `::fz_is_lossy_image()`."""
>>>>>>         return _mupdf.FzImage_fz_is_lossy_image(self)
       
    1:     def fz_new_bitmap_from_image(self, ht):
               r"""
               Class-aware wrapper for `::fz_new_bitmap_from_image()`.
                       Make a bitmap from a pixmap and a halftone.
       
                       img: The image to generate from. Currently must be a single
                       color component with no alpha.
       
                       ht: The halftone to use. NULL implies the default halftone.
       
                       Returns the resultant bitmap. Throws exceptions in the case of
                       failure to allocate.
               """
>>>>>>         return _mupdf.FzImage_fz_new_bitmap_from_image(self, ht)
       
    1:     def fz_new_buffer_from_image_as_jpeg(self, color_params, quality, invert_cmyk):
               r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_jpeg()`."""
>>>>>>         return _mupdf.FzImage_fz_new_buffer_from_image_as_jpeg(self, color_params, quality, invert_cmyk)
       
    1:     def fz_new_buffer_from_image_as_jpx(self, color_params, quality):
               r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_jpx()`."""
>>>>>>         return _mupdf.FzImage_fz_new_buffer_from_image_as_jpx(self, color_params, quality)
       
    1:     def fz_new_buffer_from_image_as_pam(self, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pam()`."""
>>>>>>         return _mupdf.FzImage_fz_new_buffer_from_image_as_pam(self, color_params)
       
    1:     def fz_new_buffer_from_image_as_pbm(self, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pbm()`."""
>>>>>>         return _mupdf.FzImage_fz_new_buffer_from_image_as_pbm(self, color_params)
       
    1:     def fz_new_buffer_from_image_as_pkm(self, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pkm()`."""
>>>>>>         return _mupdf.FzImage_fz_new_buffer_from_image_as_pkm(self, color_params)
       
    1:     def fz_new_buffer_from_image_as_png(self, color_params):
               r"""
               Class-aware wrapper for `::fz_new_buffer_from_image_as_png()`.
                       Re-encode a given image as a PNG into a buffer.
       
                       Ownership of the buffer is returned.
               """
>>>>>>         return _mupdf.FzImage_fz_new_buffer_from_image_as_png(self, color_params)
       
    1:     def fz_new_buffer_from_image_as_pnm(self, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pnm()`."""
>>>>>>         return _mupdf.FzImage_fz_new_buffer_from_image_as_pnm(self, color_params)
       
    1:     def fz_new_buffer_from_image_as_psd(self, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_psd()`."""
>>>>>>         return _mupdf.FzImage_fz_new_buffer_from_image_as_psd(self, color_params)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_barcode_image()`.
                               Create an fz_image from a barcode definition.
       
                               type: The type of barcode to create.
                               value: The value of the barcode.
                               size: The size of the barcode.
                               ec_level: error correction level 0-8.
                               quiet: whether to include quiet zones (0 or 1).
                               hrt: whether to include human readable text below the barcode (0 or 1).
       
                               returns a created fz_image.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_image_from_buffer()`.
                               Create a new image from a
                               buffer of data, inferring its type from the format
                               of the data.
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_image_from_compressed_buffer()`.
                               Create an image based on
                               the data in the supplied compressed buffer.
       
                               w,h: Width and height of the created image.
       
                               bpc: Bits per component.
       
                               colorspace: The colorspace (determines the number of components,
                               and any color conversions required while decoding).
       
                               xres, yres: The X and Y resolutions respectively.
       
                               interpolate: 1 if interpolation should be used when decoding
                               this image, 0 otherwise.
       
                               imagemask: 1 if this is an imagemask (i.e. transparency bitmap
                               mask), 0 otherwise.
       
                               decode: NULL, or a pointer to to a decode array. The default
                               decode array is [0 1] (repeated n times, for n color components).
       
                               colorkey: NULL, or a pointer to a colorkey array. The default
                               colorkey array is [0 255] (repeated n times, for n color
                               components).
       
                               buffer: Buffer of compressed data and compression parameters.
                               Ownership of this reference is passed in.
       
                               mask: NULL, or another image to use as a mask for this one.
                               A new reference is taken to this image. Supplying a masked
                               image as a mask to another image is illegal!
       
       
               |
       
               *Overload 4:*
                Constructor using `fz_new_image_from_compressed_buffer2()`.  Swig-friendly wrapper for fz_new_image_from_compressed_buffer(),
                       uses specified `decode` and `colorkey` if they are not null (in which
                       case we assert that they have size `2*fz_colorspace_n(colorspace)`).
       
               |
       
               *Overload 5:*
                Constructor using `fz_new_image_from_display_list()`.
                               Create a new image from a display list.
       
                               w, h: The conceptual width/height of the image.
       
                               transform: The matrix that needs to be applied to the given
                               list to make it render to the unit square.
       
                               list: The display list.
       
       
               |
       
               *Overload 6:*
                Constructor using `fz_new_image_from_file()`.
                               Create a new image from the contents
                               of a file, inferring its type from the format of the
                               data.
       
       
               |
       
               *Overload 7:*
                Constructor using `fz_new_image_from_pixmap()`.
                               Create an image from the given
                               pixmap.
       
                               pixmap: The pixmap to base the image upon. A new reference
                               to this is taken.
       
                               mask: NULL, or another image to use as a mask for this one.
                               A new reference is taken to this image. Supplying a masked
                               image as a mask to another image is illegal!
       
       
               |
       
               *Overload 8:*
                Constructor using `fz_new_image_from_svg()`.
                               Create a scalable image from an SVG document.
       
       
               |
       
               *Overload 9:*
                Constructor using `fz_new_image_from_svg_xml()`.
                               Create a scalable image from an SVG document.
       
       
               |
       
               *Overload 10:*
                Constructor using `fz_new_image_of_size()`.
                               Internal function to make a new fz_image structure
                               for a derived class.
       
                               w,h: Width and height of the created image.
       
                               bpc: Bits per component.
       
                               colorspace: The colorspace (determines the number of components,
                               and any color conversions required while decoding).
       
                               xres, yres: The X and Y resolutions respectively.
       
                               interpolate: 1 if interpolation should be used when decoding
                               this image, 0 otherwise.
       
                               imagemask: 1 if this is an imagemask (i.e. transparent), 0
                               otherwise.
       
                               decode: NULL, or a pointer to to a decode array. The default
                               decode array is [0 1] (repeated n times, for n color components).
       
                               colorkey: NULL, or a pointer to a colorkey array. The default
                               colorkey array is [0 255] (repeated n times, for n color
                               components).
       
                               mask: NULL, or another image to use as a mask for this one.
                               A new reference is taken to this image. Supplying a masked
                               image as a mask to another image is illegal!
       
                               size: The size of the required allocated structure (the size of
                               the derived structure).
       
                               get: The function to be called to obtain a decoded pixmap.
       
                               get_size: The function to be called to return the storage size
                               used by this image.
       
                               drop: The function to be called to dispose of this image once
                               the last reference is dropped.
       
                               Returns a pointer to an allocated structure of the required size,
                               with the first sizeof(fz_image) bytes initialised as appropriate
                               given the supplied parameters, and the other bytes set to zero.
       
       
               |
       
               *Overload 11:*
                Copy constructor using `fz_keep_image()`.
       
               |
       
               *Overload 12:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 13:*
                Constructor using raw copy of pre-existing `::fz_image`.
               """
>>>>>>         _mupdf.FzImage_swiginit(self, _mupdf.new_FzImage(*args))
       
    1:     def key_storable(self):
>>>>>>         return _mupdf.FzImage_key_storable(self)
       
    1:     def w(self):
>>>>>>         return _mupdf.FzImage_w(self)
       
    1:     def h(self):
>>>>>>         return _mupdf.FzImage_h(self)
       
    1:     def n(self):
>>>>>>         return _mupdf.FzImage_n(self)
       
    1:     def bpc(self):
>>>>>>         return _mupdf.FzImage_bpc(self)
       
    1:     def imagemask(self):
>>>>>>         return _mupdf.FzImage_imagemask(self)
       
    1:     def interpolate(self):
>>>>>>         return _mupdf.FzImage_interpolate(self)
       
    1:     def use_colorkey(self):
>>>>>>         return _mupdf.FzImage_use_colorkey(self)
       
    1:     def use_decode(self):
>>>>>>         return _mupdf.FzImage_use_decode(self)
       
    1:     def decoded(self):
>>>>>>         return _mupdf.FzImage_decoded(self)
       
    1:     def scalable(self):
>>>>>>         return _mupdf.FzImage_scalable(self)
       
    1:     def intent(self):
>>>>>>         return _mupdf.FzImage_intent(self)
       
    1:     def has_intent(self):
>>>>>>         return _mupdf.FzImage_has_intent(self)
       
    1:     def orientation(self):
>>>>>>         return _mupdf.FzImage_orientation(self)
       
    1:     def mask(self):
>>>>>>         return _mupdf.FzImage_mask(self)
       
    1:     def xres(self):
>>>>>>         return _mupdf.FzImage_xres(self)
       
    1:     def yres(self):
>>>>>>         return _mupdf.FzImage_yres(self)
       
    1:     def colorspace(self):
>>>>>>         return _mupdf.FzImage_colorspace(self)
       
    1:     def colorkey(self):
>>>>>>         return _mupdf.FzImage_colorkey(self)
       
    1:     def decode(self):
>>>>>>         return _mupdf.FzImage_decode(self)
    1:     __swig_destroy__ = _mupdf.delete_FzImage
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzImage_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzImage___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzImage_m_internal_get, _mupdf.FzImage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzImage_s_num_instances_get, _mupdf.FzImage_s_num_instances_set)
       
       # Register FzImage in _mupdf:
    1: _mupdf.FzImage_swigregister(FzImage)
    2: class FzInstallLoadSystemFontFuncsArgs(object):
    1:     r"""
            Wrapper class for struct `fz_install_load_system_font_funcs_args`.
           Extra struct containing fz_install_load_system_font_funcs()'s args,
           which we wrap with virtual_fnptrs set to allow use from Python/C# via
           Swig Directors.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_install_load_system_font_funcs2(self):
               r"""
               Class-aware wrapper for `::fz_install_load_system_font_funcs2()`.
               Alternative to fz_install_load_system_font_funcs() that takes args in a
               struct, to allow use from Python/C# via Swig Directors.
               """
>>>>>>         return _mupdf.FzInstallLoadSystemFontFuncsArgs_fz_install_load_system_font_funcs2(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_install_load_system_font_funcs_args`.
               """
>>>>>>         _mupdf.FzInstallLoadSystemFontFuncsArgs_swiginit(self, _mupdf.new_FzInstallLoadSystemFontFuncsArgs(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzInstallLoadSystemFontFuncsArgs
    1:     m_internal = property(_mupdf.FzInstallLoadSystemFontFuncsArgs_m_internal_get, _mupdf.FzInstallLoadSystemFontFuncsArgs_m_internal_set)
    1:     s_num_instances = property(_mupdf.FzInstallLoadSystemFontFuncsArgs_s_num_instances_get, _mupdf.FzInstallLoadSystemFontFuncsArgs_s_num_instances_set, doc=r"""Wrapped data is held by value.""")
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzInstallLoadSystemFontFuncsArgs_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzInstallLoadSystemFontFuncsArgs___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzInstallLoadSystemFontFuncsArgs___ne__(self, rhs)
       
       # Register FzInstallLoadSystemFontFuncsArgs in _mupdf:
    1: _mupdf.FzInstallLoadSystemFontFuncsArgs_swigregister(FzInstallLoadSystemFontFuncsArgs)
    2: class FzInstallLoadSystemFontFuncsArgs2(FzInstallLoadSystemFontFuncsArgs):
    1:     r"""Wrapper class for struct fz_install_load_system_font_funcs_args with virtual fns for each fnptr; this is for use as a SWIG Director class."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self):
               r"""== Constructor."""
>>>>>>         if self.__class__ == FzInstallLoadSystemFontFuncsArgs2:
>>>>>>             _self = None
               else:
>>>>>>             _self = self
>>>>>>         _mupdf.FzInstallLoadSystemFontFuncsArgs2_swiginit(self, _mupdf.new_FzInstallLoadSystemFontFuncsArgs2(_self, ))
    1:     __swig_destroy__ = _mupdf.delete_FzInstallLoadSystemFontFuncsArgs2
       
    1:     def use_virtual_f(self, use=True):
               r"""
               These methods set the function pointers in *m_internal
               to point to internal callbacks that call our virtual methods.
               """
>>>>>>         return _mupdf.FzInstallLoadSystemFontFuncsArgs2_use_virtual_f(self, use)
       
    1:     def use_virtual_f_cjk(self, use=True):
>>>>>>         return _mupdf.FzInstallLoadSystemFontFuncsArgs2_use_virtual_f_cjk(self, use)
       
    1:     def use_virtual_f_fallback(self, use=True):
>>>>>>         return _mupdf.FzInstallLoadSystemFontFuncsArgs2_use_virtual_f_fallback(self, use)
       
    1:     def f(self, arg_0, arg_1, arg_2, arg_3, arg_4):
               r"""Default virtual method implementations; these all throw an exception."""
>>>>>>         return _mupdf.FzInstallLoadSystemFontFuncsArgs2_f(self, arg_0, arg_1, arg_2, arg_3, arg_4)
       
    1:     def f_cjk(self, arg_0, arg_1, arg_2, arg_3):
>>>>>>         return _mupdf.FzInstallLoadSystemFontFuncsArgs2_f_cjk(self, arg_0, arg_1, arg_2, arg_3)
       
    1:     def f_fallback(self, arg_0, arg_1, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.FzInstallLoadSystemFontFuncsArgs2_f_fallback(self, arg_0, arg_1, arg_2, arg_3, arg_4, arg_5)
    1:     def __disown__(self):
>>>>>>         self.this.disown()
>>>>>>         _mupdf.disown_FzInstallLoadSystemFontFuncsArgs2(self)
>>>>>>         return weakref.proxy(self)
       
       # Register FzInstallLoadSystemFontFuncsArgs2 in _mupdf:
    1: _mupdf.FzInstallLoadSystemFontFuncsArgs2_swigregister(FzInstallLoadSystemFontFuncsArgs2)
    2: class FzInt2(object):
    1:     r"""Wrapper class for struct `fz_int2`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_int2`.
               """
>>>>>>         _mupdf.FzInt2_swiginit(self, _mupdf.new_FzInt2(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzInt2
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzInt2_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzInt2___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzInt2_m_internal_get, _mupdf.FzInt2_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzInt2_s_num_instances_get, _mupdf.FzInt2_s_num_instances_set)
       
       # Register FzInt2 in _mupdf:
    1: _mupdf.FzInt2_swigregister(FzInt2)
    2: class FzInt2Heap(object):
    1:     r"""Wrapper class for struct `fz_int2_heap`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_int2_heap_debug(self):
               r"""Class-aware wrapper for `::fz_int2_heap_debug()`."""
>>>>>>         return _mupdf.FzInt2Heap_fz_int2_heap_debug(self)
       
    1:     def fz_int2_heap_insert(self, v):
               r"""Class-aware wrapper for `::fz_int2_heap_insert()`."""
>>>>>>         return _mupdf.FzInt2Heap_fz_int2_heap_insert(self, v)
       
    1:     def fz_int2_heap_sort(self):
               r"""Class-aware wrapper for `::fz_int2_heap_sort()`."""
>>>>>>         return _mupdf.FzInt2Heap_fz_int2_heap_sort(self)
       
    1:     def fz_int2_heap_uniq(self):
               r"""Class-aware wrapper for `::fz_int2_heap_uniq()`."""
>>>>>>         return _mupdf.FzInt2Heap_fz_int2_heap_uniq(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_int2_heap`.
               """
>>>>>>         _mupdf.FzInt2Heap_swiginit(self, _mupdf.new_FzInt2Heap(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzInt2Heap
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzInt2Heap_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzInt2Heap___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzInt2Heap_m_internal_get, _mupdf.FzInt2Heap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzInt2Heap_s_num_instances_get, _mupdf.FzInt2Heap_s_num_instances_set)
       
       # Register FzInt2Heap in _mupdf:
    1: _mupdf.FzInt2Heap_swigregister(FzInt2Heap)
    2: class FzIntHeap(object):
    1:     r"""Wrapper class for struct `fz_int_heap`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_int_heap_debug(self):
               r"""Class-aware wrapper for `::fz_int_heap_debug()`."""
>>>>>>         return _mupdf.FzIntHeap_fz_int_heap_debug(self)
       
    1:     def fz_int_heap_insert(self, v):
               r"""Class-aware wrapper for `::fz_int_heap_insert()`."""
>>>>>>         return _mupdf.FzIntHeap_fz_int_heap_insert(self, v)
       
    1:     def fz_int_heap_sort(self):
               r"""Class-aware wrapper for `::fz_int_heap_sort()`."""
>>>>>>         return _mupdf.FzIntHeap_fz_int_heap_sort(self)
       
    1:     def fz_int_heap_uniq(self):
               r"""Class-aware wrapper for `::fz_int_heap_uniq()`."""
>>>>>>         return _mupdf.FzIntHeap_fz_int_heap_uniq(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_int_heap`.
               """
>>>>>>         _mupdf.FzIntHeap_swiginit(self, _mupdf.new_FzIntHeap(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzIntHeap
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzIntHeap_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzIntHeap___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzIntHeap_m_internal_get, _mupdf.FzIntHeap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzIntHeap_s_num_instances_get, _mupdf.FzIntHeap_s_num_instances_set)
       
       # Register FzIntHeap in _mupdf:
    1: _mupdf.FzIntHeap_swigregister(FzIntHeap)
    2: class FzIntptr(object):
    1:     r"""Wrapper class for struct `fz_intptr`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_intptr`.
               """
>>>>>>         _mupdf.FzIntptr_swiginit(self, _mupdf.new_FzIntptr(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzIntptr
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzIntptr_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzIntptr___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzIntptr_m_internal_get, _mupdf.FzIntptr_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzIntptr_s_num_instances_get, _mupdf.FzIntptr_s_num_instances_set)
       
       # Register FzIntptr in _mupdf:
    1: _mupdf.FzIntptr_swigregister(FzIntptr)
    2: class FzIntptrHeap(object):
    1:     r"""Wrapper class for struct `fz_intptr_heap`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_intptr_heap_debug(self):
               r"""Class-aware wrapper for `::fz_intptr_heap_debug()`."""
>>>>>>         return _mupdf.FzIntptrHeap_fz_intptr_heap_debug(self)
       
    1:     def fz_intptr_heap_insert(self, v):
               r"""Class-aware wrapper for `::fz_intptr_heap_insert()`."""
>>>>>>         return _mupdf.FzIntptrHeap_fz_intptr_heap_insert(self, v)
       
    1:     def fz_intptr_heap_sort(self):
               r"""Class-aware wrapper for `::fz_intptr_heap_sort()`."""
>>>>>>         return _mupdf.FzIntptrHeap_fz_intptr_heap_sort(self)
       
    1:     def fz_intptr_heap_uniq(self):
               r"""Class-aware wrapper for `::fz_intptr_heap_uniq()`."""
>>>>>>         return _mupdf.FzIntptrHeap_fz_intptr_heap_uniq(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_intptr_heap`.
               """
>>>>>>         _mupdf.FzIntptrHeap_swiginit(self, _mupdf.new_FzIntptrHeap(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzIntptrHeap
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzIntptrHeap_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzIntptrHeap___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzIntptrHeap_m_internal_get, _mupdf.FzIntptrHeap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzIntptrHeap_s_num_instances_get, _mupdf.FzIntptrHeap_s_num_instances_set)
       
       # Register FzIntptrHeap in _mupdf:
    1: _mupdf.FzIntptrHeap_swigregister(FzIntptrHeap)
    2: class FzIrect(object):
    1:     r"""
           Wrapper class for struct `fz_irect`.
           fz_irect is a rectangle using integers instead of floats.
       
           It's used in the draw device and for pixmap dimensions.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_expand_irect(self, expand):
               r"""Class-aware wrapper for `::fz_expand_irect()`."""
>>>>>>         return _mupdf.FzIrect_fz_expand_irect(self, expand)
       
    1:     def fz_intersect_irect(self, b):
               r"""
               Class-aware wrapper for `::fz_intersect_irect()`.
                       Compute intersection of two bounding boxes.
       
                       Similar to fz_intersect_rect but operates on two bounding
                       boxes instead of two rectangles.
               """
>>>>>>         return _mupdf.FzIrect_fz_intersect_irect(self, b)
       
    1:     def fz_irect_height(self):
               r"""
               Class-aware wrapper for `::fz_irect_height()`.
                       Return the height of an irect. Invalid irects return 0.
               """
>>>>>>         return _mupdf.FzIrect_fz_irect_height(self)
       
    1:     def fz_irect_width(self):
               r"""
               Class-aware wrapper for `::fz_irect_width()`.
                       Return the width of an irect. Invalid irects return 0.
               """
>>>>>>         return _mupdf.FzIrect_fz_irect_width(self)
       
    1:     def fz_is_empty_irect(self):
               r"""Class-aware wrapper for `::fz_is_empty_irect()`."""
>>>>>>         return _mupdf.FzIrect_fz_is_empty_irect(self)
       
    1:     def fz_is_infinite_irect(self):
               r"""
               Class-aware wrapper for `::fz_is_infinite_irect()`.
                       Check if an integer rectangle
                       is infinite.
               """
>>>>>>         return _mupdf.FzIrect_fz_is_infinite_irect(self)
       
    1:     def fz_is_irect_inside_irect(self, outer):
               r"""
               Class-aware wrapper for `::fz_is_irect_inside_irect()`.
                       Inclusion test for irects.
       
                       rects are assumed to be both open or both closed.
       
                       No invalid rect can include any other rect.
                       No invalid rect can be included by any rect.
                       Empty (point) rects can include themselves.
                       Empty (line) rects can include many (subline) rects.
               """
>>>>>>         return _mupdf.FzIrect_fz_is_irect_inside_irect(self, outer)
       
    1:     def fz_is_valid_irect(self):
               r"""
               Class-aware wrapper for `::fz_is_valid_irect()`.
                       Check if an integer rectangle is valid.
               """
>>>>>>         return _mupdf.FzIrect_fz_is_valid_irect(self)
       
    1:     def fz_rect_from_irect(self):
               r"""
               Class-aware wrapper for `::fz_rect_from_irect()`.
                       Convert a bbox into a rect.
       
                       For our purposes, a rect can represent all the values we meet in
                       a bbox, so nothing can go wrong.
       
                       rect: A place to store the generated rectangle.
       
                       bbox: The bbox to convert.
       
                       Returns rect (updated).
               """
>>>>>>         return _mupdf.FzIrect_fz_rect_from_irect(self)
       
    1:     def fz_translate_irect(self, xoff, yoff):
               r"""Class-aware wrapper for `::fz_translate_irect()`."""
>>>>>>         return _mupdf.FzIrect_fz_translate_irect(self, xoff, yoff)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_irect_from_rect()`.
                               Convert a rect into the minimal bounding box
                               that covers the rectangle.
       
                               Coordinates in a bounding box are integers, so rounding of the
                               rects coordinates takes place. The top left corner is rounded
                               upwards and left while the bottom right corner is rounded
                               downwards and to the right.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_make_irect()`.
       
               |
       
               *Overload 3:*
                We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 4:*
                Constructor using raw copy of pre-existing `::fz_irect`.
       
               |
       
               *Overload 5:*
                Constructor using raw copy of pre-existing `::fz_irect`.
               """
>>>>>>         _mupdf.FzIrect_swiginit(self, _mupdf.new_FzIrect(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.FzIrect_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_FzIrect
    1:     x0 = property(_mupdf.FzIrect_x0_get, _mupdf.FzIrect_x0_set)
    1:     y0 = property(_mupdf.FzIrect_y0_get, _mupdf.FzIrect_y0_set)
    1:     x1 = property(_mupdf.FzIrect_x1_get, _mupdf.FzIrect_x1_set)
    1:     y1 = property(_mupdf.FzIrect_y1_get, _mupdf.FzIrect_y1_set)
    1:     s_num_instances = property(_mupdf.FzIrect_s_num_instances_get, _mupdf.FzIrect_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzIrect_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzIrect___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzIrect___ne__(self, rhs)
       
       # Register FzIrect in _mupdf:
    1: _mupdf.FzIrect_swigregister(FzIrect)
    2: class FzJbig2Globals(object):
    1:     r"""Wrapper class for struct `fz_jbig2_globals`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_jbig2_globals_data(self):
               r"""
               Class-aware wrapper for `::fz_jbig2_globals_data()`.
                       Return buffer containing jbig2 globals data stream.
               """
>>>>>>         return _mupdf.FzJbig2Globals_fz_jbig2_globals_data(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Copy constructor using `fz_keep_jbig2_globals()`.
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_jbig2_globals`.
               """
>>>>>>         _mupdf.FzJbig2Globals_swiginit(self, _mupdf.new_FzJbig2Globals(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzJbig2Globals
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzJbig2Globals_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzJbig2Globals___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzJbig2Globals_m_internal_get, _mupdf.FzJbig2Globals_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzJbig2Globals_s_num_instances_get, _mupdf.FzJbig2Globals_s_num_instances_set)
       
       # Register FzJbig2Globals in _mupdf:
    1: _mupdf.FzJbig2Globals_swigregister(FzJbig2Globals)
    2: class FzJson(object):
    1:     r"""Wrapper class for struct `fz_json`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_json_array_length(self):
               r"""Class-aware wrapper for `::fz_json_array_length()`."""
>>>>>>         return _mupdf.FzJson_fz_json_array_length(self)
       
    1:     def fz_json_is_array(self):
               r"""Class-aware wrapper for `::fz_json_is_array()`."""
>>>>>>         return _mupdf.FzJson_fz_json_is_array(self)
       
    1:     def fz_json_is_boolean(self):
               r"""Class-aware wrapper for `::fz_json_is_boolean()`."""
>>>>>>         return _mupdf.FzJson_fz_json_is_boolean(self)
       
    1:     def fz_json_is_null(self):
               r"""Class-aware wrapper for `::fz_json_is_null()`."""
>>>>>>         return _mupdf.FzJson_fz_json_is_null(self)
       
    1:     def fz_json_is_number(self):
               r"""Class-aware wrapper for `::fz_json_is_number()`."""
>>>>>>         return _mupdf.FzJson_fz_json_is_number(self)
       
    1:     def fz_json_is_object(self):
               r"""Class-aware wrapper for `::fz_json_is_object()`."""
>>>>>>         return _mupdf.FzJson_fz_json_is_object(self)
       
    1:     def fz_json_is_string(self):
               r"""Class-aware wrapper for `::fz_json_is_string()`."""
>>>>>>         return _mupdf.FzJson_fz_json_is_string(self)
       
    1:     def fz_json_to_boolean(self):
               r"""Class-aware wrapper for `::fz_json_to_boolean()`."""
>>>>>>         return _mupdf.FzJson_fz_json_to_boolean(self)
       
    1:     def fz_json_to_number(self):
               r"""Class-aware wrapper for `::fz_json_to_number()`."""
>>>>>>         return _mupdf.FzJson_fz_json_to_number(self)
       
    1:     def fz_json_to_string(self):
               r"""Class-aware wrapper for `::fz_json_to_string()`."""
>>>>>>         return _mupdf.FzJson_fz_json_to_string(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_json`.
               """
>>>>>>         _mupdf.FzJson_swiginit(self, _mupdf.new_FzJson(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzJson
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzJson_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzJson___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzJson_m_internal_get, _mupdf.FzJson_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzJson_s_num_instances_get, _mupdf.FzJson_s_num_instances_set)
       
       # Register FzJson in _mupdf:
    1: _mupdf.FzJson_swigregister(FzJson)
    2: class FzJsonArray(object):
    1:     r"""Wrapper class for struct `fz_json_array`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_json_array`.
               """
>>>>>>         _mupdf.FzJsonArray_swiginit(self, _mupdf.new_FzJsonArray(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzJsonArray
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzJsonArray_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzJsonArray___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzJsonArray_m_internal_get, _mupdf.FzJsonArray_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzJsonArray_s_num_instances_get, _mupdf.FzJsonArray_s_num_instances_set)
       
       # Register FzJsonArray in _mupdf:
    1: _mupdf.FzJsonArray_swigregister(FzJsonArray)
    2: class FzJsonObject(object):
    1:     r"""Wrapper class for struct `fz_json_object`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_json_object`.
               """
>>>>>>         _mupdf.FzJsonObject_swiginit(self, _mupdf.new_FzJsonObject(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzJsonObject
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzJsonObject_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzJsonObject___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzJsonObject_m_internal_get, _mupdf.FzJsonObject_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzJsonObject_s_num_instances_get, _mupdf.FzJsonObject_s_num_instances_set)
       
       # Register FzJsonObject in _mupdf:
    1: _mupdf.FzJsonObject_swigregister(FzJsonObject)
    2: class FzKeyStorable(object):
    1:     r"""
           Wrapper class for struct `fz_key_storable`.
           Any storable object that can appear in the key of another
           storable object should include an fz_key_storable structure
           at the start (by convention at least) of their structure.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Copy constructor using `fz_keep_key_storable()`.
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_key_storable`.
               """
>>>>>>         _mupdf.FzKeyStorable_swiginit(self, _mupdf.new_FzKeyStorable(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzKeyStorable
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzKeyStorable_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzKeyStorable___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzKeyStorable_m_internal_get, _mupdf.FzKeyStorable_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzKeyStorable_s_num_instances_get, _mupdf.FzKeyStorable_s_num_instances_set)
       
       # Register FzKeyStorable in _mupdf:
    1: _mupdf.FzKeyStorable_swigregister(FzKeyStorable)
    2: class FzLayoutBlock(object):
    1:     r"""Wrapper class for struct `fz_layout_block`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_add_layout_char(self, x, w, p):
               r"""
               Class-aware wrapper for `::fz_add_layout_char()`.
                       Add a new char to the line at the end of the layout block.
               """
>>>>>>         return _mupdf.FzLayoutBlock_fz_add_layout_char(self, x, w, p)
       
    1:     def fz_add_layout_line(self, x, y, h, p):
               r"""
               Class-aware wrapper for `::fz_add_layout_line()`.
                       Add a new line to the end of the layout block.
               """
>>>>>>         return _mupdf.FzLayoutBlock_fz_add_layout_line(self, x, y, h, p)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_layout()`.
                               Create a new layout block, with new allocation pool, zero
                               matrices, and initialise linked pointers.
       
       
               |
       
               *Overload 2:*
                Constructor using raw copy of pre-existing `::fz_layout_block`.
               """
>>>>>>         _mupdf.FzLayoutBlock_swiginit(self, _mupdf.new_FzLayoutBlock(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzLayoutBlock
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzLayoutBlock_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzLayoutBlock___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzLayoutBlock_m_internal_get, _mupdf.FzLayoutBlock_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzLayoutBlock_s_num_instances_get, _mupdf.FzLayoutBlock_s_num_instances_set)
       
       # Register FzLayoutBlock in _mupdf:
    1: _mupdf.FzLayoutBlock_swigregister(FzLayoutBlock)
    2: class FzLayoutChar(object):
    1:     r"""
           Wrapper class for struct `fz_layout_char`. Not copyable or assignable.
           Simple text layout (for use with annotation editing primarily).
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_layout_char`.
               """
>>>>>>         _mupdf.FzLayoutChar_swiginit(self, _mupdf.new_FzLayoutChar(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzLayoutChar
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzLayoutChar_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzLayoutChar___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzLayoutChar_m_internal_get, _mupdf.FzLayoutChar_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzLayoutChar_s_num_instances_get, _mupdf.FzLayoutChar_s_num_instances_set)
       
       # Register FzLayoutChar in _mupdf:
    1: _mupdf.FzLayoutChar_swigregister(FzLayoutChar)
    2: class FzLayoutLine(object):
    1:     r"""Wrapper class for struct `fz_layout_line`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_layout_line`.
               """
>>>>>>         _mupdf.FzLayoutLine_swiginit(self, _mupdf.new_FzLayoutLine(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzLayoutLine
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzLayoutLine_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzLayoutLine___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzLayoutLine_m_internal_get, _mupdf.FzLayoutLine_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzLayoutLine_s_num_instances_get, _mupdf.FzLayoutLine_s_num_instances_set)
       
       # Register FzLayoutLine in _mupdf:
    1: _mupdf.FzLayoutLine_swigregister(FzLayoutLine)
    2: class FzLink(object):
    1:     r"""
           Wrapper class for struct `fz_link`.
           fz_link is a list of interactive links on a page.
       
           There is no relation between the order of the links in the
           list and the order they appear on the page. The list of links
           for a given page can be obtained from fz_load_links.
       
           A link is reference counted. Dropping a reference to a link is
           done by calling fz_drop_link.
       
           rect: The hot zone. The area that can be clicked in
           untransformed coordinates.
       
           uri: Link destinations come in two forms: internal and external.
           Internal links refer to other pages in the same document.
           External links are URLs to other documents.
       
           next: A pointer to the next link on the same page.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_set_link_rect(self, rect):
               r"""Class-aware wrapper for `::fz_set_link_rect()`."""
>>>>>>         return _mupdf.FzLink_fz_set_link_rect(self, rect)
       
    1:     def fz_set_link_uri(self, uri):
               r"""Class-aware wrapper for `::fz_set_link_uri()`."""
>>>>>>         return _mupdf.FzLink_fz_set_link_uri(self, uri)
       
    1:     def begin(self):
               r"""Used for iteration over linked list of FzLink items starting at fz_link::."""
>>>>>>         return _mupdf.FzLink_begin(self)
       
    1:     def end(self):
               r"""Used for iteration over linked list of FzLink items starting at fz_link::."""
>>>>>>         return _mupdf.FzLink_end(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_link_of_size()`.
                               Create a new link record.
       
                               next is set to NULL with the expectation that the caller will
                               handle the linked list setup. Internal function.
       
                               Different document types will be implemented by deriving from
                               fz_link. This macro allocates such derived structures, and
                               initialises the base sections.
       
       
               |
       
               *Overload 2:*
                Constructor using `pdf_new_link()`.
       
               |
       
               *Overload 3:*
                Construct by calling fz_new_link_of_size() with size=sizeof(fz_link).
       
               |
       
               *Overload 4:*
                Copy constructor using `fz_keep_link()`.
       
               |
       
               *Overload 5:*
                Constructor using raw copy of pre-existing `::fz_link`.
       
               |
       
               *Overload 6:*
                Constructor using raw copy of pre-existing `::fz_link`.
               """
>>>>>>         _mupdf.FzLink_swiginit(self, _mupdf.new_FzLink(*args))
       
    1:     def refs(self):
>>>>>>         return _mupdf.FzLink_refs(self)
       
    1:     def next(self):
>>>>>>         return _mupdf.FzLink_next(self)
       
    1:     def rect(self):
>>>>>>         return _mupdf.FzLink_rect(self)
       
    1:     def uri(self):
>>>>>>         return _mupdf.FzLink_uri(self)
    1:     __swig_destroy__ = _mupdf.delete_FzLink
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzLink_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzLink___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzLink_m_internal_get, _mupdf.FzLink_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzLink_s_num_instances_get, _mupdf.FzLink_s_num_instances_set)
       
       # Register FzLink in _mupdf:
    1: _mupdf.FzLink_swigregister(FzLink)
    2: class FzLinkDest(object):
    1:     r"""Wrapper class for struct `fz_link_dest`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_new_uri_from_explicit_dest(self):
               r"""Class-aware wrapper for `::pdf_new_uri_from_explicit_dest()`."""
>>>>>>         return _mupdf.FzLinkDest_pdf_new_uri_from_explicit_dest(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_link_dest`.
               """
>>>>>>         _mupdf.FzLinkDest_swiginit(self, _mupdf.new_FzLinkDest(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzLinkDest
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzLinkDest_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzLinkDest___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzLinkDest_m_internal_get, _mupdf.FzLinkDest_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzLinkDest_s_num_instances_get, _mupdf.FzLinkDest_s_num_instances_set)
       
       # Register FzLinkDest in _mupdf:
    1: _mupdf.FzLinkDest_swigregister(FzLinkDest)
    2: class FzLocation(object):
    1:     r"""
           Wrapper class for struct `fz_location`.
           Locations within the document are referred to in terms of
           chapter and page, rather than just a page number. For some
           documents (such as epub documents with large numbers of pages
           broken into many chapters) this can make navigation much faster
           as only the required chapter needs to be decoded at a time.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_make_location()`.
                               Simple constructor for fz_locations.
       
       
               |
       
               *Overload 2:*
                We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 3:*
                Constructor using raw copy of pre-existing `::fz_location`.
       
               |
       
               *Overload 4:*
                Constructor using raw copy of pre-existing `::fz_location`.
               """
>>>>>>         _mupdf.FzLocation_swiginit(self, _mupdf.new_FzLocation(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.FzLocation_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_FzLocation
    1:     chapter = property(_mupdf.FzLocation_chapter_get, _mupdf.FzLocation_chapter_set)
    1:     page = property(_mupdf.FzLocation_page_get, _mupdf.FzLocation_page_set)
    1:     s_num_instances = property(_mupdf.FzLocation_s_num_instances_get, _mupdf.FzLocation_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzLocation_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzLocation___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzLocation___ne__(self, rhs)
       
       # Register FzLocation in _mupdf:
    1: _mupdf.FzLocation_swigregister(FzLocation)
    2: class FzLocksContext(object):
    1:     r"""
           Wrapper class for struct `fz_locks_context`. Not copyable or assignable.
           Locking functions
       
           MuPDF is kept deliberately free of any knowledge of particular
           threading systems. As such, in order for safe multi-threaded
           operation, we rely on callbacks to client provided functions.
       
           A client is expected to provide FZ_LOCK_MAX number of mutexes,
           and a function to lock/unlock each of them. These may be
           recursive mutexes, but do not have to be.
       
           If a client does not intend to use multiple threads, then it
           may pass NULL instead of a lock structure.
       
           In order to avoid deadlocks, we have one simple rule
           internally as to how we use locks: We can never take lock n
           when we already hold any lock i, where 0 <= i <= n. In order
           to verify this, we have some debugging code, that can be
           enabled by defining FITZ_DEBUG_LOCKING.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_locks_context`.
               """
>>>>>>         _mupdf.FzLocksContext_swiginit(self, _mupdf.new_FzLocksContext(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzLocksContext
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzLocksContext_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzLocksContext___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzLocksContext_m_internal_get, _mupdf.FzLocksContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzLocksContext_s_num_instances_get, _mupdf.FzLocksContext_s_num_instances_set)
       
       # Register FzLocksContext in _mupdf:
    1: _mupdf.FzLocksContext_swigregister(FzLocksContext)
    2: class FzMatrix(object):
    1:     r"""
            Wrapper class for struct `fz_matrix`.
               fz_matrix is a row-major 3x3 matrix used for representing
               transformations of coordinates throughout MuPDF.
       
               Since all points reside in a two-dimensional space, one vector
               is always a constant unit vector; hence only some elements may
               vary in a matrix. Below is how the elements map between
               different representations.
       
           a b 0
               | c d 0 | normally represented as [ a b c d e f ].
               \ e f 1 /
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    2:     @staticmethod
    2:     def fz_scale(sx, sy):
               r"""
               Class-aware wrapper for `::fz_scale()`.
                       Create a scaling matrix.
       
                       The returned matrix is of the form [ sx 0 0 sy 0 0 ].
       
                       m: Pointer to the matrix to populate
       
                       sx, sy: Scaling factors along the X- and Y-axes. A scaling
                       factor of 1.0 will not cause any scaling along the relevant
                       axis.
       
                       Returns m.
               """
>>>>>>         return _mupdf.FzMatrix_fz_scale(sx, sy)
       
    2:     @staticmethod
    2:     def fz_shear(sx, sy):
               r"""
               Class-aware wrapper for `::fz_shear()`.
                       Create a shearing matrix.
       
                       The returned matrix is of the form [ 1 sy sx 1 0 0 ].
       
                       m: pointer to place to store returned matrix
       
                       sx, sy: Shearing factors. A shearing factor of 0.0 will not
                       cause any shearing along the relevant axis.
       
                       Returns m.
               """
>>>>>>         return _mupdf.FzMatrix_fz_shear(sx, sy)
       
    2:     @staticmethod
    2:     def fz_rotate(degrees):
               r"""
               Class-aware wrapper for `::fz_rotate()`.
                       Create a rotation matrix.
       
                       The returned matrix is of the form
                       [ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].
       
                       m: Pointer to place to store matrix
       
                       degrees: Degrees of counter clockwise rotation. Values less
                       than zero and greater than 360 are handled as expected.
       
                       Returns m.
               """
>>>>>>         return _mupdf.FzMatrix_fz_rotate(degrees)
       
    2:     @staticmethod
    2:     def fz_translate(tx, ty):
               r"""
               Class-aware wrapper for `::fz_translate()`.
                       Create a translation matrix.
       
                       The returned matrix is of the form [ 1 0 0 1 tx ty ].
       
                       m: A place to store the created matrix.
       
                       tx, ty: Translation distances along the X- and Y-axes. A
                       translation of 0 will not cause any translation along the
                       relevant axis.
       
                       Returns m.
               """
>>>>>>         return _mupdf.FzMatrix_fz_translate(tx, ty)
       
    2:     @staticmethod
    2:     def fz_transform_page(mediabox, resolution, rotate):
               r"""
               Class-aware wrapper for `::fz_transform_page()`.
                       Create transform matrix to draw page
                       at a given resolution and rotation. Adjusts the scaling
                       factors so that the page covers whole number of
                       pixels and adjust the page origin to be at 0,0.
               """
>>>>>>         return _mupdf.FzMatrix_fz_transform_page(mediabox, resolution, rotate)
       
    1:     def fz_concat(self, *args):
               r"""
               *Overload 1:*
                We use default copy constructor and operator=.  Class-aware wrapper for `::fz_concat()`.
                               Multiply two matrices.
       
                               The order of the two matrices are important since matrix
                               multiplication is not commutative.
       
                               Returns result.
       
       
               |
       
               *Overload 2:*
                Class-aware wrapper for `::fz_concat()`.
                               Multiply two matrices.
       
                               The order of the two matrices are important since matrix
                               multiplication is not commutative.
       
                               Returns result.
               """
>>>>>>         return _mupdf.FzMatrix_fz_concat(self, *args)
       
    1:     def fz_invert_matrix(self):
               r"""
               Class-aware wrapper for `::fz_invert_matrix()`.
                       Create an inverse matrix.
       
                       matrix: Matrix to invert. A degenerate matrix, where the
                       determinant is equal to zero, can not be inverted and the
                       original matrix is returned instead.
       
                       Returns inverse.
               """
>>>>>>         return _mupdf.FzMatrix_fz_invert_matrix(self)
       
    1:     def fz_is_identity(self):
               r"""Class-aware wrapper for `::fz_is_identity()`."""
>>>>>>         return _mupdf.FzMatrix_fz_is_identity(self)
       
    1:     def fz_is_rectilinear(self):
               r"""
               Class-aware wrapper for `::fz_is_rectilinear()`.
                       Check if a transformation is rectilinear.
       
                       Rectilinear means that no shearing is present and that any
                       rotations present are a multiple of 90 degrees. Usually this
                       is used to make sure that axis-aligned rectangles before the
                       transformation are still axis-aligned rectangles afterwards.
               """
>>>>>>         return _mupdf.FzMatrix_fz_is_rectilinear(self)
       
    1:     def fz_matrix_expansion(self):
               r"""
               Class-aware wrapper for `::fz_matrix_expansion()`.
                       Calculate average scaling factor of matrix.
               """
>>>>>>         return _mupdf.FzMatrix_fz_matrix_expansion(self)
       
    1:     def fz_matrix_max_expansion(self):
               r"""
               Class-aware wrapper for `::fz_matrix_max_expansion()`.
                       Find the largest expansion performed by this matrix.
                       (i.e. max(abs(m.a),abs(m.b),abs(m.c),abs(m.d))
               """
>>>>>>         return _mupdf.FzMatrix_fz_matrix_max_expansion(self)
       
    1:     def fz_post_scale(self, sx, sy):
               r"""
               Class-aware wrapper for `::fz_post_scale()`.
                       Scale a matrix by postmultiplication.
       
                       m: Pointer to the matrix to scale
       
                       sx, sy: Scaling factors along the X- and Y-axes. A scaling
                       factor of 1.0 will not cause any scaling along the relevant
                       axis.
       
                       Returns m (updated).
               """
>>>>>>         return _mupdf.FzMatrix_fz_post_scale(self, sx, sy)
       
    1:     def fz_pre_rotate(self, degrees):
               r"""
               Class-aware wrapper for `::fz_pre_rotate()`.
                       Rotate a transformation by premultiplying.
       
                       The premultiplied matrix is of the form
                       [ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].
       
                       m: Pointer to matrix to premultiply.
       
                       degrees: Degrees of counter clockwise rotation. Values less
                       than zero and greater than 360 are handled as expected.
       
                       Returns m (updated).
               """
>>>>>>         return _mupdf.FzMatrix_fz_pre_rotate(self, degrees)
       
    1:     def fz_pre_scale(self, sx, sy):
               r"""
               Class-aware wrapper for `::fz_pre_scale()`.
                       Scale a matrix by premultiplication.
       
                       m: Pointer to the matrix to scale
       
                       sx, sy: Scaling factors along the X- and Y-axes. A scaling
                       factor of 1.0 will not cause any scaling along the relevant
                       axis.
       
                       Returns m (updated).
               """
>>>>>>         return _mupdf.FzMatrix_fz_pre_scale(self, sx, sy)
       
    1:     def fz_pre_shear(self, sx, sy):
               r"""
               Class-aware wrapper for `::fz_pre_shear()`.
                       Premultiply a matrix with a shearing matrix.
       
                       The shearing matrix is of the form [ 1 sy sx 1 0 0 ].
       
                       m: pointer to matrix to premultiply
       
                       sx, sy: Shearing factors. A shearing factor of 0.0 will not
                       cause any shearing along the relevant axis.
       
                       Returns m (updated).
               """
>>>>>>         return _mupdf.FzMatrix_fz_pre_shear(self, sx, sy)
       
    1:     def fz_pre_translate(self, tx, ty):
               r"""
               Class-aware wrapper for `::fz_pre_translate()`.
                       Translate a matrix by premultiplication.
       
                       m: The matrix to translate
       
                       tx, ty: Translation distances along the X- and Y-axes. A
                       translation of 0 will not cause any translation along the
                       relevant axis.
       
                       Returns m.
               """
>>>>>>         return _mupdf.FzMatrix_fz_pre_translate(self, tx, ty)
       
    1:     def fz_subpixel_adjust(self, subpix_ctm, qe, qf):
               r"""
               Class-aware wrapper for `::fz_subpixel_adjust()`.
                       Perform subpixel quantisation and adjustment on a glyph matrix.
       
                       ctm: On entry, the desired 'ideal' transformation for a glyph.
                       On exit, adjusted to a (very similar) transformation quantised
                       for subpixel caching.
       
                       subpix_ctm: Initialised by the routine to the transform that
                       should be used to render the glyph.
       
                       qe, qf: which subpixel position we quantised to.
       
                       Returns: the size of the glyph.
       
                       Note: This is currently only exposed for use in our app. It
                       should be considered "at risk" of removal from the API.
               """
>>>>>>         return _mupdf.FzMatrix_fz_subpixel_adjust(self, subpix_ctm, qe, qf)
       
    1:     def fz_try_invert_matrix(self, src):
               r"""
               Class-aware wrapper for `::fz_try_invert_matrix()`.
                       Attempt to create an inverse matrix.
       
                       inv: Place to store inverse matrix.
       
                       src: Matrix to invert. A degenerate matrix, where the
                       determinant is equal to zero, can not be inverted.
       
                       Returns 1 if matrix is degenerate (singular), or 0 otherwise.
               """
>>>>>>         return _mupdf.FzMatrix_fz_try_invert_matrix(self, src)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `fz_make_matrix()`.
       
               |
       
               *Overload 2:*
               Constructs identity matrix (like fz_identity).
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_matrix`.
       
               |
       
               *Overload 4:*
               Constructor using raw copy of pre-existing `::fz_matrix`.
               """
>>>>>>         _mupdf.FzMatrix_swiginit(self, _mupdf.new_FzMatrix(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.FzMatrix_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_FzMatrix
    1:     a = property(_mupdf.FzMatrix_a_get, _mupdf.FzMatrix_a_set)
    1:     b = property(_mupdf.FzMatrix_b_get, _mupdf.FzMatrix_b_set)
    1:     c = property(_mupdf.FzMatrix_c_get, _mupdf.FzMatrix_c_set)
    1:     d = property(_mupdf.FzMatrix_d_get, _mupdf.FzMatrix_d_set)
    1:     e = property(_mupdf.FzMatrix_e_get, _mupdf.FzMatrix_e_set)
    1:     f = property(_mupdf.FzMatrix_f_get, _mupdf.FzMatrix_f_set)
    1:     s_num_instances = property(_mupdf.FzMatrix_s_num_instances_get, _mupdf.FzMatrix_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzMatrix_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzMatrix___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzMatrix___ne__(self, rhs)
       
       # Register FzMatrix in _mupdf:
    1: _mupdf.FzMatrix_swigregister(FzMatrix)
    2: class FzMd5(object):
    1:     r"""
           Wrapper class for struct `fz_md5`.
           Structure definition is public to enable stack
           based allocation. Do not access the members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_md5_final(self, digest):
               r"""
               We use default copy constructor and operator=.  Class-aware wrapper for `::fz_md5_final()`.
                       MD5 finalization. Ends an MD5 message-digest operation, writing
                       the message digest and zeroizing the context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzMd5_fz_md5_final(self, digest)
       
    1:     def fz_md5_final2(self):
               r"""
               Class-aware wrapper for `::fz_md5_final2()`.
               C++ alternative to fz_md5_final() that returns the digest by value.
               """
>>>>>>         return _mupdf.FzMd5_fz_md5_final2(self)
       
    1:     def fz_md5_init(self):
               r"""
               Class-aware wrapper for `::fz_md5_init()`.
                       MD5 initialization. Begins an MD5 operation, writing a new
                       context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzMd5_fz_md5_init(self)
       
    1:     def fz_md5_update(self, input, inlen):
               r"""
               Class-aware wrapper for `::fz_md5_update()`.
                       MD5 block update operation. Continues an MD5 message-digest
                       operation, processing another message block, and updating the
                       context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzMd5_fz_md5_update(self, input, inlen)
       
    1:     def fz_md5_update_int64(self, i):
               r"""
               Class-aware wrapper for `::fz_md5_update_int64()`.
                       MD5 block update operation. Continues an MD5 message-digest
                       operation, processing an int64, and updating the context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzMd5_fz_md5_update_int64(self, i)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor calls md5_init().
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_md5`.
               """
>>>>>>         _mupdf.FzMd5_swiginit(self, _mupdf.new_FzMd5(*args))
       
    1:     def lo(self):
>>>>>>         return _mupdf.FzMd5_lo(self)
       
    1:     def hi(self):
>>>>>>         return _mupdf.FzMd5_hi(self)
       
    1:     def a(self):
>>>>>>         return _mupdf.FzMd5_a(self)
       
    1:     def b(self):
>>>>>>         return _mupdf.FzMd5_b(self)
       
    1:     def c(self):
>>>>>>         return _mupdf.FzMd5_c(self)
       
    1:     def d(self):
>>>>>>         return _mupdf.FzMd5_d(self)
       
    1:     def buffer(self):
>>>>>>         return _mupdf.FzMd5_buffer(self)
    1:     __swig_destroy__ = _mupdf.delete_FzMd5
    1:     m_internal = property(_mupdf.FzMd5_m_internal_get, _mupdf.FzMd5_m_internal_set)
    1:     s_num_instances = property(_mupdf.FzMd5_s_num_instances_get, _mupdf.FzMd5_s_num_instances_set, doc=r"""Wrapped data is held by value.""")
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzMd5_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzMd5___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzMd5___ne__(self, rhs)
       
       # Register FzMd5 in _mupdf:
    1: _mupdf.FzMd5_swigregister(FzMd5)
    2: class FzOutline(object):
    1:     r"""
           Wrapper class for struct `fz_outline`.
           fz_outline is a tree of the outline of a document (also known
           as table of contents).
       
           title: Title of outline item using UTF-8 encoding. May be NULL
           if the outline item has no text string.
       
           uri: Destination in the document to be displayed when this
           outline item is activated. May be an internal or external
           link, or NULL if the outline item does not have a destination.
       
           page: The page number of an internal link, or -1 for external
           links or links with no destination.
       
           next: The next outline item at the same level as this outline
           item. May be NULL if no more outline items exist at this level.
       
           down: The outline items immediate children in the hierarchy.
           May be NULL if no children exist.
       
           is_open: If zero, the outline element is closed in the UI. If
           1, it should be open, showing any child elements.
       
           flags: Bit 0 set -> Bold, Bit 1 set -> Italic. All other bits
           reserved.
       
           r, g, b: The RGB components of the color of this entry.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_load_outline()`.
                               Load the hierarchical document outline.
       
                               Should be freed by fz_drop_outline.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_load_outline_from_iterator()`.
                               Routine to implement the old Structure based API from an iterator.
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_outline()`.
                               Create a new outline entry with zeroed fields for the caller
                               to fill in.
       
       
               |
       
               *Overload 4:*
                Copy constructor using `fz_keep_outline()`.
       
               |
       
               *Overload 5:*
                Constructor using raw copy of pre-existing `::fz_outline`.
               """
>>>>>>         _mupdf.FzOutline_swiginit(self, _mupdf.new_FzOutline(*args))
       
    1:     def refs(self):
>>>>>>         return _mupdf.FzOutline_refs(self)
       
    1:     def title(self):
>>>>>>         return _mupdf.FzOutline_title(self)
       
    1:     def uri(self):
>>>>>>         return _mupdf.FzOutline_uri(self)
       
    1:     def page(self):
>>>>>>         return _mupdf.FzOutline_page(self)
       
    1:     def x(self):
>>>>>>         return _mupdf.FzOutline_x(self)
       
    1:     def y(self):
>>>>>>         return _mupdf.FzOutline_y(self)
       
    1:     def next(self):
>>>>>>         return _mupdf.FzOutline_next(self)
       
    1:     def down(self):
>>>>>>         return _mupdf.FzOutline_down(self)
       
    1:     def is_open(self):
>>>>>>         return _mupdf.FzOutline_is_open(self)
       
    1:     def flags(self):
>>>>>>         return _mupdf.FzOutline_flags(self)
       
    1:     def r(self):
>>>>>>         return _mupdf.FzOutline_r(self)
       
    1:     def g(self):
>>>>>>         return _mupdf.FzOutline_g(self)
       
    1:     def b(self):
>>>>>>         return _mupdf.FzOutline_b(self)
    1:     __swig_destroy__ = _mupdf.delete_FzOutline
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzOutline_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzOutline___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzOutline_m_internal_get, _mupdf.FzOutline_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzOutline_s_num_instances_get, _mupdf.FzOutline_s_num_instances_set)
       
       # Register FzOutline in _mupdf:
    1: _mupdf.FzOutline_swigregister(FzOutline)
    2: class FzOutlineItem(object):
    1:     r"""Wrapper class for struct `fz_outline_item`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def valid(self):
>>>>>>         return _mupdf.FzOutlineItem_valid(self)
       
    1:     def title(self):
>>>>>>         return _mupdf.FzOutlineItem_title(self)
       
    1:     def uri(self):
>>>>>>         return _mupdf.FzOutlineItem_uri(self)
       
    1:     def is_open(self):
>>>>>>         return _mupdf.FzOutlineItem_is_open(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_outline_item`.
               """
>>>>>>         _mupdf.FzOutlineItem_swiginit(self, _mupdf.new_FzOutlineItem(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzOutlineItem
    1:     s_num_instances = property(_mupdf.FzOutlineItem_s_num_instances_get, _mupdf.FzOutlineItem_s_num_instances_set)
       
       # Register FzOutlineItem in _mupdf:
    1: _mupdf.FzOutlineItem_swigregister(FzOutlineItem)
    2: class FzOutlineIterator(object):
    1:     r"""Wrapper class for struct `fz_outline_iterator`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_load_outline_from_iterator(self):
               r"""
               Class-aware wrapper for `::fz_load_outline_from_iterator()`.
                       Routine to implement the old Structure based API from an iterator.
               """
>>>>>>         return _mupdf.FzOutlineIterator_fz_load_outline_from_iterator(self)
       
    1:     def fz_outline_iterator_delete(self):
               r"""
               Class-aware wrapper for `::fz_outline_iterator_delete()`.
                       Delete the current item.
       
                       This implicitly moves us to the 'next' item, and the return code is as for fz_outline_iterator_next.
               """
>>>>>>         return _mupdf.FzOutlineIterator_fz_outline_iterator_delete(self)
       
    1:     def fz_outline_iterator_down(self):
               r"""Class-aware wrapper for `::fz_outline_iterator_down()`."""
>>>>>>         return _mupdf.FzOutlineIterator_fz_outline_iterator_down(self)
       
    1:     def fz_outline_iterator_item(self):
               r"""
               Class-aware wrapper for `::fz_outline_iterator_item()`.
                       Call to get the current outline item.
       
                       Can return NULL. The item is only valid until the next call.
               """
>>>>>>         return _mupdf.FzOutlineIterator_fz_outline_iterator_item(self)
       
    1:     def fz_outline_iterator_next(self):
               r"""
               Class-aware wrapper for `::fz_outline_iterator_next()`.
                       Calls to move the iterator position.
       
                       A negative return value means we could not move as requested. Otherwise:
                       0 = the final position has a valid item.
                       1 = not a valid item, but we can insert an item here.
               """
>>>>>>         return _mupdf.FzOutlineIterator_fz_outline_iterator_next(self)
       
    1:     def fz_outline_iterator_prev(self):
               r"""Class-aware wrapper for `::fz_outline_iterator_prev()`."""
>>>>>>         return _mupdf.FzOutlineIterator_fz_outline_iterator_prev(self)
       
    1:     def fz_outline_iterator_up(self):
               r"""Class-aware wrapper for `::fz_outline_iterator_up()`."""
>>>>>>         return _mupdf.FzOutlineIterator_fz_outline_iterator_up(self)
       
    1:     def fz_outline_iterator_insert(self, item):
               r"""Custom wrapper for fz_outline_iterator_insert()."""
>>>>>>         return _mupdf.FzOutlineIterator_fz_outline_iterator_insert(self, item)
       
    1:     def fz_outline_iterator_update(self, item):
               r"""Custom wrapper for fz_outline_iterator_update()."""
>>>>>>         return _mupdf.FzOutlineIterator_fz_outline_iterator_update(self, item)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_outline_iterator()`.
                               Get an iterator for the document outline.
       
                               Should be freed by fz_drop_outline_iterator.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_outline_iterator_of_size()`.
       
               |
       
               *Overload 3:*
                Constructor using `pdf_new_outline_iterator()`.
       
               |
       
               *Overload 4:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 5:*
                Constructor using raw copy of pre-existing `::fz_outline_iterator`.
               """
>>>>>>         _mupdf.FzOutlineIterator_swiginit(self, _mupdf.new_FzOutlineIterator(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzOutlineIterator
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzOutlineIterator_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzOutlineIterator___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzOutlineIterator_m_internal_get, _mupdf.FzOutlineIterator_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzOutlineIterator_s_num_instances_get, _mupdf.FzOutlineIterator_s_num_instances_set)
       
       # Register FzOutlineIterator in _mupdf:
    1: _mupdf.FzOutlineIterator_swigregister(FzOutlineIterator)
    2: class FzOutput(object):
    1:     r"""Wrapper class for struct `fz_output`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     Fixed_STDOUT = _mupdf.FzOutput_Fixed_STDOUT
    1:     Fixed_STDERR = _mupdf.FzOutput_Fixed_STDERR
    1:     Filter_HEX = _mupdf.FzOutput_Filter_HEX
    1:     Filter_85 = _mupdf.FzOutput_Filter_85
    1:     Filter_RLE = _mupdf.FzOutput_Filter_RLE
       
    1:     def fz_close_output(self):
               r"""
               Class-aware wrapper for `::fz_close_output()`.
                       Flush pending output and close an output stream.
               """
>>>>>>         return _mupdf.FzOutput_fz_close_output(self)
       
    1:     def fz_debug_store(self):
               r"""
               Class-aware wrapper for `::fz_debug_store()`.
                       Output debugging information for the current state of the store
                       to the given output channel.
               """
>>>>>>         return _mupdf.FzOutput_fz_debug_store(self)
       
    1:     def fz_dump_glyph_cache_stats(self):
               r"""
               Class-aware wrapper for `::fz_dump_glyph_cache_stats()`.
                       Dump debug statistics for the glyph cache.
               """
>>>>>>         return _mupdf.FzOutput_fz_dump_glyph_cache_stats(self)
       
    1:     def fz_flush_output(self):
               r"""
               Class-aware wrapper for `::fz_flush_output()`.
                       Flush unwritten data.
               """
>>>>>>         return _mupdf.FzOutput_fz_flush_output(self)
       
    1:     def fz_int2_heap_dump(self, heap):
               r"""Class-aware wrapper for `::fz_int2_heap_dump()`."""
>>>>>>         return _mupdf.FzOutput_fz_int2_heap_dump(self, heap)
       
    1:     def fz_int_heap_dump(self, heap):
               r"""Class-aware wrapper for `::fz_int_heap_dump()`."""
>>>>>>         return _mupdf.FzOutput_fz_int_heap_dump(self, heap)
       
    1:     def fz_intptr_heap_dump(self, heap):
               r"""Class-aware wrapper for `::fz_intptr_heap_dump()`."""
>>>>>>         return _mupdf.FzOutput_fz_intptr_heap_dump(self, heap)
       
    1:     def fz_new_svg_device(self, page_width, page_height, text_format, reuse_images):
               r"""
               Class-aware wrapper for `::fz_new_svg_device()`.
                       Create a device that outputs (single page) SVG files to
                       the given output stream.
       
                       Equivalent to fz_new_svg_device_with_id passing id = NULL.
               """
>>>>>>         return _mupdf.FzOutput_fz_new_svg_device(self, page_width, page_height, text_format, reuse_images)
       
    1:     def fz_new_svg_device_with_id(self, page_width, page_height, text_format, reuse_images, id):
               r"""
               Class-aware wrapper for `::fz_new_svg_device_with_id()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_new_svg_device_with_id(float page_width, float page_height, int text_format, int reuse_images)` => `(fz_device *, int id)`
       
                       Create a device that outputs (single page) SVG files to
                       the given output stream.
       
                       output: The output stream to send the constructed SVG page to.
       
                       page_width, page_height: The page dimensions to use (in points).
       
                       text_format: How to emit text. One of the following values:
                               FZ_SVG_TEXT_AS_TEXT: As <text> elements with possible
                               layout errors and mismatching fonts.
                               FZ_SVG_TEXT_AS_PATH: As <path> elements with exact
                               visual appearance.
       
                       reuse_images: Share image resources using <symbol> definitions.
       
                       id: ID parameter to keep generated IDs unique across SVG files.
               """
>>>>>>         return _mupdf.FzOutput_fz_new_svg_device_with_id(self, page_width, page_height, text_format, reuse_images, id)
       
    1:     def fz_new_trace_device(self):
               r"""
               Class-aware wrapper for `::fz_new_trace_device()`.
                       Create a device to print a debug trace of all device calls.
               """
>>>>>>         return _mupdf.FzOutput_fz_new_trace_device(self)
       
    1:     def fz_new_xmltext_device(self):
               r"""
               Class-aware wrapper for `::fz_new_xmltext_device()`.
                       Create a device to output raw information.
               """
>>>>>>         return _mupdf.FzOutput_fz_new_xmltext_device(self)
       
    1:     def fz_output_supports_stream(self):
               r"""
               Class-aware wrapper for `::fz_output_supports_stream()`.
                       Query whether a given fz_output supports fz_stream_from_output.
               """
>>>>>>         return _mupdf.FzOutput_fz_output_supports_stream(self)
       
    1:     def fz_output_xml(self, item, level):
               r"""
               Class-aware wrapper for `::fz_output_xml()`.
                       Pretty-print an XML tree to given output.
               """
>>>>>>         return _mupdf.FzOutput_fz_output_xml(self, item, level)
       
    1:     def fz_print_stext_header_as_html(self):
               r"""Class-aware wrapper for `::fz_print_stext_header_as_html()`."""
>>>>>>         return _mupdf.FzOutput_fz_print_stext_header_as_html(self)
       
    1:     def fz_print_stext_header_as_xhtml(self):
               r"""Class-aware wrapper for `::fz_print_stext_header_as_xhtml()`."""
>>>>>>         return _mupdf.FzOutput_fz_print_stext_header_as_xhtml(self)
       
    1:     def fz_print_stext_page_as_html(self, page, id):
               r"""
               Class-aware wrapper for `::fz_print_stext_page_as_html()`.
                       Output structured text to a file in HTML (visual) format.
               """
>>>>>>         return _mupdf.FzOutput_fz_print_stext_page_as_html(self, page, id)
       
    1:     def fz_print_stext_page_as_json(self, page, scale):
               r"""
               Class-aware wrapper for `::fz_print_stext_page_as_json()`.
                       Output structured text to a file in JSON format.
               """
>>>>>>         return _mupdf.FzOutput_fz_print_stext_page_as_json(self, page, scale)
       
    1:     def fz_print_stext_page_as_text(self, page):
               r"""
               Class-aware wrapper for `::fz_print_stext_page_as_text()`.
                       Output structured text to a file in plain-text UTF-8 format.
               """
>>>>>>         return _mupdf.FzOutput_fz_print_stext_page_as_text(self, page)
       
    1:     def fz_print_stext_page_as_xhtml(self, page, id):
               r"""
               Class-aware wrapper for `::fz_print_stext_page_as_xhtml()`.
                       Output structured text to a file in XHTML (semantic) format.
               """
>>>>>>         return _mupdf.FzOutput_fz_print_stext_page_as_xhtml(self, page, id)
       
    1:     def fz_print_stext_page_as_xml(self, page, id):
               r"""
               Class-aware wrapper for `::fz_print_stext_page_as_xml()`.
                       Output structured text to a file in XML format.
               """
>>>>>>         return _mupdf.FzOutput_fz_print_stext_page_as_xml(self, page, id)
       
    1:     def fz_print_stext_trailer_as_html(self):
               r"""Class-aware wrapper for `::fz_print_stext_trailer_as_html()`."""
>>>>>>         return _mupdf.FzOutput_fz_print_stext_trailer_as_html(self)
       
    1:     def fz_print_stext_trailer_as_xhtml(self):
               r"""Class-aware wrapper for `::fz_print_stext_trailer_as_xhtml()`."""
>>>>>>         return _mupdf.FzOutput_fz_print_stext_trailer_as_xhtml(self)
       
    1:     def fz_reset_output(self):
               r"""
               Class-aware wrapper for `::fz_reset_output()`.
                       Reset a closed output stream. Returns state to
                       (broadly) that which it was in when opened. Not
                       all outputs can be reset, so this may throw an
                       exception.
               """
>>>>>>         return _mupdf.FzOutput_fz_reset_output(self)
       
    1:     def fz_seek_output(self, off, whence):
               r"""
               Class-aware wrapper for `::fz_seek_output()`.
                       Seek to the specified file position.
                       See fseek for arguments.
       
                       Throw an error on unseekable outputs.
               """
>>>>>>         return _mupdf.FzOutput_fz_seek_output(self, off, whence)
       
    1:     def fz_set_stddbg(self):
               r"""
               Class-aware wrapper for `::fz_set_stddbg()`.
                       Set the output stream to be used for fz_stddbg. Set to NULL to
                       reset to default (stderr).
               """
>>>>>>         return _mupdf.FzOutput_fz_set_stddbg(self)
       
    1:     def fz_stream_from_output(self):
               r"""
               Class-aware wrapper for `::fz_stream_from_output()`.
                       Obtain the fz_output in the form of a fz_stream.
       
                       This allows data to be read back from some forms of fz_output
                       object. When finished reading, the fz_stream should be released
                       by calling fz_drop_stream. Until the fz_stream is dropped, no
                       further operations should be performed on the fz_output object.
               """
>>>>>>         return _mupdf.FzOutput_fz_stream_from_output(self)
       
    1:     def fz_tell_output(self):
               r"""
               Class-aware wrapper for `::fz_tell_output()`.
                       Return the current file position.
       
                       Throw an error on untellable outputs.
               """
>>>>>>         return _mupdf.FzOutput_fz_tell_output(self)
       
    1:     def fz_truncate_output(self):
               r"""
               Class-aware wrapper for `::fz_truncate_output()`.
                       Truncate the output at the current position.
       
                       This allows output streams which have seeked back from the end
                       of their storage to be truncated at the current point.
               """
>>>>>>         return _mupdf.FzOutput_fz_truncate_output(self)
       
    1:     def fz_write_base64(self, data, size, newline):
               r"""
               Class-aware wrapper for `::fz_write_base64()`.
                       Write a base64 encoded data block, optionally with periodic
                       newlines.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_base64(self, data, size, newline)
       
    1:     def fz_write_base64_buffer(self, data, newline):
               r"""
               Class-aware wrapper for `::fz_write_base64_buffer()`.
                       Write a base64 encoded fz_buffer, optionally with periodic
                       newlines.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_base64_buffer(self, data, newline)
       
    1:     def fz_write_bitmap_as_pbm(self, bitmap):
               r"""
               Class-aware wrapper for `::fz_write_bitmap_as_pbm()`.
                       Write a bitmap as a pbm.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_bitmap_as_pbm(self, bitmap)
       
    1:     def fz_write_bitmap_as_pcl(self, bitmap, pcl):
               r"""
               Class-aware wrapper for `::fz_write_bitmap_as_pcl()`.
                       Write a bitmap as mono PCL.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_bitmap_as_pcl(self, bitmap, pcl)
       
    1:     def fz_write_bitmap_as_pkm(self, bitmap):
               r"""
               Class-aware wrapper for `::fz_write_bitmap_as_pkm()`.
                       Write a CMYK bitmap as a pkm.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_bitmap_as_pkm(self, bitmap)
       
    1:     def fz_write_bitmap_as_pwg(self, bitmap, pwg):
               r"""
               Class-aware wrapper for `::fz_write_bitmap_as_pwg()`.
                       Write a bitmap as a PWG.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_bitmap_as_pwg(self, bitmap, pwg)
       
    1:     def fz_write_bitmap_as_pwg_page(self, bitmap, pwg):
               r"""
               Class-aware wrapper for `::fz_write_bitmap_as_pwg_page()`.
                       Write a bitmap as a PWG page.
       
                       Caller should provide a file header by calling
                       fz_write_pwg_file_header, but can then write several pages to
                       the same file.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_bitmap_as_pwg_page(self, bitmap, pwg)
       
    1:     def fz_write_bits(self, data, num_bits):
               r"""
               Class-aware wrapper for `::fz_write_bits()`.
                       Write num_bits of data to the end of the output stream, assumed to be packed
                       most significant bits first.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_bits(self, data, num_bits)
       
    1:     def fz_write_bits_sync(self):
               r"""
               Class-aware wrapper for `::fz_write_bits_sync()`.
                       Sync to byte boundary after writing bits.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_bits_sync(self)
       
    1:     def fz_write_buffer(self, data):
               r"""Class-aware wrapper for `::fz_write_buffer()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_buffer(self, data)
       
    1:     def fz_write_byte(self, x):
               r"""Class-aware wrapper for `::fz_write_byte()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_byte(self, x)
       
    1:     def fz_write_char(self, x):
               r"""Class-aware wrapper for `::fz_write_char()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_char(self, x)
       
    1:     def fz_write_data(self, data, size):
               r"""
               Class-aware wrapper for `::fz_write_data()`.
                       Write data to output.
       
                       data: Pointer to data to write.
                       size: Size of data to write in bytes.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_data(self, data, size)
       
    1:     def fz_write_float_be(self, f):
               r"""Class-aware wrapper for `::fz_write_float_be()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_float_be(self, f)
       
    1:     def fz_write_float_le(self, f):
               r"""Class-aware wrapper for `::fz_write_float_le()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_float_le(self, f)
       
    1:     def fz_write_image_as_data_uri(self, image):
               r"""
               Class-aware wrapper for `::fz_write_image_as_data_uri()`.
                       Write image as a data URI (for HTML and SVG output).
               """
>>>>>>         return _mupdf.FzOutput_fz_write_image_as_data_uri(self, image)
       
    1:     def fz_write_int16_be(self, x):
               r"""Class-aware wrapper for `::fz_write_int16_be()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_int16_be(self, x)
       
    1:     def fz_write_int16_le(self, x):
               r"""Class-aware wrapper for `::fz_write_int16_le()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_int16_le(self, x)
       
    1:     def fz_write_int32_be(self, x):
               r"""
               Class-aware wrapper for `::fz_write_int32_be()`.
                       Write different sized data to an output stream.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_int32_be(self, x)
       
    1:     def fz_write_int32_le(self, x):
               r"""Class-aware wrapper for `::fz_write_int32_le()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_int32_le(self, x)
       
    1:     def fz_write_json(self, value):
               r"""Class-aware wrapper for `::fz_write_json()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_json(self, value)
       
    1:     def fz_write_pixmap_as_data_uri(self, pixmap):
               r"""Class-aware wrapper for `::fz_write_pixmap_as_data_uri()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_pixmap_as_data_uri(self, pixmap)
       
    1:     def fz_write_pixmap_as_jpeg(self, pix, quality, invert_cmyk):
               r"""
               Class-aware wrapper for `::fz_write_pixmap_as_jpeg()`.
                       Write a pixmap as a JPEG.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_pixmap_as_jpeg(self, pix, quality, invert_cmyk)
       
    1:     def fz_write_pixmap_as_jpx(self, pix, quality):
               r"""
               Class-aware wrapper for `::fz_write_pixmap_as_jpx()`.
                       Pixmap data as JP2K with no subsampling.
       
                       quality = 100 = lossless
                       otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
               """
>>>>>>         return _mupdf.FzOutput_fz_write_pixmap_as_jpx(self, pix, quality)
       
    1:     def fz_write_pixmap_as_pam(self, pixmap):
               r"""
               Class-aware wrapper for `::fz_write_pixmap_as_pam()`.
                       Write a pixmap as a pnm (greyscale, rgb or cmyk, with or without
                       alpha).
               """
>>>>>>         return _mupdf.FzOutput_fz_write_pixmap_as_pam(self, pixmap)
       
    1:     def fz_write_pixmap_as_pcl(self, pixmap, pcl):
               r"""
               Class-aware wrapper for `::fz_write_pixmap_as_pcl()`.
                       Write an (RGB) pixmap as color PCL.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_pixmap_as_pcl(self, pixmap, pcl)
       
    1:     def fz_write_pixmap_as_pclm(self, pixmap, options):
               r"""
               Class-aware wrapper for `::fz_write_pixmap_as_pclm()`.
                       Write a (Greyscale or RGB) pixmap as pclm.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_pixmap_as_pclm(self, pixmap, options)
       
    1:     def fz_write_pixmap_as_pdfocr(self, pixmap, options):
               r"""
               Class-aware wrapper for `::fz_write_pixmap_as_pdfocr()`.
                       Write a (Greyscale or RGB) pixmap as pdfocr.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_pixmap_as_pdfocr(self, pixmap, options)
       
    1:     def fz_write_pixmap_as_png(self, pixmap):
               r"""
               Class-aware wrapper for `::fz_write_pixmap_as_png()`.
                       Write a (Greyscale or RGB) pixmap as a png.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_pixmap_as_png(self, pixmap)
       
    1:     def fz_write_pixmap_as_pnm(self, pixmap):
               r"""
               Class-aware wrapper for `::fz_write_pixmap_as_pnm()`.
                       Write a pixmap as a pnm (greyscale or rgb, no alpha).
               """
>>>>>>         return _mupdf.FzOutput_fz_write_pixmap_as_pnm(self, pixmap)
       
    1:     def fz_write_pixmap_as_ps(self, pixmap):
               r"""
               Class-aware wrapper for `::fz_write_pixmap_as_ps()`.
                       Write a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_pixmap_as_ps(self, pixmap)
       
    1:     def fz_write_pixmap_as_psd(self, pixmap):
               r"""
               Class-aware wrapper for `::fz_write_pixmap_as_psd()`.
                       Write a pixmap as a PSD file.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_pixmap_as_psd(self, pixmap)
       
    1:     def fz_write_pixmap_as_pwg(self, pixmap, pwg):
               r"""
               Class-aware wrapper for `::fz_write_pixmap_as_pwg()`.
                       Write a pixmap as a PWG.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_pixmap_as_pwg(self, pixmap, pwg)
       
    1:     def fz_write_pixmap_as_pwg_page(self, pixmap, pwg):
               r"""
               Class-aware wrapper for `::fz_write_pixmap_as_pwg_page()`.
                       Write a pixmap as a PWG page.
       
                       Caller should provide a file header by calling
                       fz_write_pwg_file_header, but can then write several pages to
                       the same file.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_pixmap_as_pwg_page(self, pixmap, pwg)
       
    1:     def fz_write_ps_file_header(self):
               r"""
               Class-aware wrapper for `::fz_write_ps_file_header()`.
                       Write the file level header for ps band writer output.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_ps_file_header(self)
       
    1:     def fz_write_ps_file_trailer(self, pages):
               r"""
               Class-aware wrapper for `::fz_write_ps_file_trailer()`.
                       Write the file level trailer for ps band writer output.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_ps_file_trailer(self, pages)
       
    1:     def fz_write_pwg_file_header(self):
               r"""
               Class-aware wrapper for `::fz_write_pwg_file_header()`.
                       Output the file header to a pwg stream, ready for pages to follow it.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_pwg_file_header(self)
       
    1:     def fz_write_rune(self, rune):
               r"""
               Class-aware wrapper for `::fz_write_rune()`.
                       Write a UTF-8 encoded unicode character.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_rune(self, rune)
       
    1:     def fz_write_stream(self, _in):
               r"""
               Class-aware wrapper for `::fz_write_stream()`.
                       Copy the stream contents to the output.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_stream(self, _in)
       
    1:     def fz_write_string(self, s):
               r"""
               Class-aware wrapper for `::fz_write_string()`.
                       Write a string. Does not write zero terminator.
               """
>>>>>>         return _mupdf.FzOutput_fz_write_string(self, s)
       
    1:     def fz_write_uint16_be(self, x):
               r"""Class-aware wrapper for `::fz_write_uint16_be()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_uint16_be(self, x)
       
    1:     def fz_write_uint16_le(self, x):
               r"""Class-aware wrapper for `::fz_write_uint16_le()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_uint16_le(self, x)
       
    1:     def fz_write_uint32_be(self, x):
               r"""Class-aware wrapper for `::fz_write_uint32_be()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_uint32_be(self, x)
       
    1:     def fz_write_uint32_le(self, x):
               r"""Class-aware wrapper for `::fz_write_uint32_le()`."""
>>>>>>         return _mupdf.FzOutput_fz_write_uint32_le(self, x)
       
    1:     def pdf_new_output_processor(self, ahxencode, newlines):
               r"""Class-aware wrapper for `::pdf_new_output_processor()`."""
>>>>>>         return _mupdf.FzOutput_pdf_new_output_processor(self, ahxencode, newlines)
       
    1:     def pdf_print_crypt(self, crypt):
               r"""Class-aware wrapper for `::pdf_print_crypt()`."""
>>>>>>         return _mupdf.FzOutput_pdf_print_crypt(self, crypt)
       
    1:     def pdf_print_encrypted_obj(self, obj, tight, ascii, crypt, num, gen, sep):
               r"""
               Class-aware wrapper for `::pdf_print_encrypted_obj()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_print_encrypted_obj(::pdf_obj *obj, int tight, int ascii, ::pdf_crypt *crypt, int num, int gen)` => int sep
               """
>>>>>>         return _mupdf.FzOutput_pdf_print_encrypted_obj(self, obj, tight, ascii, crypt, num, gen, sep)
       
    1:     def pdf_print_font(self, fontdesc):
               r"""Class-aware wrapper for `::pdf_print_font()`."""
>>>>>>         return _mupdf.FzOutput_pdf_print_font(self, fontdesc)
       
    1:     def pdf_print_obj(self, obj, tight, ascii):
               r"""Class-aware wrapper for `::pdf_print_obj()`."""
>>>>>>         return _mupdf.FzOutput_pdf_print_obj(self, obj, tight, ascii)
       
    1:     def pdf_write_digest(self, byte_range, field, digest_offset, digest_length, signer):
               r"""Class-aware wrapper for `::pdf_write_digest()`."""
>>>>>>         return _mupdf.FzOutput_pdf_write_digest(self, byte_range, field, digest_offset, digest_length, signer)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_arc4_output()`.
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_deflate_output()`.
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_log_for_module()`.
                               Internal function to actually do the opening of the logfile.
       
                               Caller should close/drop the output when finished with it.
       
       
               |
       
               *Overload 4:*
                Constructor using `fz_new_output()`.
                               Create a new output object with the given
                               internal state and function pointers.
       
                               state: Internal state (opaque to everything but implementation).
       
                               write: Function to output a given buffer.
       
                               close: Cleanup function to destroy state when output closed.
                               May permissibly be null.
       
       
               |
       
               *Overload 5:*
                Constructor using `fz_new_output_with_buffer()`.
                               Open an output stream that appends
                               to a buffer.
       
                               buf: The buffer to append to.
       
       
               |
       
               *Overload 6:*
                Constructor using `fz_new_output_with_file_ptr()`.
                               Open an output stream that writes to a
                               given FILE *.
       
                               file: The file pointers to write to. NULL is interpreted as effectively
                               meaning /dev/null or similar.
       
       
               |
       
               *Overload 7:*
                Constructor using `fz_new_output_with_path()`.
                               Open an output stream that writes to a
                               given path.
       
                               filename: The filename to write to (specified in UTF-8).
       
                               append: non-zero if we should append to the file, rather than
                               overwriting it.
       
       
               |
       
               *Overload 8:*
                Uses fz_stdout() or fz_stderr().
       
               |
       
               *Overload 9:*
                Calls one of: fz_new_asciihex_output(), fz_new_ascii85_output(), fz_new_rle_output().
       
               |
       
               *Overload 10:*
                Constructor using raw copy of pre-existing `::fz_output`.
       
               |
       
               *Overload 11:*
                Constructor using raw copy of pre-existing `::fz_output`.
               """
>>>>>>         _mupdf.FzOutput_swiginit(self, _mupdf.new_FzOutput(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzOutput
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzOutput_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzOutput___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzOutput_m_internal_get, _mupdf.FzOutput_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzOutput_s_num_instances_get, _mupdf.FzOutput_s_num_instances_set)
       
       # Register FzOutput in _mupdf:
    1: _mupdf.FzOutput_swigregister(FzOutput)
    2: class FzOutput2(FzOutput):
    1:     r"""Wrapper class for struct fz_output with virtual fns for each fnptr; this is for use as a SWIG Director class."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self):
               r"""== Constructor."""
>>>>>>         if self.__class__ == FzOutput2:
>>>>>>             _self = None
               else:
>>>>>>             _self = self
>>>>>>         _mupdf.FzOutput2_swiginit(self, _mupdf.new_FzOutput2(_self, ))
    1:     __swig_destroy__ = _mupdf.delete_FzOutput2
       
    1:     def use_virtual_write(self, use=True):
               r"""
               These methods set the function pointers in *m_internal
               to point to internal callbacks that call our virtual methods.
               """
>>>>>>         return _mupdf.FzOutput2_use_virtual_write(self, use)
       
    1:     def use_virtual_seek(self, use=True):
>>>>>>         return _mupdf.FzOutput2_use_virtual_seek(self, use)
       
    1:     def use_virtual_tell(self, use=True):
>>>>>>         return _mupdf.FzOutput2_use_virtual_tell(self, use)
       
    1:     def use_virtual_close(self, use=True):
>>>>>>         return _mupdf.FzOutput2_use_virtual_close(self, use)
       
    1:     def use_virtual_drop(self, use=True):
>>>>>>         return _mupdf.FzOutput2_use_virtual_drop(self, use)
       
    1:     def use_virtual_reset(self, use=True):
>>>>>>         return _mupdf.FzOutput2_use_virtual_reset(self, use)
       
    1:     def use_virtual_as_stream(self, use=True):
>>>>>>         return _mupdf.FzOutput2_use_virtual_as_stream(self, use)
       
    1:     def use_virtual_truncate(self, use=True):
>>>>>>         return _mupdf.FzOutput2_use_virtual_truncate(self, use)
       
    1:     def write(self, arg_0, arg_2, arg_3):
               r"""Default virtual method implementations; these all throw an exception."""
>>>>>>         return _mupdf.FzOutput2_write(self, arg_0, arg_2, arg_3)
       
    1:     def seek(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.FzOutput2_seek(self, arg_0, arg_2, arg_3)
       
    1:     def tell(self, arg_0):
>>>>>>         return _mupdf.FzOutput2_tell(self, arg_0)
       
    1:     def close(self, arg_0):
>>>>>>         return _mupdf.FzOutput2_close(self, arg_0)
       
    1:     def drop(self, arg_0):
>>>>>>         return _mupdf.FzOutput2_drop(self, arg_0)
       
    1:     def reset(self, arg_0):
>>>>>>         return _mupdf.FzOutput2_reset(self, arg_0)
       
    1:     def as_stream(self, arg_0):
>>>>>>         return _mupdf.FzOutput2_as_stream(self, arg_0)
       
    1:     def truncate(self, arg_0):
>>>>>>         return _mupdf.FzOutput2_truncate(self, arg_0)
    1:     def __disown__(self):
>>>>>>         self.this.disown()
>>>>>>         _mupdf.disown_FzOutput2(self)
>>>>>>         return weakref.proxy(self)
       
       # Register FzOutput2 in _mupdf:
    1: _mupdf.FzOutput2_swigregister(FzOutput2)
    2: class FzOverprint(object):
    1:     r"""
           Wrapper class for struct `fz_overprint`. Not copyable or assignable.
           Pixmaps represent a set of pixels for a 2 dimensional region of
           a plane. Each pixel has n components per pixel. The components
           are in the order process-components, spot-colors, alpha, where
           there can be 0 of any of those types. The data is in
           premultiplied alpha when rendering, but non-premultiplied for
           colorspace conversions and rescaling.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_overprint`.
               """
>>>>>>         _mupdf.FzOverprint_swiginit(self, _mupdf.new_FzOverprint(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzOverprint
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzOverprint_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzOverprint___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzOverprint_m_internal_get, _mupdf.FzOverprint_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzOverprint_s_num_instances_get, _mupdf.FzOverprint_s_num_instances_set)
       
       # Register FzOverprint in _mupdf:
    1: _mupdf.FzOverprint_swigregister(FzOverprint)
    2: class FzPage(object):
    1:     r"""Wrapper class for struct `fz_page`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_bound_page(self):
               r"""
               Class-aware wrapper for `::fz_bound_page()`.
                       Determine the size of a page at 72 dpi.
               """
>>>>>>         return _mupdf.FzPage_fz_bound_page(self)
       
    1:     def fz_bound_page_box(self, box):
               r"""Class-aware wrapper for `::fz_bound_page_box()`."""
>>>>>>         return _mupdf.FzPage_fz_bound_page_box(self, box)
       
    1:     def fz_create_link(self, bbox, uri):
               r"""
               Class-aware wrapper for `::fz_create_link()`.
                       Create a new link on a page.
               """
>>>>>>         return _mupdf.FzPage_fz_create_link(self, bbox, uri)
       
    1:     def fz_delete_link(self, link):
               r"""
               Class-aware wrapper for `::fz_delete_link()`.
                       Delete an existing link on a page.
               """
>>>>>>         return _mupdf.FzPage_fz_delete_link(self, link)
       
    1:     def fz_load_links(self):
               r"""
               Class-aware wrapper for `::fz_load_links()`.
                       Load the list of links for a page.
       
                       Returns a linked list of all the links on the page, each with
                       its clickable region and link destination. Each link is
                       reference counted so drop and free the list of links by
                       calling fz_drop_link on the pointer return from fz_load_links.
       
                       page: Page obtained from fz_load_page.
               """
>>>>>>         return _mupdf.FzPage_fz_load_links(self)
       
    1:     def fz_new_buffer_from_page(self, options):
               r"""Class-aware wrapper for `::fz_new_buffer_from_page()`."""
>>>>>>         return _mupdf.FzPage_fz_new_buffer_from_page(self, options)
       
    1:     def fz_new_buffer_from_page_with_format(self, format, options, transform, cookie):
               r"""
               Class-aware wrapper for `::fz_new_buffer_from_page_with_format()`.
                       Returns an fz_buffer containing a page after conversion to specified format.
       
                       page: The page to convert.
                       format, options: Passed to fz_new_document_writer_with_output() internally.
                       transform, cookie: Passed to fz_run_page() internally.
               """
>>>>>>         return _mupdf.FzPage_fz_new_buffer_from_page_with_format(self, format, options, transform, cookie)
       
    1:     def fz_new_display_list_from_page(self):
               r"""
               Class-aware wrapper for `::fz_new_display_list_from_page()`.
                       Create a display list.
       
                       Ownership of the display list is returned to the caller.
               """
>>>>>>         return _mupdf.FzPage_fz_new_display_list_from_page(self)
       
    1:     def fz_new_display_list_from_page_contents(self):
               r"""
               Class-aware wrapper for `::fz_new_display_list_from_page_contents()`.
                       Create a display list from page contents (no annotations).
       
                       Ownership of the display list is returned to the caller.
               """
>>>>>>         return _mupdf.FzPage_fz_new_display_list_from_page_contents(self)
       
    1:     def fz_new_pixmap_from_page(self, ctm, cs, alpha):
               r"""Class-aware wrapper for `::fz_new_pixmap_from_page()`."""
>>>>>>         return _mupdf.FzPage_fz_new_pixmap_from_page(self, ctm, cs, alpha)
       
    1:     def fz_new_pixmap_from_page_contents(self, ctm, cs, alpha):
               r"""
               Class-aware wrapper for `::fz_new_pixmap_from_page_contents()`.
                       Render the page contents without annotations.
       
                       Ownership of the pixmap is returned to the caller.
               """
>>>>>>         return _mupdf.FzPage_fz_new_pixmap_from_page_contents(self, ctm, cs, alpha)
       
    1:     def fz_new_pixmap_from_page_contents_with_separations(self, ctm, cs, seps, alpha):
               r"""Class-aware wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`."""
>>>>>>         return _mupdf.FzPage_fz_new_pixmap_from_page_contents_with_separations(self, ctm, cs, seps, alpha)
       
    1:     def fz_new_pixmap_from_page_with_separations(self, ctm, cs, seps, alpha):
               r"""Class-aware wrapper for `::fz_new_pixmap_from_page_with_separations()`."""
>>>>>>         return _mupdf.FzPage_fz_new_pixmap_from_page_with_separations(self, ctm, cs, seps, alpha)
       
    1:     def fz_page_label(self, buf, size):
               r"""
               Class-aware wrapper for `::fz_page_label()`.
                       Get page label for a given page.
               """
>>>>>>         return _mupdf.FzPage_fz_page_label(self, buf, size)
       
    1:     def fz_page_presentation(self, transition, duration):
               r"""
               Class-aware wrapper for `::fz_page_presentation()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_page_presentation(::fz_transition *transition)` => `(fz_transition *, float duration)`
       
                       Get the presentation details for a given page.
       
                       transition: A pointer to a transition struct to fill out.
       
                       duration: A pointer to a place to set the page duration in
                       seconds. Will be set to 0 if no transition is specified for the
                       page.
       
                       Returns: a pointer to the transition structure, or NULL if there
                       is no transition specified for the page.
               """
>>>>>>         return _mupdf.FzPage_fz_page_presentation(self, transition, duration)
       
    1:     def fz_page_separations(self):
               r"""
               Class-aware wrapper for `::fz_page_separations()`.
                       Get the separations details for a page.
                       This will be NULL, unless the format specifically supports
                       separations (such as PDF files). May be NULL even
                       so, if there are no separations on a page.
       
                       Returns a reference that must be dropped.
               """
>>>>>>         return _mupdf.FzPage_fz_page_separations(self)
       
    1:     def fz_page_uses_overprint(self):
               r"""
               Class-aware wrapper for `::fz_page_uses_overprint()`.
                       Query if a given page requires overprint.
               """
>>>>>>         return _mupdf.FzPage_fz_page_uses_overprint(self)
       
    1:     def fz_run_page(self, dev, transform, cookie):
               r"""
               Class-aware wrapper for `::fz_run_page()`.
                       Run a page through a device.
       
                       page: Page obtained from fz_load_page.
       
                       dev: Device obtained from fz_new_*_device.
       
                       transform: Transform to apply to page. May include for example
                       scaling and rotation, see fz_scale, fz_rotate and fz_concat.
                       Set to fz_identity if no transformation is desired.
       
                       cookie: Communication mechanism between caller and library
                       rendering the page. Intended for multi-threaded applications,
                       while single-threaded applications set cookie to NULL. The
                       caller may abort an ongoing rendering of a page. Cookie also
                       communicates progress information back to the caller. The
                       fields inside cookie are continually updated while the page is
                       rendering.
               """
>>>>>>         return _mupdf.FzPage_fz_run_page(self, dev, transform, cookie)
       
    1:     def fz_run_page_annots(self, dev, transform, cookie):
               r"""
               Class-aware wrapper for `::fz_run_page_annots()`.
                       Run the annotations on a page through a device.
               """
>>>>>>         return _mupdf.FzPage_fz_run_page_annots(self, dev, transform, cookie)
       
    1:     def fz_run_page_contents(self, dev, transform, cookie):
               r"""
               Class-aware wrapper for `::fz_run_page_contents()`.
                       Run a page through a device. Just the main
                       page content, without the annotations, if any.
       
                       page: Page obtained from fz_load_page.
       
                       dev: Device obtained from fz_new_*_device.
       
                       transform: Transform to apply to page. May include for example
                       scaling and rotation, see fz_scale, fz_rotate and fz_concat.
                       Set to fz_identity if no transformation is desired.
       
                       cookie: Communication mechanism between caller and library
                       rendering the page. Intended for multi-threaded applications,
                       while single-threaded applications set cookie to NULL. The
                       caller may abort an ongoing rendering of a page. Cookie also
                       communicates progress information back to the caller. The
                       fields inside cookie are continually updated while the page is
                       rendering.
               """
>>>>>>         return _mupdf.FzPage_fz_run_page_contents(self, dev, transform, cookie)
       
    1:     def fz_run_page_widgets(self, dev, transform, cookie):
               r"""
               Class-aware wrapper for `::fz_run_page_widgets()`.
                       Run the widgets on a page through a device.
               """
>>>>>>         return _mupdf.FzPage_fz_run_page_widgets(self, dev, transform, cookie)
       
    1:     def fz_search_page(self, needle, hit_mark, hit_bbox, hit_max):
               r"""
               Class-aware wrapper for `::fz_search_page()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_search_page(const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
       
                       Search for the 'needle' text on the page.
                       Record the hits in the hit_bbox array and return the number of
                       hits. Will stop looking once it has filled hit_max rectangles.
               """
>>>>>>         return _mupdf.FzPage_fz_search_page(self, needle, hit_mark, hit_bbox, hit_max)
       
    1:     def fz_search_page_cb(self, needle, cb, opaque):
               r"""
               Class-aware wrapper for `::fz_search_page_cb()`.
                       Search for the 'needle' text on the page.
               """
>>>>>>         return _mupdf.FzPage_fz_search_page_cb(self, needle, cb, opaque)
       
    1:     def pdf_page_from_fz_page(self):
               r"""Class-aware wrapper for `::pdf_page_from_fz_page()`."""
>>>>>>         return _mupdf.FzPage_pdf_page_from_fz_page(self)
       
    1:     def doc(self):
               r"""Returns wrapper for .doc member."""
>>>>>>         return _mupdf.FzPage_doc(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_load_chapter_page()`.
                               Load a page.
       
                               After fz_load_page is it possible to retrieve the size of the
                               page using fz_bound_page, or to render the page using
                               fz_run_page_*. Free the page by calling fz_drop_page.
       
                               chapter: chapter number, 0 is the first chapter of the document.
                               number: page number, 0 is the first page of the chapter.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_load_page()`.
                               Load a given page number from a document. This may be much less
                               efficient than loading by location (chapter+page) for some
                               document types.
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_page_of_size()`.
                               Different document types will be implemented by deriving from
                               fz_page. This macro allocates such derived structures, and
                               initialises the base sections.
       
       
               |
       
               *Overload 4:*
                Return FzPage for pdfpage.m_internal.super.
       
               |
       
               *Overload 5:*
                Copy constructor using `fz_keep_page()`.
       
               |
       
               *Overload 6:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 7:*
                Constructor using raw copy of pre-existing `::fz_page`.
               """
>>>>>>         _mupdf.FzPage_swiginit(self, _mupdf.new_FzPage(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzPage
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzPage_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzPage___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzPage_m_internal_get, _mupdf.FzPage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzPage_s_num_instances_get, _mupdf.FzPage_s_num_instances_set)
       
       # Register FzPage in _mupdf:
    1: _mupdf.FzPage_swigregister(FzPage)
    2: class FzPath(object):
    1:     r"""
            Wrapper class for struct `fz_path`.
           Vector path buffer.
           It can be stroked and dashed, or be filled.
           It has a fill rule (nonzero or even_odd).
       
           When rendering, they are flattened, stroked and dashed straight
           into the Global Edge List.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_bound_path(self, stroke, ctm):
               r"""
               Class-aware wrapper for `::fz_bound_path()`.
                       Return a bounding rectangle for a path.
       
                       path: The path to bound.
       
                       stroke: If NULL, the bounding rectangle given is for
                       the filled path. If non-NULL the bounding rectangle
                       given is for the path stroked with the given attributes.
       
                       ctm: The matrix to apply to the path during stroking.
       
                       r: Pointer to a fz_rect which will be used to hold
                       the result.
       
                       Returns r, updated to contain the bounding rectangle.
               """
>>>>>>         return _mupdf.FzPath_fz_bound_path(self, stroke, ctm)
       
    1:     def fz_clone_path(self):
               r"""
               Class-aware wrapper for `::fz_clone_path()`.
                       Clone the data for a path.
       
                       This is used in preference to fz_keep_path when a whole
                       new copy of a path is required, rather than just a shared
                       pointer. This probably indicates that the path is about to
                       be modified.
       
                       path: path to clone.
       
                       Throws exceptions on failure to allocate.
               """
>>>>>>         return _mupdf.FzPath_fz_clone_path(self)
       
    1:     def fz_closepath(self):
               r"""
               Class-aware wrapper for `::fz_closepath()`.
                       Close the current subpath.
       
                       path: The path to modify.
       
                       Throws exceptions on failure to allocate, attempting to modify
                       a packed path, and illegal path closes (i.e. closing a non open
                       path).
               """
>>>>>>         return _mupdf.FzPath_fz_closepath(self)
       
    1:     def fz_currentpoint(self):
               r"""
               Class-aware wrapper for `::fz_currentpoint()`.
                       Return the current point that a path has
                       reached or (0,0) if empty.
       
                       path: path to return the current point of.
               """
>>>>>>         return _mupdf.FzPath_fz_currentpoint(self)
       
    1:     def fz_curveto(self, x0, y0, x1, y1, x2, y2):
               r"""
               Class-aware wrapper for `::fz_curveto()`.
                       Append a 'curveto' command to an open path. (For a
                       cubic bezier).
       
                       path: The path to modify.
       
                       x0, y0: The coordinates of the first control point for the
                       curve.
       
                       x1, y1: The coordinates of the second control point for the
                       curve.
       
                       x2, y2: The end coordinates for the curve.
       
                       Throws exceptions on failure to allocate, or attempting to
                       modify a packed path.
               """
>>>>>>         return _mupdf.FzPath_fz_curveto(self, x0, y0, x1, y1, x2, y2)
       
    1:     def fz_curvetov(self, x1, y1, x2, y2):
               r"""
               Class-aware wrapper for `::fz_curvetov()`.
                       Append a 'curvetov' command to an open path. (For a
                       cubic bezier with the first control coordinate equal to
                       the start point).
       
                       path: The path to modify.
       
                       x1, y1: The coordinates of the second control point for the
                       curve.
       
                       x2, y2: The end coordinates for the curve.
       
                       Throws exceptions on failure to allocate, or attempting to
                       modify a packed path.
               """
>>>>>>         return _mupdf.FzPath_fz_curvetov(self, x1, y1, x2, y2)
       
    1:     def fz_curvetoy(self, x0, y0, x2, y2):
               r"""
               Class-aware wrapper for `::fz_curvetoy()`.
                       Append a 'curvetoy' command to an open path. (For a
                       cubic bezier with the second control coordinate equal to
                       the end point).
       
                       path: The path to modify.
       
                       x0, y0: The coordinates of the first control point for the
                       curve.
       
                       x2, y2: The end coordinates for the curve (and the second
                       control coordinate).
       
                       Throws exceptions on failure to allocate, or attempting to
                       modify a packed path.
               """
>>>>>>         return _mupdf.FzPath_fz_curvetoy(self, x0, y0, x2, y2)
       
    1:     def fz_lineto(self, x, y):
               r"""
               Class-aware wrapper for `::fz_lineto()`.
                       Append a 'lineto' command to an open path.
       
                       path: The path to modify.
       
                       x, y: The coordinate to line to.
       
                       Throws exceptions on failure to allocate, or attempting to
                       modify a packed path.
               """
>>>>>>         return _mupdf.FzPath_fz_lineto(self, x, y)
       
    1:     def fz_moveto(self, x, y):
               r"""
               Class-aware wrapper for `::fz_moveto()`.
                       Append a 'moveto' command to a path.
                       This 'opens' a path.
       
                       path: The path to modify.
       
                       x, y: The coordinate to move to.
       
                       Throws exceptions on failure to allocate, or attempting to
                       modify a packed path.
               """
>>>>>>         return _mupdf.FzPath_fz_moveto(self, x, y)
       
    1:     def fz_packed_path_size(self):
               r"""
               Class-aware wrapper for `::fz_packed_path_size()`.
                       Return the number of bytes required to pack a path.
               """
>>>>>>         return _mupdf.FzPath_fz_packed_path_size(self)
       
    1:     def fz_path_is_rect(self, ctm):
               r"""
               Class-aware wrapper for `::fz_path_is_rect()`.
                       Check whether a given path, under the given transform
                       is an axis-aligned rectangle.
       
                       We accept zero width or height rectangles, so
                       "move 100, 100; line 200, 100" would count as
                       a rectangle too.
               """
>>>>>>         return _mupdf.FzPath_fz_path_is_rect(self, ctm)
       
    1:     def fz_path_is_rect_with_bounds(self, ctm, bounds):
               r"""
               Class-aware wrapper for `::fz_path_is_rect_with_bounds()`.
                       Check whether a given path, under the given transform
                       is an axis-aligned rectangle.
       
                       We accept zero width or height rectangles, so
                       "move 100, 100; line 200, 100" would count as
                       a rectangle too.
       
                       bounds = NULL, or place to return the rectangle
                       bounds if the path is a rectangle.
               """
>>>>>>         return _mupdf.FzPath_fz_path_is_rect_with_bounds(self, ctm, bounds)
       
    1:     def fz_quadto(self, x0, y0, x1, y1):
               r"""
               Class-aware wrapper for `::fz_quadto()`.
                       Append a 'quadto' command to an open path. (For a
                       quadratic bezier).
       
                       path: The path to modify.
       
                       x0, y0: The control coordinates for the quadratic curve.
       
                       x1, y1: The end coordinates for the quadratic curve.
       
                       Throws exceptions on failure to allocate, or attempting to
                       modify a packed path.
               """
>>>>>>         return _mupdf.FzPath_fz_quadto(self, x0, y0, x1, y1)
       
    1:     def fz_rectto(self, x0, y0, x1, y1):
               r"""
               Class-aware wrapper for `::fz_rectto()`.
                       Append a 'rectto' command to an open path.
       
                       The rectangle is equivalent to:
                               moveto x0 y0
                               lineto x1 y0
                               lineto x1 y1
                               lineto x0 y1
                               closepath
       
                       path: The path to modify.
       
                       x0, y0: First corner of the rectangle.
       
                       x1, y1: Second corner of the rectangle.
       
                       Throws exceptions on failure to allocate, or attempting to
                       modify a packed path.
               """
>>>>>>         return _mupdf.FzPath_fz_rectto(self, x0, y0, x1, y1)
       
    1:     def fz_transform_path(self, transform):
               r"""
               Class-aware wrapper for `::fz_transform_path()`.
                       Transform a path by a given
                       matrix.
       
                       path: The path to modify (must not be a packed path).
       
                       transform: The transform to apply.
       
                       Throws exceptions if the path is packed, or on failure
                       to allocate.
               """
>>>>>>         return _mupdf.FzPath_fz_transform_path(self, transform)
       
    1:     def fz_trim_path(self):
               r"""
               Class-aware wrapper for `::fz_trim_path()`.
                       Minimise the internal storage used by a path.
       
                       As paths are constructed, the internal buffers
                       grow. To avoid repeated reallocations they
                       grow with some spare space. Once a path has
                       been fully constructed, this call allows the
                       excess space to be trimmed.
               """
>>>>>>         return _mupdf.FzPath_fz_trim_path(self)
       
    1:     def fz_walk_path(self, walker, arg):
               r"""
               Class-aware wrapper for `::fz_walk_path()`.
                       Walk the segments of a path, calling the
                       appropriate callback function from a given set for each
                       segment of the path.
       
                       path: The path to walk.
       
                       walker: The set of callback functions to use. The first
                       4 callback pointers in the set must be non-NULL. The
                       subsequent ones can either be supplied, or can be left
                       as NULL, in which case the top 4 functions will be
                       called as appropriate to simulate them.
       
                       arg: An opaque argument passed in to each callback.
       
                       Exceptions will only be thrown if the underlying callback
                       functions throw them.
               """
>>>>>>         return _mupdf.FzPath_fz_walk_path(self, walker, arg)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_path()`.
                               Create a new (empty) path structure.
       
       
               |
       
               *Overload 2:*
                Copy constructor using `fz_keep_path()`.
       
               |
       
               *Overload 3:*
                Constructor using raw copy of pre-existing `::fz_path`.
               """
>>>>>>         _mupdf.FzPath_swiginit(self, _mupdf.new_FzPath(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzPath
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzPath_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzPath___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzPath_m_internal_get, _mupdf.FzPath_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzPath_s_num_instances_get, _mupdf.FzPath_s_num_instances_set)
       
       # Register FzPath in _mupdf:
    1: _mupdf.FzPath_swigregister(FzPath)
    2: class FzPathWalker(object):
    1:     r"""Wrapper class for struct `fz_path_walker`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, internal=None):
               r"""Constructor using raw copy of pre-existing `::fz_path_walker`."""
>>>>>>         _mupdf.FzPathWalker_swiginit(self, _mupdf.new_FzPathWalker(internal))
    1:     __swig_destroy__ = _mupdf.delete_FzPathWalker
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzPathWalker_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzPathWalker___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzPathWalker_m_internal_get, _mupdf.FzPathWalker_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzPathWalker_s_num_instances_get, _mupdf.FzPathWalker_s_num_instances_set)
       
       # Register FzPathWalker in _mupdf:
    1: _mupdf.FzPathWalker_swigregister(FzPathWalker)
    2: class FzPathWalker2(FzPathWalker):
    1:     r"""Wrapper class for struct fz_path_walker with virtual fns for each fnptr; this is for use as a SWIG Director class."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self):
               r"""== Constructor."""
>>>>>>         if self.__class__ == FzPathWalker2:
>>>>>>             _self = None
               else:
>>>>>>             _self = self
>>>>>>         _mupdf.FzPathWalker2_swiginit(self, _mupdf.new_FzPathWalker2(_self, ))
    1:     __swig_destroy__ = _mupdf.delete_FzPathWalker2
       
    1:     def use_virtual_moveto(self, use=True):
               r"""
               These methods set the function pointers in *m_internal
               to point to internal callbacks that call our virtual methods.
               """
>>>>>>         return _mupdf.FzPathWalker2_use_virtual_moveto(self, use)
       
    1:     def use_virtual_lineto(self, use=True):
>>>>>>         return _mupdf.FzPathWalker2_use_virtual_lineto(self, use)
       
    1:     def use_virtual_curveto(self, use=True):
>>>>>>         return _mupdf.FzPathWalker2_use_virtual_curveto(self, use)
       
    1:     def use_virtual_closepath(self, use=True):
>>>>>>         return _mupdf.FzPathWalker2_use_virtual_closepath(self, use)
       
    1:     def use_virtual_quadto(self, use=True):
>>>>>>         return _mupdf.FzPathWalker2_use_virtual_quadto(self, use)
       
    1:     def use_virtual_curvetov(self, use=True):
>>>>>>         return _mupdf.FzPathWalker2_use_virtual_curvetov(self, use)
       
    1:     def use_virtual_curvetoy(self, use=True):
>>>>>>         return _mupdf.FzPathWalker2_use_virtual_curvetoy(self, use)
       
    1:     def use_virtual_rectto(self, use=True):
>>>>>>         return _mupdf.FzPathWalker2_use_virtual_rectto(self, use)
       
    1:     def moveto(self, arg_0, arg_2, arg_3):
               r"""Default virtual method implementations; these all throw an exception."""
>>>>>>         return _mupdf.FzPathWalker2_moveto(self, arg_0, arg_2, arg_3)
       
    1:     def lineto(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.FzPathWalker2_lineto(self, arg_0, arg_2, arg_3)
       
    1:     def curveto(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
>>>>>>         return _mupdf.FzPathWalker2_curveto(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)
       
    1:     def closepath(self, arg_0):
>>>>>>         return _mupdf.FzPathWalker2_closepath(self, arg_0)
       
    1:     def quadto(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.FzPathWalker2_quadto(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def curvetov(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.FzPathWalker2_curvetov(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def curvetoy(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.FzPathWalker2_curvetoy(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def rectto(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.FzPathWalker2_rectto(self, arg_0, arg_2, arg_3, arg_4, arg_5)
    1:     def __disown__(self):
>>>>>>         self.this.disown()
>>>>>>         _mupdf.disown_FzPathWalker2(self)
>>>>>>         return weakref.proxy(self)
       
       # Register FzPathWalker2 in _mupdf:
    1: _mupdf.FzPathWalker2_swigregister(FzPathWalker2)
    2: class FzPclOptions(object):
    1:     r"""
           Wrapper class for struct `fz_pcl_options`. Not copyable or assignable.
           PCL output
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_pcl_preset(self, preset):
               r"""
               Class-aware wrapper for `::fz_pcl_preset()`.
                       Initialize PCL option struct for a given preset.
       
                       Currently defined presets include:
       
                               generic Generic PCL printer
                               ljet4   HP DeskJet
                               dj500   HP DeskJet 500
                               fs600   Kyocera FS-600
                               lj      HP LaserJet, HP LaserJet Plus
                               lj2     HP LaserJet IIp, HP LaserJet IId
                               lj3     HP LaserJet III
                               lj3d    HP LaserJet IIId
                               lj4     HP LaserJet 4
                               lj4pl   HP LaserJet 4 PL
                               lj4d    HP LaserJet 4d
                               lp2563b HP 2563B line printer
                               oce9050 Oce 9050 Line printer
               """
>>>>>>         return _mupdf.FzPclOptions_fz_pcl_preset(self, preset)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_parse_pcl_options()`.
                               Parse PCL options.
       
                               Currently defined options and values are as follows:
       
                                       preset=X        Either "generic" or one of the presets as for fz_pcl_preset.
                                       spacing=0       No vertical spacing capability
                                       spacing=1       PCL 3 spacing (<ESC>*p+<n>Y)
                                       spacing=2       PCL 4 spacing (<ESC>*b<n>Y)
                                       spacing=3       PCL 5 spacing (<ESC>*b<n>Y and clear seed row)
                                       mode2           Disable/Enable mode 2 graphics compression
                                       mode3           Disable/Enable mode 3 graphics compression
                                       eog_reset       End of graphics (<ESC>*rB) resets all parameters
                                       has_duplex      Duplex supported (<ESC>&l<duplex>S)
                                       has_papersize   Papersize setting supported (<ESC>&l<sizecode>A)
                                       has_copies      Number of copies supported (<ESC>&l<copies>X)
                                       is_ljet4pjl     Disable/Enable HP 4PJL model-specific output
                                       is_oce9050      Disable/Enable Oce 9050 model-specific output
       
       
               |
       
               *Overload 2:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
                Constructor using raw copy of pre-existing `::fz_pcl_options`.
               """
>>>>>>         _mupdf.FzPclOptions_swiginit(self, _mupdf.new_FzPclOptions(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzPclOptions
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzPclOptions_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzPclOptions___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzPclOptions_m_internal_get, _mupdf.FzPclOptions_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzPclOptions_s_num_instances_get, _mupdf.FzPclOptions_s_num_instances_set)
       
       # Register FzPclOptions in _mupdf:
    1: _mupdf.FzPclOptions_swigregister(FzPclOptions)
    2: class FzPclmOptions(object):
    1:     r"""
           Wrapper class for struct `fz_pclm_options`. Not copyable or assignable.
           PCLm output
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_parse_pclm_options()`.
                               Parse PCLm options.
       
                               Currently defined options and values are as follows:
       
                                       compression=none: No compression
                                       compression=flate: Flate compression
                                       strip-height=n: Strip height (default 16)
       
       
               |
       
               *Overload 2:*
                Construct using fz_parse_pclm_options().
       
               |
       
               *Overload 3:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 4:*
                Constructor using raw copy of pre-existing `::fz_pclm_options`.
               """
>>>>>>         _mupdf.FzPclmOptions_swiginit(self, _mupdf.new_FzPclmOptions(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzPclmOptions
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzPclmOptions_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzPclmOptions___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzPclmOptions_m_internal_get, _mupdf.FzPclmOptions_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzPclmOptions_s_num_instances_get, _mupdf.FzPclmOptions_s_num_instances_set)
       
       # Register FzPclmOptions in _mupdf:
    1: _mupdf.FzPclmOptions_swigregister(FzPclmOptions)
    2: class FzPdfocrOptions(object):
    1:     r"""
           Wrapper class for struct `fz_pdfocr_options`.
           PDFOCR output
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_parse_pdfocr_options(self, args):
               r"""
               Class-aware wrapper for `::fz_parse_pdfocr_options()`.
                       Parse PDFOCR options.
       
                       Currently defined options and values are as follows:
       
                               compression=none: No compression
                               compression=flate: Flate compression
                               strip-height=n: Strip height (default 16)
                               ocr-language=<lang>: OCR Language (default eng)
                               ocr-datadir=<datadir>: OCR data path (default rely on TESSDATA_PREFIX)
               """
>>>>>>         return _mupdf.FzPdfocrOptions_fz_parse_pdfocr_options(self, args)
       
    1:     def language_set2(self, language):
               r"""Copies <language> into this->language, truncating if necessary."""
>>>>>>         return _mupdf.FzPdfocrOptions_language_set2(self, language)
       
    1:     def datadir_set2(self, datadir):
               r"""Copies <datadir> into this->datadir, truncating if necessary."""
>>>>>>         return _mupdf.FzPdfocrOptions_datadir_set2(self, datadir)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_pdfocr_options`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_pdfocr_options`.
               """
>>>>>>         _mupdf.FzPdfocrOptions_swiginit(self, _mupdf.new_FzPdfocrOptions(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.FzPdfocrOptions_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_FzPdfocrOptions
    1:     compress = property(_mupdf.FzPdfocrOptions_compress_get, _mupdf.FzPdfocrOptions_compress_set)
    1:     strip_height = property(_mupdf.FzPdfocrOptions_strip_height_get, _mupdf.FzPdfocrOptions_strip_height_set)
    1:     language = property(_mupdf.FzPdfocrOptions_language_get, _mupdf.FzPdfocrOptions_language_set)
    1:     datadir = property(_mupdf.FzPdfocrOptions_datadir_get, _mupdf.FzPdfocrOptions_datadir_set)
    1:     skew_correct = property(_mupdf.FzPdfocrOptions_skew_correct_get, _mupdf.FzPdfocrOptions_skew_correct_set)
    1:     skew_angle = property(_mupdf.FzPdfocrOptions_skew_angle_get, _mupdf.FzPdfocrOptions_skew_angle_set)
    1:     skew_border = property(_mupdf.FzPdfocrOptions_skew_border_get, _mupdf.FzPdfocrOptions_skew_border_set)
    1:     page_count = property(_mupdf.FzPdfocrOptions_page_count_get, _mupdf.FzPdfocrOptions_page_count_set)
    1:     s_num_instances = property(_mupdf.FzPdfocrOptions_s_num_instances_get, _mupdf.FzPdfocrOptions_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzPdfocrOptions_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzPdfocrOptions___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzPdfocrOptions___ne__(self, rhs)
       
       # Register FzPdfocrOptions in _mupdf:
    1: _mupdf.FzPdfocrOptions_swigregister(FzPdfocrOptions)
    2: class FzPixmap(object):
    1:     r"""
           Wrapper class for struct `fz_pixmap`.
           Pixmaps represent a set of pixels for a 2 dimensional region of
           a plane. Each pixel has n components per pixel. The components
           are in the order process-components, spot-colors, alpha, where
           there can be 0 of any of those types. The data is in
           premultiplied alpha when rendering, but non-premultiplied for
           colorspace conversions and rescaling.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    2:     @staticmethod
    2:     def pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box):
               r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_with_usage()`."""
>>>>>>         return _mupdf.FzPixmap_pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box)
       
    2:     @staticmethod
    2:     def pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
               r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`."""
>>>>>>         return _mupdf.FzPixmap_pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)
       
    2:     @staticmethod
    2:     def fz_new_pixmap_from_page_contents(page, ctm, cs, alpha):
               r"""
               Class-aware wrapper for `::fz_new_pixmap_from_page_contents()`.
                       Render the page contents without annotations.
       
                       Ownership of the pixmap is returned to the caller.
               """
>>>>>>         return _mupdf.FzPixmap_fz_new_pixmap_from_page_contents(page, ctm, cs, alpha)
       
    2:     @staticmethod
    2:     def fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha):
               r"""Class-aware wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`."""
>>>>>>         return _mupdf.FzPixmap_fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha)
       
    1:     def fz_alpha_from_gray(self):
               r"""Class-aware wrapper for `::fz_alpha_from_gray()`."""
>>>>>>         return _mupdf.FzPixmap_fz_alpha_from_gray(self)
       
    1:     def fz_autowarp_pixmap(self, points):
               r"""Class-aware wrapper for `::fz_autowarp_pixmap()`."""
>>>>>>         return _mupdf.FzPixmap_fz_autowarp_pixmap(self, points)
       
    1:     def fz_clear_pixmap(self):
               r"""
               Class-aware wrapper for `::fz_clear_pixmap()`.
                       Sets all components (including alpha) of
                       all pixels in a pixmap to 0.
       
                       pix: The pixmap to clear.
               """
>>>>>>         return _mupdf.FzPixmap_fz_clear_pixmap(self)
       
    1:     def fz_clear_pixmap_rect_with_value(self, value, r):
               r"""
               Class-aware wrapper for `::fz_clear_pixmap_rect_with_value()`.
                       Clears a subrect of a pixmap with the given value.
       
                       pix: The pixmap to clear.
       
                       value: Values in the range 0 to 255 are valid. Each component
                       sample for each pixel in the pixmap will be set to this value,
                       while alpha will always be set to 255 (non-transparent).
       
                       r: the rectangle.
               """
>>>>>>         return _mupdf.FzPixmap_fz_clear_pixmap_rect_with_value(self, value, r)
       
    1:     def fz_clear_pixmap_with_value(self, value):
               r"""
               Class-aware wrapper for `::fz_clear_pixmap_with_value()`.
                       Clears a pixmap with the given value.
       
                       pix: The pixmap to clear.
       
                       value: Values in the range 0 to 255 are valid. Each component
                       sample for each pixel in the pixmap will be set to this value,
                       while alpha will always be set to 255 (non-transparent).
       
                       This function is horrible, and should be removed from the
                       API and replaced with a less magic one.
               """
>>>>>>         return _mupdf.FzPixmap_fz_clear_pixmap_with_value(self, value)
       
    1:     def fz_clone_pixmap(self):
               r"""
               Class-aware wrapper for `::fz_clone_pixmap()`.
                       Clone a pixmap, copying the pixels and associated data to new
                       storage.
       
                       The reference count of 'old' is unchanged.
               """
>>>>>>         return _mupdf.FzPixmap_fz_clone_pixmap(self)
       
    1:     def fz_clone_pixmap_area_with_different_seps(self, bbox, dcs, seps, color_params, default_cs):
               r"""Class-aware wrapper for `::fz_clone_pixmap_area_with_different_seps()`."""
>>>>>>         return _mupdf.FzPixmap_fz_clone_pixmap_area_with_different_seps(self, bbox, dcs, seps, color_params, default_cs)
       
    1:     def fz_convert_indexed_pixmap_to_base(self):
               r"""
               Class-aware wrapper for `::fz_convert_indexed_pixmap_to_base()`.
                       Convert pixmap from indexed to base colorspace.
       
                       This creates a new bitmap containing the converted pixmap data.
               """
>>>>>>         return _mupdf.FzPixmap_fz_convert_indexed_pixmap_to_base(self)
       
    1:     def fz_convert_pixmap(self, cs_des, prf, default_cs, color_params, keep_alpha):
               r"""
               Class-aware wrapper for `::fz_convert_pixmap()`.
                       Convert an existing pixmap to a desired
                       colorspace. Other properties of the pixmap, such as resolution
                       and position are copied to the converted pixmap.
       
                       pix: The pixmap to convert.
       
                       default_cs: If NULL pix->colorspace is used. It is possible that
                       the data may need to be interpreted as one of the color spaces
                       in default_cs.
       
                       cs_des: Desired colorspace, may be NULL to denote alpha-only.
       
                       prf: Proofing color space through which we need to convert.
       
                       color_params: Parameters that may be used in conversion (e.g.
                       ri).
       
                       keep_alpha: If 0 any alpha component is removed, otherwise
                       alpha is kept if present in the pixmap.
               """
>>>>>>         return _mupdf.FzPixmap_fz_convert_pixmap(self, cs_des, prf, default_cs, color_params, keep_alpha)
       
    1:     def fz_convert_separation_pixmap_to_base(self):
               r"""
               Class-aware wrapper for `::fz_convert_separation_pixmap_to_base()`.
                       Convert pixmap from DeviceN/Separation to base colorspace.
       
                       This creates a new bitmap containing the converted pixmap data.
               """
>>>>>>         return _mupdf.FzPixmap_fz_convert_separation_pixmap_to_base(self)
       
    1:     def fz_copy_pixmap_rect(self, src, r, default_cs):
               r"""Class-aware wrapper for `::fz_copy_pixmap_rect()`."""
>>>>>>         return _mupdf.FzPixmap_fz_copy_pixmap_rect(self, src, r, default_cs)
       
    1:     def fz_decode_tile(self, decode):
               r"""Class-aware wrapper for `::fz_decode_tile()`."""
>>>>>>         return _mupdf.FzPixmap_fz_decode_tile(self, decode)
       
    1:     def fz_deskew_pixmap(self, degrees, border):
               r"""Class-aware wrapper for `::fz_deskew_pixmap()`."""
>>>>>>         return _mupdf.FzPixmap_fz_deskew_pixmap(self, degrees, border)
       
    1:     def fz_detect_skew(self):
               r"""Class-aware wrapper for `::fz_detect_skew()`."""
>>>>>>         return _mupdf.FzPixmap_fz_detect_skew(self)
       
    1:     def fz_fill_pixmap_with_color(self, colorspace, color, color_params):
               r"""
               Class-aware wrapper for `::fz_fill_pixmap_with_color()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_fill_pixmap_with_color(::fz_colorspace *colorspace, ::fz_color_params color_params)` => float color
       
                       Fill pixmap with solid color.
               """
>>>>>>         return _mupdf.FzPixmap_fz_fill_pixmap_with_color(self, colorspace, color, color_params)
       
    1:     def fz_gamma_pixmap(self, gamma):
               r"""
               Class-aware wrapper for `::fz_gamma_pixmap()`.
                       Apply gamma correction to a pixmap. All components
                       of all pixels are modified (except alpha, which is unchanged).
       
                       gamma: The gamma value to apply; 1.0 for no change.
               """
>>>>>>         return _mupdf.FzPixmap_fz_gamma_pixmap(self, gamma)
       
    1:     def fz_generate_transition(self, opix, npix, time, trans):
               r"""
               Class-aware wrapper for `::fz_generate_transition()`.
                       Generate a frame of a transition.
       
                       tpix: Target pixmap
                       opix: Old pixmap
                       npix: New pixmap
                       time: Position within the transition (0 to 256)
                       trans: Transition details
       
                       Returns 1 if successfully generated a frame.
       
                       Note: Pixmaps must include alpha.
               """
>>>>>>         return _mupdf.FzPixmap_fz_generate_transition(self, opix, npix, time, trans)
       
    1:     def fz_invert_pixmap(self):
               r"""
               Class-aware wrapper for `::fz_invert_pixmap()`.
                       Invert all the pixels in a pixmap. All components (process and
                       spots) of all pixels are inverted (except alpha, which is
                       unchanged).
               """
>>>>>>         return _mupdf.FzPixmap_fz_invert_pixmap(self)
       
    1:     def fz_invert_pixmap_alpha(self):
               r"""
               Class-aware wrapper for `::fz_invert_pixmap_alpha()`.
                       Invert the alpha of all the pixels in a pixmap.
               """
>>>>>>         return _mupdf.FzPixmap_fz_invert_pixmap_alpha(self)
       
    1:     def fz_invert_pixmap_luminance(self):
               r"""
               Class-aware wrapper for `::fz_invert_pixmap_luminance()`.
                       Transform the pixels in a pixmap so that luminance of each
                       pixel is inverted, and the chrominance remains unchanged (as
                       much as accuracy allows).
       
                       All components of all pixels are inverted (except alpha, which
                       is unchanged). Only supports Grey and RGB bitmaps.
               """
>>>>>>         return _mupdf.FzPixmap_fz_invert_pixmap_luminance(self)
       
    1:     def fz_invert_pixmap_raw(self):
               r"""
               Class-aware wrapper for `::fz_invert_pixmap_raw()`.
                       Invert all the pixels in a non-premultiplied pixmap in a
                       very naive manner.
               """
>>>>>>         return _mupdf.FzPixmap_fz_invert_pixmap_raw(self)
       
    1:     def fz_invert_pixmap_rect(self, rect):
               r"""
               Class-aware wrapper for `::fz_invert_pixmap_rect()`.
                       Invert all the pixels in a given rectangle of a (premultiplied)
                       pixmap. All components of all pixels in the rectangle are
                       inverted (except alpha, which is unchanged).
               """
>>>>>>         return _mupdf.FzPixmap_fz_invert_pixmap_rect(self, rect)
       
    1:     def fz_is_pixmap_monochrome(self):
               r"""
               Class-aware wrapper for `::fz_is_pixmap_monochrome()`.
                       Check if the pixmap is a 1-channel image containing samples with
                       only values 0 and 255
               """
>>>>>>         return _mupdf.FzPixmap_fz_is_pixmap_monochrome(self)
       
    1:     def fz_md5_pixmap(self, digest):
               r"""Class-aware wrapper for `::fz_md5_pixmap()`."""
>>>>>>         return _mupdf.FzPixmap_fz_md5_pixmap(self, digest)
       
    1:     def fz_md5_pixmap2(self):
               r"""
               Class-aware wrapper for `::fz_md5_pixmap2()`.
               C++ alternative to `fz_md5_pixmap()` that returns the digest by value.
               """
>>>>>>         return _mupdf.FzPixmap_fz_md5_pixmap2(self)
       
    1:     def fz_new_bitmap_from_pixmap(self, ht):
               r"""
               Class-aware wrapper for `::fz_new_bitmap_from_pixmap()`.
                       Make a bitmap from a pixmap and a halftone.
       
                       pix: The pixmap to generate from. Currently must be a single
                       color component with no alpha.
       
                       ht: The halftone to use. NULL implies the default halftone.
       
                       Returns the resultant bitmap. Throws exceptions in the case of
                       failure to allocate.
               """
>>>>>>         return _mupdf.FzPixmap_fz_new_bitmap_from_pixmap(self, ht)
       
    1:     def fz_new_bitmap_from_pixmap_band(self, ht, band_start):
               r"""
               Class-aware wrapper for `::fz_new_bitmap_from_pixmap_band()`.
                       Make a bitmap from a pixmap and a
                       halftone, allowing for the position of the pixmap within an
                       overall banded rendering.
       
                       pix: The pixmap to generate from. Currently must be a single
                       color component with no alpha.
       
                       ht: The halftone to use. NULL implies the default halftone.
       
                       band_start: Vertical offset within the overall banded rendering
                       (in pixels)
       
                       Returns the resultant bitmap. Throws exceptions in the case of
                       failure to allocate.
               """
>>>>>>         return _mupdf.FzPixmap_fz_new_bitmap_from_pixmap_band(self, ht, band_start)
       
    1:     def fz_new_buffer_from_pixmap_as_jpeg(self, color_params, quality, invert_cmyk):
               r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpeg()`."""
>>>>>>         return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_jpeg(self, color_params, quality, invert_cmyk)
       
    1:     def fz_new_buffer_from_pixmap_as_jpx(self, color_params, quality):
               r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpx()`."""
>>>>>>         return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_jpx(self, color_params, quality)
       
    1:     def fz_new_buffer_from_pixmap_as_pam(self, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pam()`."""
>>>>>>         return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_pam(self, color_params)
       
    1:     def fz_new_buffer_from_pixmap_as_pbm(self, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pbm()`."""
>>>>>>         return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_pbm(self, color_params)
       
    1:     def fz_new_buffer_from_pixmap_as_pkm(self, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pkm()`."""
>>>>>>         return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_pkm(self, color_params)
       
    1:     def fz_new_buffer_from_pixmap_as_png(self, color_params):
               r"""
               Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_png()`.
                       Re-encode a given pixmap as a PNG into a buffer.
       
                       Ownership of the buffer is returned.
               """
>>>>>>         return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_png(self, color_params)
       
    1:     def fz_new_buffer_from_pixmap_as_pnm(self, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`."""
>>>>>>         return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_pnm(self, color_params)
       
    1:     def fz_new_buffer_from_pixmap_as_psd(self, color_params):
               r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_psd()`."""
>>>>>>         return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_psd(self, color_params)
       
    1:     def fz_new_image_from_pixmap(self, mask):
               r"""
               Class-aware wrapper for `::fz_new_image_from_pixmap()`.
                       Create an image from the given
                       pixmap.
       
                       pixmap: The pixmap to base the image upon. A new reference
                       to this is taken.
       
                       mask: NULL, or another image to use as a mask for this one.
                       A new reference is taken to this image. Supplying a masked
                       image as a mask to another image is illegal!
               """
>>>>>>         return _mupdf.FzPixmap_fz_new_image_from_pixmap(self, mask)
       
    1:     def fz_new_pixmap_from_alpha_channel(self):
               r"""Class-aware wrapper for `::fz_new_pixmap_from_alpha_channel()`."""
>>>>>>         return _mupdf.FzPixmap_fz_new_pixmap_from_alpha_channel(self)
       
    1:     def fz_new_pixmap_from_color_and_mask(self, mask):
               r"""Class-aware wrapper for `::fz_new_pixmap_from_color_and_mask()`."""
>>>>>>         return _mupdf.FzPixmap_fz_new_pixmap_from_color_and_mask(self, mask)
       
    1:     def fz_new_pixmap_from_pixmap(self, rect):
               r"""
               Class-aware wrapper for `::fz_new_pixmap_from_pixmap()`.
                       Create a new pixmap that represents a subarea of the specified
                       pixmap. A reference is taken to this pixmap that will be dropped
                       on destruction.
       
                       The supplied rectangle must be wholly contained within the
                       original pixmap.
       
                       Returns a pointer to the new pixmap. Throws exception on failure
                       to allocate.
               """
>>>>>>         return _mupdf.FzPixmap_fz_new_pixmap_from_pixmap(self, rect)
       
    1:     def fz_pixmap_alpha(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_alpha()`.
                       Return the number of alpha planes in a pixmap.
       
                       Returns the number of alphas. Does not throw exceptions.
               """
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_alpha(self)
       
    1:     def fz_pixmap_bbox(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_bbox()`.
                       Return the bounding box for a pixmap.
               """
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_bbox(self)
       
    1:     def fz_pixmap_colorants(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_colorants()`.
                       Return the number of colorants in a pixmap.
       
                       Returns the number of colorants (components, less any spots and
                       alpha).
               """
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_colorants(self)
       
    1:     def fz_pixmap_colorspace(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_colorspace()`.
                       Return the colorspace of a pixmap
       
                       Returns colorspace.
               """
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_colorspace(self)
       
    1:     def fz_pixmap_components(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_components()`.
                       Return the number of components in a pixmap.
       
                       Returns the number of components (including spots and alpha).
               """
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_components(self)
       
    1:     def fz_pixmap_height(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_height()`.
                       Return the height of the pixmap in pixels.
               """
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_height(self)
       
    1:     def fz_pixmap_samples(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_samples()`.
                       Returns a pointer to the pixel data of a pixmap.
       
                       Returns the pointer.
               """
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_samples(self)
       
    1:     def fz_pixmap_samples_int(self):
               r"""Class-aware wrapper for `::fz_pixmap_samples_int()`."""
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_samples_int(self)
       
    1:     def fz_pixmap_size(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_size()`.
                       Return sizeof fz_pixmap plus size of data, in bytes.
               """
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_size(self)
       
    1:     def fz_pixmap_spots(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_spots()`.
                       Return the number of spots in a pixmap.
       
                       Returns the number of spots (components, less colorants and
                       alpha). Does not throw exceptions.
               """
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_spots(self)
       
    1:     def fz_pixmap_stride(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_stride()`.
                       Return the number of bytes in a row in the pixmap.
               """
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_stride(self)
       
    1:     def fz_pixmap_width(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_width()`.
                       Return the width of the pixmap in pixels.
               """
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_width(self)
       
    1:     def fz_pixmap_x(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_x()`.
                       Return the x value of the pixmap in pixels.
               """
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_x(self)
       
    1:     def fz_pixmap_y(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_y()`.
                       Return the y value of the pixmap in pixels.
               """
>>>>>>         return _mupdf.FzPixmap_fz_pixmap_y(self)
       
    1:     def fz_samples_get(self, offset):
               r"""
               Class-aware wrapper for `::fz_samples_get()`.
               Provides simple (but slow) access to pixmap data from Python and C#.
               """
>>>>>>         return _mupdf.FzPixmap_fz_samples_get(self, offset)
       
    1:     def fz_samples_set(self, offset, value):
               r"""
               Class-aware wrapper for `::fz_samples_set()`.
               Provides simple (but slow) write access to pixmap data from Python and
               C#.
               """
>>>>>>         return _mupdf.FzPixmap_fz_samples_set(self, offset, value)
       
    1:     def fz_save_pixmap_as_jpeg(self, filename, quality):
               r"""
               Class-aware wrapper for `::fz_save_pixmap_as_jpeg()`.
                       Save a pixmap as a JPEG.
               """
>>>>>>         return _mupdf.FzPixmap_fz_save_pixmap_as_jpeg(self, filename, quality)
       
    1:     def fz_save_pixmap_as_jpx(self, filename, q):
               r"""
               Class-aware wrapper for `::fz_save_pixmap_as_jpx()`.
                       Save pixmap data as JP2K with no subsampling.
       
                       quality = 100 = lossless
                       otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
               """
>>>>>>         return _mupdf.FzPixmap_fz_save_pixmap_as_jpx(self, filename, q)
       
    1:     def fz_save_pixmap_as_pam(self, filename):
               r"""
               Class-aware wrapper for `::fz_save_pixmap_as_pam()`.
                       Save a pixmap as a pnm (greyscale, rgb or cmyk, with or without
                       alpha).
               """
>>>>>>         return _mupdf.FzPixmap_fz_save_pixmap_as_pam(self, filename)
       
    1:     def fz_save_pixmap_as_pbm(self, filename):
               r"""
               Class-aware wrapper for `::fz_save_pixmap_as_pbm()`.
                       Save a pixmap as a pbm. (Performing halftoning).
               """
>>>>>>         return _mupdf.FzPixmap_fz_save_pixmap_as_pbm(self, filename)
       
    1:     def fz_save_pixmap_as_pcl(self, filename, append, pcl):
               r"""
               Class-aware wrapper for `::fz_save_pixmap_as_pcl()`.
                       Save an (RGB) pixmap as color PCL.
               """
>>>>>>         return _mupdf.FzPixmap_fz_save_pixmap_as_pcl(self, filename, append, pcl)
       
    1:     def fz_save_pixmap_as_pclm(self, filename, append, options):
               r"""
               Class-aware wrapper for `::fz_save_pixmap_as_pclm()`.
                       Save a (Greyscale or RGB) pixmap as pclm.
               """
>>>>>>         return _mupdf.FzPixmap_fz_save_pixmap_as_pclm(self, filename, append, options)
       
    1:     def fz_save_pixmap_as_pdfocr(self, filename, append, options):
               r"""
               Class-aware wrapper for `::fz_save_pixmap_as_pdfocr()`.
                       Save a (Greyscale or RGB) pixmap as pdfocr.
               """
>>>>>>         return _mupdf.FzPixmap_fz_save_pixmap_as_pdfocr(self, filename, append, options)
       
    1:     def fz_save_pixmap_as_pkm(self, filename):
               r"""
               Class-aware wrapper for `::fz_save_pixmap_as_pkm()`.
                       Save a CMYK pixmap as a pkm. (Performing halftoning).
               """
>>>>>>         return _mupdf.FzPixmap_fz_save_pixmap_as_pkm(self, filename)
       
    1:     def fz_save_pixmap_as_png(self, filename):
               r"""
               Class-aware wrapper for `::fz_save_pixmap_as_png()`.
                       Save a (Greyscale or RGB) pixmap as a png.
               """
>>>>>>         return _mupdf.FzPixmap_fz_save_pixmap_as_png(self, filename)
       
    1:     def fz_save_pixmap_as_pnm(self, filename):
               r"""
               Class-aware wrapper for `::fz_save_pixmap_as_pnm()`.
                       Save a pixmap as a pnm (greyscale or rgb, no alpha).
               """
>>>>>>         return _mupdf.FzPixmap_fz_save_pixmap_as_pnm(self, filename)
       
    1:     def fz_save_pixmap_as_ps(self, filename, append):
               r"""
               Class-aware wrapper for `::fz_save_pixmap_as_ps()`.
                       Save a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
               """
>>>>>>         return _mupdf.FzPixmap_fz_save_pixmap_as_ps(self, filename, append)
       
    1:     def fz_save_pixmap_as_psd(self, filename):
               r"""
               Class-aware wrapper for `::fz_save_pixmap_as_psd()`.
                       Save a pixmap as a PSD file.
               """
>>>>>>         return _mupdf.FzPixmap_fz_save_pixmap_as_psd(self, filename)
       
    1:     def fz_save_pixmap_as_pwg(self, filename, append, pwg):
               r"""
               Class-aware wrapper for `::fz_save_pixmap_as_pwg()`.
                       Save a pixmap as a PWG.
               """
>>>>>>         return _mupdf.FzPixmap_fz_save_pixmap_as_pwg(self, filename, append, pwg)
       
    1:     def fz_scale_pixmap(self, x, y, w, h, clip):
               r"""Class-aware wrapper for `::fz_scale_pixmap()`."""
>>>>>>         return _mupdf.FzPixmap_fz_scale_pixmap(self, x, y, w, h, clip)
       
    1:     def fz_set_pixmap_resolution(self, xres, yres):
               r"""
               Class-aware wrapper for `::fz_set_pixmap_resolution()`.
                       Set the pixels per inch resolution of the pixmap.
               """
>>>>>>         return _mupdf.FzPixmap_fz_set_pixmap_resolution(self, xres, yres)
       
    1:     def fz_subsample_pixmap(self, factor):
               r"""Class-aware wrapper for `::fz_subsample_pixmap()`."""
>>>>>>         return _mupdf.FzPixmap_fz_subsample_pixmap(self, factor)
       
    1:     def fz_tint_pixmap(self, black, white):
               r"""
               Class-aware wrapper for `::fz_tint_pixmap()`.
                       Tint all the pixels in an RGB, BGR, or Gray pixmap.
       
                       black: Map black to this hexadecimal RGB color.
       
                       white: Map white to this hexadecimal RGB color.
               """
>>>>>>         return _mupdf.FzPixmap_fz_tint_pixmap(self, black, white)
       
    1:     def fz_warp_pixmap(self, points, width, height):
               r"""Class-aware wrapper for `::fz_warp_pixmap()`."""
>>>>>>         return _mupdf.FzPixmap_fz_warp_pixmap(self, points, width, height)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_barcode_pixmap()`.
                               Create an fz_pixmap from a barcode definition.
       
                               type: The type of barcode to create.
                               value: The value of the barcode.
                               size: The size of the barcode.
                               ec_level: error correction level 0-8.
                               quiet: whether to include quiet zones (0 or 1).
                               hrt: whether to include human readable text below the barcode (0 or 1).
       
                               returns a created fz_pixmap.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_pixmap()`.
                               Create a new pixmap, with its origin at (0,0)
       
                               cs: The colorspace to use for the pixmap, or NULL for an alpha
                               plane/mask.
       
                               w: The width of the pixmap (in pixels)
       
                               h: The height of the pixmap (in pixels)
       
                               seps: Details of separations.
       
                               alpha: 0 for no alpha, 1 for alpha.
       
                               Returns a pointer to the new pixmap. Throws exception on failure
                               to allocate.
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_pixmap_from_color_and_mask()`.
       
               |
       
               *Overload 4:*
                Constructor using `fz_new_pixmap_from_display_list()`.
                               Render the page to a pixmap using the transform and colorspace.
       
                               Ownership of the pixmap is returned to the caller.
       
       
               |
       
               *Overload 5:*
                Constructor using `fz_new_pixmap_from_display_list_with_separations()`.
                               Render the page contents with control over spot colors.
       
                               Ownership of the pixmap is returned to the caller.
       
       
               |
       
               *Overload 6:*
                Constructor using `fz_new_pixmap_from_page()`.
       
               |
       
               *Overload 7:*
                Constructor using `fz_new_pixmap_from_page_number()`.
       
               |
       
               *Overload 8:*
                Constructor using `fz_new_pixmap_from_page_number_with_separations()`.
       
               |
       
               *Overload 9:*
                Constructor using `fz_new_pixmap_from_page_with_separations()`.
       
               |
       
               *Overload 10:*
                Constructor using `fz_new_pixmap_from_pixmap()`.
                               Create a new pixmap that represents a subarea of the specified
                               pixmap. A reference is taken to this pixmap that will be dropped
                               on destruction.
       
                               The supplied rectangle must be wholly contained within the
                               original pixmap.
       
                               Returns a pointer to the new pixmap. Throws exception on failure
                               to allocate.
       
       
               |
       
               *Overload 11:*
                Constructor using `fz_new_pixmap_with_bbox()`.
                               Create a pixmap of a given size, location and pixel format.
       
                               The bounding box specifies the size of the created pixmap and
                               where it will be located. The colorspace determines the number
                               of components per pixel. Alpha is always present. Pixmaps are
                               reference counted, so drop references using fz_drop_pixmap.
       
                               colorspace: Colorspace format used for the created pixmap. The
                               pixmap will keep a reference to the colorspace.
       
                               bbox: Bounding box specifying location/size of created pixmap.
       
                               seps: Details of separations.
       
                               alpha: 0 for no alpha, 1 for alpha.
       
                               Returns a pointer to the new pixmap. Throws exception on failure
                               to allocate.
       
       
               |
       
               *Overload 12:*
                Constructor using `fz_new_pixmap_with_bbox_and_data()`.
                               Create a pixmap of a given size, location and pixel format,
                               using the supplied data block.
       
                               The bounding box specifies the size of the created pixmap and
                               where it will be located. The colorspace determines the number
                               of components per pixel. Alpha is always present. Pixmaps are
                               reference counted, so drop references using fz_drop_pixmap.
       
                               colorspace: Colorspace format used for the created pixmap. The
                               pixmap will keep a reference to the colorspace.
       
                               rect: Bounding box specifying location/size of created pixmap.
       
                               seps: Details of separations.
       
                               alpha: Number of alpha planes (0 or 1).
       
                               samples: The data block to keep the samples in.
       
                               Returns a pointer to the new pixmap. Throws exception on failure
                               to allocate.
       
       
               |
       
               *Overload 13:*
                Constructor using `fz_new_pixmap_with_data()`.
                               Create a new pixmap, with its origin at
                               (0,0) using the supplied data block.
       
                               cs: The colorspace to use for the pixmap, or NULL for an alpha
                               plane/mask.
       
                               w: The width of the pixmap (in pixels)
       
                               h: The height of the pixmap (in pixels)
       
                               seps: Details of separations.
       
                               alpha: 0 for no alpha, 1 for alpha.
       
                               stride: The byte offset from the pixel data in a row to the
                               pixel data in the next row.
       
                               samples: The data block to keep the samples in.
       
                               Returns a pointer to the new pixmap. Throws exception on failure to
                               allocate.
       
       
               |
       
               *Overload 14:*
                Constructor using `pdf_new_pixmap_from_annot()`.
       
               |
       
               *Overload 15:*
                Constructor using `pdf_new_pixmap_from_page_contents_with_separations_and_usage()`.
       
               |
       
               *Overload 16:*
                Constructor using `pdf_new_pixmap_from_page_contents_with_usage()`.
       
               |
       
               *Overload 17:*
                Copy constructor using `fz_keep_pixmap()`.
       
               |
       
               *Overload 18:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 19:*
                Constructor using raw copy of pre-existing `::fz_pixmap`.
               """
>>>>>>         _mupdf.FzPixmap_swiginit(self, _mupdf.new_FzPixmap(*args))
       
    1:     def storable(self):
>>>>>>         return _mupdf.FzPixmap_storable(self)
       
    1:     def x(self):
>>>>>>         return _mupdf.FzPixmap_x(self)
       
    1:     def y(self):
>>>>>>         return _mupdf.FzPixmap_y(self)
       
    1:     def w(self):
>>>>>>         return _mupdf.FzPixmap_w(self)
       
    1:     def h(self):
>>>>>>         return _mupdf.FzPixmap_h(self)
       
    1:     def n(self):
>>>>>>         return _mupdf.FzPixmap_n(self)
       
    1:     def s(self):
>>>>>>         return _mupdf.FzPixmap_s(self)
       
    1:     def alpha(self):
>>>>>>         return _mupdf.FzPixmap_alpha(self)
       
    1:     def flags(self):
>>>>>>         return _mupdf.FzPixmap_flags(self)
       
    1:     def stride(self):
>>>>>>         return _mupdf.FzPixmap_stride(self)
       
    1:     def seps(self):
>>>>>>         return _mupdf.FzPixmap_seps(self)
       
    1:     def xres(self):
>>>>>>         return _mupdf.FzPixmap_xres(self)
       
    1:     def yres(self):
>>>>>>         return _mupdf.FzPixmap_yres(self)
       
    1:     def colorspace(self):
>>>>>>         return _mupdf.FzPixmap_colorspace(self)
       
    1:     def samples(self):
>>>>>>         return _mupdf.FzPixmap_samples(self)
       
    1:     def underlying(self):
>>>>>>         return _mupdf.FzPixmap_underlying(self)
    1:     __swig_destroy__ = _mupdf.delete_FzPixmap
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzPixmap_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzPixmap___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzPixmap_m_internal_get, _mupdf.FzPixmap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzPixmap_s_num_instances_get, _mupdf.FzPixmap_s_num_instances_set)
       
       # Register FzPixmap in _mupdf:
    1: _mupdf.FzPixmap_swigregister(FzPixmap)
    2: class FzPixmapImage(object):
    1:     r"""Wrapper class for struct `fz_pixmap_image`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_pixmap_image_tile(self):
               r"""
               Class-aware wrapper for `::fz_pixmap_image_tile()`.
                       Retrieve the underlying fz_pixmap for an image.
       
                       Returns a pointer to the underlying fz_pixmap for an image,
                       or NULL if this image is not based upon an fz_pixmap.
       
                       No reference is returned. Lifespan is limited to that of
                       the image itself. If required, use fz_keep_pixmap to take
                       a reference to keep it longer.
               """
>>>>>>         return _mupdf.FzPixmapImage_fz_pixmap_image_tile(self)
       
    1:     def fz_set_pixmap_image_tile(self, pix):
               r"""Class-aware wrapper for `::fz_set_pixmap_image_tile()`."""
>>>>>>         return _mupdf.FzPixmapImage_fz_set_pixmap_image_tile(self, pix)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_pixmap_image`.
               """
>>>>>>         _mupdf.FzPixmapImage_swiginit(self, _mupdf.new_FzPixmapImage(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzPixmapImage
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzPixmapImage_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzPixmapImage___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzPixmapImage_m_internal_get, _mupdf.FzPixmapImage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzPixmapImage_s_num_instances_get, _mupdf.FzPixmapImage_s_num_instances_set)
       
       # Register FzPixmapImage in _mupdf:
    1: _mupdf.FzPixmapImage_swigregister(FzPixmapImage)
    2: class FzPoint(object):
    1:     r"""
           Wrapper class for struct `fz_point`.
           fz_point is a point in a two-dimensional space.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    2:     @staticmethod
    2:     def fz_transform_point_xy(x, y, m):
               r"""Class-aware wrapper for `::fz_transform_point_xy()`."""
>>>>>>         return _mupdf.FzPoint_fz_transform_point_xy(x, y, m)
       
    1:     def fz_is_point_inside_quad(self, q):
               r"""
               Class-aware wrapper for `::fz_is_point_inside_quad()`.
                       Inclusion test for quads.
               """
>>>>>>         return _mupdf.FzPoint_fz_is_point_inside_quad(self, q)
       
    1:     def fz_is_point_inside_rect(self, r):
               r"""
               Class-aware wrapper for `::fz_is_point_inside_rect()`.
                       Inclusion test for rects. (Rect is assumed to be open, i.e.
                       top right corner is not included).
               """
>>>>>>         return _mupdf.FzPoint_fz_is_point_inside_rect(self, r)
       
    1:     def fz_normalize_vector(self):
               r"""
               Class-aware wrapper for `::fz_normalize_vector()`.
                       Normalize a vector to length one.
               """
>>>>>>         return _mupdf.FzPoint_fz_normalize_vector(self)
       
    1:     def fz_transform_point(self, *args):
               r"""
               *Overload 1:*
                Class-aware wrapper for `::fz_transform_point()`.
                               Apply a transformation to a point.
       
                               transform: Transformation matrix to apply. See fz_concat,
                               fz_scale, fz_rotate and fz_translate for how to create a
                               matrix.
       
                               point: Pointer to point to update.
       
                               Returns transform (unchanged).
       
       
               |
       
               *Overload 2:*
                Class-aware wrapper for `::fz_transform_point()`.
                               Apply a transformation to a point.
       
                               transform: Transformation matrix to apply. See fz_concat,
                               fz_scale, fz_rotate and fz_translate for how to create a
                               matrix.
       
                               point: Pointer to point to update.
       
                               Returns transform (unchanged).
               """
>>>>>>         return _mupdf.FzPoint_fz_transform_point(self, *args)
       
    1:     def fz_transform_vector(self, *args):
               r"""
               *Overload 1:*
                Class-aware wrapper for `::fz_transform_vector()`.
                               Apply a transformation to a vector.
       
                               transform: Transformation matrix to apply. See fz_concat,
                               fz_scale and fz_rotate for how to create a matrix. Any
                               translation will be ignored.
       
                               vector: Pointer to vector to update.
       
       
               |
       
               *Overload 2:*
                Class-aware wrapper for `::fz_transform_vector()`.
                               Apply a transformation to a vector.
       
                               transform: Transformation matrix to apply. See fz_concat,
                               fz_scale and fz_rotate for how to create a matrix. Any
                               translation will be ignored.
       
                               vector: Pointer to vector to update.
               """
>>>>>>         return _mupdf.FzPoint_fz_transform_vector(self, *args)
       
    1:     def transform(self, m):
               r"""Post-multiply *this by <m> and return *this."""
>>>>>>         return _mupdf.FzPoint_transform(self, m)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Construct using specified values.
       
               |
       
               *Overload 2:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_point`.
       
               |
       
               *Overload 4:*
               Constructor using raw copy of pre-existing `::fz_point`.
               """
>>>>>>         _mupdf.FzPoint_swiginit(self, _mupdf.new_FzPoint(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.FzPoint_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_FzPoint
    1:     x = property(_mupdf.FzPoint_x_get, _mupdf.FzPoint_x_set)
    1:     y = property(_mupdf.FzPoint_y_get, _mupdf.FzPoint_y_set)
    1:     s_num_instances = property(_mupdf.FzPoint_s_num_instances_get, _mupdf.FzPoint_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzPoint_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzPoint___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzPoint___ne__(self, rhs)
       
       # Register FzPoint in _mupdf:
    1: _mupdf.FzPoint_swigregister(FzPoint)
    2: class FzPool(object):
    1:     r"""
           Wrapper class for struct `fz_pool`. Not copyable or assignable.
           Simple pool allocators.
       
           Allocate from the pool, which can then be freed at once.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_json_array_push(self, array, item):
               r"""Class-aware wrapper for `::fz_json_array_push()`."""
>>>>>>         return _mupdf.FzPool_fz_json_array_push(self, array, item)
       
    1:     def fz_json_object_set(self, object, key, item):
               r"""Class-aware wrapper for `::fz_json_object_set()`."""
>>>>>>         return _mupdf.FzPool_fz_json_object_set(self, object, key, item)
       
    1:     def fz_pool_alloc(self, size):
               r"""
               Class-aware wrapper for `::fz_pool_alloc()`.
                       Allocate a block of size bytes from the pool.
               """
>>>>>>         return _mupdf.FzPool_fz_pool_alloc(self, size)
       
    1:     def fz_pool_size(self):
               r"""
               Class-aware wrapper for `::fz_pool_size()`.
                       The current size of the pool.
       
                       The number of bytes of storage currently allocated to the pool.
                       This is the total of the storage used for the blocks making
                       up the pool, rather then total of the allocated blocks so far,
                       so it will increase in 'lumps'.
                       from the pool, then the pool size may still be X
               """
>>>>>>         return _mupdf.FzPool_fz_pool_size(self)
       
    1:     def fz_pool_strdup(self, s):
               r"""
               Class-aware wrapper for `::fz_pool_strdup()`.
                       strdup equivalent allocating from the pool.
               """
>>>>>>         return _mupdf.FzPool_fz_pool_strdup(self, s)
       
    1:     def fz_xml_add_att(self, node, key, val):
               r"""
               Class-aware wrapper for `::fz_xml_add_att()`.
                       Add an attribute to an XML node.
               """
>>>>>>         return _mupdf.FzPool_fz_xml_add_att(self, node, key, val)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_pool()`.
                               Create a new pool to allocate from.
       
       
               |
       
               *Overload 2:*
                Constructor using raw copy of pre-existing `::fz_pool`.
               """
>>>>>>         _mupdf.FzPool_swiginit(self, _mupdf.new_FzPool(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzPool
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzPool_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzPool___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzPool_m_internal_get, _mupdf.FzPool_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzPool_s_num_instances_get, _mupdf.FzPool_s_num_instances_set)
       
       # Register FzPool in _mupdf:
    1: _mupdf.FzPool_swigregister(FzPool)
    2: class FzPoolArray(object):
    1:     r"""
           Wrapper class for struct `fz_pool_array`. Not copyable or assignable.
           Routines to handle a 'variable length array' within the pool.
       
           Appending to the array, and looking up items within the array
           are O(log n) operations.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_pool_array_append(self, idx):
               r"""
               Class-aware wrapper for `::fz_pool_array_append()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_pool_array_append()` => `(void *, size_t idx)`
       
                       Append an element to the end of the array.
       
                       Returns a pointer to the new element (initially all 0's), and
                       (optionally) the index of that element.
               """
>>>>>>         return _mupdf.FzPoolArray_fz_pool_array_append(self, idx)
       
    1:     def fz_pool_array_len(self):
               r"""
               Class-aware wrapper for `::fz_pool_array_len()`.
                       Get the length of the array.
               """
>>>>>>         return _mupdf.FzPoolArray_fz_pool_array_len(self)
       
    1:     def fz_pool_array_lookup(self, idx):
               r"""
               Class-aware wrapper for `::fz_pool_array_lookup()`.
                       Lookup an element in the array.
               """
>>>>>>         return _mupdf.FzPoolArray_fz_pool_array_lookup(self, idx)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `fz_new_pool_array_imp()`.
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_pool_array`.
               """
>>>>>>         _mupdf.FzPoolArray_swiginit(self, _mupdf.new_FzPoolArray(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzPoolArray
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzPoolArray_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzPoolArray___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzPoolArray_m_internal_get, _mupdf.FzPoolArray_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzPoolArray_s_num_instances_get, _mupdf.FzPoolArray_s_num_instances_set)
       
       # Register FzPoolArray in _mupdf:
    1: _mupdf.FzPoolArray_swigregister(FzPoolArray)
    2: class FzPtrHeap(object):
    1:     r"""Wrapper class for struct `fz_ptr_heap`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_ptr_heap_insert(self, v, HEAP_CMP):
               r"""Class-aware wrapper for `::fz_ptr_heap_insert()`."""
>>>>>>         return _mupdf.FzPtrHeap_fz_ptr_heap_insert(self, v, HEAP_CMP)
       
    1:     def fz_ptr_heap_sort(self, HEAP_CMP):
               r"""Class-aware wrapper for `::fz_ptr_heap_sort()`."""
>>>>>>         return _mupdf.FzPtrHeap_fz_ptr_heap_sort(self, HEAP_CMP)
       
    1:     def fz_ptr_heap_uniq(self, HEAP_CMP):
               r"""Class-aware wrapper for `::fz_ptr_heap_uniq()`."""
>>>>>>         return _mupdf.FzPtrHeap_fz_ptr_heap_uniq(self, HEAP_CMP)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_ptr_heap`.
               """
>>>>>>         _mupdf.FzPtrHeap_swiginit(self, _mupdf.new_FzPtrHeap(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzPtrHeap
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzPtrHeap_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzPtrHeap___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzPtrHeap_m_internal_get, _mupdf.FzPtrHeap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzPtrHeap_s_num_instances_get, _mupdf.FzPtrHeap_s_num_instances_set)
       
       # Register FzPtrHeap in _mupdf:
    1: _mupdf.FzPtrHeap_swigregister(FzPtrHeap)
    2: class FzPwgOptions(object):
    1:     r"""Wrapper class for struct `fz_pwg_options`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_pwg_options`.
               """
>>>>>>         _mupdf.FzPwgOptions_swiginit(self, _mupdf.new_FzPwgOptions(*args))
       
    1:     def media_class(self):
>>>>>>         return _mupdf.FzPwgOptions_media_class(self)
       
    1:     def media_color(self):
>>>>>>         return _mupdf.FzPwgOptions_media_color(self)
       
    1:     def media_type(self):
>>>>>>         return _mupdf.FzPwgOptions_media_type(self)
       
    1:     def output_type(self):
>>>>>>         return _mupdf.FzPwgOptions_output_type(self)
       
    1:     def advance_distance(self):
>>>>>>         return _mupdf.FzPwgOptions_advance_distance(self)
       
    1:     def advance_media(self):
>>>>>>         return _mupdf.FzPwgOptions_advance_media(self)
       
    1:     def collate(self):
>>>>>>         return _mupdf.FzPwgOptions_collate(self)
       
    1:     def cut_media(self):
>>>>>>         return _mupdf.FzPwgOptions_cut_media(self)
       
    1:     def duplex(self):
>>>>>>         return _mupdf.FzPwgOptions_duplex(self)
       
    1:     def insert_sheet(self):
>>>>>>         return _mupdf.FzPwgOptions_insert_sheet(self)
       
    1:     def jog(self):
>>>>>>         return _mupdf.FzPwgOptions_jog(self)
       
    1:     def leading_edge(self):
>>>>>>         return _mupdf.FzPwgOptions_leading_edge(self)
       
    1:     def manual_feed(self):
>>>>>>         return _mupdf.FzPwgOptions_manual_feed(self)
       
    1:     def media_position(self):
>>>>>>         return _mupdf.FzPwgOptions_media_position(self)
       
    1:     def media_weight(self):
>>>>>>         return _mupdf.FzPwgOptions_media_weight(self)
       
    1:     def mirror_print(self):
>>>>>>         return _mupdf.FzPwgOptions_mirror_print(self)
       
    1:     def negative_print(self):
>>>>>>         return _mupdf.FzPwgOptions_negative_print(self)
       
    1:     def num_copies(self):
>>>>>>         return _mupdf.FzPwgOptions_num_copies(self)
       
    1:     def orientation(self):
>>>>>>         return _mupdf.FzPwgOptions_orientation(self)
       
    1:     def output_face_up(self):
>>>>>>         return _mupdf.FzPwgOptions_output_face_up(self)
       
    1:     def PageSize(self):
>>>>>>         return _mupdf.FzPwgOptions_PageSize(self)
       
    1:     def separations(self):
>>>>>>         return _mupdf.FzPwgOptions_separations(self)
       
    1:     def tray_switch(self):
>>>>>>         return _mupdf.FzPwgOptions_tray_switch(self)
       
    1:     def tumble(self):
>>>>>>         return _mupdf.FzPwgOptions_tumble(self)
       
    1:     def media_type_num(self):
>>>>>>         return _mupdf.FzPwgOptions_media_type_num(self)
       
    1:     def compression(self):
>>>>>>         return _mupdf.FzPwgOptions_compression(self)
       
    1:     def row_count(self):
>>>>>>         return _mupdf.FzPwgOptions_row_count(self)
       
    1:     def row_feed(self):
>>>>>>         return _mupdf.FzPwgOptions_row_feed(self)
       
    1:     def row_step(self):
>>>>>>         return _mupdf.FzPwgOptions_row_step(self)
       
    1:     def rendering_intent(self):
>>>>>>         return _mupdf.FzPwgOptions_rendering_intent(self)
       
    1:     def page_size_name(self):
>>>>>>         return _mupdf.FzPwgOptions_page_size_name(self)
    1:     __swig_destroy__ = _mupdf.delete_FzPwgOptions
    1:     m_internal = property(_mupdf.FzPwgOptions_m_internal_get, _mupdf.FzPwgOptions_m_internal_set)
    1:     s_num_instances = property(_mupdf.FzPwgOptions_s_num_instances_get, _mupdf.FzPwgOptions_s_num_instances_set, doc=r"""Wrapped data is held by value.""")
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzPwgOptions_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzPwgOptions___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzPwgOptions___ne__(self, rhs)
       
       # Register FzPwgOptions in _mupdf:
    1: _mupdf.FzPwgOptions_swigregister(FzPwgOptions)
    2: class FzQuad(object):
    1:     r"""
           Wrapper class for struct `fz_quad`.
           A representation for a region defined by 4 points.
       
           The significant difference between quads and rects is that
           the edges of quads are not axis aligned.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_detect_document(self, src):
               r"""Class-aware wrapper for `::fz_detect_document()`."""
>>>>>>         return _mupdf.FzQuad_fz_detect_document(self, src)
       
    1:     def fz_is_empty_quad(self):
               r"""
               Class-aware wrapper for `::fz_is_empty_quad()`.
                       Is a quad empty?
               """
>>>>>>         return _mupdf.FzQuad_fz_is_empty_quad(self)
       
    1:     def fz_is_infinite_quad(self):
               r"""
               Class-aware wrapper for `::fz_is_infinite_quad()`.
                       Is a quad infinite?
               """
>>>>>>         return _mupdf.FzQuad_fz_is_infinite_quad(self)
       
    1:     def fz_is_quad_inside_quad(self, haystack):
               r"""
               Class-aware wrapper for `::fz_is_quad_inside_quad()`.
                       Inclusion test for quad in quad.
       
                       This may break down if quads are not 'well formed'.
               """
>>>>>>         return _mupdf.FzQuad_fz_is_quad_inside_quad(self, haystack)
       
    1:     def fz_is_quad_intersecting_quad(self, b):
               r"""
               Class-aware wrapper for `::fz_is_quad_intersecting_quad()`.
                       Intersection test for quads.
       
                       This may break down if quads are not 'well formed'.
               """
>>>>>>         return _mupdf.FzQuad_fz_is_quad_intersecting_quad(self, b)
       
    1:     def fz_is_valid_quad(self):
               r"""
               Class-aware wrapper for `::fz_is_valid_quad()`.
                       Is a quad valid?
               """
>>>>>>         return _mupdf.FzQuad_fz_is_valid_quad(self)
       
    1:     def fz_rect_from_quad(self):
               r"""
               Class-aware wrapper for `::fz_rect_from_quad()`.
                       Convert a quad to the smallest rect that covers it.
               """
>>>>>>         return _mupdf.FzQuad_fz_rect_from_quad(self)
       
    1:     def fz_transform_quad(self, m):
               r"""
               Class-aware wrapper for `::fz_transform_quad()`.
                       Transform a quad by a matrix.
               """
>>>>>>         return _mupdf.FzQuad_fz_transform_quad(self, m)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_quad_from_rect()`.
                               Convert a rect to a quad (losslessly).
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_transform_quad()`.
                               Transform a quad by a matrix.
       
       
               |
       
               *Overload 3:*
                We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 4:*
                Constructor using raw copy of pre-existing `::fz_quad`.
       
               |
       
               *Overload 5:*
                Constructor using raw copy of pre-existing `::fz_quad`.
               """
>>>>>>         _mupdf.FzQuad_swiginit(self, _mupdf.new_FzQuad(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.FzQuad_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_FzQuad
    1:     ul = property(_mupdf.FzQuad_ul_get, _mupdf.FzQuad_ul_set)
    1:     ur = property(_mupdf.FzQuad_ur_get, _mupdf.FzQuad_ur_set)
    1:     ll = property(_mupdf.FzQuad_ll_get, _mupdf.FzQuad_ll_set)
    1:     lr = property(_mupdf.FzQuad_lr_get, _mupdf.FzQuad_lr_set)
    1:     s_num_instances = property(_mupdf.FzQuad_s_num_instances_get, _mupdf.FzQuad_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzQuad_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzQuad___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzQuad___ne__(self, rhs)
       
       # Register FzQuad in _mupdf:
    1: _mupdf.FzQuad_swigregister(FzQuad)
    2: class FzRange(object):
    1:     r"""Wrapper class for struct `fz_range`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_range`.
               """
>>>>>>         _mupdf.FzRange_swiginit(self, _mupdf.new_FzRange(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzRange
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzRange_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzRange___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzRange_m_internal_get, _mupdf.FzRange_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzRange_s_num_instances_get, _mupdf.FzRange_s_num_instances_set)
       
       # Register FzRange in _mupdf:
    1: _mupdf.FzRange_swigregister(FzRange)
    2: class FzRect(object):
    1:     r"""Wrapper class for struct `fz_rect`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     Fixed_UNIT = _mupdf.FzRect_Fixed_UNIT
    1:     Fixed_EMPTY = _mupdf.FzRect_Fixed_EMPTY
    1:     Fixed_INFINITE = _mupdf.FzRect_Fixed_INFINITE
       
    1:     def fz_adjust_rect_for_stroke(self, stroke, ctm):
               r"""
               Class-aware wrapper for `::fz_adjust_rect_for_stroke()`.
                       Given a rectangle (assumed to be the bounding box for a path),
                       expand it to allow for the expansion of the bbox that would be
                       seen by stroking the path with the given stroke state and
                       transform.
               """
>>>>>>         return _mupdf.FzRect_fz_adjust_rect_for_stroke(self, stroke, ctm)
       
    1:     def fz_contains_rect(self, b):
               r"""
               Class-aware wrapper for `::fz_contains_rect()`.
                       Test rectangle inclusion.
       
                       Return true if a entirely contains b.
               """
>>>>>>         return _mupdf.FzRect_fz_contains_rect(self, b)
       
    1:     def fz_expand_rect(self, expand):
               r"""
               Class-aware wrapper for `::fz_expand_rect()`.
                       Expand a bbox by a given amount in all directions.
               """
>>>>>>         return _mupdf.FzRect_fz_expand_rect(self, expand)
       
    1:     def fz_include_point_in_rect(self, p):
               r"""
               Class-aware wrapper for `::fz_include_point_in_rect()`.
                       Expand a bbox to include a given point.
                       To create a rectangle that encompasses a sequence of points, the
                       rectangle must first be set to be the empty rectangle at one of
                       the points before including the others.
               """
>>>>>>         return _mupdf.FzRect_fz_include_point_in_rect(self, p)
       
    1:     def fz_intersect_rect(self, *args):
               r"""
               *Overload 1:*
                Class-aware wrapper for `::fz_intersect_rect()`.
                               Compute intersection of two rectangles.
       
                               Given two rectangles, update the first to be the smallest
                               axis-aligned rectangle that covers the area covered by both
                               given rectangles. If either rectangle is empty then the
                               intersection is also empty. If either rectangle is infinite
                               then the intersection is simply the non-infinite rectangle.
                               Should both rectangles be infinite, then the intersection is
                               also infinite.
       
       
               |
       
               *Overload 2:*
                Class-aware wrapper for `::fz_intersect_rect()`.
                               Compute intersection of two rectangles.
       
                               Given two rectangles, update the first to be the smallest
                               axis-aligned rectangle that covers the area covered by both
                               given rectangles. If either rectangle is empty then the
                               intersection is also empty. If either rectangle is infinite
                               then the intersection is simply the non-infinite rectangle.
                               Should both rectangles be infinite, then the intersection is
                               also infinite.
               """
>>>>>>         return _mupdf.FzRect_fz_intersect_rect(self, *args)
       
    1:     def fz_irect_from_rect(self):
               r"""
               Class-aware wrapper for `::fz_irect_from_rect()`.
                       Convert a rect into the minimal bounding box
                       that covers the rectangle.
       
                       Coordinates in a bounding box are integers, so rounding of the
                       rects coordinates takes place. The top left corner is rounded
                       upwards and left while the bottom right corner is rounded
                       downwards and to the right.
               """
>>>>>>         return _mupdf.FzRect_fz_irect_from_rect(self)
       
    1:     def fz_is_empty_rect(self):
               r"""
               Class-aware wrapper for `::fz_is_empty_rect()`.
                       Check if rectangle is empty.
       
                       An empty rectangle is defined as one whose area is zero.
                       All invalid rectangles are empty.
               """
>>>>>>         return _mupdf.FzRect_fz_is_empty_rect(self)
       
    1:     def fz_is_infinite_rect(self):
               r"""
               Class-aware wrapper for `::fz_is_infinite_rect()`.
                       Check if rectangle is infinite.
               """
>>>>>>         return _mupdf.FzRect_fz_is_infinite_rect(self)
       
    1:     def fz_is_rect_inside_rect(self, outer):
               r"""
               Class-aware wrapper for `::fz_is_rect_inside_rect()`.
                       Inclusion test for rects.
       
                       rects are assumed to be both open or both closed.
       
                       No invalid rect can include any other rect.
                       No invalid rect can be included by any rect.
                       Empty (point) rects can include themselves.
                       Empty (line) rects can include many (subline) rects.
               """
>>>>>>         return _mupdf.FzRect_fz_is_rect_inside_rect(self, outer)
       
    1:     def fz_is_valid_rect(self):
               r"""
               Class-aware wrapper for `::fz_is_valid_rect()`.
                       Check if rectangle is valid.
               """
>>>>>>         return _mupdf.FzRect_fz_is_valid_rect(self)
       
    1:     def fz_new_bbox_device(self):
               r"""
               Class-aware wrapper for `::fz_new_bbox_device()`.
                       Create a device to compute the bounding
                       box of all marks on a page.
       
                       The returned bounding box will be the union of all bounding
                       boxes of all objects on a page.
               """
>>>>>>         return _mupdf.FzRect_fz_new_bbox_device(self)
       
    1:     def fz_new_display_list(self):
               r"""
               Class-aware wrapper for `::fz_new_display_list()`.
                       Create an empty display list.
       
                       A display list contains drawing commands (text, images, etc.).
                       Use fz_new_list_device for populating the list.
       
                       mediabox: Bounds of the page (in points) represented by the
                       display list.
               """
>>>>>>         return _mupdf.FzRect_fz_new_display_list(self)
       
    1:     def fz_overlaps_rect(self, b):
               r"""
               Class-aware wrapper for `::fz_overlaps_rect()`.
                       Test rectangle overlap.
       
                       Returns true if the area of the overlap is
                       non zero.
               """
>>>>>>         return _mupdf.FzRect_fz_overlaps_rect(self, b)
       
    1:     def fz_quad_from_rect(self):
               r"""
               Class-aware wrapper for `::fz_quad_from_rect()`.
                       Convert a rect to a quad (losslessly).
               """
>>>>>>         return _mupdf.FzRect_fz_quad_from_rect(self)
       
    1:     def fz_round_rect(self):
               r"""
               Class-aware wrapper for `::fz_round_rect()`.
                       Round rectangle coordinates.
       
                       Coordinates in a bounding box are integers, so rounding of the
                       rects coordinates takes place. The top left corner is rounded
                       upwards and left while the bottom right corner is rounded
                       downwards and to the right.
       
                       This differs from fz_irect_from_rect, in that fz_irect_from_rect
                       slavishly follows the numbers (i.e any slight over/under
                       calculations can cause whole extra pixels to be added).
                       fz_round_rect allows for a small amount of rounding error when
                       calculating the bbox.
               """
>>>>>>         return _mupdf.FzRect_fz_round_rect(self)
       
    1:     def fz_transform_page(self, resolution, rotate):
               r"""
               Class-aware wrapper for `::fz_transform_page()`.
                       Create transform matrix to draw page
                       at a given resolution and rotation. Adjusts the scaling
                       factors so that the page covers whole number of
                       pixels and adjust the page origin to be at 0,0.
               """
>>>>>>         return _mupdf.FzRect_fz_transform_page(self, resolution, rotate)
       
    1:     def fz_transform_rect(self, m):
               r"""
               Class-aware wrapper for `::fz_transform_rect()`.
                       Apply a transform to a rectangle.
       
                       After the four corner points of the axis-aligned rectangle
                       have been transformed it may not longer be axis-aligned. So a
                       new axis-aligned rectangle is created covering at least the
                       area of the transformed rectangle.
       
                       transform: Transformation matrix to apply. See fz_concat,
                       fz_scale and fz_rotate for how to create a matrix.
       
                       rect: Rectangle to be transformed. The two special cases
                       fz_empty_rect and fz_infinite_rect, may be used but are
                       returned unchanged as expected.
               """
>>>>>>         return _mupdf.FzRect_fz_transform_rect(self, m)
       
    1:     def fz_translate_rect(self, xoff, yoff):
               r"""
               Class-aware wrapper for `::fz_translate_rect()`.
                       Translate bounding box.
       
                       Translate a bbox by a given x and y offset. Allows for overflow.
               """
>>>>>>         return _mupdf.FzRect_fz_translate_rect(self, xoff, yoff)
       
    1:     def fz_union_rect(self, *args):
               r"""
               *Overload 1:*
                Class-aware wrapper for `::fz_union_rect()`.
                               Compute union of two rectangles.
       
                               Given two rectangles, update the first to be the smallest
                               axis-aligned rectangle that encompasses both given rectangles.
                               If either rectangle is infinite then the union is also infinite.
                               If either rectangle is empty then the union is simply the
                               non-empty rectangle. Should both rectangles be empty, then the
                               union is also empty.
       
       
               |
       
               *Overload 2:*
                Class-aware wrapper for `::fz_union_rect()`.
                               Compute union of two rectangles.
       
                               Given two rectangles, update the first to be the smallest
                               axis-aligned rectangle that encompasses both given rectangles.
                               If either rectangle is infinite then the union is also infinite.
                               If either rectangle is empty then the union is simply the
                               non-empty rectangle. Should both rectangles be empty, then the
                               union is also empty.
               """
>>>>>>         return _mupdf.FzRect_fz_union_rect(self, *args)
       
    1:     def pdf_signature_appearance_signed(self, lang, img, left_text, right_text, include_logo):
               r"""Class-aware wrapper for `::pdf_signature_appearance_signed()`."""
>>>>>>         return _mupdf.FzRect_pdf_signature_appearance_signed(self, lang, img, left_text, right_text, include_logo)
       
    1:     def pdf_signature_appearance_unsigned(self, lang):
               r"""Class-aware wrapper for `::pdf_signature_appearance_unsigned()`."""
>>>>>>         return _mupdf.FzRect_pdf_signature_appearance_unsigned(self, lang)
       
    1:     def transform(self, m):
               r"""Transforms *this using fz_transform_rect() with <m>."""
>>>>>>         return _mupdf.FzRect_transform(self, m)
       
    1:     def contains(self, *args):
               r"""
               *Overload 1:*
               Convenience method using fz_contains_rect().
       
               |
       
               *Overload 2:*
               Uses fz_contains_rect(*this, rhs).
               """
>>>>>>         return _mupdf.FzRect_contains(self, *args)
       
    1:     def is_empty(self):
               r"""Uses fz_is_empty_rect()."""
>>>>>>         return _mupdf.FzRect_is_empty(self)
       
    1:     def union_(self, rhs):
               r"""Updates *this using fz_union_rect()."""
>>>>>>         return _mupdf.FzRect_union_(self, rhs)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_bound_display_list()`.
                               Return the bounding box of the page recorded in a display list.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_rect_from_irect()`.
                               Convert a bbox into a rect.
       
                               For our purposes, a rect can represent all the values we meet in
                               a bbox, so nothing can go wrong.
       
                               rect: A place to store the generated rectangle.
       
                               bbox: The bbox to convert.
       
                               Returns rect (updated).
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_rect_from_quad()`.
                               Convert a quad to the smallest rect that covers it.
       
       
               |
       
               *Overload 4:*
                Constructor using `fz_transform_rect()`.
                               Apply a transform to a rectangle.
       
                               After the four corner points of the axis-aligned rectangle
                               have been transformed it may not longer be axis-aligned. So a
                               new axis-aligned rectangle is created covering at least the
                               area of the transformed rectangle.
       
                               transform: Transformation matrix to apply. See fz_concat,
                               fz_scale and fz_rotate for how to create a matrix.
       
                               rect: Rectangle to be transformed. The two special cases
                               fz_empty_rect and fz_infinite_rect, may be used but are
                               returned unchanged as expected.
       
       
               |
       
               *Overload 5:*
                Construct from specified values.
       
               |
       
               *Overload 6:*
                Copy constructor using plain copy.
       
               |
       
               *Overload 7:*
                Construct from fz_unit_rect, fz_empty_rect or fz_infinite_rect.
       
               |
       
               *Overload 8:*
                We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 9:*
                Constructor using raw copy of pre-existing `::fz_rect`.
       
               |
       
               *Overload 10:*
                Constructor using raw copy of pre-existing `::fz_rect`.
               """
>>>>>>         _mupdf.FzRect_swiginit(self, _mupdf.new_FzRect(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.FzRect_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_FzRect
    1:     x0 = property(_mupdf.FzRect_x0_get, _mupdf.FzRect_x0_set)
    1:     y0 = property(_mupdf.FzRect_y0_get, _mupdf.FzRect_y0_set)
    1:     x1 = property(_mupdf.FzRect_x1_get, _mupdf.FzRect_x1_set)
    1:     y1 = property(_mupdf.FzRect_y1_get, _mupdf.FzRect_y1_set)
    1:     s_num_instances = property(_mupdf.FzRect_s_num_instances_get, _mupdf.FzRect_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzRect_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzRect___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzRect___ne__(self, rhs)
       
       # Register FzRect in _mupdf:
    1: _mupdf.FzRect_swigregister(FzRect)
    2: class FzSeparations(object):
    1:     r"""Wrapper class for struct `fz_separations`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_add_separation(self, name, cs, cs_channel):
               r"""
               Class-aware wrapper for `::fz_add_separation()`.
                       Add a separation (null terminated name, colorspace)
               """
>>>>>>         return _mupdf.FzSeparations_fz_add_separation(self, name, cs, cs_channel)
       
    1:     def fz_add_separation_equivalents(self, rgba, cmyk, name):
               r"""
               Class-aware wrapper for `::fz_add_separation_equivalents()`.
                       Add a separation with equivalents (null terminated name,
                       colorspace)
       
                       (old, deprecated)
               """
>>>>>>         return _mupdf.FzSeparations_fz_add_separation_equivalents(self, rgba, cmyk, name)
       
    1:     def fz_clone_separations_for_overprint(self):
               r"""
               Class-aware wrapper for `::fz_clone_separations_for_overprint()`.
                       Return a separations object with all the spots in the input
                       separations object that are set to composite, reset to be
                       enabled. If there ARE no spots in the object, this returns
                       NULL. If the object already has all its spots enabled, then
                       just returns another handle on the same object.
               """
>>>>>>         return _mupdf.FzSeparations_fz_clone_separations_for_overprint(self)
       
    1:     def fz_compare_separations(self, sep2):
               r"""
               Class-aware wrapper for `::fz_compare_separations()`.
                       Compare 2 separations structures (or NULLs).
       
                       Return 0 if identical, non-zero if not identical.
               """
>>>>>>         return _mupdf.FzSeparations_fz_compare_separations(self, sep2)
       
    1:     def fz_count_active_separations(self):
               r"""
               Class-aware wrapper for `::fz_count_active_separations()`.
                       Return the number of active separations.
               """
>>>>>>         return _mupdf.FzSeparations_fz_count_active_separations(self)
       
    1:     def fz_count_separations(self):
               r"""Class-aware wrapper for `::fz_count_separations()`."""
>>>>>>         return _mupdf.FzSeparations_fz_count_separations(self)
       
    1:     def fz_separation_equivalent(self, idx, dst_cs, dst_color, prf, color_params):
               r"""
               Class-aware wrapper for `::fz_separation_equivalent()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_separation_equivalent(int idx, ::fz_colorspace *dst_cs, ::fz_colorspace *prf, ::fz_color_params color_params)` => float dst_color
       
                       Get the equivalent separation color in a given colorspace.
               """
>>>>>>         return _mupdf.FzSeparations_fz_separation_equivalent(self, idx, dst_cs, dst_color, prf, color_params)
       
    1:     def fz_separation_name(self, separation):
               r"""Class-aware wrapper for `::fz_separation_name()`."""
>>>>>>         return _mupdf.FzSeparations_fz_separation_name(self, separation)
       
    1:     def fz_set_separation_behavior(self, separation, behavior):
               r"""
               Class-aware wrapper for `::fz_set_separation_behavior()`.
                       Control the rendering of a given separation.
               """
>>>>>>         return _mupdf.FzSeparations_fz_set_separation_behavior(self, separation, behavior)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_separations()`.
                               Create a new separations structure (initially empty)
       
       
               |
       
               *Overload 2:*
                Copy constructor using `fz_keep_separations()`.
       
               |
       
               *Overload 3:*
                Constructor using raw copy of pre-existing `::fz_separations`.
       
               |
       
               *Overload 4:*
                Constructor using raw copy of pre-existing `::fz_separations`.
               """
>>>>>>         _mupdf.FzSeparations_swiginit(self, _mupdf.new_FzSeparations(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzSeparations
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzSeparations_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzSeparations___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzSeparations_m_internal_get, _mupdf.FzSeparations_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzSeparations_s_num_instances_get, _mupdf.FzSeparations_s_num_instances_set)
       
       # Register FzSeparations in _mupdf:
    1: _mupdf.FzSeparations_swigregister(FzSeparations)
    2: class FzSha256(object):
    1:     r"""
           Wrapper class for struct `fz_sha256`. Not copyable or assignable.
           Structure definition is public to enable stack
           based allocation. Do not access the members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_sha256_final(self, digest):
               r"""
               Class-aware wrapper for `::fz_sha256_final()`.
                       MD5 finalization. Ends an MD5 message-digest operation, writing
                       the message digest and zeroizing the context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzSha256_fz_sha256_final(self, digest)
       
    1:     def fz_sha256_init(self):
               r"""
               Class-aware wrapper for `::fz_sha256_init()`.
                       SHA256 initialization. Begins an SHA256 operation, initialising
                       the supplied context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzSha256_fz_sha256_init(self)
       
    1:     def fz_sha256_update(self, input, inlen):
               r"""
               Class-aware wrapper for `::fz_sha256_update()`.
                       SHA256 block update operation. Continues an SHA256 message-
                       digest operation, processing another message block, and updating
                       the context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzSha256_fz_sha256_update(self, input, inlen)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_sha256`.
               """
>>>>>>         _mupdf.FzSha256_swiginit(self, _mupdf.new_FzSha256(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzSha256
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzSha256_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzSha256___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzSha256_m_internal_get, _mupdf.FzSha256_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzSha256_s_num_instances_get, _mupdf.FzSha256_s_num_instances_set)
       
       # Register FzSha256 in _mupdf:
    1: _mupdf.FzSha256_swigregister(FzSha256)
    2: class FzSha384(object):
    1:     r"""Wrapper class for struct `fz_sha384`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_sha384`.
               """
>>>>>>         _mupdf.FzSha384_swiginit(self, _mupdf.new_FzSha384(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzSha384
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzSha384_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzSha384___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzSha384_m_internal_get, _mupdf.FzSha384_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzSha384_s_num_instances_get, _mupdf.FzSha384_s_num_instances_set)
       
       # Register FzSha384 in _mupdf:
    1: _mupdf.FzSha384_swigregister(FzSha384)
    2: class FzSha512(object):
    1:     r"""
           Wrapper class for struct `fz_sha512`. Not copyable or assignable.
           Structure definition is public to enable stack
           based allocation. Do not access the members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_sha384_final(self, digest):
               r"""
               Class-aware wrapper for `::fz_sha384_final()`.
                       SHA384 finalization. Ends an SHA384 message-digest operation,
                       writing the message digest and zeroizing the context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzSha512_fz_sha384_final(self, digest)
       
    1:     def fz_sha384_init(self):
               r"""
               Class-aware wrapper for `::fz_sha384_init()`.
                       SHA384 initialization. Begins an SHA384 operation, initialising
                       the supplied context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzSha512_fz_sha384_init(self)
       
    1:     def fz_sha384_update(self, input, inlen):
               r"""
               Class-aware wrapper for `::fz_sha384_update()`.
                       SHA384 block update operation. Continues an SHA384 message-
                       digest operation, processing another message block, and updating
                       the context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzSha512_fz_sha384_update(self, input, inlen)
       
    1:     def fz_sha512_final(self, digest):
               r"""
               Class-aware wrapper for `::fz_sha512_final()`.
                       SHA512 finalization. Ends an SHA512 message-digest operation,
                       writing the message digest and zeroizing the context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzSha512_fz_sha512_final(self, digest)
       
    1:     def fz_sha512_init(self):
               r"""
               Class-aware wrapper for `::fz_sha512_init()`.
                       SHA512 initialization. Begins an SHA512 operation, initialising
                       the supplied context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzSha512_fz_sha512_init(self)
       
    1:     def fz_sha512_update(self, input, inlen):
               r"""
               Class-aware wrapper for `::fz_sha512_update()`.
                       SHA512 block update operation. Continues an SHA512 message-
                       digest operation, processing another message block, and updating
                       the context.
       
                       Never throws an exception.
               """
>>>>>>         return _mupdf.FzSha512_fz_sha512_update(self, input, inlen)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_sha512`.
               """
>>>>>>         _mupdf.FzSha512_swiginit(self, _mupdf.new_FzSha512(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzSha512
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzSha512_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzSha512___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzSha512_m_internal_get, _mupdf.FzSha512_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzSha512_s_num_instances_get, _mupdf.FzSha512_s_num_instances_set)
       
       # Register FzSha512 in _mupdf:
    1: _mupdf.FzSha512_swigregister(FzSha512)
    2: class FzShade(object):
    1:     r"""
           Wrapper class for struct `fz_shade`.
           Structure is public to allow derived classes. Do not
           access the members directly.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_bound_shade(self, ctm):
               r"""
               Class-aware wrapper for `::fz_bound_shade()`.
                       Bound a given shading.
       
                       shade: The shade to bound.
       
                       ctm: The transform to apply to the shade before bounding.
       
                       r: Pointer to storage to put the bounds in.
       
                       Returns r, updated to contain the bounds for the shading.
               """
>>>>>>         return _mupdf.FzShade_fz_bound_shade(self, ctm)
       
    1:     def fz_paint_shade(self, override_cs, ctm, dest, color_params, bbox, eop, cache):
               r"""
               Class-aware wrapper for `::fz_paint_shade()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_paint_shade(::fz_colorspace *override_cs, ::fz_matrix ctm, ::fz_pixmap *dest, ::fz_color_params color_params, ::fz_irect bbox, const ::fz_overprint *eop, ::fz_shade_color_cache **cache)` =>
       
                       Render a shade to a given pixmap.
       
                       shade: The shade to paint.
       
                       override_cs: NULL, or colorspace to override the shades
                       inbuilt colorspace.
       
                       ctm: The transform to apply.
       
                       dest: The pixmap to render into.
       
                       color_params: The color rendering settings
       
                       bbox: Pointer to a bounding box to limit the rendering
                       of the shade.
       
                       eop: NULL, or pointer to overprint bitmap.
       
                       cache: *cache is used to cache color information. If *cache is NULL it
                       is set to point to a new fz_shade_color_cache. If cache is NULL it is
                       ignored.
               """
>>>>>>         return _mupdf.FzShade_fz_paint_shade(self, override_cs, ctm, dest, color_params, bbox, eop, cache)
       
    1:     def fz_process_shade(self, ctm, scissor, prepare, process, process_arg):
               r"""
               Class-aware wrapper for `::fz_process_shade()`.
                       Process a shade, using supplied callback functions. This
                       decomposes the shading to a mesh (even ones that are not
                       natively meshes, such as linear or radial shadings), and
                       processes triangles from those meshes.
       
                       shade: The shade to process.
       
                       ctm: The transform to use
       
                       prepare: Callback function to 'prepare' each vertex.
                       This function is passed an array of floats, and populates
                       a fz_vertex structure.
       
                       process: This function is passed 3 pointers to vertex
                       structures, and actually performs the processing (typically
                       filling the area between the vertices).
       
                       process_arg: An opaque argument passed through from caller
                       to callback functions.
               """
>>>>>>         return _mupdf.FzShade_fz_process_shade(self, ctm, scissor, prepare, process, process_arg)
       
    1:     def fz_paint_shade_no_cache(self, override_cs, ctm, dest, color_params, bbox, eop):
               r"""Extra wrapper for fz_paint_shade(), passing cache=NULL."""
>>>>>>         return _mupdf.FzShade_fz_paint_shade_no_cache(self, override_cs, ctm, dest, color_params, bbox, eop)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Copy constructor using `fz_keep_shade()`.
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_shade`.
               """
>>>>>>         _mupdf.FzShade_swiginit(self, _mupdf.new_FzShade(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzShade
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzShade_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzShade___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzShade_m_internal_get, _mupdf.FzShade_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzShade_s_num_instances_get, _mupdf.FzShade_s_num_instances_set)
       
       # Register FzShade in _mupdf:
    1: _mupdf.FzShade_swigregister(FzShade)
    2: class FzShadeColorCache(object):
    1:     r"""Wrapper class for struct `fz_shade_color_cache`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_shade_color_cache`.
               """
>>>>>>         _mupdf.FzShadeColorCache_swiginit(self, _mupdf.new_FzShadeColorCache(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzShadeColorCache
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzShadeColorCache_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzShadeColorCache___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzShadeColorCache_m_internal_get, _mupdf.FzShadeColorCache_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzShadeColorCache_s_num_instances_get, _mupdf.FzShadeColorCache_s_num_instances_set)
       
       # Register FzShadeColorCache in _mupdf:
    1: _mupdf.FzShadeColorCache_swigregister(FzShadeColorCache)
    2: class FzShaperDataT(object):
    1:     r"""
           Wrapper class for struct `fz_shaper_data_t`. Not copyable or assignable.
           In order to shape a given font, we need to
           declare it to a shaper library (harfbuzz, by default, but others
           are possible). To avoid redeclaring it every time we need to
           shape, we hold a shaper handle and the destructor for it within
           the font itself. The handle is initialised by the caller when
           first required and the destructor is called when the fz_font is
           destroyed.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_shaper_data_t`.
               """
>>>>>>         _mupdf.FzShaperDataT_swiginit(self, _mupdf.new_FzShaperDataT(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzShaperDataT
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzShaperDataT_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzShaperDataT___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzShaperDataT_m_internal_get, _mupdf.FzShaperDataT_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzShaperDataT_s_num_instances_get, _mupdf.FzShaperDataT_s_num_instances_set)
       
       # Register FzShaperDataT in _mupdf:
    1: _mupdf.FzShaperDataT_swigregister(FzShaperDataT)
    2: class FzStextBlock(object):
    1:     r"""Wrapper class for struct `fz_stext_block`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def i_transform(self):
               r"""Returns m_internal.u.i.transform if m_internal->type is FZ_STEXT_BLOCK_IMAGE, else throws."""
>>>>>>         return _mupdf.FzStextBlock_i_transform(self)
       
    1:     def i_image(self):
               r"""Returns m_internal.u.i.image if m_internal->type is FZ_STEXT_BLOCK_IMAGE, else throws."""
>>>>>>         return _mupdf.FzStextBlock_i_image(self)
       
    1:     def begin(self):
               r"""Used for iteration over linked list of FzStextLine items starting at fz_stext_line::u.t.first_line."""
>>>>>>         return _mupdf.FzStextBlock_begin(self)
       
    1:     def end(self):
               r"""Used for iteration over linked list of FzStextLine items starting at fz_stext_line::u.t.first_line."""
>>>>>>         return _mupdf.FzStextBlock_end(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `fz_new_stext_struct()`.
       
               |
       
               *Overload 2:*
               We use default copy constructor and operator=.  Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_stext_block`.
               """
>>>>>>         _mupdf.FzStextBlock_swiginit(self, _mupdf.new_FzStextBlock(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStextBlock
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStextBlock_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStextBlock___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStextBlock_m_internal_get, _mupdf.FzStextBlock_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStextBlock_s_num_instances_get, _mupdf.FzStextBlock_s_num_instances_set)
       
       # Register FzStextBlock in _mupdf:
    1: _mupdf.FzStextBlock_swigregister(FzStextBlock)
    2: class FzStextChar(object):
    1:     r"""
           Wrapper class for struct `fz_stext_char`.
           Text extraction device: Used for searching, format conversion etc.
       
           (In development - Subject to change in future versions)
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_stext_char`.
               """
>>>>>>         _mupdf.FzStextChar_swiginit(self, _mupdf.new_FzStextChar(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStextChar
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStextChar_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStextChar___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStextChar_m_internal_get, _mupdf.FzStextChar_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStextChar_s_num_instances_get, _mupdf.FzStextChar_s_num_instances_set)
       
       # Register FzStextChar in _mupdf:
    1: _mupdf.FzStextChar_swigregister(FzStextChar)
    2: class FzStextGridPositions(object):
    1:     r"""Wrapper class for struct `fz_stext_grid_positions`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_stext_grid_positions`.
               """
>>>>>>         _mupdf.FzStextGridPositions_swiginit(self, _mupdf.new_FzStextGridPositions(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStextGridPositions
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStextGridPositions_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStextGridPositions___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStextGridPositions_m_internal_get, _mupdf.FzStextGridPositions_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStextGridPositions_s_num_instances_get, _mupdf.FzStextGridPositions_s_num_instances_set)
       
       # Register FzStextGridPositions in _mupdf:
    1: _mupdf.FzStextGridPositions_swigregister(FzStextGridPositions)
    2: class FzStextLine(object):
    1:     r"""Wrapper class for struct `fz_stext_line`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def begin(self):
               r"""Used for iteration over linked list of FzStextChar items starting at fz_stext_char::first_char."""
>>>>>>         return _mupdf.FzStextLine_begin(self)
       
    1:     def end(self):
               r"""Used for iteration over linked list of FzStextChar items starting at fz_stext_char::first_char."""
>>>>>>         return _mupdf.FzStextLine_end(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_stext_line`.
               """
>>>>>>         _mupdf.FzStextLine_swiginit(self, _mupdf.new_FzStextLine(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStextLine
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStextLine_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStextLine___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStextLine_m_internal_get, _mupdf.FzStextLine_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStextLine_s_num_instances_get, _mupdf.FzStextLine_s_num_instances_set)
       
       # Register FzStextLine in _mupdf:
    1: _mupdf.FzStextLine_swigregister(FzStextLine)
    2: class FzStextOptions(object):
    1:     r"""
           Wrapper class for struct `fz_stext_options`.
           Options for creating structured text.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_parse_stext_options(self, string):
               r"""
               Class-aware wrapper for `::fz_parse_stext_options()`.
                       Parse stext device options from a comma separated key-value
                       string.
               """
>>>>>>         return _mupdf.FzStextOptions_fz_parse_stext_options(self, string)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                Construct with .flags, .scale but no clip.
       
               |
       
               *Overload 2:*
                Construct with .flags, .scale and .clip; FZ_STEXT_CLIP_RECT
                       is automatically set in .flags.
       
               |
       
               *Overload 3:*
                Construct with .flags, .scale and .clip; FZ_STEXT_CLIP_RECT
                       is automatically set in .flags.
       
               |
       
               *Overload 4:*
                We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 5:*
                Constructor using raw copy of pre-existing `::fz_stext_options`.
       
               |
       
               *Overload 6:*
                Constructor using raw copy of pre-existing `::fz_stext_options`.
               """
>>>>>>         _mupdf.FzStextOptions_swiginit(self, _mupdf.new_FzStextOptions(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.FzStextOptions_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_FzStextOptions
    1:     flags = property(_mupdf.FzStextOptions_flags_get, _mupdf.FzStextOptions_flags_set)
    1:     scale = property(_mupdf.FzStextOptions_scale_get, _mupdf.FzStextOptions_scale_set)
    1:     clip = property(_mupdf.FzStextOptions_clip_get, _mupdf.FzStextOptions_clip_set)
    1:     s_num_instances = property(_mupdf.FzStextOptions_s_num_instances_get, _mupdf.FzStextOptions_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzStextOptions_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzStextOptions___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzStextOptions___ne__(self, rhs)
       
       # Register FzStextOptions in _mupdf:
    1: _mupdf.FzStextOptions_swigregister(FzStextOptions)
    2: class FzStextPage(object):
    1:     r"""
           Wrapper class for struct `fz_stext_page`. Not copyable or assignable.
           A text page is a list of blocks, together with an overall
           bounding box.
       
           The name of this structure is now slightly out of date. It
           should really be fz_stext_document, cos it can contain
           content from multiple pages.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_classify_stext_rect(self, classification, rect):
               r"""Class-aware wrapper for `::fz_classify_stext_rect()`."""
>>>>>>         return _mupdf.FzStextPage_fz_classify_stext_rect(self, classification, rect)
       
    1:     def fz_find_table_within_bounds(self, bounds):
               r"""
               Class-aware wrapper for `::fz_find_table_within_bounds()`.
                       Interpret the bounded contents of a given stext page as
                       a table.
       
                       The page contents will be rewritten to contain a Table
                       structure with the identified content in it.
       
                       This uses the same logic as for fz_table_hunt, without the
                       actual hunting. fz_table_hunt hunts to find possible bounds
                       for multiple tables on the page; this routine just finds a
                       single table contained within the given rectangle.
       
                       Returns the stext_block list that contains the content of
                       the table.
               """
>>>>>>         return _mupdf.FzStextPage_fz_find_table_within_bounds(self, bounds)
       
    1:     def fz_highlight_selection(self, a, b, quads, max_quads):
               r"""
               Class-aware wrapper for `::fz_highlight_selection()`.
                       Return a list of quads to highlight lines inside the selection
                       points.
               """
>>>>>>         return _mupdf.FzStextPage_fz_highlight_selection(self, a, b, quads, max_quads)
       
    1:     def fz_highlight_selection2(self, a, b, max_quads):
               r"""
               Class-aware wrapper for `::fz_highlight_selection2()`.
               C++ alternative to fz_highlight_selection() that returns quads in a
               std::vector.
               """
>>>>>>         return _mupdf.FzStextPage_fz_highlight_selection2(self, a, b, max_quads)
       
    1:     def fz_new_buffer_from_stext_page(self):
               r"""
               Class-aware wrapper for `::fz_new_buffer_from_stext_page()`.
                       Convert structured text into plain text.
               """
>>>>>>         return _mupdf.FzStextPage_fz_new_buffer_from_stext_page(self)
       
    1:     def fz_new_stext_device(self, options):
               r"""
               Class-aware wrapper for `::fz_new_stext_device()`.
                       Create a device to extract the text on a page.
       
                       Gather the text on a page into blocks and lines.
       
                       The reading order is taken from the order the text is drawn in
                       the source file, so may not be accurate.
       
                       page: The text page to which content should be added. This will
                       usually be a newly created (empty) text page, but it can be one
                       containing data already (for example when merging multiple
                       pages, or watermarking).
       
                       options: Options to configure the stext device.
               """
>>>>>>         return _mupdf.FzStextPage_fz_new_stext_device(self, options)
       
    1:     def fz_new_stext_device_for_page(self, opts, chapter_num, page_num, mediabox):
               r"""
               Class-aware wrapper for `::fz_new_stext_device_for_page()`.
                       Create a device to extract the text on a page into an existing
                       fz_stext_page structure.
       
                       Gather the text on a page into blocks and lines.
       
                       The reading order is taken from the order the text is drawn in
                       the source file, so may not be accurate.
       
                       stext_page: The text page to which content should be added. This will
                       usually be a newly created (empty) text page, but it can be one
                       containing data already (for example when merging multiple
                       pages, or watermarking).
       
                       options: Options to configure the stext device.
       
                       The next 2 parameters are copied into the fz_stext_page structure's
                       ids section, so only have to be valid if you expect to interrogate
                       that section later.
       
                       chapter_num: The chapter number that this page came from.
       
                       page_num: The page number that this page came from.
       
                       The final parameter is copied into the fz_stext_page structure's
                       ids section. The mediabox for the enture fz_stext_page is unioned
                       with this, so pass fz_empty_bbox if you don't care about getting
                       a valid value back from the ids section, but you don't want to
                       upset the value in the page->mediabox field.
       
                       mediabox: The mediabox for this page.
               """
>>>>>>         return _mupdf.FzStextPage_fz_new_stext_device_for_page(self, opts, chapter_num, page_num, mediabox)
       
    1:     def fz_new_stext_struct(self, standard, raw, index):
               r"""Class-aware wrapper for `::fz_new_stext_struct()`."""
>>>>>>         return _mupdf.FzStextPage_fz_new_stext_struct(self, standard, raw, index)
       
    1:     def fz_paragraph_break(self):
               r"""
               Class-aware wrapper for `::fz_paragraph_break()`.
                       Attempt to break paragraphs at plausible places.
               """
>>>>>>         return _mupdf.FzStextPage_fz_paragraph_break(self)
       
    1:     def fz_search_stext_page(self, needle, hit_mark, hit_bbox, hit_max):
               r"""
               Class-aware wrapper for `::fz_search_stext_page()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_search_stext_page(const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
       
                       Search for occurrence of 'needle' in text page.
       
                       Return the number of quads and store hit quads in the passed in
                       array.
       
                       NOTE: This is an experimental interface and subject to change
                       without notice.
               """
>>>>>>         return _mupdf.FzStextPage_fz_search_stext_page(self, needle, hit_mark, hit_bbox, hit_max)
       
    1:     def fz_search_stext_page_cb(self, needle, cb, opaque):
               r"""
               Class-aware wrapper for `::fz_search_stext_page_cb()`.
                       Search for occurrence of 'needle' in text page.
       
                       Call callback once for each hit. This callback will receive
                       (potentially) multiple quads for each hit.
       
                       Returns the number of hits - note that this is potentially
                       different from (i.e. is not greater than) the number of quads
                       as returned by the non callback API.
       
                       NOTE: This is an experimental interface and subject to change
                       without notice.
               """
>>>>>>         return _mupdf.FzStextPage_fz_search_stext_page_cb(self, needle, cb, opaque)
       
    1:     def fz_segment_stext_page(self):
               r"""
               Class-aware wrapper for `::fz_segment_stext_page()`.
                       Perform segmentation analysis on an (unstructured) page to look for
                       recursive subdivisions.
       
                       Essentially this code attempts to split the page horizontally and/or
                       vertically repeatedly into smaller and smaller "segments" (divisions).
       
                       This minimises the reordering of the content, but some reordering
                       may be unavoidable.
       
                       Returns 0 if no changes were made to the document.
       
                       This is experimental code, and may change (or be removed) in future
                       versions!
               """
>>>>>>         return _mupdf.FzStextPage_fz_segment_stext_page(self)
       
    1:     def fz_segment_stext_rect(self, rect):
               r"""
               Class-aware wrapper for `::fz_segment_stext_rect()`.
                       Perform segmentation analysis on a rectangle of a given
                       stext page.
       
                       Like fz_segment_stext_page, this attempts to split the given page
                       region horizontally and/or vertically repeatedly into smaller and
                       smaller "segments".
       
                       This works for pages with structure too, but splitting with
                       rectangles that cut across structure blocks may not behave as
                       expected.
       
                       This minimises the reordering of the content (as viewed from the
                       perspective of a depth first traversal), but some reordering may
                       be unavoidable.
       
                       This function accepts smaller gaps for segmentation than the full
                       page segmentation does.
       
                       Returns 0 if no changes were made to the document.
       
                       This is experimental code, and may change (or be removed) in future
                       versions!
               """
>>>>>>         return _mupdf.FzStextPage_fz_segment_stext_rect(self, rect)
       
    1:     def fz_snap_selection(self, ap, bp, mode):
               r"""Class-aware wrapper for `::fz_snap_selection()`."""
>>>>>>         return _mupdf.FzStextPage_fz_snap_selection(self, ap, bp, mode)
       
    1:     def fz_stext_remove_page_fill(self):
               r"""Class-aware wrapper for `::fz_stext_remove_page_fill()`."""
>>>>>>         return _mupdf.FzStextPage_fz_stext_remove_page_fill(self)
       
    1:     def fz_table_hunt(self):
               r"""
               Class-aware wrapper for `::fz_table_hunt()`.
                       Hunt for possible tables on a page, and update the stext with
                       information.
               """
>>>>>>         return _mupdf.FzStextPage_fz_table_hunt(self)
       
    1:     def fz_table_hunt_within_bounds(self, bounds):
               r"""
               Class-aware wrapper for `::fz_table_hunt_within_bounds()`.
                       Hunt for possible tables within a specific rect on a page, and
                       update the stext with information.
               """
>>>>>>         return _mupdf.FzStextPage_fz_table_hunt_within_bounds(self, bounds)
       
    1:     def fz_copy_selection(self, a, b, crlf):
               r"""Wrapper for fz_copy_selection() that returns std::string."""
>>>>>>         return _mupdf.FzStextPage_fz_copy_selection(self, a, b, crlf)
       
    1:     def fz_copy_rectangle(self, area, crlf):
               r"""Wrapper for fz_copy_rectangle() that returns a std::string."""
>>>>>>         return _mupdf.FzStextPage_fz_copy_rectangle(self, area, crlf)
       
    1:     def search_stext_page(self, needle, hit_mark, max_quads):
               r"""Wrapper for fz_search_stext_page() that returns std::vector of Quads."""
>>>>>>         return _mupdf.FzStextPage_search_stext_page(self, needle, hit_mark, max_quads)
       
    1:     def begin(self):
               r"""Used for iteration over linked list of FzStextBlock items starting at fz_stext_block::first_block."""
>>>>>>         return _mupdf.FzStextPage_begin(self)
       
    1:     def end(self):
               r"""Used for iteration over linked list of FzStextBlock items starting at fz_stext_block::first_block."""
>>>>>>         return _mupdf.FzStextPage_end(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_stext_page()`.
                               Create an empty text page.
       
                               The text page is filled out by the text device to contain the
                               blocks and lines of text on the page.
       
                               mediabox: optional mediabox information.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_stext_page_from_chapter_page_number()`.
       
               |
       
               *Overload 3:*
                Constructor using `fz_new_stext_page_from_display_list()`.
       
               |
       
               *Overload 4:*
                Constructor using `fz_new_stext_page_from_page()`.
                               Extract text from page.
       
                               Ownership of the fz_stext_page is returned to the caller.
       
       
               |
       
               *Overload 5:*
                Constructor using `fz_new_stext_page_from_page_number()`.
       
               |
       
               *Overload 6:*
                Constructor using `pdf_new_stext_page_from_annot()`.
       
               |
       
               *Overload 7:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 8:*
                Constructor using raw copy of pre-existing `::fz_stext_page`.
               """
>>>>>>         _mupdf.FzStextPage_swiginit(self, _mupdf.new_FzStextPage(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStextPage
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStextPage_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStextPage___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStextPage_m_internal_get, _mupdf.FzStextPage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStextPage_s_num_instances_get, _mupdf.FzStextPage_s_num_instances_set)
       
       # Register FzStextPage in _mupdf:
    1: _mupdf.FzStextPage_swigregister(FzStextPage)
    2: class FzStextPageBlockIterator(object):
    1:     r"""Wrapper class for struct `fz_stext_page_block_iterator`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_stext_page_block_iterator_eod(self):
               r"""Class-aware wrapper for `::fz_stext_page_block_iterator_eod()`."""
>>>>>>         return _mupdf.FzStextPageBlockIterator_fz_stext_page_block_iterator_eod(self)
       
    1:     def fz_stext_page_block_iterator_eod_dfs(self):
               r"""Class-aware wrapper for `::fz_stext_page_block_iterator_eod_dfs()`."""
>>>>>>         return _mupdf.FzStextPageBlockIterator_fz_stext_page_block_iterator_eod_dfs(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_stext_page_block_iterator`.
               """
>>>>>>         _mupdf.FzStextPageBlockIterator_swiginit(self, _mupdf.new_FzStextPageBlockIterator(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStextPageBlockIterator
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStextPageBlockIterator_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStextPageBlockIterator___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStextPageBlockIterator_m_internal_get, _mupdf.FzStextPageBlockIterator_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStextPageBlockIterator_s_num_instances_get, _mupdf.FzStextPageBlockIterator_s_num_instances_set)
       
       # Register FzStextPageBlockIterator in _mupdf:
    1: _mupdf.FzStextPageBlockIterator_swigregister(FzStextPageBlockIterator)
    2: class FzStextPageDetails(object):
    1:     r"""
           Wrapper class for struct `fz_stext_page_details`. Not copyable or assignable.
           A note on stext's handling of structure.
       
           A PDF document can contain a structure tree. This gives the
           structure of a document in its entirety as a tree. e.g.
       
           Tree                        MCID    INDEX
           -------------------------------------
           DOC                 0       0
            TOC                        1       0
             TOC_ITEM          2       0
             TOC_ITEM          3       1
             TOC_ITEM          4       2
             ...
            STORY                      100     1
             SECTION           101     0
              HEADING          102     0
              SUBSECTION               103     1
               PARAGRAPH               104     0
               PARAGRAPH               105     1
               PARAGRAPH               106     2
              SUBSECTION               107     2
               PARAGRAPH               108     0
               PARAGRAPH               109     1
               PARAGRAPH               110     2
              ...
             SECTION           200     1
               ...
       
           Each different section of the tree is identified as part of an
           MCID by a number (this is a slight simplification, but makes the
           explanation easier).
       
           The PDF document contains markings that say "Entering MCID 0"
           and "Leaving MCID 0". Any content within that region is therefore
           identified as appearing in that particular structural region.
       
           This means that content can be sent in the document in a different
           order to which it appears 'logically' in the tree.
       
           MuPDF converts this tree form into a nested series of calls to
           begin_structure and end_structure.
       
           For instance, if the document started out with MCID 100, then
           we'd send:
               begin_structure("DOC")
               begin_structure("STORY")
       
           The problem with this is that if we send:
               begin_structure("DOC")
               begin_structure("STORY")
               begin_structure("SECTION")
               begin_structure("SUBSECTION")
       
           or
               begin_structure("DOC")
               begin_structure("STORY")
               begin_structure("SECTION")
               begin_structure("HEADING")
       
           How do I know what order the SECTION and HEADING should appear in?
           Are they even in the same STORY? Or the same DOC?
       
           Accordingly, every begin_structure is accompanied not only with the
           node type, but with an index. The index is the number of this node
           within this level of the tree. Hence:
       
               begin_structure("DOC", 0)
               begin_structure("STORY", 0)
               begin_structure("SECTION", 0)
               begin_structure("HEADING", 0)
           and
               begin_structure("DOC", 0)
               begin_structure("STORY", 0)
               begin_structure("SECTION", 0)
               begin_structure("SUBSECTION", 1)
       
           are now unambiguous in their describing of the tree.
       
           MuPDF automatically sends the minimal end_structure/begin_structure
           pairs to move us between nodes in the tree.
       
           In order to accommodate this information within the structured text
           data structures an additional block type is used. Previously a
           "page" was just a list of blocks, either text or images. e.g.
       
           [BLOCK:TEXT] <-> [BLOCK:IMG] <-> [BLOCK:TEXT] <-> [BLOCK:TEXT] ...
       
           We now introduce a new type of block, STRUCT, that turns this into
           a tree:
       
           [BLOCK:TEXT] <-> [BLOCK:STRUCT(IDX=0)] <-> [BLOCK:TEXT] <-> ...
                                 /|
           [STRUCT:TYPE=DOC] <----
               |
           [BLOCK:TEXT] <-> [BLOCK:STRUCT(IDX=0)] <-> [BLOCK:TEXT] <-> ...
                                 /|
           [STRUCT:TYPE=STORY] <--
               |
              ...
       
           Rather than doing a simple linear traversal of the list to extract
           the logical data, a caller now has to do a depth-first traversal.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_stext_page_details`.
               """
>>>>>>         _mupdf.FzStextPageDetails_swiginit(self, _mupdf.new_FzStextPageDetails(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStextPageDetails
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStextPageDetails_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStextPageDetails___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStextPageDetails_m_internal_get, _mupdf.FzStextPageDetails_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStextPageDetails_s_num_instances_get, _mupdf.FzStextPageDetails_s_num_instances_set)
       
       # Register FzStextPageDetails in _mupdf:
    1: _mupdf.FzStextPageDetails_swigregister(FzStextPageDetails)
    2: class FzStextStruct(object):
    1:     r"""Wrapper class for struct `fz_stext_struct`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_stext_struct`.
               """
>>>>>>         _mupdf.FzStextStruct_swiginit(self, _mupdf.new_FzStextStruct(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStextStruct
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStextStruct_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStextStruct___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStextStruct_m_internal_get, _mupdf.FzStextStruct_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStextStruct_s_num_instances_get, _mupdf.FzStextStruct_s_num_instances_set)
       
       # Register FzStextStruct in _mupdf:
    1: _mupdf.FzStextStruct_swigregister(FzStextStruct)
    2: class FzStorable(object):
    1:     r"""
           Wrapper class for struct `fz_storable`.
           Resource store
       
           MuPDF stores decoded "objects" into a store for potential reuse.
           If the size of the store gets too big, objects stored within it
           can be evicted and freed to recover space. When MuPDF comes to
           decode such an object, it will check to see if a version of this
           object is already in the store - if it is, it will simply reuse
           it. If not, it will decode it and place it into the store.
       
           All objects that can be placed into the store are derived from
           the fz_storable type (i.e. this should be the first component of
           the objects structure). This allows for consistent (thread safe)
           reference counting, and includes a function that will be called
           to free the object as soon as the reference count reaches zero.
       
           Most objects offer fz_keep_XXXX/fz_drop_XXXX functions derived
           from fz_keep_storable/fz_drop_storable. Creation of such objects
           includes a call to FZ_INIT_STORABLE to set up the fz_storable
           header.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Copy constructor using `fz_keep_storable()`.
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_storable`.
               """
>>>>>>         _mupdf.FzStorable_swiginit(self, _mupdf.new_FzStorable(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStorable
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStorable_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStorable___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStorable_m_internal_get, _mupdf.FzStorable_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStorable_s_num_instances_get, _mupdf.FzStorable_s_num_instances_set)
       
       # Register FzStorable in _mupdf:
    1: _mupdf.FzStorable_swigregister(FzStorable)
    2: class FzStore(object):
    1:     r"""Wrapper class for struct `fz_store`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_store`.
               """
>>>>>>         _mupdf.FzStore_swiginit(self, _mupdf.new_FzStore(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStore
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStore_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStore___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStore_m_internal_get, _mupdf.FzStore_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStore_s_num_instances_get, _mupdf.FzStore_s_num_instances_set)
       
       # Register FzStore in _mupdf:
    1: _mupdf.FzStore_swigregister(FzStore)
    2: class FzStoreHash(object):
    1:     r"""
           Wrapper class for struct `fz_store_hash`. Not copyable or assignable.
           The store can be seen as a dictionary that maps keys to
           fz_storable values. In order to allow keys of different types to
           be stored, we have a structure full of functions for each key
           'type'; this fz_store_type pointer is stored with each key, and
           tells the store how to perform certain operations (like taking/
           dropping a reference, comparing two keys, outputting details for
           debugging etc).
       
           The store uses a hash table internally for speed where possible.
           In order for this to work, we need a mechanism for turning a
           generic 'key' into 'a hashable string'. For this purpose the
           type structure contains a make_hash_key function pointer that
           maps from a void * to a fz_store_hash structure. If
           make_hash_key function returns 0, then the key is determined not
           to be hashable, and the value is not stored in the hash table.
       
           Some objects can be used both as values within the store, and as
           a component of keys within the store. We refer to these objects
           as "key storable" objects. In this case, we need to take
           additional care to ensure that we do not end up keeping an item
           within the store, purely because its value is referred to by
           another key in the store.
       
           An example of this are fz_images in PDF files. Each fz_image is
           placed into the     store to enable it to be easily reused. When the
           image is rendered, a pixmap is generated from the image, and the
           pixmap is placed into the store so it can be reused on
           subsequent renders. The image forms part of the key for the
           pixmap.
       
           When we close the pdf document (and any associated pages/display
           lists etc), we drop the images from the store. This may leave us
           in the position of the images having non-zero reference counts
           purely because they are used as part of the keys for the
           pixmaps.
       
           We therefore use special reference counting functions to keep
           track of these "key storable" items, and hence store the number
           of references to these items that are used in keys.
       
           When the number of references to an object == the number of
           references to an object from keys in the store, we know that we
           can remove all the items which have that object as part of the
           key. This is done by running a pass over the store, 'reaping'
           those items.
       
           Reap passes are slower than we would like as they touch every
           item in the store. We therefore provide a way to 'batch' such
           reap passes together, using fz_defer_reap_start/
           fz_defer_reap_end to bracket a region in which many may be
           triggered.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_store_hash`.
               """
>>>>>>         _mupdf.FzStoreHash_swiginit(self, _mupdf.new_FzStoreHash(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStoreHash
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStoreHash_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStoreHash___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStoreHash_m_internal_get, _mupdf.FzStoreHash_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStoreHash_s_num_instances_get, _mupdf.FzStoreHash_s_num_instances_set)
       
       # Register FzStoreHash in _mupdf:
    1: _mupdf.FzStoreHash_swigregister(FzStoreHash)
    2: class FzStoreType(object):
    1:     r"""
           Wrapper class for struct `fz_store_type`. Not copyable or assignable.
           Every type of object to be placed into the store defines an
           fz_store_type. This contains the pointers to functions to
           make hashes, manipulate keys, and check for needing reaping.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_store_type`.
               """
>>>>>>         _mupdf.FzStoreType_swiginit(self, _mupdf.new_FzStoreType(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStoreType
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStoreType_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStoreType___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStoreType_m_internal_get, _mupdf.FzStoreType_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStoreType_s_num_instances_get, _mupdf.FzStoreType_s_num_instances_set)
       
       # Register FzStoreType in _mupdf:
    1: _mupdf.FzStoreType_swigregister(FzStoreType)
    2: class FzStory(object):
    1:     r"""Wrapper class for struct `fz_story`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_draw_story(self, dev, ctm):
               r"""Class-aware wrapper for `::fz_draw_story()`."""
>>>>>>         return _mupdf.FzStory_fz_draw_story(self, dev, ctm)
       
    1:     def fz_place_story(self, where, filled):
               r"""Class-aware wrapper for `::fz_place_story()`."""
>>>>>>         return _mupdf.FzStory_fz_place_story(self, where, filled)
       
    1:     def fz_place_story_flags(self, where, filled, flags):
               r"""Class-aware wrapper for `::fz_place_story_flags()`."""
>>>>>>         return _mupdf.FzStory_fz_place_story_flags(self, where, filled, flags)
       
    1:     def fz_reset_story(self):
               r"""Class-aware wrapper for `::fz_reset_story()`."""
>>>>>>         return _mupdf.FzStory_fz_reset_story(self)
       
    1:     def fz_story_document(self):
               r"""Class-aware wrapper for `::fz_story_document()`."""
>>>>>>         return _mupdf.FzStory_fz_story_document(self)
       
    1:     def fz_story_positions(self, cb, arg):
               r"""Class-aware wrapper for `::fz_story_positions()`."""
>>>>>>         return _mupdf.FzStory_fz_story_positions(self, cb, arg)
       
    1:     def fz_story_warnings(self):
               r"""Class-aware wrapper for `::fz_story_warnings()`."""
>>>>>>         return _mupdf.FzStory_fz_story_warnings(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `fz_new_story()`.
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_story`.
               """
>>>>>>         _mupdf.FzStory_swiginit(self, _mupdf.new_FzStory(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStory
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStory_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStory___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStory_m_internal_get, _mupdf.FzStory_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStory_s_num_instances_get, _mupdf.FzStory_s_num_instances_set)
       
       # Register FzStory in _mupdf:
    1: _mupdf.FzStory_swigregister(FzStory)
    2: class FzStoryElementPosition(object):
    1:     r"""Wrapper class for struct `fz_story_element_position`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_story_element_position`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_story_element_position`.
               """
>>>>>>         _mupdf.FzStoryElementPosition_swiginit(self, _mupdf.new_FzStoryElementPosition(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.FzStoryElementPosition_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_FzStoryElementPosition
    1:     depth = property(_mupdf.FzStoryElementPosition_depth_get, _mupdf.FzStoryElementPosition_depth_set)
    1:     heading = property(_mupdf.FzStoryElementPosition_heading_get, _mupdf.FzStoryElementPosition_heading_set)
    1:     id = property(_mupdf.FzStoryElementPosition_id_get, _mupdf.FzStoryElementPosition_id_set)
    1:     href = property(_mupdf.FzStoryElementPosition_href_get, _mupdf.FzStoryElementPosition_href_set)
    1:     rect = property(_mupdf.FzStoryElementPosition_rect_get, _mupdf.FzStoryElementPosition_rect_set)
    1:     text = property(_mupdf.FzStoryElementPosition_text_get, _mupdf.FzStoryElementPosition_text_set)
    1:     open_close = property(_mupdf.FzStoryElementPosition_open_close_get, _mupdf.FzStoryElementPosition_open_close_set)
    1:     rectangle_num = property(_mupdf.FzStoryElementPosition_rectangle_num_get, _mupdf.FzStoryElementPosition_rectangle_num_set)
    1:     s_num_instances = property(_mupdf.FzStoryElementPosition_s_num_instances_get, _mupdf.FzStoryElementPosition_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzStoryElementPosition_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzStoryElementPosition___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzStoryElementPosition___ne__(self, rhs)
       
       # Register FzStoryElementPosition in _mupdf:
    1: _mupdf.FzStoryElementPosition_swigregister(FzStoryElementPosition)
    2: class FzStream(object):
    1:     r"""
           Wrapper class for struct `fz_stream`.
           fz_stream is a buffered reader capable of seeking in both
           directions.
       
           Streams are reference counted, so references must be dropped
           by a call to fz_drop_stream.
       
           Only the data between rp and wp is valid.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    2:     @staticmethod
    2:     def fz_open_file_autodelete(filename):
               r"""
               Class-aware wrapper for `::fz_open_file_autodelete()`.
                       Do the same as fz_open_file, but delete the file upon close.
               """
>>>>>>         return _mupdf.FzStream_fz_open_file_autodelete(filename)
       
    1:     def fz_available(self, max):
               r"""
               Class-aware wrapper for `::fz_available()`.
                       Ask how many bytes are available immediately from
                       a given stream.
       
                       stm: The stream to read from.
       
                       max: A hint for the underlying stream; the maximum number of
                       bytes that we are sure we will want to read. If you do not know
                       this number, give 1.
       
                       Returns the number of bytes immediately available between the
                       read and write pointers. This number is guaranteed only to be 0
                       if we have hit EOF. The number of bytes returned here need have
                       no relation to max (could be larger, could be smaller).
               """
>>>>>>         return _mupdf.FzStream_fz_available(self, max)
       
    1:     def fz_decomp_image_from_stream(self, image, subarea, indexed, l2factor, l2extra):
               r"""
               Class-aware wrapper for `::fz_decomp_image_from_stream()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_decomp_image_from_stream(::fz_compressed_image *image, ::fz_irect *subarea, int indexed, int l2factor)` => `(fz_pixmap *, int l2extra)`
       
                       Decode a subarea of a compressed image. l2factor is the amount
                       of subsampling inbuilt to the stream (i.e. performed by the
                       decoder). If non NULL, l2extra is the extra amount of
                       subsampling that should be performed by this routine. This will
                       be updated on exit to the amount of subsampling that is still
                       required to be done.
       
                       Returns a kept reference.
               """
>>>>>>         return _mupdf.FzStream_fz_decomp_image_from_stream(self, image, subarea, indexed, l2factor, l2extra)
       
    1:     def fz_is_cfb_archive(self):
               r"""
               Class-aware wrapper for `::fz_is_cfb_archive()`.
                       Detect if stream object is a cfb archive.
       
                       Assumes that the stream object is seekable.
               """
>>>>>>         return _mupdf.FzStream_fz_is_cfb_archive(self)
       
    1:     def fz_is_eof(self):
               r"""
               Class-aware wrapper for `::fz_is_eof()`.
                       Query if the stream has reached EOF (during normal bytewise
                       reading).
       
                       See fz_is_eof_bits for the equivalent function for bitwise
                       reading.
               """
>>>>>>         return _mupdf.FzStream_fz_is_eof(self)
       
    1:     def fz_is_eof_bits(self):
               r"""
               Class-aware wrapper for `::fz_is_eof_bits()`.
                       Query if the stream has reached EOF (during bitwise
                       reading).
       
                       See fz_is_eof for the equivalent function for bytewise
                       reading.
               """
>>>>>>         return _mupdf.FzStream_fz_is_eof_bits(self)
       
    1:     def fz_is_libarchive_archive(self):
               r"""
               Class-aware wrapper for `::fz_is_libarchive_archive()`.
                       Detect if stream object is an archive supported by libarchive.
       
                       Assumes that the stream object is seekable.
               """
>>>>>>         return _mupdf.FzStream_fz_is_libarchive_archive(self)
       
    1:     def fz_is_tar_archive(self):
               r"""
               Class-aware wrapper for `::fz_is_tar_archive()`.
                       Detect if stream object is a tar archive.
       
                       Assumes that the stream object is seekable.
               """
>>>>>>         return _mupdf.FzStream_fz_is_tar_archive(self)
       
    1:     def fz_is_zip_archive(self):
               r"""
               Class-aware wrapper for `::fz_is_zip_archive()`.
                       Detect if stream object is a zip archive.
       
                       Assumes that the stream object is seekable.
               """
>>>>>>         return _mupdf.FzStream_fz_is_zip_archive(self)
       
    1:     def fz_new_archive_of_size(self, size):
               r"""Class-aware wrapper for `::fz_new_archive_of_size()`."""
>>>>>>         return _mupdf.FzStream_fz_new_archive_of_size(self, size)
       
    1:     def fz_open_a85d(self):
               r"""
               Class-aware wrapper for `::fz_open_a85d()`.
                       a85d filter performs ASCII 85 Decoding of data read
                       from the chained filter.
               """
>>>>>>         return _mupdf.FzStream_fz_open_a85d(self)
       
    1:     def fz_open_aesd(self, key, keylen):
               r"""
               Class-aware wrapper for `::fz_open_aesd()`.
                       aesd filter performs AES decoding of data read from the chained
                       filter using the supplied key.
               """
>>>>>>         return _mupdf.FzStream_fz_open_aesd(self, key, keylen)
       
    1:     def fz_open_ahxd(self):
               r"""
               Class-aware wrapper for `::fz_open_ahxd()`.
                       ahxd filter performs ASCII Hex decoding of data read
                       from the chained filter.
               """
>>>>>>         return _mupdf.FzStream_fz_open_ahxd(self)
       
    1:     def fz_open_arc4(self, key, keylen):
               r"""
               Class-aware wrapper for `::fz_open_arc4()`.
                       arc4 filter performs RC4 decoding of data read from the chained
                       filter using the supplied key.
               """
>>>>>>         return _mupdf.FzStream_fz_open_arc4(self, key, keylen)
       
    1:     def fz_open_archive_with_stream(self):
               r"""
               Class-aware wrapper for `::fz_open_archive_with_stream()`.
                       Open zip or tar archive stream.
       
                       Open an archive using a seekable stream object rather than
                       opening a file or directory on disk.
               """
>>>>>>         return _mupdf.FzStream_fz_open_archive_with_stream(self)
       
    1:     def fz_open_brotlid(self):
               r"""
               Class-aware wrapper for `::fz_open_brotlid()`.
                       brotlid filter performs Brotli decoding of data read
                       from the chained filter.
               """
>>>>>>         return _mupdf.FzStream_fz_open_brotlid(self)
       
    1:     def fz_open_cfb_archive_with_stream(self):
               r"""
               Class-aware wrapper for `::fz_open_cfb_archive_with_stream()`.
                       Open a cfb file as an archive.
       
                       Open an archive using a seekable stream object rather than
                       opening a file or directory on disk.
       
                       An exception is thrown if the file is not recognised as a chm.
               """
>>>>>>         return _mupdf.FzStream_fz_open_cfb_archive_with_stream(self)
       
    1:     def fz_open_dctd(self, color_transform, invert_cmyk, l2factor, jpegtables):
               r"""
               Class-aware wrapper for `::fz_open_dctd()`.
                       dctd filter performs DCT (JPEG) decoding of data read
                       from the chained filter.
       
                       color_transform implements the PDF color_transform option
                               use -1 for default behavior
                               use 0 to disable YUV-RGB / YCCK-CMYK transforms
                               use 1 to enable YUV-RGB / YCCK-CMYK transforms
       
                       invert_cmyk implements the necessary inversion for Photoshop CMYK images
                               use 0 if embedded in PDF
                               use 1 if not embedded in PDF
       
                       For subsampling on decode, set l2factor to the log2 of the
                       reduction required (therefore 0 = full size decode).
       
                       jpegtables is an optional stream from which the JPEG tables
                       can be read. Use NULL if not required.
               """
>>>>>>         return _mupdf.FzStream_fz_open_dctd(self, color_transform, invert_cmyk, l2factor, jpegtables)
       
    1:     def fz_open_endstream_filter(self, len, offset):
               r"""
               Class-aware wrapper for `::fz_open_endstream_filter()`.
                       The endstream filter reads a PDF substream, and starts to look
                       for an 'endstream' token after the specified length.
               """
>>>>>>         return _mupdf.FzStream_fz_open_endstream_filter(self, len, offset)
       
    1:     def fz_open_faxd(self, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1):
               r"""
               Class-aware wrapper for `::fz_open_faxd()`.
                       faxd filter performs FAX decoding of data read from
                       the chained filter.
       
                       k: see fax specification (fax default is 0).
       
                       end_of_line: whether we expect end of line markers (fax default
                       is 0).
       
                       encoded_byte_align: whether we align to bytes after each line
                       (fax default is 0).
       
                       columns: how many columns in the image (fax default is 1728).
       
                       rows: 0 for unspecified or the number of rows of data to expect.
       
                       end_of_block: whether we expect end of block markers (fax
                       default is 1).
       
                       black_is_1: determines the polarity of the image (fax default is
                       0).
               """
>>>>>>         return _mupdf.FzStream_fz_open_faxd(self, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1)
       
    1:     def fz_open_flated(self, window_bits):
               r"""
               Class-aware wrapper for `::fz_open_flated()`.
                       flated filter performs LZ77 decoding (inflating) of data read
                       from the chained filter.
       
                       window_bits: How large a decompression window to use. Typically
                       15. A negative number, -n, means to use n bits, but to expect
                       raw data with no header.
               """
>>>>>>         return _mupdf.FzStream_fz_open_flated(self, window_bits)
       
    1:     def fz_open_image_decomp_stream(self, arg_1, l2factor):
               r"""
               Class-aware wrapper for `::fz_open_image_decomp_stream()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_open_image_decomp_stream(::fz_compression_params *arg_1)` => `(fz_stream *, int l2factor)`
       
                       Open a stream to read the decompressed version of another stream
                       with optional log2 subsampling.
               """
>>>>>>         return _mupdf.FzStream_fz_open_image_decomp_stream(self, arg_1, l2factor)
       
    1:     def fz_open_jbig2d(self, globals, embedded):
               r"""
               Class-aware wrapper for `::fz_open_jbig2d()`.
                       Open a filter that performs jbig2 decompression on the chained
                       stream, using the optional globals record.
               """
>>>>>>         return _mupdf.FzStream_fz_open_jbig2d(self, globals, embedded)
       
    1:     def fz_open_leecher(self, buf):
               r"""
               Class-aware wrapper for `::fz_open_leecher()`.
                       Attach a filter to a stream that will store any
                       characters read from the stream into the supplied buffer.
       
                       chain: The underlying stream to leech from.
       
                       buf: The buffer into which the read data should be appended.
                       The buffer will be resized as required.
       
                       Returns pointer to newly created stream. May throw exceptions on
                       failure to allocate.
               """
>>>>>>         return _mupdf.FzStream_fz_open_leecher(self, buf)
       
    1:     def fz_open_libarchive_archive_with_stream(self):
               r"""
               Class-aware wrapper for `::fz_open_libarchive_archive_with_stream()`.
                       Open an archive using libarchive.
       
                       Open an archive using a seekable stream object rather than
                       opening a file or directory on disk.
       
                       An exception is thrown if the stream is not supported by libarchive.
               """
>>>>>>         return _mupdf.FzStream_fz_open_libarchive_archive_with_stream(self)
       
    1:     def fz_open_libarchived(self):
               r"""
               Class-aware wrapper for `::fz_open_libarchived()`.
                       libarchived filter performs generic compressed decoding of data
                       in any format understood by libarchive from the chained filter.
       
                       This will throw an exception if libarchive is not built in, or
                       if the compression format is not recognised.
               """
>>>>>>         return _mupdf.FzStream_fz_open_libarchived(self)
       
    1:     def fz_open_lzwd(self, early_change, min_bits, reverse_bits, old_tiff):
               r"""
               Class-aware wrapper for `::fz_open_lzwd()`.
                       lzwd filter performs LZW decoding of data read from the chained
                       filter.
       
                       early_change: (Default 1) specifies whether to change codes 1
                       bit early.
       
                       min_bits: (Default 9) specifies the minimum number of bits to
                       use.
       
                       reverse_bits: (Default 0) allows for compatibility with gif and
                       old style tiffs (1).
       
                       old_tiff: (Default 0) allows for different handling of the clear
                       code, as found in old style tiffs.
               """
>>>>>>         return _mupdf.FzStream_fz_open_lzwd(self, early_change, min_bits, reverse_bits, old_tiff)
       
    1:     def fz_open_null_filter(self, len, offset):
               r"""
               Class-aware wrapper for `::fz_open_null_filter()`.
                       The null filter reads a specified amount of data from the
                       substream.
               """
>>>>>>         return _mupdf.FzStream_fz_open_null_filter(self, len, offset)
       
    1:     def fz_open_predict(self, predictor, columns, colors, bpc):
               r"""
               Class-aware wrapper for `::fz_open_predict()`.
                       predict filter performs pixel prediction on data read from
                       the chained filter.
       
                       predictor: 1 = copy, 2 = tiff, other = inline PNG predictor
       
                       columns: width of image in pixels
       
                       colors: number of components.
       
                       bpc: bits per component (typically 8)
               """
>>>>>>         return _mupdf.FzStream_fz_open_predict(self, predictor, columns, colors, bpc)
       
    1:     def fz_open_range_filter(self, ranges, nranges):
               r"""
               Class-aware wrapper for `::fz_open_range_filter()`.
                       The range filter copies data from specified ranges of the
                       chained stream.
               """
>>>>>>         return _mupdf.FzStream_fz_open_range_filter(self, ranges, nranges)
       
    1:     def fz_open_rld(self):
               r"""
               Class-aware wrapper for `::fz_open_rld()`.
                       rld filter performs Run Length Decoding of data read
                       from the chained filter.
               """
>>>>>>         return _mupdf.FzStream_fz_open_rld(self)
       
    1:     def fz_open_sgilog16(self, w):
               r"""
               Class-aware wrapper for `::fz_open_sgilog16()`.
                       SGI Log 16bit (greyscale) decode from the chained filter.
                       Decodes lines of w pixels to 8bpp greyscale.
               """
>>>>>>         return _mupdf.FzStream_fz_open_sgilog16(self, w)
       
    1:     def fz_open_sgilog24(self, w):
               r"""
               Class-aware wrapper for `::fz_open_sgilog24()`.
                       SGI Log 24bit (LUV) decode from the chained filter.
                       Decodes lines of w pixels to 8bpc rgb.
               """
>>>>>>         return _mupdf.FzStream_fz_open_sgilog24(self, w)
       
    1:     def fz_open_sgilog32(self, w):
               r"""
               Class-aware wrapper for `::fz_open_sgilog32()`.
                       SGI Log 32bit (LUV) decode from the chained filter.
                       Decodes lines of w pixels to 8bpc rgb.
               """
>>>>>>         return _mupdf.FzStream_fz_open_sgilog32(self, w)
       
    1:     def fz_open_tar_archive_with_stream(self):
               r"""
               Class-aware wrapper for `::fz_open_tar_archive_with_stream()`.
                       Open a tar archive stream.
       
                       Open an archive using a seekable stream object rather than
                       opening a file or directory on disk.
       
                       An exception is thrown if the stream is not a tar archive as
                       indicated by the presence of a tar signature.
       
               """
>>>>>>         return _mupdf.FzStream_fz_open_tar_archive_with_stream(self)
       
    1:     def fz_open_thunder(self, w):
               r"""
               Class-aware wrapper for `::fz_open_thunder()`.
                       4bit greyscale Thunderscan decoding from the chained filter.
                       Decodes lines of w pixels to 8bpp greyscale.
               """
>>>>>>         return _mupdf.FzStream_fz_open_thunder(self, w)
       
    1:     def fz_open_zip_archive_with_stream(self):
               r"""
               Class-aware wrapper for `::fz_open_zip_archive_with_stream()`.
                       Open a zip archive stream.
       
                       Open an archive using a seekable stream object rather than
                       opening a file or directory on disk.
       
                       An exception is thrown if the stream is not a zip archive as
                       indicated by the presence of a zip signature.
       
               """
>>>>>>         return _mupdf.FzStream_fz_open_zip_archive_with_stream(self)
       
    1:     def fz_parse_xml_stream(self, preserve_white):
               r"""
               Class-aware wrapper for `::fz_parse_xml_stream()`.
                       Parse the contents of buffer into a tree of xml nodes.
       
                       preserve_white: whether to keep or delete all-whitespace nodes.
               """
>>>>>>         return _mupdf.FzStream_fz_parse_xml_stream(self, preserve_white)
       
    1:     def fz_peek_byte(self):
               r"""
               Class-aware wrapper for `::fz_peek_byte()`.
                       Peek at the next byte in a stream.
       
                       stm: The stream to peek at.
       
                       Returns -1 for EOF, or the next byte that will be read.
               """
>>>>>>         return _mupdf.FzStream_fz_peek_byte(self)
       
    1:     def fz_read(self, data, len):
               r"""
               Class-aware wrapper for `::fz_read()`.
                       Read from a stream into a given data block.
       
                       stm: The stream to read from.
       
                       data: The data block to read into.
       
                       len: The length of the data block (in bytes).
       
                       Returns the number of bytes read. May throw exceptions.
               """
>>>>>>         return _mupdf.FzStream_fz_read(self, data, len)
       
    1:     def fz_read_all(self, initial):
               r"""
               Class-aware wrapper for `::fz_read_all()`.
                       Read all of a stream into a buffer.
       
                       stm: The stream to read from
       
                       initial: Suggested initial size for the buffer.
       
                       Returns a buffer created from reading from the stream. May throw
                       exceptions on failure to allocate.
               """
>>>>>>         return _mupdf.FzStream_fz_read_all(self, initial)
       
    1:     def fz_read_best(self, initial, truncated, worst_case):
               r"""
               Class-aware wrapper for `::fz_read_best()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_read_best(size_t initial, size_t worst_case)` => `(fz_buffer *, int truncated)`
       
                       Attempt to read a stream into a buffer. If truncated
                       is NULL behaves as fz_read_all, sets a truncated flag in case of
                       error.
       
                       stm: The stream to read from.
       
                       initial: Suggested initial size for the buffer.
       
                       truncated: Flag to store success/failure indication in.
       
                       worst_case: 0 for unknown, otherwise an upper bound for the
                       size of the stream.
       
                       Returns a buffer created from reading from the stream.
               """
>>>>>>         return _mupdf.FzStream_fz_read_best(self, initial, truncated, worst_case)
       
    1:     def fz_read_bits(self, n):
               r"""
               Class-aware wrapper for `::fz_read_bits()`.
                       Read the next n bits from a stream (assumed to
                       be packed most significant bit first).
       
                       stm: The stream to read from.
       
                       n: The number of bits to read, between 1 and 8*sizeof(int)
                       inclusive.
       
                       Returns -1 for EOF, or the required number of bits.
               """
>>>>>>         return _mupdf.FzStream_fz_read_bits(self, n)
       
    1:     def fz_read_byte(self):
               r"""
               Class-aware wrapper for `::fz_read_byte()`.
                       Read the next byte from a stream.
       
                       stm: The stream t read from.
       
                       Returns -1 for end of stream, or the next byte. May
                       throw exceptions.
               """
>>>>>>         return _mupdf.FzStream_fz_read_byte(self)
       
    1:     def fz_read_float(self):
               r"""Class-aware wrapper for `::fz_read_float()`."""
>>>>>>         return _mupdf.FzStream_fz_read_float(self)
       
    1:     def fz_read_float_le(self):
               r"""Class-aware wrapper for `::fz_read_float_le()`."""
>>>>>>         return _mupdf.FzStream_fz_read_float_le(self)
       
    1:     def fz_read_int16(self):
               r"""Class-aware wrapper for `::fz_read_int16()`."""
>>>>>>         return _mupdf.FzStream_fz_read_int16(self)
       
    1:     def fz_read_int16_le(self):
               r"""Class-aware wrapper for `::fz_read_int16_le()`."""
>>>>>>         return _mupdf.FzStream_fz_read_int16_le(self)
       
    1:     def fz_read_int32(self):
               r"""Class-aware wrapper for `::fz_read_int32()`."""
>>>>>>         return _mupdf.FzStream_fz_read_int32(self)
       
    1:     def fz_read_int32_le(self):
               r"""Class-aware wrapper for `::fz_read_int32_le()`."""
>>>>>>         return _mupdf.FzStream_fz_read_int32_le(self)
       
    1:     def fz_read_int64(self):
               r"""Class-aware wrapper for `::fz_read_int64()`."""
>>>>>>         return _mupdf.FzStream_fz_read_int64(self)
       
    1:     def fz_read_int64_le(self):
               r"""Class-aware wrapper for `::fz_read_int64_le()`."""
>>>>>>         return _mupdf.FzStream_fz_read_int64_le(self)
       
    1:     def fz_read_line(self, buf, max):
               r"""
               Class-aware wrapper for `::fz_read_line()`.
                       Read a line from stream into the buffer until either a
                       terminating newline or EOF, which it replaces with a null byte
                       ('').
       
                       Returns buf on success, and NULL when end of file occurs while
                       no characters have been read.
               """
>>>>>>         return _mupdf.FzStream_fz_read_line(self, buf, max)
       
    1:     def fz_read_rbits(self, n):
               r"""
               Class-aware wrapper for `::fz_read_rbits()`.
                       Read the next n bits from a stream (assumed to
                       be packed least significant bit first).
       
                       stm: The stream to read from.
       
                       n: The number of bits to read, between 1 and 8*sizeof(int)
                       inclusive.
       
                       Returns (unsigned int)-1 for EOF, or the required number of bits.
               """
>>>>>>         return _mupdf.FzStream_fz_read_rbits(self, n)
       
    1:     def fz_read_rune(self):
               r"""
               Class-aware wrapper for `::fz_read_rune()`.
                       Read a utf-8 rune from a stream.
       
                       In the event of encountering badly formatted utf-8 codes
                       (such as a leading code with an unexpected number of following
                       codes) no error/exception is given, but undefined values may be
                       returned.
               """
>>>>>>         return _mupdf.FzStream_fz_read_rune(self)
       
    1:     def fz_read_string(self, buffer, len):
               r"""
               Class-aware wrapper for `::fz_read_string()`.
                       Read a null terminated string from the stream into
                       a buffer of a given length. The buffer will be null terminated.
                       Throws on failure (including the failure to fit the entire
                       string including the terminator into the buffer).
               """
>>>>>>         return _mupdf.FzStream_fz_read_string(self, buffer, len)
       
    1:     def fz_read_uint16(self):
               r"""
               Class-aware wrapper for `::fz_read_uint16()`.
                       fz_read_[u]int(16|24|32|64)(_le)?
       
                       Read a 16/32/64 bit signed/unsigned integer from stream,
                       in big or little-endian byte orders.
       
                       Throws an exception if EOF is encountered.
               """
>>>>>>         return _mupdf.FzStream_fz_read_uint16(self)
       
    1:     def fz_read_uint16_le(self):
               r"""Class-aware wrapper for `::fz_read_uint16_le()`."""
>>>>>>         return _mupdf.FzStream_fz_read_uint16_le(self)
       
    1:     def fz_read_uint24(self):
               r"""Class-aware wrapper for `::fz_read_uint24()`."""
>>>>>>         return _mupdf.FzStream_fz_read_uint24(self)
       
    1:     def fz_read_uint24_le(self):
               r"""Class-aware wrapper for `::fz_read_uint24_le()`."""
>>>>>>         return _mupdf.FzStream_fz_read_uint24_le(self)
       
    1:     def fz_read_uint32(self):
               r"""Class-aware wrapper for `::fz_read_uint32()`."""
>>>>>>         return _mupdf.FzStream_fz_read_uint32(self)
       
    1:     def fz_read_uint32_le(self):
               r"""Class-aware wrapper for `::fz_read_uint32_le()`."""
>>>>>>         return _mupdf.FzStream_fz_read_uint32_le(self)
       
    1:     def fz_read_uint64(self):
               r"""Class-aware wrapper for `::fz_read_uint64()`."""
>>>>>>         return _mupdf.FzStream_fz_read_uint64(self)
       
    1:     def fz_read_uint64_le(self):
               r"""Class-aware wrapper for `::fz_read_uint64_le()`."""
>>>>>>         return _mupdf.FzStream_fz_read_uint64_le(self)
       
    1:     def fz_read_utf16_be(self):
               r"""Class-aware wrapper for `::fz_read_utf16_be()`."""
>>>>>>         return _mupdf.FzStream_fz_read_utf16_be(self)
       
    1:     def fz_read_utf16_le(self):
               r"""
               Class-aware wrapper for `::fz_read_utf16_le()`.
                       Read a utf-16 rune from a stream. (little endian and
                       big endian respectively).
       
                       In the event of encountering badly formatted utf-16 codes
                       (mismatched surrogates) no error/exception is given, but
                       undefined values may be returned.
               """
>>>>>>         return _mupdf.FzStream_fz_read_utf16_le(self)
       
    1:     def fz_seek(self, offset, whence):
               r"""
               Class-aware wrapper for `::fz_seek()`.
                       Seek within a stream.
       
                       stm: The stream to seek within.
       
                       offset: The offset to seek to.
       
                       whence: From where the offset is measured (see fseek).
                       SEEK_SET - start of stream.
                       SEEK_CUR - current position.
                       SEEK_END - end of stream.
       
               """
>>>>>>         return _mupdf.FzStream_fz_seek(self, offset, whence)
       
    1:     def fz_skip(self, len):
               r"""
               Class-aware wrapper for `::fz_skip()`.
                       Read from a stream discarding data.
       
                       stm: The stream to read from.
       
                       len: The number of bytes to read.
       
                       Returns the number of bytes read. May throw exceptions.
               """
>>>>>>         return _mupdf.FzStream_fz_skip(self, len)
       
    1:     def fz_skip_space(self):
               r"""
               Class-aware wrapper for `::fz_skip_space()`.
                       Skip over whitespace (bytes <= 32) in a stream.
               """
>>>>>>         return _mupdf.FzStream_fz_skip_space(self)
       
    1:     def fz_skip_string(self, str):
               r"""
               Class-aware wrapper for `::fz_skip_string()`.
                       Skip over a given string in a stream. Return 0 if successfully
                       skipped, non-zero otherwise. As many characters will be skipped
                       over as matched in the string.
               """
>>>>>>         return _mupdf.FzStream_fz_skip_string(self, str)
       
    1:     def fz_stream_filename(self):
               r"""
               Class-aware wrapper for `::fz_stream_filename()`.
                       Return the filename (UTF-8 encoded) from which a stream was opened.
       
                       Returns NULL if the filename is not available (or the stream was
                       opened from a source other than a file).
               """
>>>>>>         return _mupdf.FzStream_fz_stream_filename(self)
       
    1:     def fz_sync_bits(self):
               r"""
               Class-aware wrapper for `::fz_sync_bits()`.
                       Called after reading bits to tell the stream
                       that we are about to return to reading bytewise. Resyncs
                       the stream to whole byte boundaries.
               """
>>>>>>         return _mupdf.FzStream_fz_sync_bits(self)
       
    1:     def fz_tell(self):
               r"""
               Class-aware wrapper for `::fz_tell()`.
                       return the current reading position within a stream
               """
>>>>>>         return _mupdf.FzStream_fz_tell(self)
       
    1:     def fz_try_open_archive_with_stream(self):
               r"""
               Class-aware wrapper for `::fz_try_open_archive_with_stream()`.
                       Open zip or tar archive stream.
       
                       Does the same as fz_open_archive_with_stream, but will not throw
                       an error in the event of failing to recognise the format. Will
                       still throw errors in other cases though!
               """
>>>>>>         return _mupdf.FzStream_fz_try_open_archive_with_stream(self)
       
    1:     def fz_unpack_stream(self, depth, w, h, n, indexed, pad, skip):
               r"""Class-aware wrapper for `::fz_unpack_stream()`."""
>>>>>>         return _mupdf.FzStream_fz_unpack_stream(self, depth, w, h, n, indexed, pad, skip)
       
    1:     def fz_unread_byte(self):
               r"""
               Class-aware wrapper for `::fz_unread_byte()`.
                       Unread the single last byte successfully
                       read from a stream. Do not call this without having
                       successfully read a byte.
       
                       stm: The stream to operate upon.
               """
>>>>>>         return _mupdf.FzStream_fz_unread_byte(self)
       
    1:     def pdf_load_cmap(self):
               r"""Class-aware wrapper for `::pdf_load_cmap()`."""
>>>>>>         return _mupdf.FzStream_pdf_load_cmap(self)
       
    1:     def pdf_open_crypt(self, crypt, num, gen):
               r"""Class-aware wrapper for `::pdf_open_crypt()`."""
>>>>>>         return _mupdf.FzStream_pdf_open_crypt(self, crypt, num, gen)
       
    1:     def pdf_open_crypt_with_filter(self, crypt, name, num, gen):
               r"""Class-aware wrapper for `::pdf_open_crypt_with_filter()`."""
>>>>>>         return _mupdf.FzStream_pdf_open_crypt_with_filter(self, crypt, name, num, gen)
       
    1:     def pdf_open_document_with_stream(self):
               r"""Class-aware wrapper for `::pdf_open_document_with_stream()`."""
>>>>>>         return _mupdf.FzStream_pdf_open_document_with_stream(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_stream()`.
                               Create a new stream object with the given
                               internal state and function pointers.
       
                               state: Internal state (opaque to everything but implementation).
       
                               next: Should provide the next set of bytes (up to max) of stream
                               data. Return the number of bytes read, or EOF when there is no
                               more data.
       
                               drop: Should clean up and free the internal state. May not
                               throw exceptions.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_open_file()`.
                               Open the named file and wrap it in a stream.
       
                               filename: Path to a file. On non-Windows machines the filename
                               should be exactly as it would be passed to fopen(2). On Windows
                               machines, the path should be UTF-8 encoded so that non-ASCII
                               characters can be represented. Other platforms do the encoding
                               as standard anyway (and in most cases, particularly for MacOS
                               and Linux, the encoding they use is UTF-8 anyway).
       
       
               |
       
               *Overload 3:*
                Constructor using `fz_open_file_ptr_no_close()`.
                               Create a stream from a FILE * that will not be closed
                               when the stream is dropped.
       
       
               |
       
               *Overload 4:*
                Constructor using `fz_open_memory()`.
                               Open a block of memory as a stream.
       
                               data: Pointer to start of data block. Ownership of the data
                               block is NOT passed in.
       
                               len: Number of bytes in data block.
       
                               Returns pointer to newly created stream. May throw exceptions on
                               failure to allocate.
       
       
               |
       
               *Overload 5:*
                Construct using fz_open_file().
       
               |
       
               *Overload 6:*
                Copy constructor using `fz_keep_stream()`.
       
               |
       
               *Overload 7:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 8:*
                Constructor using raw copy of pre-existing `::fz_stream`.
               """
>>>>>>         _mupdf.FzStream_swiginit(self, _mupdf.new_FzStream(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStream
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStream_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStream___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStream_m_internal_get, _mupdf.FzStream_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStream_s_num_instances_get, _mupdf.FzStream_s_num_instances_set)
       
       # Register FzStream in _mupdf:
    1: _mupdf.FzStream_swigregister(FzStream)
    2: class FzString(object):
    1:     r"""Wrapper class for struct `fz_string`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `fz_new_string()`.
       
               |
       
               *Overload 2:*
               Copy constructor using `fz_keep_string()`.
       
               |
       
               *Overload 3:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 4:*
               Constructor using raw copy of pre-existing `::fz_string`.
               """
>>>>>>         _mupdf.FzString_swiginit(self, _mupdf.new_FzString(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzString
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzString_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzString___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzString_m_internal_get, _mupdf.FzString_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzString_s_num_instances_get, _mupdf.FzString_s_num_instances_set)
       
       # Register FzString in _mupdf:
    1: _mupdf.FzString_swigregister(FzString)
    2: class FzStrokeState(object):
    1:     r"""Wrapper class for struct `fz_stroke_state`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_clone_stroke_state(self):
               r"""
               Class-aware wrapper for `::fz_clone_stroke_state()`.
                       Create an identical stroke_state structure and return a
                       reference to it.
       
                       stroke: The stroke state reference to clone.
       
                       Exceptions may be thrown in the event of a failure to
                       allocate.
               """
>>>>>>         return _mupdf.FzStrokeState_fz_clone_stroke_state(self)
       
    1:     def fz_stroke_state_eq(self, b):
               r"""Class-aware wrapper for `::fz_stroke_state_eq()`."""
>>>>>>         return _mupdf.FzStrokeState_fz_stroke_state_eq(self, b)
       
    1:     def fz_unshare_stroke_state(self):
               r"""
               Class-aware wrapper for `::fz_unshare_stroke_state()`.
                       Given a reference to a (possibly) shared stroke_state structure,
                       return a reference to an equivalent stroke_state structure
                       that is guaranteed to be unshared (i.e. one that can
                       safely be modified).
       
                       shared: The reference to a (possibly) shared structure
                       to unshare. Ownership of this reference is passed in
                       to this function, even in the case of exceptions being
                       thrown.
       
                       Exceptions may be thrown in the event of failure to
                       allocate if required.
               """
>>>>>>         return _mupdf.FzStrokeState_fz_unshare_stroke_state(self)
       
    1:     def fz_unshare_stroke_state_with_dash_len(self, len):
               r"""
               Class-aware wrapper for `::fz_unshare_stroke_state_with_dash_len()`.
                       Given a reference to a (possibly) shared stroke_state structure,
                       return a reference to a stroke_state structure (with room for a
                       given amount of dash data) that is guaranteed to be unshared
                       (i.e. one that can safely be modified).
       
                       shared: The reference to a (possibly) shared structure
                       to unshare. Ownership of this reference is passed in
                       to this function, even in the case of exceptions being
                       thrown.
       
                       Exceptions may be thrown in the event of failure to
                       allocate if required.
               """
>>>>>>         return _mupdf.FzStrokeState_fz_unshare_stroke_state_with_dash_len(self, len)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_stroke_state()`.
                               Create a new (empty) stroke state structure (with no dash
                               data) and return a reference to it.
       
                               Throws exception on failure to allocate.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_stroke_state_with_dash_len()`.
                               Create a new (empty) stroke state structure, with room for
                               dash data of the given length, and return a reference to it.
       
                               len: The number of dash elements to allow room for.
       
                               Throws exception on failure to allocate.
       
       
               |
       
               *Overload 3:*
                Copy constructor using `fz_keep_stroke_state()`.
       
               |
       
               *Overload 4:*
                Constructor using raw copy of pre-existing `::fz_stroke_state`.
               """
>>>>>>         _mupdf.FzStrokeState_swiginit(self, _mupdf.new_FzStrokeState(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStrokeState
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStrokeState_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStrokeState___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStrokeState_m_internal_get, _mupdf.FzStrokeState_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStrokeState_s_num_instances_get, _mupdf.FzStrokeState_s_num_instances_set)
       
       # Register FzStrokeState in _mupdf:
    1: _mupdf.FzStrokeState_swigregister(FzStrokeState)
    2: class FzStyleContext(object):
    1:     r"""Wrapper class for struct `fz_style_context`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_style_context`.
               """
>>>>>>         _mupdf.FzStyleContext_swiginit(self, _mupdf.new_FzStyleContext(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzStyleContext
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStyleContext_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStyleContext___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStyleContext_m_internal_get, _mupdf.FzStyleContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStyleContext_s_num_instances_get, _mupdf.FzStyleContext_s_num_instances_set)
       
       # Register FzStyleContext in _mupdf:
    1: _mupdf.FzStyleContext_swigregister(FzStyleContext)
    2: class FzText(object):
    1:     r"""Wrapper class for struct `fz_text`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_bound_text(self, stroke, ctm):
               r"""
               Class-aware wrapper for `::fz_bound_text()`.
                       Find the bounds of a given text object.
       
                       text: The text object to find the bounds of.
       
                       stroke: Pointer to the stroke attributes (for stroked
                       text), or NULL (for filled text).
       
                       ctm: The matrix in use.
       
                       r: pointer to storage for the bounds.
       
                       Returns a pointer to r, which is updated to contain the
                       bounding box for the text object.
               """
>>>>>>         return _mupdf.FzText_fz_bound_text(self, stroke, ctm)
       
    1:     def fz_show_glyph(self, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language):
               r"""
               Class-aware wrapper for `::fz_show_glyph()`.
                       Add a glyph/unicode value to a text object.
       
                       text: Text object to add to.
       
                       font: The font the glyph should be added in.
       
                       trm: The transform to use for the glyph.
       
                       glyph: The glyph id to add.
       
                       unicode: The unicode character for the glyph.
       
                       cid: The CJK CID value or raw character code.
       
                       wmode: 1 for vertical mode, 0 for horizontal.
       
                       bidi_level: The bidirectional level for this glyph.
       
                       markup_dir: The direction of the text as specified in the
                       markup.
       
                       language: The language in use (if known, 0 otherwise)
                       (e.g. FZ_LANG_zh_Hans).
       
                       Throws exception on failure to allocate.
               """
>>>>>>         return _mupdf.FzText_fz_show_glyph(self, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language)
       
    1:     def fz_show_glyph_aux(self, font, trm, adv, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang):
               r"""Class-aware wrapper for `::fz_show_glyph_aux()`."""
>>>>>>         return _mupdf.FzText_fz_show_glyph_aux(self, font, trm, adv, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang)
       
    1:     def fz_show_string(self, font, trm, s, wmode, bidi_level, markup_dir, language):
               r"""
               Class-aware wrapper for `::fz_show_string()`.
                       Add a UTF8 string to a text object.
       
                       text: Text object to add to.
       
                       font: The font the string should be added in.
       
                       trm: The transform to use.
       
                       s: The utf-8 string to add.
       
                       wmode: 1 for vertical mode, 0 for horizontal.
       
                       bidi_level: The bidirectional level for this glyph.
       
                       markup_dir: The direction of the text as specified in the markup.
       
                       language: The language in use (if known, 0 otherwise)
                               (e.g. FZ_LANG_zh_Hans).
       
                       Returns the transform updated with the advance width of the
                       string.
               """
>>>>>>         return _mupdf.FzText_fz_show_string(self, font, trm, s, wmode, bidi_level, markup_dir, language)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_text()`.
                               Create a new empty fz_text object.
       
                               Throws exception on failure to allocate.
       
       
               |
       
               *Overload 2:*
                Copy constructor using `fz_keep_text()`.
       
               |
       
               *Overload 3:*
                Constructor using raw copy of pre-existing `::fz_text`.
               """
>>>>>>         _mupdf.FzText_swiginit(self, _mupdf.new_FzText(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzText
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzText_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzText___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzText_m_internal_get, _mupdf.FzText_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzText_s_num_instances_get, _mupdf.FzText_s_num_instances_set)
       
       # Register FzText in _mupdf:
    1: _mupdf.FzText_swigregister(FzText)
    2: class FzTextDecoder(object):
    1:     r"""
            Wrapper class for struct `fz_text_decoder`. Not copyable or assignable.
           A text decoder (to read arbitrary encodings and convert to unicode).
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_init_text_decoder(self, encoding):
               r"""Class-aware wrapper for `::fz_init_text_decoder()`."""
>>>>>>         return _mupdf.FzTextDecoder_fz_init_text_decoder(self, encoding)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_text_decoder`.
               """
>>>>>>         _mupdf.FzTextDecoder_swiginit(self, _mupdf.new_FzTextDecoder(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzTextDecoder
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzTextDecoder_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzTextDecoder___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzTextDecoder_m_internal_get, _mupdf.FzTextDecoder_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzTextDecoder_s_num_instances_get, _mupdf.FzTextDecoder_s_num_instances_set)
       
       # Register FzTextDecoder in _mupdf:
    1: _mupdf.FzTextDecoder_swigregister(FzTextDecoder)
    2: class FzTextItem(object):
    1:     r"""
           Wrapper class for struct `fz_text_item`. Not copyable or assignable.
           Text buffer.
       
           The trm field contains the a, b, c and d coefficients.
           The e and f coefficients come from the individual elements,
           together they form the transform matrix for the glyph.
       
           Glyphs are referenced by glyph ID.
           The Unicode text equivalent is kept in a separate array
           with indexes into the glyph array.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_text_item`.
               """
>>>>>>         _mupdf.FzTextItem_swiginit(self, _mupdf.new_FzTextItem(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzTextItem
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzTextItem_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzTextItem___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzTextItem_m_internal_get, _mupdf.FzTextItem_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzTextItem_s_num_instances_get, _mupdf.FzTextItem_s_num_instances_set)
       
       # Register FzTextItem in _mupdf:
    1: _mupdf.FzTextItem_swigregister(FzTextItem)
    2: class FzTextSpan(object):
    1:     r"""Wrapper class for struct `fz_text_span`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def font(self):
               r"""Gives class-aware access to m_internal->font."""
>>>>>>         return _mupdf.FzTextSpan_font(self)
       
    1:     def trm(self):
               r"""Gives class-aware access to m_internal->trm."""
>>>>>>         return _mupdf.FzTextSpan_trm(self)
       
    1:     def items(self, i):
               r"""
               Gives access to m_internal->items[i].
                                                               Returned reference is only valid as long as `this`.
                                                               Provided mainly for use by SWIG bindings.
               """
>>>>>>         return _mupdf.FzTextSpan_items(self, i)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_text_span`.
               """
>>>>>>         _mupdf.FzTextSpan_swiginit(self, _mupdf.new_FzTextSpan(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzTextSpan
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzTextSpan_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzTextSpan___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzTextSpan_m_internal_get, _mupdf.FzTextSpan_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzTextSpan_s_num_instances_get, _mupdf.FzTextSpan_s_num_instances_set)
       
       # Register FzTextSpan in _mupdf:
    1: _mupdf.FzTextSpan_swigregister(FzTextSpan)
    2: class FzTransition(object):
    1:     r"""Wrapper class for struct `fz_transition`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_transition`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::fz_transition`.
               """
>>>>>>         _mupdf.FzTransition_swiginit(self, _mupdf.new_FzTransition(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.FzTransition_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_FzTransition
    1:     type = property(_mupdf.FzTransition_type_get, _mupdf.FzTransition_type_set)
    1:     duration = property(_mupdf.FzTransition_duration_get, _mupdf.FzTransition_duration_set)
    1:     vertical = property(_mupdf.FzTransition_vertical_get, _mupdf.FzTransition_vertical_set)
    1:     outwards = property(_mupdf.FzTransition_outwards_get, _mupdf.FzTransition_outwards_set)
    1:     direction = property(_mupdf.FzTransition_direction_get, _mupdf.FzTransition_direction_set)
    1:     state0 = property(_mupdf.FzTransition_state0_get, _mupdf.FzTransition_state0_set)
    1:     state1 = property(_mupdf.FzTransition_state1_get, _mupdf.FzTransition_state1_set)
    1:     s_num_instances = property(_mupdf.FzTransition_s_num_instances_get, _mupdf.FzTransition_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.FzTransition_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzTransition___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.FzTransition___ne__(self, rhs)
       
       # Register FzTransition in _mupdf:
    1: _mupdf.FzTransition_swigregister(FzTransition)
    2: class FzTree(object):
    1:     r"""
           Wrapper class for struct `fz_tree`. Not copyable or assignable.
           AA-tree to look up things by strings.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_new_tree_archive(self):
               r"""
               Class-aware wrapper for `::fz_new_tree_archive()`.
                       Create an archive that holds named buffers.
       
                       tree can either be a preformed tree with fz_buffers as values,
                       or it can be NULL for an empty tree.
               """
>>>>>>         return _mupdf.FzTree_fz_new_tree_archive(self)
       
    1:     def fz_tree_lookup(self, key):
               r"""
               Class-aware wrapper for `::fz_tree_lookup()`.
                       Look for the value of a node in the tree with the given key.
       
                       Simple pointer equivalence is used for key.
       
                       Returns NULL for no match.
               """
>>>>>>         return _mupdf.FzTree_fz_tree_lookup(self, key)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_tree`.
               """
>>>>>>         _mupdf.FzTree_swiginit(self, _mupdf.new_FzTree(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzTree
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzTree_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzTree___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzTree_m_internal_get, _mupdf.FzTree_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzTree_s_num_instances_get, _mupdf.FzTree_s_num_instances_set)
       
       # Register FzTree in _mupdf:
    1: _mupdf.FzTree_swigregister(FzTree)
    2: class FzTuningContext(object):
    1:     r"""Wrapper class for struct `fz_tuning_context`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_tuning_context`.
               """
>>>>>>         _mupdf.FzTuningContext_swiginit(self, _mupdf.new_FzTuningContext(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzTuningContext
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzTuningContext_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzTuningContext___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzTuningContext_m_internal_get, _mupdf.FzTuningContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzTuningContext_s_num_instances_get, _mupdf.FzTuningContext_s_num_instances_set)
       
       # Register FzTuningContext in _mupdf:
    1: _mupdf.FzTuningContext_swigregister(FzTuningContext)
    2: class FzVertex(object):
    1:     r"""
           Wrapper class for struct `fz_vertex`. Not copyable or assignable.
           Handy routine for processing mesh based shades
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_vertex`.
               """
>>>>>>         _mupdf.FzVertex_swiginit(self, _mupdf.new_FzVertex(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzVertex
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzVertex_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzVertex___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzVertex_m_internal_get, _mupdf.FzVertex_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzVertex_s_num_instances_get, _mupdf.FzVertex_s_num_instances_set)
       
       # Register FzVertex in _mupdf:
    1: _mupdf.FzVertex_swigregister(FzVertex)
    2: class FzWarnContext(object):
    1:     r"""Wrapper class for struct `fz_warn_context`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_warn_context`.
               """
>>>>>>         _mupdf.FzWarnContext_swiginit(self, _mupdf.new_FzWarnContext(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzWarnContext
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzWarnContext_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzWarnContext___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzWarnContext_m_internal_get, _mupdf.FzWarnContext_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzWarnContext_s_num_instances_get, _mupdf.FzWarnContext_s_num_instances_set)
       
       # Register FzWarnContext in _mupdf:
    1: _mupdf.FzWarnContext_swigregister(FzWarnContext)
    2: class FzWriteStoryPosition(object):
    1:     r"""Wrapper class for struct `fz_write_story_position`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_write_story_position`.
               """
>>>>>>         _mupdf.FzWriteStoryPosition_swiginit(self, _mupdf.new_FzWriteStoryPosition(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzWriteStoryPosition
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzWriteStoryPosition_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzWriteStoryPosition___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzWriteStoryPosition_m_internal_get, _mupdf.FzWriteStoryPosition_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzWriteStoryPosition_s_num_instances_get, _mupdf.FzWriteStoryPosition_s_num_instances_set)
       
       # Register FzWriteStoryPosition in _mupdf:
    1: _mupdf.FzWriteStoryPosition_swigregister(FzWriteStoryPosition)
    2: class FzWriteStoryPositions(object):
    1:     r"""Wrapper class for struct `fz_write_story_positions`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_write_story_positions`.
               """
>>>>>>         _mupdf.FzWriteStoryPositions_swiginit(self, _mupdf.new_FzWriteStoryPositions(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzWriteStoryPositions
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzWriteStoryPositions_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzWriteStoryPositions___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzWriteStoryPositions_m_internal_get, _mupdf.FzWriteStoryPositions_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzWriteStoryPositions_s_num_instances_get, _mupdf.FzWriteStoryPositions_s_num_instances_set)
       
       # Register FzWriteStoryPositions in _mupdf:
    1: _mupdf.FzWriteStoryPositions_swigregister(FzWriteStoryPositions)
    2: class FzXml(object):
    1:     r"""
           Wrapper class for struct `fz_xml`.
           XML document model
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_debug_xml(self, level):
               r"""
               Class-aware wrapper for `::fz_debug_xml()`.
                       Pretty-print an XML tree to stdout. (Deprecated, use
                       fz_output_xml in preference).
               """
>>>>>>         return _mupdf.FzXml_fz_debug_xml(self, level)
       
    1:     def fz_detach_xml(self):
               r"""
               Class-aware wrapper for `::fz_detach_xml()`.
                       Detach a node from the tree, unlinking it from its parent,
                       and setting the document root to the node.
               """
>>>>>>         return _mupdf.FzXml_fz_detach_xml(self)
       
    1:     def fz_dom_add_attribute(self, att, value):
               r"""
               Class-aware wrapper for `::fz_dom_add_attribute()`.
                       Add an attribute to an element.
       
                       Ownership of att and value remain with the caller.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_add_attribute(self, att, value)
       
    1:     def fz_dom_append_child(self, child):
               r"""
               Class-aware wrapper for `::fz_dom_append_child()`.
                       Insert an element as the last child of a parent, unlinking the
                       child from its current position if required.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_append_child(self, child)
       
    1:     def fz_dom_attribute(self, att):
               r"""
               Class-aware wrapper for `::fz_dom_attribute()`.
                       Retrieve the value of a given attribute from a given element.
       
                       Returns a borrowed pointer to the value or NULL if not found.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_attribute(self, att)
       
    1:     def fz_dom_body(self):
               r"""
               Class-aware wrapper for `::fz_dom_body()`.
                       Return a borrowed reference for the 'body' element of
                       the given DOM.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_body(self)
       
    1:     def fz_dom_clone(self):
               r"""
               Class-aware wrapper for `::fz_dom_clone()`.
                       Clone an element (and its children).
       
                       A borrowed reference to the clone is returned. The clone is not
                       yet linked into the DOM.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_clone(self)
       
    1:     def fz_dom_create_element(self, tag):
               r"""
               Class-aware wrapper for `::fz_dom_create_element()`.
                       Create an element of a given tag type for the given DOM.
       
                       The element is not linked into the DOM yet.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_create_element(self, tag)
       
    1:     def fz_dom_create_text_node(self, text):
               r"""
               Class-aware wrapper for `::fz_dom_create_text_node()`.
                       Create a text node for the given DOM.
       
                       The element is not linked into the DOM yet.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_create_text_node(self, text)
       
    1:     def fz_dom_document_element(self):
               r"""
               Class-aware wrapper for `::fz_dom_document_element()`.
                       Return a borrowed reference for the document (the top
                       level element) of the DOM.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_document_element(self)
       
    1:     def fz_dom_find(self, tag, att, match):
               r"""
               Class-aware wrapper for `::fz_dom_find()`.
                       Find the first element matching the requirements in a depth first traversal from elt.
       
                       The tagname must match tag, unless tag is NULL, when all tag names are considered to match.
       
                       If att is NULL, then all tags match.
                       Otherwise:
                               If match is NULL, then only nodes that have an att attribute match.
                               If match is non-NULL, then only nodes that have an att attribute that matches match match.
       
                       Returns NULL (if no match found), or a borrowed reference to the first matching element.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_find(self, tag, att, match)
       
    1:     def fz_dom_find_next(self, tag, att, match):
               r"""
               Class-aware wrapper for `::fz_dom_find_next()`.
                       Find the next element matching the requirements.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_find_next(self, tag, att, match)
       
    1:     def fz_dom_first_child(self):
               r"""
               Class-aware wrapper for `::fz_dom_first_child()`.
                       Return a borrowed reference to the first child of a node,
                       or NULL if there isn't one.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_first_child(self)
       
    1:     def fz_dom_get_attribute(self, i, att):
               r"""
               Class-aware wrapper for `::fz_dom_get_attribute()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_dom_get_attribute(int i)` => `(const char *, const char *att)`
       
                       Enumerate through the attributes of an element.
       
                       Call with i=0,1,2,3... to enumerate attributes.
       
                       On return *att and the return value will be NULL if there are not
                       that many attributes to read. Otherwise, *att will be filled in
                       with a borrowed pointer to the attribute name, and the return
                       value will be a borrowed pointer to the value.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_get_attribute(self, i, att)
       
    1:     def fz_dom_insert_after(self, new_elt):
               r"""
               Class-aware wrapper for `::fz_dom_insert_after()`.
                       Insert an element (new_elt), after another element (node),
                       unlinking the new_elt from its current position if required.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_insert_after(self, new_elt)
       
    1:     def fz_dom_insert_before(self, new_elt):
               r"""
               Class-aware wrapper for `::fz_dom_insert_before()`.
                       Insert an element (new_elt), before another element (node),
                       unlinking the new_elt from its current position if required.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_insert_before(self, new_elt)
       
    1:     def fz_dom_next(self):
               r"""
               Class-aware wrapper for `::fz_dom_next()`.
                       Return a borrowed reference to the next sibling of a node,
                       or NULL if there isn't one.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_next(self)
       
    1:     def fz_dom_parent(self):
               r"""
               Class-aware wrapper for `::fz_dom_parent()`.
                       Return a borrowed reference to the parent of a node,
                       or NULL if there isn't one.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_parent(self)
       
    1:     def fz_dom_previous(self):
               r"""
               Class-aware wrapper for `::fz_dom_previous()`.
                       Return a borrowed reference to the previous sibling of a node,
                       or NULL if there isn't one.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_previous(self)
       
    1:     def fz_dom_remove(self):
               r"""
               Class-aware wrapper for `::fz_dom_remove()`.
                       Remove an element from the DOM. The element can be added back elsewhere
                       if required.
       
                       No reference counting changes for the element.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_remove(self)
       
    1:     def fz_dom_remove_attribute(self, att):
               r"""
               Class-aware wrapper for `::fz_dom_remove_attribute()`.
                       Remove an attribute from an element.
               """
>>>>>>         return _mupdf.FzXml_fz_dom_remove_attribute(self, att)
       
    1:     def fz_new_display_list_from_svg_xml(self, xml, base_uri, dir, w, h):
               r"""
               Class-aware wrapper for `::fz_new_display_list_from_svg_xml()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `fz_new_display_list_from_svg_xml(::fz_xml *xml, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`
       
                       Parse an SVG document into a display-list.
               """
>>>>>>         return _mupdf.FzXml_fz_new_display_list_from_svg_xml(self, xml, base_uri, dir, w, h)
       
    1:     def fz_new_dom_node(self, tag):
               r"""
               Class-aware wrapper for `::fz_new_dom_node()`.
                       Create a new dom node.
       
                       This will NOT be linked in yet.
               """
>>>>>>         return _mupdf.FzXml_fz_new_dom_node(self, tag)
       
    1:     def fz_new_dom_text_node(self, *args):
               r"""
               *Overload 1:*
                Class-aware wrapper for `::fz_new_dom_text_node()`.
                               Create a new dom text node.
       
                               This will NOT be linked in yet.
       
       
               |
       
               *Overload 2:*
                Class-aware wrapper for `::fz_new_dom_text_node()`.
                               Create a new dom text node.
       
                               This will NOT be linked in yet.
               """
>>>>>>         return _mupdf.FzXml_fz_new_dom_text_node(self, *args)
       
    1:     def fz_new_image_from_svg_xml(self, xml, base_uri, dir):
               r"""
               Class-aware wrapper for `::fz_new_image_from_svg_xml()`.
                       Create a scalable image from an SVG document.
               """
>>>>>>         return _mupdf.FzXml_fz_new_image_from_svg_xml(self, xml, base_uri, dir)
       
    1:     def fz_save_xml(self, path, indented):
               r"""
               Class-aware wrapper for `::fz_save_xml()`.
                       As for fz_write_xml, but direct to a file.
               """
>>>>>>         return _mupdf.FzXml_fz_save_xml(self, path, indented)
       
    1:     def fz_write_xml(self, out, indented):
               r"""
               Class-aware wrapper for `::fz_write_xml()`.
                       Write our xml structure out to an xml stream.
       
                       Properly formatted XML is only allowed to have a single top-level node
                       under which everything must sit. Our structures allow for multiple
                       top level nodes. If required, we will output an extra 'ROOT' node
                       at the top so that the xml is well-formed.
       
                       If 'indented' is non-zero then additional whitespace will be added to
                       make the XML easier to read in a text editor. It will NOT be properly
                       compliant.
               """
>>>>>>         return _mupdf.FzXml_fz_write_xml(self, out, indented)
       
    1:     def fz_xml_att(self, att):
               r"""
               Class-aware wrapper for `::fz_xml_att()`.
                       Return the value of an attribute of an XML node.
                       NULL if the attribute doesn't exist.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_att(self, att)
       
    1:     def fz_xml_att_alt(self, one, two):
               r"""
               Class-aware wrapper for `::fz_xml_att_alt()`.
                       Return the value of an attribute of an XML node.
                       If the first attribute doesn't exist, try the second.
                       NULL if neither attribute exists.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_att_alt(self, one, two)
       
    1:     def fz_xml_att_eq(self, name, match):
               r"""
               Class-aware wrapper for `::fz_xml_att_eq()`.
                       Check for a matching attribute on an XML node.
       
                       If the node has the requested attribute (name), and the value
                       matches (match) then return 1. Otherwise, 0.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_att_eq(self, name, match)
       
    1:     def fz_xml_down(self):
               r"""
               Class-aware wrapper for `::fz_xml_down()`.
                       Return first child of XML node.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_down(self)
       
    1:     def fz_xml_find(self, tag):
               r"""
               Class-aware wrapper for `::fz_xml_find()`.
                       Search the siblings of XML nodes starting with item looking for
                       the first with the given tag.
       
                       Return NULL if none found.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_find(self, tag)
       
    1:     def fz_xml_find_dfs(self, tag, att, match):
               r"""
               Class-aware wrapper for `::fz_xml_find_dfs()`.
                       Perform a depth first search from item, returning the first
                       child that matches the given tag (or any tag if tag is NULL),
                       with the given attribute (if att is non NULL), that matches
                       match (if match is non NULL).
               """
>>>>>>         return _mupdf.FzXml_fz_xml_find_dfs(self, tag, att, match)
       
    1:     def fz_xml_find_dfs_top(self, tag, att, match, top):
               r"""
               Class-aware wrapper for `::fz_xml_find_dfs_top()`.
                       Perform a depth first search from item, returning the first
                       child that matches the given tag (or any tag if tag is NULL),
                       with the given attribute (if att is non NULL), that matches
                       match (if match is non NULL). The search stops if it ever
                       reaches the top of the tree, or the declared 'top' item.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_find_dfs_top(self, tag, att, match, top)
       
    1:     def fz_xml_find_down(self, tag):
               r"""
               Class-aware wrapper for `::fz_xml_find_down()`.
                       Search the siblings of XML nodes starting with the first child
                       of item looking for the first with the given tag.
       
                       Return NULL if none found.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_find_down(self, tag)
       
    1:     def fz_xml_find_down_match(self, tag, att, match):
               r"""
               Class-aware wrapper for `::fz_xml_find_down_match()`.
                       Search the siblings of XML nodes starting with the first child
                       of item looking for the first with the given tag (or any tag if
                       tag is NULL), and with a matching attribute.
       
                       Return NULL if none found.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_find_down_match(self, tag, att, match)
       
    1:     def fz_xml_find_match(self, tag, att, match):
               r"""
               Class-aware wrapper for `::fz_xml_find_match()`.
                       Search the siblings of XML nodes starting with item looking for
                       the first with the given tag (or any tag if tag is NULL), and
                       with a matching attribute.
       
                       Return NULL if none found.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_find_match(self, tag, att, match)
       
    1:     def fz_xml_find_next(self, tag):
               r"""
               Class-aware wrapper for `::fz_xml_find_next()`.
                       Search the siblings of XML nodes starting with the first sibling
                       of item looking for the first with the given tag.
       
                       Return NULL if none found.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_find_next(self, tag)
       
    1:     def fz_xml_find_next_dfs(self, tag, att, match):
               r"""
               Class-aware wrapper for `::fz_xml_find_next_dfs()`.
                       Perform a depth first search onwards from item, returning the first
                       child that matches the given tag (or any tag if tag is NULL),
                       with the given attribute (if att is non NULL), that matches
                       match (if match is non NULL).
               """
>>>>>>         return _mupdf.FzXml_fz_xml_find_next_dfs(self, tag, att, match)
       
    1:     def fz_xml_find_next_dfs_top(self, tag, att, match, top):
               r"""
               Class-aware wrapper for `::fz_xml_find_next_dfs_top()`.
                       Perform a depth first search onwards from item, returning the first
                       child that matches the given tag (or any tag if tag is NULL),
                       with the given attribute (if att is non NULL), that matches
                       match (if match is non NULL). The search stops if it ever reaches
                       the top of the tree, or the declared 'top' item.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_find_next_dfs_top(self, tag, att, match, top)
       
    1:     def fz_xml_find_next_match(self, tag, att, match):
               r"""
               Class-aware wrapper for `::fz_xml_find_next_match()`.
                       Search the siblings of XML nodes starting with the first sibling
                       of item looking for the first with the given tag (or any tag if tag
                       is NULL), and with a matching attribute.
       
                       Return NULL if none found.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_find_next_match(self, tag, att, match)
       
    1:     def fz_xml_is_tag(self, name):
               r"""
               Class-aware wrapper for `::fz_xml_is_tag()`.
                       Return true if the tag name matches.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_is_tag(self, name)
       
    1:     def fz_xml_next(self):
               r"""
               Class-aware wrapper for `::fz_xml_next()`.
                       Return next sibling of XML node.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_next(self)
       
    1:     def fz_xml_prev(self):
               r"""
               Class-aware wrapper for `::fz_xml_prev()`.
                       Return previous sibling of XML node.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_prev(self)
       
    1:     def fz_xml_root(self):
               r"""
               Class-aware wrapper for `::fz_xml_root()`.
                       Return the topmost XML node of a document.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_root(self)
       
    1:     def fz_xml_tag(self):
               r"""
               Class-aware wrapper for `::fz_xml_tag()`.
                       Return tag of XML node. Return NULL for text nodes.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_tag(self)
       
    1:     def fz_xml_text(self):
               r"""
               Class-aware wrapper for `::fz_xml_text()`.
                       Return the text content of an XML node.
                       Return NULL if the node is a tag.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_text(self)
       
    1:     def fz_xml_up(self):
               r"""
               Class-aware wrapper for `::fz_xml_up()`.
                       Return parent of XML node.
               """
>>>>>>         return _mupdf.FzXml_fz_xml_up(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_dom()`.
                               Make new xml dom root element.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_dom_node()`.
                               Create a new dom node.
       
                               This will NOT be linked in yet.
       
       
               |
       
               *Overload 3:*
                Copy constructor using `fz_keep_xml()`.
       
               |
       
               *Overload 4:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 5:*
                Constructor using raw copy of pre-existing `::fz_xml`.
               """
>>>>>>         _mupdf.FzXml_swiginit(self, _mupdf.new_FzXml(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzXml
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzXml_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzXml___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzXml_m_internal_get, _mupdf.FzXml_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzXml_s_num_instances_get, _mupdf.FzXml_s_num_instances_set)
       
       # Register FzXml in _mupdf:
    1: _mupdf.FzXml_swigregister(FzXml)
    2: class FzXmlDoc(object):
    1:     r"""Wrapper class for struct `fz_xml_doc`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::fz_xml_doc`.
               """
>>>>>>         _mupdf.FzXmlDoc_swiginit(self, _mupdf.new_FzXmlDoc(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzXmlDoc
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzXmlDoc_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzXmlDoc___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzXmlDoc_m_internal_get, _mupdf.FzXmlDoc_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzXmlDoc_s_num_instances_get, _mupdf.FzXmlDoc_s_num_instances_set)
       
       # Register FzXmlDoc in _mupdf:
    1: _mupdf.FzXmlDoc_swigregister(FzXmlDoc)
    2: class FzZipWriter(object):
    1:     r"""
           Wrapper class for struct `fz_zip_writer`. Not copyable or assignable.
           fz_zip_writer offers methods for creating and writing zip files.
           It can be seen as the reverse of the fz_archive zip
           implementation.
           """
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def fz_close_zip_writer(self):
               r"""
               Class-aware wrapper for `::fz_close_zip_writer()`.
                       Close the zip file for writing.
       
                       This flushes any pending data to the file. This can throw
                       exceptions.
               """
>>>>>>         return _mupdf.FzZipWriter_fz_close_zip_writer(self)
       
    1:     def fz_write_zip_entry(self, name, buf, compress):
               r"""
               Class-aware wrapper for `::fz_write_zip_entry()`.
                       Given a buffer of data, (optionally) compress it, and add it to
                       the zip file with the given name.
               """
>>>>>>         return _mupdf.FzZipWriter_fz_write_zip_entry(self, name, buf, compress)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
                == Constructors.  Constructor using `fz_new_zip_writer()`.
                               Create a new zip writer that writes to a given file.
       
                               Open an archive using a seekable stream object rather than
                               opening a file or directory on disk.
       
       
               |
       
               *Overload 2:*
                Constructor using `fz_new_zip_writer_with_output()`.
                               Create a new zip writer that writes to a given output stream.
       
                               Ownership of out passes in immediately upon calling this function.
                               The caller should never drop the fz_output, even if this function throws
                               an exception.
       
       
               |
       
               *Overload 3:*
                Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 4:*
                Constructor using raw copy of pre-existing `::fz_zip_writer`.
               """
>>>>>>         _mupdf.FzZipWriter_swiginit(self, _mupdf.new_FzZipWriter(*args))
    1:     __swig_destroy__ = _mupdf.delete_FzZipWriter
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzZipWriter_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzZipWriter___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzZipWriter_m_internal_get, _mupdf.FzZipWriter_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzZipWriter_s_num_instances_get, _mupdf.FzZipWriter_s_num_instances_set)
       
       # Register FzZipWriter in _mupdf:
    1: _mupdf.FzZipWriter_swigregister(FzZipWriter)
    2: class PdfAlertEvent(object):
    1:     r"""Wrapper class for struct `pdf_alert_event`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_alert_event`.
               """
>>>>>>         _mupdf.PdfAlertEvent_swiginit(self, _mupdf.new_PdfAlertEvent(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfAlertEvent
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfAlertEvent_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfAlertEvent___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfAlertEvent_m_internal_get, _mupdf.PdfAlertEvent_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfAlertEvent_s_num_instances_get, _mupdf.PdfAlertEvent_s_num_instances_set)
       
       # Register PdfAlertEvent in _mupdf:
    1: _mupdf.PdfAlertEvent_swigregister(PdfAlertEvent)
    2: class PdfAnnot(object):
    1:     r"""Wrapper class for struct `pdf_annot`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_add_annot_border_dash_item(self, length):
               r"""Class-aware wrapper for `::pdf_add_annot_border_dash_item()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_add_annot_border_dash_item(self, length)
       
    1:     def pdf_add_annot_ink_list_stroke(self):
               r"""Class-aware wrapper for `::pdf_add_annot_ink_list_stroke()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_add_annot_ink_list_stroke(self)
       
    1:     def pdf_add_annot_ink_list_stroke_vertex(self, p):
               r"""Class-aware wrapper for `::pdf_add_annot_ink_list_stroke_vertex()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_add_annot_ink_list_stroke_vertex(self, p)
       
    1:     def pdf_add_annot_quad_point(self, quad):
               r"""Class-aware wrapper for `::pdf_add_annot_quad_point()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_add_annot_quad_point(self, quad)
       
    1:     def pdf_add_annot_vertex(self, p):
               r"""Class-aware wrapper for `::pdf_add_annot_vertex()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_add_annot_vertex(self, p)
       
    1:     def pdf_annot_MK_BC(self, n, color):
               r"""
               Class-aware wrapper for `::pdf_annot_MK_BC()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_annot_MK_BC(float color[4])` => int n
               """
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_MK_BC(self, n, color)
       
    1:     def pdf_annot_MK_BC_rgb(self, rgb):
               r"""Class-aware wrapper for `::pdf_annot_MK_BC_rgb()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_MK_BC_rgb(self, rgb)
       
    1:     def pdf_annot_MK_BG(self, n, color):
               r"""
               Class-aware wrapper for `::pdf_annot_MK_BG()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_annot_MK_BG(float color[4])` => int n
               """
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_MK_BG(self, n, color)
       
    1:     def pdf_annot_MK_BG_rgb(self, rgb):
               r"""Class-aware wrapper for `::pdf_annot_MK_BG_rgb()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_MK_BG_rgb(self, rgb)
       
    1:     def pdf_annot_active(self):
               r"""Class-aware wrapper for `::pdf_annot_active()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_active(self)
       
    1:     def pdf_annot_ap(self):
               r"""Class-aware wrapper for `::pdf_annot_ap()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_ap(self)
       
    1:     def pdf_annot_author(self):
               r"""Class-aware wrapper for `::pdf_annot_author()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_author(self)
       
    1:     def pdf_annot_border(self):
               r"""Class-aware wrapper for `::pdf_annot_border()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_border(self)
       
    1:     def pdf_annot_border_dash_count(self):
               r"""Class-aware wrapper for `::pdf_annot_border_dash_count()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_border_dash_count(self)
       
    1:     def pdf_annot_border_dash_item(self, i):
               r"""Class-aware wrapper for `::pdf_annot_border_dash_item()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_border_dash_item(self, i)
       
    1:     def pdf_annot_border_effect(self):
               r"""Class-aware wrapper for `::pdf_annot_border_effect()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_border_effect(self)
       
    1:     def pdf_annot_border_effect_intensity(self):
               r"""Class-aware wrapper for `::pdf_annot_border_effect_intensity()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_border_effect_intensity(self)
       
    1:     def pdf_annot_border_style(self):
               r"""Class-aware wrapper for `::pdf_annot_border_style()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_border_style(self)
       
    1:     def pdf_annot_border_width(self):
               r"""Class-aware wrapper for `::pdf_annot_border_width()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_border_width(self)
       
    1:     def pdf_annot_callout_point(self):
               r"""Class-aware wrapper for `::pdf_annot_callout_point()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_callout_point(self)
       
    1:     def pdf_annot_callout_style(self):
               r"""Class-aware wrapper for `::pdf_annot_callout_style()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_callout_style(self)
       
    1:     def pdf_annot_color(self, n, color):
               r"""
               Class-aware wrapper for `::pdf_annot_color()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_annot_color(float color[4])` => int n
               """
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_color(self, n, color)
       
    1:     def pdf_annot_contents(self):
               r"""Class-aware wrapper for `::pdf_annot_contents()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_contents(self)
       
    1:     def pdf_annot_creation_date(self):
               r"""Class-aware wrapper for `::pdf_annot_creation_date()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_creation_date(self)
       
    1:     def pdf_annot_default_appearance(self, font, size, n, color):
               r"""
               Class-aware wrapper for `::pdf_annot_default_appearance()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_annot_default_appearance(float color[4])` => `(const char *font, float size, int n)`
               """
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_default_appearance(self, font, size, n, color)
       
    1:     def pdf_annot_default_appearance_unmapped(self, font_name, font_name_len, size, n, color):
               r"""
               Class-aware wrapper for `::pdf_annot_default_appearance_unmapped()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_annot_default_appearance_unmapped(char *font_name, int font_name_len, float color[4])` => `(float size, int n)`
               """
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_default_appearance_unmapped(self, font_name, font_name_len, size, n, color)
       
    1:     def pdf_annot_ensure_local_xref(self):
               r"""Class-aware wrapper for `::pdf_annot_ensure_local_xref()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_ensure_local_xref(self)
       
    1:     def pdf_annot_event_blur(self):
               r"""Class-aware wrapper for `::pdf_annot_event_blur()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_event_blur(self)
       
    1:     def pdf_annot_event_down(self):
               r"""Class-aware wrapper for `::pdf_annot_event_down()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_event_down(self)
       
    1:     def pdf_annot_event_enter(self):
               r"""Class-aware wrapper for `::pdf_annot_event_enter()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_event_enter(self)
       
    1:     def pdf_annot_event_exit(self):
               r"""Class-aware wrapper for `::pdf_annot_event_exit()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_event_exit(self)
       
    1:     def pdf_annot_event_focus(self):
               r"""Class-aware wrapper for `::pdf_annot_event_focus()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_event_focus(self)
       
    1:     def pdf_annot_event_page_close(self):
               r"""Class-aware wrapper for `::pdf_annot_event_page_close()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_event_page_close(self)
       
    1:     def pdf_annot_event_page_invisible(self):
               r"""Class-aware wrapper for `::pdf_annot_event_page_invisible()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_event_page_invisible(self)
       
    1:     def pdf_annot_event_page_open(self):
               r"""Class-aware wrapper for `::pdf_annot_event_page_open()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_event_page_open(self)
       
    1:     def pdf_annot_event_page_visible(self):
               r"""Class-aware wrapper for `::pdf_annot_event_page_visible()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_event_page_visible(self)
       
    1:     def pdf_annot_event_up(self):
               r"""Class-aware wrapper for `::pdf_annot_event_up()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_event_up(self)
       
    1:     def pdf_annot_field_flags(self):
               r"""Class-aware wrapper for `::pdf_annot_field_flags()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_field_flags(self)
       
    1:     def pdf_annot_field_label(self):
               r"""Class-aware wrapper for `::pdf_annot_field_label()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_field_label(self)
       
    1:     def pdf_annot_field_value(self):
               r"""Class-aware wrapper for `::pdf_annot_field_value()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_field_value(self)
       
    1:     def pdf_annot_filespec(self):
               r"""Class-aware wrapper for `::pdf_annot_filespec()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_filespec(self)
       
    1:     def pdf_annot_flags(self):
               r"""Class-aware wrapper for `::pdf_annot_flags()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_flags(self)
       
    1:     def pdf_annot_has_author(self):
               r"""Class-aware wrapper for `::pdf_annot_has_author()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_author(self)
       
    1:     def pdf_annot_has_border(self):
               r"""Class-aware wrapper for `::pdf_annot_has_border()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_border(self)
       
    1:     def pdf_annot_has_border_effect(self):
               r"""Class-aware wrapper for `::pdf_annot_has_border_effect()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_border_effect(self)
       
    1:     def pdf_annot_has_callout(self):
               r"""Class-aware wrapper for `::pdf_annot_has_callout()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_callout(self)
       
    1:     def pdf_annot_has_default_appearance(self):
               r"""Class-aware wrapper for `::pdf_annot_has_default_appearance()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_default_appearance(self)
       
    1:     def pdf_annot_has_filespec(self):
               r"""Class-aware wrapper for `::pdf_annot_has_filespec()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_filespec(self)
       
    1:     def pdf_annot_has_icon_name(self):
               r"""Class-aware wrapper for `::pdf_annot_has_icon_name()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_icon_name(self)
       
    1:     def pdf_annot_has_ink_list(self):
               r"""Class-aware wrapper for `::pdf_annot_has_ink_list()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_ink_list(self)
       
    1:     def pdf_annot_has_intent(self):
               r"""Class-aware wrapper for `::pdf_annot_has_intent()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_intent(self)
       
    1:     def pdf_annot_has_interior_color(self):
               r"""Class-aware wrapper for `::pdf_annot_has_interior_color()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_interior_color(self)
       
    1:     def pdf_annot_has_line(self):
               r"""Class-aware wrapper for `::pdf_annot_has_line()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_line(self)
       
    1:     def pdf_annot_has_line_ending_styles(self):
               r"""Class-aware wrapper for `::pdf_annot_has_line_ending_styles()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_line_ending_styles(self)
       
    1:     def pdf_annot_has_open(self):
               r"""Class-aware wrapper for `::pdf_annot_has_open()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_open(self)
       
    1:     def pdf_annot_has_popup(self):
               r"""Class-aware wrapper for `::pdf_annot_has_popup()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_popup(self)
       
    1:     def pdf_annot_has_quad_points(self):
               r"""Class-aware wrapper for `::pdf_annot_has_quad_points()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_quad_points(self)
       
    1:     def pdf_annot_has_quadding(self):
               r"""Class-aware wrapper for `::pdf_annot_has_quadding()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_quadding(self)
       
    1:     def pdf_annot_has_rect(self):
               r"""Class-aware wrapper for `::pdf_annot_has_rect()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_rect(self)
       
    1:     def pdf_annot_has_rich_contents(self):
               r"""Class-aware wrapper for `::pdf_annot_has_rich_contents()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_rich_contents(self)
       
    1:     def pdf_annot_has_rich_defaults(self):
               r"""Class-aware wrapper for `::pdf_annot_has_rich_defaults()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_rich_defaults(self)
       
    1:     def pdf_annot_has_vertices(self):
               r"""Class-aware wrapper for `::pdf_annot_has_vertices()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_has_vertices(self)
       
    1:     def pdf_annot_hidden_for_editing(self):
               r"""Class-aware wrapper for `::pdf_annot_hidden_for_editing()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_hidden_for_editing(self)
       
    1:     def pdf_annot_hot(self):
               r"""Class-aware wrapper for `::pdf_annot_hot()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_hot(self)
       
    1:     def pdf_annot_icon_name(self):
               r"""Class-aware wrapper for `::pdf_annot_icon_name()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_icon_name(self)
       
    1:     def pdf_annot_ink_list_count(self):
               r"""Class-aware wrapper for `::pdf_annot_ink_list_count()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_ink_list_count(self)
       
    1:     def pdf_annot_ink_list_stroke_count(self, i):
               r"""Class-aware wrapper for `::pdf_annot_ink_list_stroke_count()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_ink_list_stroke_count(self, i)
       
    1:     def pdf_annot_ink_list_stroke_vertex(self, i, k):
               r"""Class-aware wrapper for `::pdf_annot_ink_list_stroke_vertex()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_ink_list_stroke_vertex(self, i, k)
       
    1:     def pdf_annot_intent(self):
               r"""Class-aware wrapper for `::pdf_annot_intent()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_intent(self)
       
    1:     def pdf_annot_interior_color(self, n, color):
               r"""
               Class-aware wrapper for `::pdf_annot_interior_color()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_annot_interior_color(float color[4])` => int n
               """
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_interior_color(self, n, color)
       
    1:     def pdf_annot_is_open(self):
               r"""Class-aware wrapper for `::pdf_annot_is_open()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_is_open(self)
       
    1:     def pdf_annot_is_standard_stamp(self):
               r"""Class-aware wrapper for `::pdf_annot_is_standard_stamp()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_is_standard_stamp(self)
       
    1:     def pdf_annot_line(self, a, b):
               r"""Class-aware wrapper for `::pdf_annot_line()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_line(self, a, b)
       
    1:     def pdf_annot_line_caption(self):
               r"""Class-aware wrapper for `::pdf_annot_line_caption()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_line_caption(self)
       
    1:     def pdf_annot_line_caption_offset(self):
               r"""Class-aware wrapper for `::pdf_annot_line_caption_offset()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_line_caption_offset(self)
       
    1:     def pdf_annot_line_end_style(self):
               r"""Class-aware wrapper for `::pdf_annot_line_end_style()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_line_end_style(self)
       
    1:     def pdf_annot_line_ending_styles(self, start_style, end_style):
               r"""
               Class-aware wrapper for `::pdf_annot_line_ending_styles()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_annot_line_ending_styles()` => `(enum pdf_line_ending start_style, enum pdf_line_ending end_style)`
               """
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_line_ending_styles(self, start_style, end_style)
       
    1:     def pdf_annot_line_leader(self):
               r"""Class-aware wrapper for `::pdf_annot_line_leader()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_line_leader(self)
       
    1:     def pdf_annot_line_leader_extension(self):
               r"""Class-aware wrapper for `::pdf_annot_line_leader_extension()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_line_leader_extension(self)
       
    1:     def pdf_annot_line_leader_offset(self):
               r"""Class-aware wrapper for `::pdf_annot_line_leader_offset()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_line_leader_offset(self)
       
    1:     def pdf_annot_line_start_style(self):
               r"""Class-aware wrapper for `::pdf_annot_line_start_style()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_line_start_style(self)
       
    1:     def pdf_annot_modification_date(self):
               r"""Class-aware wrapper for `::pdf_annot_modification_date()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_modification_date(self)
       
    1:     def pdf_annot_needs_resynthesis(self):
               r"""Class-aware wrapper for `::pdf_annot_needs_resynthesis()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_needs_resynthesis(self)
       
    1:     def pdf_annot_obj(self):
               r"""Class-aware wrapper for `::pdf_annot_obj()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_obj(self)
       
    1:     def pdf_annot_opacity(self):
               r"""Class-aware wrapper for `::pdf_annot_opacity()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_opacity(self)
       
    1:     def pdf_annot_page(self):
               r"""Class-aware wrapper for `::pdf_annot_page()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_page(self)
       
    1:     def pdf_annot_pop_and_discard_local_xref(self):
               r"""Class-aware wrapper for `::pdf_annot_pop_and_discard_local_xref()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_pop_and_discard_local_xref(self)
       
    1:     def pdf_annot_pop_local_xref(self):
               r"""Class-aware wrapper for `::pdf_annot_pop_local_xref()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_pop_local_xref(self)
       
    1:     def pdf_annot_popup(self):
               r"""Class-aware wrapper for `::pdf_annot_popup()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_popup(self)
       
    1:     def pdf_annot_push_local_xref(self):
               r"""Class-aware wrapper for `::pdf_annot_push_local_xref()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_push_local_xref(self)
       
    1:     def pdf_annot_quad_point(self, i):
               r"""Class-aware wrapper for `::pdf_annot_quad_point()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_quad_point(self, i)
       
    1:     def pdf_annot_quad_point_count(self):
               r"""Class-aware wrapper for `::pdf_annot_quad_point_count()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_quad_point_count(self)
       
    1:     def pdf_annot_quadding(self):
               r"""Class-aware wrapper for `::pdf_annot_quadding()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_quadding(self)
       
    1:     def pdf_annot_rect(self):
               r"""Class-aware wrapper for `::pdf_annot_rect()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_rect(self)
       
    1:     def pdf_annot_request_resynthesis(self):
               r"""Class-aware wrapper for `::pdf_annot_request_resynthesis()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_request_resynthesis(self)
       
    1:     def pdf_annot_request_synthesis(self):
               r"""Class-aware wrapper for `::pdf_annot_request_synthesis()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_request_synthesis(self)
       
    1:     def pdf_annot_rich_contents(self):
               r"""Class-aware wrapper for `::pdf_annot_rich_contents()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_rich_contents(self)
       
    1:     def pdf_annot_rich_defaults(self):
               r"""Class-aware wrapper for `::pdf_annot_rich_defaults()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_rich_defaults(self)
       
    1:     def pdf_annot_stamp_image_obj(self):
               r"""Class-aware wrapper for `::pdf_annot_stamp_image_obj()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_stamp_image_obj(self)
       
    1:     def pdf_annot_transform(self):
               r"""Class-aware wrapper for `::pdf_annot_transform()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_transform(self)
       
    1:     def pdf_annot_type(self):
               r"""Class-aware wrapper for `::pdf_annot_type()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_type(self)
       
    1:     def pdf_annot_vertex(self, i):
               r"""Class-aware wrapper for `::pdf_annot_vertex()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_vertex(self, i)
       
    1:     def pdf_annot_vertex_count(self):
               r"""Class-aware wrapper for `::pdf_annot_vertex_count()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_annot_vertex_count(self)
       
    1:     def pdf_apply_redaction(self, opts):
               r"""Class-aware wrapper for `::pdf_apply_redaction()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_apply_redaction(self, opts)
       
    1:     def pdf_bound_annot(self):
               r"""Class-aware wrapper for `::pdf_bound_annot()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_bound_annot(self)
       
    1:     def pdf_bound_widget(self):
               r"""Class-aware wrapper for `::pdf_bound_widget()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_bound_widget(self)
       
    1:     def pdf_choice_widget_is_multiselect(self):
               r"""Class-aware wrapper for `::pdf_choice_widget_is_multiselect()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_choice_widget_is_multiselect(self)
       
    1:     def pdf_choice_widget_options(self, exportval, opts):
               r"""Class-aware wrapper for `::pdf_choice_widget_options()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_choice_widget_options(self, exportval, opts)
       
    1:     def pdf_choice_widget_options2(self, exportval):
               r"""
               Class-aware wrapper for `::pdf_choice_widget_options2()`.   Swig-friendly wrapper for pdf_choice_widget_options(), returns the
               options directly in a vector.
               """
>>>>>>         return _mupdf.PdfAnnot_pdf_choice_widget_options2(self, exportval)
       
    1:     def pdf_choice_widget_set_value(self, n, opts):
               r"""Class-aware wrapper for `::pdf_choice_widget_set_value()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_choice_widget_set_value(self, n, opts)
       
    1:     def pdf_choice_widget_value(self, opts):
               r"""Class-aware wrapper for `::pdf_choice_widget_value()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_choice_widget_value(self, opts)
       
    1:     def pdf_clear_annot_border_dash(self):
               r"""Class-aware wrapper for `::pdf_clear_annot_border_dash()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_clear_annot_border_dash(self)
       
    1:     def pdf_clear_annot_ink_list(self):
               r"""Class-aware wrapper for `::pdf_clear_annot_ink_list()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_clear_annot_ink_list(self)
       
    1:     def pdf_clear_annot_quad_points(self):
               r"""Class-aware wrapper for `::pdf_clear_annot_quad_points()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_clear_annot_quad_points(self)
       
    1:     def pdf_clear_annot_vertices(self):
               r"""Class-aware wrapper for `::pdf_clear_annot_vertices()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_clear_annot_vertices(self)
       
    1:     def pdf_clear_signature(self):
               r"""Class-aware wrapper for `::pdf_clear_signature()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_clear_signature(self)
       
    1:     def pdf_dirty_annot(self):
               r"""Class-aware wrapper for `::pdf_dirty_annot()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_dirty_annot(self)
       
    1:     def pdf_edit_text_field_value(self, value, change, selStart, selEnd, newvalue):
               r"""
               Class-aware wrapper for `::pdf_edit_text_field_value()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_edit_text_field_value(const char *value, const char *change)` => `(int, int selStart, int selEnd, char *newvalue)`
               """
>>>>>>         return _mupdf.PdfAnnot_pdf_edit_text_field_value(self, value, change, selStart, selEnd, newvalue)
       
    1:     def pdf_get_widget_editing_state(self):
               r"""Class-aware wrapper for `::pdf_get_widget_editing_state()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_get_widget_editing_state(self)
       
    1:     def pdf_incremental_change_since_signing_widget(self):
               r"""Class-aware wrapper for `::pdf_incremental_change_since_signing_widget()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_incremental_change_since_signing_widget(self)
       
    1:     def pdf_new_display_list_from_annot(self):
               r"""Class-aware wrapper for `::pdf_new_display_list_from_annot()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_new_display_list_from_annot(self)
       
    1:     def pdf_new_pixmap_from_annot(self, ctm, cs, seps, alpha):
               r"""Class-aware wrapper for `::pdf_new_pixmap_from_annot()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_new_pixmap_from_annot(self, ctm, cs, seps, alpha)
       
    1:     def pdf_next_annot(self):
               r"""Class-aware wrapper for `::pdf_next_annot()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_next_annot(self)
       
    1:     def pdf_next_widget(self):
               r"""Class-aware wrapper for `::pdf_next_widget()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_next_widget(self)
       
    1:     def pdf_run_annot(self, dev, ctm, cookie):
               r"""Class-aware wrapper for `::pdf_run_annot()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_run_annot(self, dev, ctm, cookie)
       
    1:     def pdf_set_annot_active(self, active):
               r"""Class-aware wrapper for `::pdf_set_annot_active()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_active(self, active)
       
    1:     def pdf_set_annot_appearance(self, appearance, state, ctm, bbox, res, contents):
               r"""Class-aware wrapper for `::pdf_set_annot_appearance()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_appearance(self, appearance, state, ctm, bbox, res, contents)
       
    1:     def pdf_set_annot_appearance_from_display_list(self, appearance, state, ctm, list):
               r"""Class-aware wrapper for `::pdf_set_annot_appearance_from_display_list()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_appearance_from_display_list(self, appearance, state, ctm, list)
       
    1:     def pdf_set_annot_author(self, author):
               r"""Class-aware wrapper for `::pdf_set_annot_author()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_author(self, author)
       
    1:     def pdf_set_annot_border(self, width):
               r"""Class-aware wrapper for `::pdf_set_annot_border()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_border(self, width)
       
    1:     def pdf_set_annot_border_effect(self, effect):
               r"""Class-aware wrapper for `::pdf_set_annot_border_effect()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_border_effect(self, effect)
       
    1:     def pdf_set_annot_border_effect_intensity(self, intensity):
               r"""Class-aware wrapper for `::pdf_set_annot_border_effect_intensity()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_border_effect_intensity(self, intensity)
       
    1:     def pdf_set_annot_border_style(self, style):
               r"""Class-aware wrapper for `::pdf_set_annot_border_style()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_border_style(self, style)
       
    1:     def pdf_set_annot_border_width(self, width):
               r"""Class-aware wrapper for `::pdf_set_annot_border_width()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_border_width(self, width)
       
    1:     def pdf_set_annot_callout_line2(self, callout):
               r"""Class-aware wrapper for `::pdf_set_annot_callout_line2()`.   SWIG-friendly wrapper for pdf_set_annot_callout_line()."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_callout_line2(self, callout)
       
    1:     def pdf_set_annot_callout_point(self, p):
               r"""Class-aware wrapper for `::pdf_set_annot_callout_point()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_callout_point(self, p)
       
    1:     def pdf_set_annot_callout_style(self, style):
               r"""Class-aware wrapper for `::pdf_set_annot_callout_style()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_callout_style(self, style)
       
    1:     def pdf_set_annot_color(self, n, color):
               r"""Class-aware wrapper for `::pdf_set_annot_color()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_color(self, n, color)
       
    1:     def pdf_set_annot_contents(self, text):
               r"""Class-aware wrapper for `::pdf_set_annot_contents()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_contents(self, text)
       
    1:     def pdf_set_annot_creation_date(self, time):
               r"""Class-aware wrapper for `::pdf_set_annot_creation_date()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_creation_date(self, time)
       
    1:     def pdf_set_annot_default_appearance(self, font, size, n, color):
               r"""Class-aware wrapper for `::pdf_set_annot_default_appearance()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_default_appearance(self, font, size, n, color)
       
    1:     def pdf_set_annot_filespec(self, obj):
               r"""Class-aware wrapper for `::pdf_set_annot_filespec()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_filespec(self, obj)
       
    1:     def pdf_set_annot_flags(self, flags):
               r"""Class-aware wrapper for `::pdf_set_annot_flags()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_flags(self, flags)
       
    1:     def pdf_set_annot_hidden_for_editing(self, hidden):
               r"""Class-aware wrapper for `::pdf_set_annot_hidden_for_editing()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_hidden_for_editing(self, hidden)
       
    1:     def pdf_set_annot_hot(self, hot):
               r"""Class-aware wrapper for `::pdf_set_annot_hot()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_hot(self, hot)
       
    1:     def pdf_set_annot_icon_name(self, name):
               r"""Class-aware wrapper for `::pdf_set_annot_icon_name()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_icon_name(self, name)
       
    1:     def pdf_set_annot_ink_list(self, n, count, v):
               r"""Class-aware wrapper for `::pdf_set_annot_ink_list()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_ink_list(self, n, count, v)
       
    1:     def pdf_set_annot_intent(self, it):
               r"""Class-aware wrapper for `::pdf_set_annot_intent()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_intent(self, it)
       
    1:     def pdf_set_annot_interior_color(self, n, color):
               r"""Class-aware wrapper for `::pdf_set_annot_interior_color()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_interior_color(self, n, color)
       
    1:     def pdf_set_annot_is_open(self, is_open):
               r"""Class-aware wrapper for `::pdf_set_annot_is_open()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_is_open(self, is_open)
       
    1:     def pdf_set_annot_language(self, lang):
               r"""Class-aware wrapper for `::pdf_set_annot_language()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_language(self, lang)
       
    1:     def pdf_set_annot_line(self, a, b):
               r"""Class-aware wrapper for `::pdf_set_annot_line()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_line(self, a, b)
       
    1:     def pdf_set_annot_line_caption(self, cap):
               r"""Class-aware wrapper for `::pdf_set_annot_line_caption()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_line_caption(self, cap)
       
    1:     def pdf_set_annot_line_caption_offset(self, offset):
               r"""Class-aware wrapper for `::pdf_set_annot_line_caption_offset()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_line_caption_offset(self, offset)
       
    1:     def pdf_set_annot_line_end_style(self, e):
               r"""Class-aware wrapper for `::pdf_set_annot_line_end_style()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_line_end_style(self, e)
       
    1:     def pdf_set_annot_line_ending_styles(self, start_style, end_style):
               r"""Class-aware wrapper for `::pdf_set_annot_line_ending_styles()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_line_ending_styles(self, start_style, end_style)
       
    1:     def pdf_set_annot_line_leader(self, ll):
               r"""Class-aware wrapper for `::pdf_set_annot_line_leader()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_line_leader(self, ll)
       
    1:     def pdf_set_annot_line_leader_extension(self, lle):
               r"""Class-aware wrapper for `::pdf_set_annot_line_leader_extension()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_line_leader_extension(self, lle)
       
    1:     def pdf_set_annot_line_leader_offset(self, llo):
               r"""Class-aware wrapper for `::pdf_set_annot_line_leader_offset()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_line_leader_offset(self, llo)
       
    1:     def pdf_set_annot_line_start_style(self, s):
               r"""Class-aware wrapper for `::pdf_set_annot_line_start_style()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_line_start_style(self, s)
       
    1:     def pdf_set_annot_modification_date(self, time):
               r"""Class-aware wrapper for `::pdf_set_annot_modification_date()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_modification_date(self, time)
       
    1:     def pdf_set_annot_opacity(self, opacity):
               r"""Class-aware wrapper for `::pdf_set_annot_opacity()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_opacity(self, opacity)
       
    1:     def pdf_set_annot_popup(self, rect):
               r"""Class-aware wrapper for `::pdf_set_annot_popup()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_popup(self, rect)
       
    1:     def pdf_set_annot_quad_points(self, n, qv):
               r"""Class-aware wrapper for `::pdf_set_annot_quad_points()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_quad_points(self, n, qv)
       
    1:     def pdf_set_annot_quadding(self, q):
               r"""Class-aware wrapper for `::pdf_set_annot_quadding()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_quadding(self, q)
       
    1:     def pdf_set_annot_rect(self, rect):
               r"""Class-aware wrapper for `::pdf_set_annot_rect()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_rect(self, rect)
       
    1:     def pdf_set_annot_resynthesised(self):
               r"""Class-aware wrapper for `::pdf_set_annot_resynthesised()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_resynthesised(self)
       
    1:     def pdf_set_annot_rich_contents(self, plain, rich):
               r"""Class-aware wrapper for `::pdf_set_annot_rich_contents()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_rich_contents(self, plain, rich)
       
    1:     def pdf_set_annot_rich_defaults(self, style):
               r"""Class-aware wrapper for `::pdf_set_annot_rich_defaults()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_rich_defaults(self, style)
       
    1:     def pdf_set_annot_stamp_image(self, image):
               r"""Class-aware wrapper for `::pdf_set_annot_stamp_image()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_stamp_image(self, image)
       
    1:     def pdf_set_annot_stamp_image_obj(self, ref):
               r"""Class-aware wrapper for `::pdf_set_annot_stamp_image_obj()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_stamp_image_obj(self, ref)
       
    1:     def pdf_set_annot_vertex(self, i, p):
               r"""Class-aware wrapper for `::pdf_set_annot_vertex()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_vertex(self, i, p)
       
    1:     def pdf_set_annot_vertices(self, n, v):
               r"""Class-aware wrapper for `::pdf_set_annot_vertices()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_annot_vertices(self, n, v)
       
    1:     def pdf_set_choice_field_value(self, value):
               r"""Class-aware wrapper for `::pdf_set_choice_field_value()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_choice_field_value(self, value)
       
    1:     def pdf_set_text_field_value(self, value):
               r"""Class-aware wrapper for `::pdf_set_text_field_value()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_text_field_value(self, value)
       
    1:     def pdf_set_widget_editing_state(self, editing):
               r"""Class-aware wrapper for `::pdf_set_widget_editing_state()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_set_widget_editing_state(self, editing)
       
    1:     def pdf_sign_signature(self, signer, appearance_flags, graphic, reason, location):
               r"""Class-aware wrapper for `::pdf_sign_signature()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_sign_signature(self, signer, appearance_flags, graphic, reason, location)
       
    1:     def pdf_sign_signature_with_appearance(self, signer, date, disp_list):
               r"""Class-aware wrapper for `::pdf_sign_signature_with_appearance()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_sign_signature_with_appearance(self, signer, date, disp_list)
       
    1:     def pdf_text_widget_format(self):
               r"""Class-aware wrapper for `::pdf_text_widget_format()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_text_widget_format(self)
       
    1:     def pdf_text_widget_max_len(self):
               r"""Class-aware wrapper for `::pdf_text_widget_max_len()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_text_widget_max_len(self)
       
    1:     def pdf_toggle_widget(self):
               r"""Class-aware wrapper for `::pdf_toggle_widget()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_toggle_widget(self)
       
    1:     def pdf_update_annot(self):
               r"""Class-aware wrapper for `::pdf_update_annot()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_update_annot(self)
       
    1:     def pdf_update_widget(self):
               r"""Class-aware wrapper for `::pdf_update_widget()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_update_widget(self)
       
    1:     def pdf_validate_signature(self):
               r"""Class-aware wrapper for `::pdf_validate_signature()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_validate_signature(self)
       
    1:     def pdf_widget_is_readonly(self):
               r"""Class-aware wrapper for `::pdf_widget_is_readonly()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_widget_is_readonly(self)
       
    1:     def pdf_widget_is_signed(self):
               r"""Class-aware wrapper for `::pdf_widget_is_signed()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_widget_is_signed(self)
       
    1:     def pdf_widget_type(self):
               r"""Class-aware wrapper for `::pdf_widget_type()`."""
>>>>>>         return _mupdf.PdfAnnot_pdf_widget_type(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Copy constructor using `pdf_keep_annot()`.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_annot`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_annot`.
               """
>>>>>>         _mupdf.PdfAnnot_swiginit(self, _mupdf.new_PdfAnnot(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfAnnot
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfAnnot_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfAnnot___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfAnnot_m_internal_get, _mupdf.PdfAnnot_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfAnnot_s_num_instances_get, _mupdf.PdfAnnot_s_num_instances_set)
       
       # Register PdfAnnot in _mupdf:
    1: _mupdf.PdfAnnot_swigregister(PdfAnnot)
    2: class PdfCleanOptions(object):
    1:     r"""Wrapper class for struct `pdf_clean_options`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def write_opwd_utf8_set(self, text):
               r"""Copies <text> into write.opwd_utf8[]."""
>>>>>>         return _mupdf.PdfCleanOptions_write_opwd_utf8_set(self, text)
       
    1:     def write_upwd_utf8_set(self, text):
               r"""Copies <text> into upwd_utf8[]."""
>>>>>>         return _mupdf.PdfCleanOptions_write_upwd_utf8_set(self, text)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, makes copy of pdf_default_write_options.
       
               |
       
               *Overload 2:*
               Copy constructor using raw memcopy().
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_clean_options`.
       
               |
       
               *Overload 4:*
               Constructor using raw copy of pre-existing `::pdf_clean_options`.
               """
>>>>>>         _mupdf.PdfCleanOptions_swiginit(self, _mupdf.new_PdfCleanOptions(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.PdfCleanOptions_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_PdfCleanOptions
    1:     write = property(_mupdf.PdfCleanOptions_write_get, _mupdf.PdfCleanOptions_write_set)
    1:     image = property(_mupdf.PdfCleanOptions_image_get, _mupdf.PdfCleanOptions_image_set)
    1:     subset_fonts = property(_mupdf.PdfCleanOptions_subset_fonts_get, _mupdf.PdfCleanOptions_subset_fonts_set)
    1:     structure = property(_mupdf.PdfCleanOptions_structure_get, _mupdf.PdfCleanOptions_structure_set)
    1:     s_num_instances = property(_mupdf.PdfCleanOptions_s_num_instances_get, _mupdf.PdfCleanOptions_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.PdfCleanOptions_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfCleanOptions___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfCleanOptions___ne__(self, rhs)
       
       # Register PdfCleanOptions in _mupdf:
    1: _mupdf.PdfCleanOptions_swigregister(PdfCleanOptions)
    2: class PdfCmap(object):
    1:     r"""Wrapper class for struct `pdf_cmap`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_add_codespace(self, low, high, n):
               r"""Class-aware wrapper for `::pdf_add_codespace()`."""
>>>>>>         return _mupdf.PdfCmap_pdf_add_codespace(self, low, high, n)
       
    1:     def pdf_cmap_size(self):
               r"""Class-aware wrapper for `::pdf_cmap_size()`."""
>>>>>>         return _mupdf.PdfCmap_pdf_cmap_size(self)
       
    1:     def pdf_cmap_wmode(self):
               r"""Class-aware wrapper for `::pdf_cmap_wmode()`."""
>>>>>>         return _mupdf.PdfCmap_pdf_cmap_wmode(self)
       
    1:     def pdf_decode_cmap(self, s, e, cpt):
               r"""
               Class-aware wrapper for `::pdf_decode_cmap()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_decode_cmap(unsigned char *s, unsigned char *e)` => `(int, unsigned int cpt)`
               """
>>>>>>         return _mupdf.PdfCmap_pdf_decode_cmap(self, s, e, cpt)
       
    1:     def pdf_lookup_cmap(self, cpt):
               r"""Class-aware wrapper for `::pdf_lookup_cmap()`."""
>>>>>>         return _mupdf.PdfCmap_pdf_lookup_cmap(self, cpt)
       
    1:     def pdf_lookup_cmap_full(self, cpt, out):
               r"""
               Class-aware wrapper for `::pdf_lookup_cmap_full()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_lookup_cmap_full(unsigned int cpt)` => `(int, int out)`
               """
>>>>>>         return _mupdf.PdfCmap_pdf_lookup_cmap_full(self, cpt, out)
       
    1:     def pdf_map_one_to_many(self, one, many, len):
               r"""
               Class-aware wrapper for `::pdf_map_one_to_many()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_map_one_to_many(unsigned int one, size_t len)` => int many
               """
>>>>>>         return _mupdf.PdfCmap_pdf_map_one_to_many(self, one, many, len)
       
    1:     def pdf_map_range_to_range(self, srclo, srchi, dstlo):
               r"""Class-aware wrapper for `::pdf_map_range_to_range()`."""
>>>>>>         return _mupdf.PdfCmap_pdf_map_range_to_range(self, srclo, srchi, dstlo)
       
    1:     def pdf_set_cmap_wmode(self, wmode):
               r"""Class-aware wrapper for `::pdf_set_cmap_wmode()`."""
>>>>>>         return _mupdf.PdfCmap_pdf_set_cmap_wmode(self, wmode)
       
    1:     def pdf_set_usecmap(self, usecmap):
               r"""Class-aware wrapper for `::pdf_set_usecmap()`."""
>>>>>>         return _mupdf.PdfCmap_pdf_set_usecmap(self, usecmap)
       
    1:     def pdf_sort_cmap(self):
               r"""Class-aware wrapper for `::pdf_sort_cmap()`."""
>>>>>>         return _mupdf.PdfCmap_pdf_sort_cmap(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `pdf_new_cmap()`.
       
               |
       
               *Overload 2:*
               Constructor using `pdf_new_identity_cmap()`.
       
               |
       
               *Overload 3:*
               Copy constructor using `pdf_keep_cmap()`.
       
               |
       
               *Overload 4:*
               Constructor using raw copy of pre-existing `::pdf_cmap`.
               """
>>>>>>         _mupdf.PdfCmap_swiginit(self, _mupdf.new_PdfCmap(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfCmap
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfCmap_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfCmap___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfCmap_m_internal_get, _mupdf.PdfCmap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfCmap_s_num_instances_get, _mupdf.PdfCmap_s_num_instances_set)
       
       # Register PdfCmap in _mupdf:
    1: _mupdf.PdfCmap_swigregister(PdfCmap)
    2: class PdfColorFilterOptions(object):
    1:     r"""Wrapper class for struct `pdf_color_filter_options`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_color_filter_options`.
               """
>>>>>>         _mupdf.PdfColorFilterOptions_swiginit(self, _mupdf.new_PdfColorFilterOptions(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfColorFilterOptions
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfColorFilterOptions_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfColorFilterOptions___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfColorFilterOptions_m_internal_get, _mupdf.PdfColorFilterOptions_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfColorFilterOptions_s_num_instances_get, _mupdf.PdfColorFilterOptions_s_num_instances_set)
       
       # Register PdfColorFilterOptions in _mupdf:
    1: _mupdf.PdfColorFilterOptions_swigregister(PdfColorFilterOptions)
    2: class PdfColorspaceResourceKey(object):
    1:     r"""Wrapper class for struct `pdf_colorspace_resource_key`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_colorspace_resource_key`.
               """
>>>>>>         _mupdf.PdfColorspaceResourceKey_swiginit(self, _mupdf.new_PdfColorspaceResourceKey(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfColorspaceResourceKey
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfColorspaceResourceKey_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfColorspaceResourceKey___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfColorspaceResourceKey_m_internal_get, _mupdf.PdfColorspaceResourceKey_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfColorspaceResourceKey_s_num_instances_get, _mupdf.PdfColorspaceResourceKey_s_num_instances_set)
       
       # Register PdfColorspaceResourceKey in _mupdf:
    1: _mupdf.PdfColorspaceResourceKey_swigregister(PdfColorspaceResourceKey)
    2: class PdfCrypt(object):
    1:     r"""Wrapper class for struct `pdf_crypt`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_crypt_encrypt_metadata(self):
               r"""Class-aware wrapper for `::pdf_crypt_encrypt_metadata()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_encrypt_metadata(self)
       
    1:     def pdf_crypt_key(self):
               r"""Class-aware wrapper for `::pdf_crypt_key()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_key(self)
       
    1:     def pdf_crypt_length(self):
               r"""Class-aware wrapper for `::pdf_crypt_length()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_length(self)
       
    1:     def pdf_crypt_method(self):
               r"""Class-aware wrapper for `::pdf_crypt_method()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_method(self)
       
    1:     def pdf_crypt_obj(self, obj, num, gen):
               r"""Class-aware wrapper for `::pdf_crypt_obj()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_obj(self, obj, num, gen)
       
    1:     def pdf_crypt_owner_encryption(self):
               r"""Class-aware wrapper for `::pdf_crypt_owner_encryption()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_owner_encryption(self)
       
    1:     def pdf_crypt_owner_password(self):
               r"""Class-aware wrapper for `::pdf_crypt_owner_password()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_owner_password(self)
       
    1:     def pdf_crypt_permissions(self):
               r"""Class-aware wrapper for `::pdf_crypt_permissions()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_permissions(self)
       
    1:     def pdf_crypt_permissions_encryption(self):
               r"""Class-aware wrapper for `::pdf_crypt_permissions_encryption()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_permissions_encryption(self)
       
    1:     def pdf_crypt_revision(self):
               r"""Class-aware wrapper for `::pdf_crypt_revision()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_revision(self)
       
    1:     def pdf_crypt_stream_method(self):
               r"""Class-aware wrapper for `::pdf_crypt_stream_method()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_stream_method(self)
       
    1:     def pdf_crypt_string_method(self):
               r"""Class-aware wrapper for `::pdf_crypt_string_method()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_string_method(self)
       
    1:     def pdf_crypt_user_encryption(self):
               r"""Class-aware wrapper for `::pdf_crypt_user_encryption()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_user_encryption(self)
       
    1:     def pdf_crypt_user_password(self):
               r"""Class-aware wrapper for `::pdf_crypt_user_password()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_user_password(self)
       
    1:     def pdf_crypt_version(self):
               r"""Class-aware wrapper for `::pdf_crypt_version()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_crypt_version(self)
       
    1:     def pdf_encrypt_data(self, num, gen, fmt_str_out, arg, s, n):
               r"""Class-aware wrapper for `::pdf_encrypt_data()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_encrypt_data(self, num, gen, fmt_str_out, arg, s, n)
       
    1:     def pdf_encrypted_len(self, num, gen, len):
               r"""Class-aware wrapper for `::pdf_encrypted_len()`."""
>>>>>>         return _mupdf.PdfCrypt_pdf_encrypted_len(self, num, gen, len)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `pdf_new_crypt()`.
       
               |
       
               *Overload 2:*
               Constructor using `pdf_new_encrypt()`.
       
               |
       
               *Overload 3:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 4:*
               Constructor using raw copy of pre-existing `::pdf_crypt`.
               """
>>>>>>         _mupdf.PdfCrypt_swiginit(self, _mupdf.new_PdfCrypt(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfCrypt
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfCrypt_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfCrypt___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfCrypt_m_internal_get, _mupdf.PdfCrypt_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfCrypt_s_num_instances_get, _mupdf.PdfCrypt_s_num_instances_set)
       
       # Register PdfCrypt in _mupdf:
    1: _mupdf.PdfCrypt_swigregister(PdfCrypt)
    2: class PdfCsi(object):
    1:     r"""Wrapper class for struct `pdf_csi`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_csi`.
               """
>>>>>>         _mupdf.PdfCsi_swiginit(self, _mupdf.new_PdfCsi(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfCsi
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfCsi_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfCsi___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfCsi_m_internal_get, _mupdf.PdfCsi_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfCsi_s_num_instances_get, _mupdf.PdfCsi_s_num_instances_set)
       
       # Register PdfCsi in _mupdf:
    1: _mupdf.PdfCsi_swigregister(PdfCsi)
    2: class PdfCycleList(object):
    1:     r"""Wrapper class for struct `pdf_cycle_list`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_cycle(self, prev, obj):
               r"""Class-aware wrapper for `::pdf_cycle()`."""
>>>>>>         return _mupdf.PdfCycleList_pdf_cycle(self, prev, obj)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_cycle_list`.
               """
>>>>>>         _mupdf.PdfCycleList_swiginit(self, _mupdf.new_PdfCycleList(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfCycleList
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfCycleList_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfCycleList___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfCycleList_m_internal_get, _mupdf.PdfCycleList_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfCycleList_s_num_instances_get, _mupdf.PdfCycleList_s_num_instances_set)
       
       # Register PdfCycleList in _mupdf:
    1: _mupdf.PdfCycleList_swigregister(PdfCycleList)
    2: class PdfDocEvent(object):
    1:     r"""Wrapper class for struct `pdf_doc_event`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_access_exec_menu_item_event(self):
               r"""Class-aware wrapper for `::pdf_access_exec_menu_item_event()`."""
>>>>>>         return _mupdf.PdfDocEvent_pdf_access_exec_menu_item_event(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_doc_event`.
               """
>>>>>>         _mupdf.PdfDocEvent_swiginit(self, _mupdf.new_PdfDocEvent(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfDocEvent
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfDocEvent_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfDocEvent___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfDocEvent_m_internal_get, _mupdf.PdfDocEvent_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfDocEvent_s_num_instances_get, _mupdf.PdfDocEvent_s_num_instances_set)
       
       # Register PdfDocEvent in _mupdf:
    1: _mupdf.PdfDocEvent_swigregister(PdfDocEvent)
    2: class PdfDocument(object):
    1:     r"""Wrapper class for struct `pdf_document`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_abandon_operation(self):
               r"""Class-aware wrapper for `::pdf_abandon_operation()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_abandon_operation(self)
       
    1:     def pdf_add_cid_font(self, font):
               r"""Class-aware wrapper for `::pdf_add_cid_font()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_add_cid_font(self, font)
       
    1:     def pdf_add_cjk_font(self, font, script, wmode, serif):
               r"""Class-aware wrapper for `::pdf_add_cjk_font()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_add_cjk_font(self, font, script, wmode, serif)
       
    1:     def pdf_add_colorspace(self, cs):
               r"""Class-aware wrapper for `::pdf_add_colorspace()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_add_colorspace(self, cs)
       
    1:     def pdf_add_embedded_file(self, filename, mimetype, contents, created, modified, add_checksum):
               r"""Class-aware wrapper for `::pdf_add_embedded_file()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_add_embedded_file(self, filename, mimetype, contents, created, modified, add_checksum)
       
    1:     def pdf_add_image(self, image):
               r"""Class-aware wrapper for `::pdf_add_image()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_add_image(self, image)
       
    1:     def pdf_add_journal_fragment(self, parent, copy, copy_stream, newobj):
               r"""Class-aware wrapper for `::pdf_add_journal_fragment()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_add_journal_fragment(self, parent, copy, copy_stream, newobj)
       
    1:     def pdf_add_new_array(self, initial):
               r"""Class-aware wrapper for `::pdf_add_new_array()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_add_new_array(self, initial)
       
    1:     def pdf_add_new_dict(self, initial):
               r"""Class-aware wrapper for `::pdf_add_new_dict()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_add_new_dict(self, initial)
       
    1:     def pdf_add_object(self, obj):
               r"""Class-aware wrapper for `::pdf_add_object()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_add_object(self, obj)
       
    1:     def pdf_add_page(self, mediabox, rotate, resources, contents):
               r"""Class-aware wrapper for `::pdf_add_page()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_add_page(self, mediabox, rotate, resources, contents)
       
    1:     def pdf_add_simple_font(self, font, encoding):
               r"""Class-aware wrapper for `::pdf_add_simple_font()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_add_simple_font(self, font, encoding)
       
    1:     def pdf_add_stream(self, buf, obj, compressed):
               r"""Class-aware wrapper for `::pdf_add_stream()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_add_stream(self, buf, obj, compressed)
       
    1:     def pdf_add_substitute_font(self, font):
               r"""Class-aware wrapper for `::pdf_add_substitute_font()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_add_substitute_font(self, font)
       
    1:     def pdf_annot_field_event_keystroke(self, annot, evt):
               r"""Class-aware wrapper for `::pdf_annot_field_event_keystroke()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_annot_field_event_keystroke(self, annot, evt)
       
    1:     def pdf_authenticate_password(self, pw):
               r"""Class-aware wrapper for `::pdf_authenticate_password()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_authenticate_password(self, pw)
       
    1:     def pdf_bake_document(self, bake_annots, bake_widgets):
               r"""Class-aware wrapper for `::pdf_bake_document()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_bake_document(self, bake_annots, bake_widgets)
       
    1:     def pdf_begin_implicit_operation(self):
               r"""Class-aware wrapper for `::pdf_begin_implicit_operation()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_begin_implicit_operation(self)
       
    1:     def pdf_begin_operation(self, operation):
               r"""Class-aware wrapper for `::pdf_begin_operation()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_begin_operation(self, operation)
       
    1:     def pdf_calculate_form(self):
               r"""Class-aware wrapper for `::pdf_calculate_form()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_calculate_form(self)
       
    1:     def pdf_can_be_saved_incrementally(self):
               r"""Class-aware wrapper for `::pdf_can_be_saved_incrementally()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_can_be_saved_incrementally(self)
       
    1:     def pdf_can_redo(self):
               r"""Class-aware wrapper for `::pdf_can_redo()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_can_redo(self)
       
    1:     def pdf_can_undo(self):
               r"""Class-aware wrapper for `::pdf_can_undo()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_can_undo(self)
       
    1:     def pdf_clear_xref(self):
               r"""Class-aware wrapper for `::pdf_clear_xref()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_clear_xref(self)
       
    1:     def pdf_clear_xref_to_mark(self):
               r"""Class-aware wrapper for `::pdf_clear_xref_to_mark()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_clear_xref_to_mark(self)
       
    1:     def pdf_count_document_associated_files(self):
               r"""Class-aware wrapper for `::pdf_count_document_associated_files()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_count_document_associated_files(self)
       
    1:     def pdf_count_layer_config_ui(self):
               r"""Class-aware wrapper for `::pdf_count_layer_config_ui()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_count_layer_config_ui(self)
       
    1:     def pdf_count_layer_configs(self):
               r"""Class-aware wrapper for `::pdf_count_layer_configs()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_count_layer_configs(self)
       
    1:     def pdf_count_layers(self):
               r"""Class-aware wrapper for `::pdf_count_layers()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_count_layers(self)
       
    1:     def pdf_count_objects(self):
               r"""Class-aware wrapper for `::pdf_count_objects()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_count_objects(self)
       
    1:     def pdf_count_pages(self):
               r"""Class-aware wrapper for `::pdf_count_pages()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_count_pages(self)
       
    1:     def pdf_count_q_balance(self, res, stm, prepend, append):
               r"""
               Class-aware wrapper for `::pdf_count_q_balance()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_count_q_balance(::pdf_obj *res, ::pdf_obj *stm)` => `(int prepend, int append)`
               """
>>>>>>         return _mupdf.PdfDocument_pdf_count_q_balance(self, res, stm, prepend, append)
       
    1:     def pdf_count_signatures(self):
               r"""Class-aware wrapper for `::pdf_count_signatures()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_count_signatures(self)
       
    1:     def pdf_count_unsaved_versions(self):
               r"""Class-aware wrapper for `::pdf_count_unsaved_versions()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_count_unsaved_versions(self)
       
    1:     def pdf_count_versions(self):
               r"""Class-aware wrapper for `::pdf_count_versions()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_count_versions(self)
       
    1:     def pdf_create_field_name(self, prefix, buf, len):
               r"""Class-aware wrapper for `::pdf_create_field_name()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_create_field_name(self, prefix, buf, len)
       
    1:     def pdf_create_object(self):
               r"""Class-aware wrapper for `::pdf_create_object()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_create_object(self)
       
    1:     def pdf_debug_doc_changes(self):
               r"""Class-aware wrapper for `::pdf_debug_doc_changes()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_debug_doc_changes(self)
       
    1:     def pdf_delete_object(self, num):
               r"""Class-aware wrapper for `::pdf_delete_object()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_delete_object(self, num)
       
    1:     def pdf_delete_page(self, number):
               r"""Class-aware wrapper for `::pdf_delete_page()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_delete_page(self, number)
       
    1:     def pdf_delete_page_labels(self, index):
               r"""Class-aware wrapper for `::pdf_delete_page_labels()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_delete_page_labels(self, index)
       
    1:     def pdf_delete_page_range(self, start, end):
               r"""Class-aware wrapper for `::pdf_delete_page_range()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_delete_page_range(self, start, end)
       
    1:     def pdf_deselect_layer_config_ui(self, ui):
               r"""Class-aware wrapper for `::pdf_deselect_layer_config_ui()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_deselect_layer_config_ui(self, ui)
       
    1:     def pdf_deserialise_journal(self, stm):
               r"""Class-aware wrapper for `::pdf_deserialise_journal()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_deserialise_journal(self, stm)
       
    1:     def pdf_disable_js(self):
               r"""Class-aware wrapper for `::pdf_disable_js()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_disable_js(self)
       
    1:     def pdf_doc_was_linearized(self):
               r"""Class-aware wrapper for `::pdf_doc_was_linearized()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_doc_was_linearized(self)
       
    1:     def pdf_document_associated_file(self, idx):
               r"""Class-aware wrapper for `::pdf_document_associated_file()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_document_associated_file(self, idx)
       
    1:     def pdf_document_event_did_print(self):
               r"""Class-aware wrapper for `::pdf_document_event_did_print()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_document_event_did_print(self)
       
    1:     def pdf_document_event_did_save(self):
               r"""Class-aware wrapper for `::pdf_document_event_did_save()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_document_event_did_save(self)
       
    1:     def pdf_document_event_will_close(self):
               r"""Class-aware wrapper for `::pdf_document_event_will_close()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_document_event_will_close(self)
       
    1:     def pdf_document_event_will_print(self):
               r"""Class-aware wrapper for `::pdf_document_event_will_print()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_document_event_will_print(self)
       
    1:     def pdf_document_event_will_save(self):
               r"""Class-aware wrapper for `::pdf_document_event_will_save()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_document_event_will_save(self)
       
    1:     def pdf_document_output_intent(self):
               r"""Class-aware wrapper for `::pdf_document_output_intent()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_document_output_intent(self)
       
    1:     def pdf_document_permissions(self):
               r"""Class-aware wrapper for `::pdf_document_permissions()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_document_permissions(self)
       
    1:     def pdf_empty_store(self):
               r"""Class-aware wrapper for `::pdf_empty_store()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_empty_store(self)
       
    1:     def pdf_enable_journal(self):
               r"""Class-aware wrapper for `::pdf_enable_journal()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_enable_journal(self)
       
    1:     def pdf_enable_js(self):
               r"""Class-aware wrapper for `::pdf_enable_js()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_enable_js(self)
       
    1:     def pdf_enable_layer(self, layer, enabled):
               r"""Class-aware wrapper for `::pdf_enable_layer()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_enable_layer(self, layer, enabled)
       
    1:     def pdf_end_operation(self):
               r"""Class-aware wrapper for `::pdf_end_operation()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_end_operation(self)
       
    1:     def pdf_ensure_solid_xref(self, num):
               r"""Class-aware wrapper for `::pdf_ensure_solid_xref()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_ensure_solid_xref(self, num)
       
    1:     def pdf_event_issue_alert(self, evt):
               r"""Class-aware wrapper for `::pdf_event_issue_alert()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_event_issue_alert(self, evt)
       
    1:     def pdf_event_issue_exec_menu_item(self, item):
               r"""Class-aware wrapper for `::pdf_event_issue_exec_menu_item()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_event_issue_exec_menu_item(self, item)
       
    1:     def pdf_event_issue_launch_url(self, url, new_frame):
               r"""Class-aware wrapper for `::pdf_event_issue_launch_url()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_event_issue_launch_url(self, url, new_frame)
       
    1:     def pdf_event_issue_mail_doc(self, evt):
               r"""Class-aware wrapper for `::pdf_event_issue_mail_doc()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_event_issue_mail_doc(self, evt)
       
    1:     def pdf_event_issue_print(self):
               r"""Class-aware wrapper for `::pdf_event_issue_print()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_event_issue_print(self)
       
    1:     def pdf_field_event_calculate(self, field):
               r"""Class-aware wrapper for `::pdf_field_event_calculate()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_field_event_calculate(self, field)
       
    1:     def pdf_field_event_format(self, field):
               r"""Class-aware wrapper for `::pdf_field_event_format()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_field_event_format(self, field)
       
    1:     def pdf_field_event_keystroke(self, field, evt):
               r"""Class-aware wrapper for `::pdf_field_event_keystroke()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_field_event_keystroke(self, field, evt)
       
    1:     def pdf_field_event_validate(self, field, value, newvalue):
               r"""
               Class-aware wrapper for `::pdf_field_event_validate()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_field_event_validate(::pdf_obj *field, const char *value)` => `(int, char *newvalue)`
               """
>>>>>>         return _mupdf.PdfDocument_pdf_field_event_validate(self, field, value, newvalue)
       
    1:     def pdf_field_reset(self, field):
               r"""Class-aware wrapper for `::pdf_field_reset()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_field_reset(self, field)
       
    1:     def pdf_filter_annot_contents(self, annot, options):
               r"""Class-aware wrapper for `::pdf_filter_annot_contents()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_filter_annot_contents(self, annot, options)
       
    1:     def pdf_filter_page_contents(self, page, options):
               r"""Class-aware wrapper for `::pdf_filter_page_contents()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_filter_page_contents(self, page, options)
       
    1:     def pdf_find_colorspace_resource(self, item, key):
               r"""Class-aware wrapper for `::pdf_find_colorspace_resource()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_find_colorspace_resource(self, item, key)
       
    1:     def pdf_find_font_resource(self, type, encoding, item, key):
               r"""Class-aware wrapper for `::pdf_find_font_resource()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_find_font_resource(self, type, encoding, item, key)
       
    1:     def pdf_find_version_for_obj(self, obj):
               r"""Class-aware wrapper for `::pdf_find_version_for_obj()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_find_version_for_obj(self, obj)
       
    1:     def pdf_forget_xref(self):
               r"""Class-aware wrapper for `::pdf_forget_xref()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_forget_xref(self)
       
    1:     def pdf_get_doc_event_callback_data(self):
               r"""Class-aware wrapper for `::pdf_get_doc_event_callback_data()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_get_doc_event_callback_data(self)
       
    1:     def pdf_graft_object(self, obj):
               r"""Class-aware wrapper for `::pdf_graft_object()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_graft_object(self, obj)
       
    1:     def pdf_graft_page(self, page_to, src, page_from):
               r"""Class-aware wrapper for `::pdf_graft_page()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_graft_page(self, page_to, src, page_from)
       
    1:     def pdf_has_permission(self, p):
               r"""Class-aware wrapper for `::pdf_has_permission()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_has_permission(self, p)
       
    1:     def pdf_has_unsaved_changes(self):
               r"""Class-aware wrapper for `::pdf_has_unsaved_changes()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_has_unsaved_changes(self)
       
    1:     def pdf_has_unsaved_sigs(self):
               r"""Class-aware wrapper for `::pdf_has_unsaved_sigs()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_has_unsaved_sigs(self)
       
    1:     def pdf_insert_colorspace_resource(self, key, obj):
               r"""Class-aware wrapper for `::pdf_insert_colorspace_resource()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_insert_colorspace_resource(self, key, obj)
       
    1:     def pdf_insert_font_resource(self, key, obj):
               r"""Class-aware wrapper for `::pdf_insert_font_resource()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_insert_font_resource(self, key, obj)
       
    1:     def pdf_insert_page(self, at, page):
               r"""Class-aware wrapper for `::pdf_insert_page()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_insert_page(self, at, page)
       
    1:     def pdf_invalidate_xfa(self):
               r"""Class-aware wrapper for `::pdf_invalidate_xfa()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_invalidate_xfa(self)
       
    1:     def pdf_is_local_object(self, obj):
               r"""Class-aware wrapper for `::pdf_is_local_object()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_is_local_object(self, obj)
       
    1:     def pdf_is_ocg_hidden(self, rdb, usage, ocg):
               r"""Class-aware wrapper for `::pdf_is_ocg_hidden()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_is_ocg_hidden(self, rdb, usage, ocg)
       
    1:     def pdf_js_set_console(self, console, user):
               r"""Class-aware wrapper for `::pdf_js_set_console()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_js_set_console(self, console, user)
       
    1:     def pdf_js_supported(self):
               r"""Class-aware wrapper for `::pdf_js_supported()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_js_supported(self)
       
    1:     def pdf_layer_config_info(self, config_num, info):
               r"""Class-aware wrapper for `::pdf_layer_config_info()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_layer_config_info(self, config_num, info)
       
    1:     def pdf_layer_config_ui_info(self, ui, info):
               r"""Class-aware wrapper for `::pdf_layer_config_ui_info()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_layer_config_ui_info(self, ui, info)
       
    1:     def pdf_layer_is_enabled(self, layer):
               r"""Class-aware wrapper for `::pdf_layer_is_enabled()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_layer_is_enabled(self, layer)
       
    1:     def pdf_layer_name(self, layer):
               r"""Class-aware wrapper for `::pdf_layer_name()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_layer_name(self, layer)
       
    1:     def pdf_load_compressed_inline_image(self, dict, length, cstm, indexed, image):
               r"""Class-aware wrapper for `::pdf_load_compressed_inline_image()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_compressed_inline_image(self, dict, length, cstm, indexed, image)
       
    1:     def pdf_load_compressed_stream(self, num, worst_case):
               r"""Class-aware wrapper for `::pdf_load_compressed_stream()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_compressed_stream(self, num, worst_case)
       
    1:     def pdf_load_default_colorspaces(self, page):
               r"""Class-aware wrapper for `::pdf_load_default_colorspaces()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_default_colorspaces(self, page)
       
    1:     def pdf_load_embedded_cmap(self, ref):
               r"""Class-aware wrapper for `::pdf_load_embedded_cmap()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_embedded_cmap(self, ref)
       
    1:     def pdf_load_image(self, obj):
               r"""Class-aware wrapper for `::pdf_load_image()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_image(self, obj)
       
    1:     def pdf_load_inline_image(self, rdb, dict, file):
               r"""Class-aware wrapper for `::pdf_load_inline_image()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_inline_image(self, rdb, dict, file)
       
    1:     def pdf_load_journal(self, filename):
               r"""Class-aware wrapper for `::pdf_load_journal()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_journal(self, filename)
       
    1:     def pdf_load_link_annots(self, arg_1, annots, pagenum, page_ctm):
               r"""Class-aware wrapper for `::pdf_load_link_annots()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_link_annots(self, arg_1, annots, pagenum, page_ctm)
       
    1:     def pdf_load_name_tree(self, which):
               r"""Class-aware wrapper for `::pdf_load_name_tree()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_name_tree(self, which)
       
    1:     def pdf_load_object(self, num):
               r"""
               Class-aware wrapper for `::pdf_load_object()`.
                       Load a given object.
       
                       This can cause xref reorganisations (solidifications etc) due to
                       repairs, so all held pdf_xref_entries should be considered
                       invalid after this call (other than the returned one).
               """
>>>>>>         return _mupdf.PdfDocument_pdf_load_object(self, num)
       
    1:     def pdf_load_outline(self):
               r"""Class-aware wrapper for `::pdf_load_outline()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_outline(self)
       
    1:     def pdf_load_page(self, number):
               r"""Class-aware wrapper for `::pdf_load_page()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_page(self, number)
       
    1:     def pdf_load_page_tree(self):
               r"""Class-aware wrapper for `::pdf_load_page_tree()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_page_tree(self)
       
    1:     def pdf_load_pattern(self, obj):
               r"""Class-aware wrapper for `::pdf_load_pattern()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_pattern(self, obj)
       
    1:     def pdf_load_raw_stream_number(self, num):
               r"""Class-aware wrapper for `::pdf_load_raw_stream_number()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_raw_stream_number(self, num)
       
    1:     def pdf_load_shading(self, obj):
               r"""Class-aware wrapper for `::pdf_load_shading()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_shading(self, obj)
       
    1:     def pdf_load_stream_number(self, num):
               r"""Class-aware wrapper for `::pdf_load_stream_number()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_stream_number(self, num)
       
    1:     def pdf_load_to_unicode(self, font, strings, collection, cmapstm):
               r"""
               Class-aware wrapper for `::pdf_load_to_unicode()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_load_to_unicode(::pdf_font_desc *font, char *collection, ::pdf_obj *cmapstm)` => const char *strings
               """
>>>>>>         return _mupdf.PdfDocument_pdf_load_to_unicode(self, font, strings, collection, cmapstm)
       
    1:     def pdf_load_type3_glyphs(self, fontdesc):
               r"""Class-aware wrapper for `::pdf_load_type3_glyphs()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_type3_glyphs(self, fontdesc)
       
    1:     def pdf_load_unencrypted_object(self, num):
               r"""Class-aware wrapper for `::pdf_load_unencrypted_object()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_load_unencrypted_object(self, num)
       
    1:     def pdf_lookup_dest(self, needle):
               r"""Class-aware wrapper for `::pdf_lookup_dest()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_lookup_dest(self, needle)
       
    1:     def pdf_lookup_metadata(self, key, ptr, size):
               r"""Class-aware wrapper for `::pdf_lookup_metadata()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_lookup_metadata(self, key, ptr, size)
       
    1:     def pdf_lookup_metadata2(self, key):
               r"""
               Class-aware wrapper for `::pdf_lookup_metadata2()`.
               C++ alternative to `pdf_lookup_metadata()` that returns a `std::string`
               or calls `fz_throw()` if not found.
               """
>>>>>>         return _mupdf.PdfDocument_pdf_lookup_metadata2(self, key)
       
    1:     def pdf_lookup_name(self, which, needle):
               r"""Class-aware wrapper for `::pdf_lookup_name()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_lookup_name(self, which, needle)
       
    1:     def pdf_lookup_page_loc(self, needle, parentp, indexp):
               r"""
               Class-aware wrapper for `::pdf_lookup_page_loc()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_lookup_page_loc(int needle, ::pdf_obj **parentp)` => `(pdf_obj *, int indexp)`
               """
>>>>>>         return _mupdf.PdfDocument_pdf_lookup_page_loc(self, needle, parentp, indexp)
       
    1:     def pdf_lookup_page_number(self, pageobj):
               r"""Class-aware wrapper for `::pdf_lookup_page_number()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_lookup_page_number(self, pageobj)
       
    1:     def pdf_lookup_page_obj(self, needle):
               r"""Class-aware wrapper for `::pdf_lookup_page_obj()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_lookup_page_obj(self, needle)
       
    1:     def pdf_mark_xref(self):
               r"""Class-aware wrapper for `::pdf_mark_xref()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_mark_xref(self)
       
    1:     def pdf_metadata(self):
               r"""Class-aware wrapper for `::pdf_metadata()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_metadata(self)
       
    1:     def pdf_minimize_document(self):
               r"""Class-aware wrapper for `::pdf_minimize_document()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_minimize_document(self)
       
    1:     def pdf_needs_password(self):
               r"""Class-aware wrapper for `::pdf_needs_password()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_needs_password(self)
       
    1:     def pdf_new_action_from_link(self, uri):
               r"""Class-aware wrapper for `::pdf_new_action_from_link()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_action_from_link(self, uri)
       
    1:     def pdf_new_array(self, initialcap):
               r"""Class-aware wrapper for `::pdf_new_array()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_array(self, initialcap)
       
    1:     def pdf_new_color_filter(self, chain, struct_parents, transform, options, copts):
               r"""Class-aware wrapper for `::pdf_new_color_filter()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_color_filter(self, chain, struct_parents, transform, options, copts)
       
    1:     def pdf_new_date(self, time):
               r"""Class-aware wrapper for `::pdf_new_date()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_date(self, time)
       
    1:     def pdf_new_dest_from_link(self, uri, is_remote):
               r"""Class-aware wrapper for `::pdf_new_dest_from_link()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_dest_from_link(self, uri, is_remote)
       
    1:     def pdf_new_dict(self, initialcap):
               r"""Class-aware wrapper for `::pdf_new_dict()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_dict(self, initialcap)
       
    1:     def pdf_new_graft_map(self):
               r"""Class-aware wrapper for `::pdf_new_graft_map()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_graft_map(self)
       
    1:     def pdf_new_indirect(self, num, gen):
               r"""Class-aware wrapper for `::pdf_new_indirect()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_indirect(self, num, gen)
       
    1:     def pdf_new_matrix(self, mtx):
               r"""Class-aware wrapper for `::pdf_new_matrix()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_matrix(self, mtx)
       
    1:     def pdf_new_pdf_device(self, topctm, resources, contents):
               r"""Class-aware wrapper for `::pdf_new_pdf_device()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_pdf_device(self, topctm, resources, contents)
       
    1:     def pdf_new_point(self, point):
               r"""Class-aware wrapper for `::pdf_new_point()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_point(self, point)
       
    1:     def pdf_new_rect(self, rect):
               r"""Class-aware wrapper for `::pdf_new_rect()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_rect(self, rect)
       
    1:     def pdf_new_run_processor(self, dev, ctm, struct_parent, usage, gstate, default_cs, cookie, fill_gstate, stroke_gstate):
               r"""Class-aware wrapper for `::pdf_new_run_processor()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_run_processor(self, dev, ctm, struct_parent, usage, gstate, default_cs, cookie, fill_gstate, stroke_gstate)
       
    1:     def pdf_new_sanitize_filter(self, chain, struct_parents, transform, options, sopts):
               r"""Class-aware wrapper for `::pdf_new_sanitize_filter()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_sanitize_filter(self, chain, struct_parents, transform, options, sopts)
       
    1:     def pdf_new_xobject(self, bbox, matrix, res, buffer):
               r"""Class-aware wrapper for `::pdf_new_xobject()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_new_xobject(self, bbox, matrix, res, buffer)
       
    1:     def pdf_obj_num_is_stream(self, num):
               r"""Class-aware wrapper for `::pdf_obj_num_is_stream()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_obj_num_is_stream(self, num)
       
    1:     def pdf_object_exists(self, num):
               r"""Class-aware wrapper for `::pdf_object_exists()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_object_exists(self, num)
       
    1:     def pdf_open_contents_stream(self, obj):
               r"""Class-aware wrapper for `::pdf_open_contents_stream()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_open_contents_stream(self, obj)
       
    1:     def pdf_open_inline_stream(self, stmobj, length, chain, params):
               r"""Class-aware wrapper for `::pdf_open_inline_stream()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_open_inline_stream(self, stmobj, length, chain, params)
       
    1:     def pdf_open_raw_stream_number(self, num):
               r"""Class-aware wrapper for `::pdf_open_raw_stream_number()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_open_raw_stream_number(self, num)
       
    1:     def pdf_open_stream_number(self, num):
               r"""Class-aware wrapper for `::pdf_open_stream_number()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_open_stream_number(self, num)
       
    1:     def pdf_open_stream_with_offset(self, num, dict, stm_ofs):
               r"""Class-aware wrapper for `::pdf_open_stream_with_offset()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_open_stream_with_offset(self, num, dict, stm_ofs)
       
    1:     def pdf_page_label(self, page, buf, size):
               r"""Class-aware wrapper for `::pdf_page_label()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_page_label(self, page, buf, size)
       
    1:     def pdf_page_write(self, mediabox, presources, pcontents):
               r"""
               Class-aware wrapper for `::pdf_page_write()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_page_write(::fz_rect mediabox, ::pdf_obj **presources, ::fz_buffer **pcontents)` => `(fz_device *)`
               """
>>>>>>         return _mupdf.PdfDocument_pdf_page_write(self, mediabox, presources, pcontents)
       
    1:     def pdf_parse_array(self, f, buf):
               r"""Class-aware wrapper for `::pdf_parse_array()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_parse_array(self, f, buf)
       
    1:     def pdf_parse_dict(self, f, buf):
               r"""Class-aware wrapper for `::pdf_parse_dict()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_parse_dict(self, f, buf)
       
    1:     def pdf_parse_ind_obj(self, f, num, gen, stm_ofs, try_repair):
               r"""
               Class-aware wrapper for `::pdf_parse_ind_obj()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_parse_ind_obj(::fz_stream *f)` => `(pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair)`
               """
>>>>>>         return _mupdf.PdfDocument_pdf_parse_ind_obj(self, f, num, gen, stm_ofs, try_repair)
       
    1:     def pdf_parse_journal_obj(self, stm, onum, ostm, newobj):
               r"""
               Class-aware wrapper for `::pdf_parse_journal_obj()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_parse_journal_obj(::fz_stream *stm, ::fz_buffer **ostm)` => `(pdf_obj *, int onum, int newobj)`
               """
>>>>>>         return _mupdf.PdfDocument_pdf_parse_journal_obj(self, stm, onum, ostm, newobj)
       
    1:     def pdf_parse_stm_obj(self, f, buf):
               r"""Class-aware wrapper for `::pdf_parse_stm_obj()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_parse_stm_obj(self, f, buf)
       
    1:     def pdf_progressive_advance(self, pagenum):
               r"""Class-aware wrapper for `::pdf_progressive_advance()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_progressive_advance(self, pagenum)
       
    1:     def pdf_purge_local_resources(self):
               r"""Class-aware wrapper for `::pdf_purge_local_resources()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_purge_local_resources(self)
       
    1:     def pdf_purge_locals_from_store(self):
               r"""Class-aware wrapper for `::pdf_purge_locals_from_store()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_purge_locals_from_store(self)
       
    1:     def pdf_purge_object_from_store(self, num):
               r"""Class-aware wrapper for `::pdf_purge_object_from_store()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_purge_object_from_store(self, num)
       
    1:     def pdf_read_journal(self, stm):
               r"""Class-aware wrapper for `::pdf_read_journal()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_read_journal(self, stm)
       
    1:     def pdf_rearrange_pages(self, count, pages, structure):
               r"""Class-aware wrapper for `::pdf_rearrange_pages()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_rearrange_pages(self, count, pages, structure)
       
    1:     def pdf_rearrange_pages2(self, pages, structure):
               r"""Class-aware wrapper for `::pdf_rearrange_pages2()`.   Swig-friendly wrapper for pdf_rearrange_pages()."""
>>>>>>         return _mupdf.PdfDocument_pdf_rearrange_pages2(self, pages, structure)
       
    1:     def pdf_recolor_page(self, pagenum, opts):
               r"""Class-aware wrapper for `::pdf_recolor_page()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_recolor_page(self, pagenum, opts)
       
    1:     def pdf_redact_page(self, page, opts):
               r"""Class-aware wrapper for `::pdf_redact_page()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_redact_page(self, page, opts)
       
    1:     def pdf_redo(self):
               r"""Class-aware wrapper for `::pdf_redo()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_redo(self)
       
    1:     def pdf_remove_output_intents(self):
               r"""Class-aware wrapper for `::pdf_remove_output_intents()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_remove_output_intents(self)
       
    1:     def pdf_repair_obj(self, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root):
               r"""
               Class-aware wrapper for `::pdf_repair_obj()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_repair_obj(::pdf_lexbuf *buf, ::pdf_obj **encrypt, ::pdf_obj **id, ::pdf_obj **page, ::pdf_obj **root)` => `(int, int64_t stmofsp, int64_t stmlenp, int64_t tmpofs)`
               """
>>>>>>         return _mupdf.PdfDocument_pdf_repair_obj(self, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root)
       
    1:     def pdf_repair_xref(self):
               r"""Class-aware wrapper for `::pdf_repair_xref()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_repair_xref(self)
       
    1:     def pdf_replace_xref(self, entries, n):
               r"""Class-aware wrapper for `::pdf_replace_xref()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_replace_xref(self, entries, n)
       
    1:     def pdf_reset_form(self, fields, exclude):
               r"""Class-aware wrapper for `::pdf_reset_form()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_reset_form(self, fields, exclude)
       
    1:     def pdf_resolve_link(self, uri, xp, yp):
               r"""
               Class-aware wrapper for `::pdf_resolve_link()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_resolve_link(const char *uri)` => `(int, float xp, float yp)`
               """
>>>>>>         return _mupdf.PdfDocument_pdf_resolve_link(self, uri, xp, yp)
       
    1:     def pdf_rewrite_images(self, opts):
               r"""Class-aware wrapper for `::pdf_rewrite_images()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_rewrite_images(self, opts)
       
    1:     def pdf_run_document_structure(self, dev, cookie):
               r"""Class-aware wrapper for `::pdf_run_document_structure()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_run_document_structure(self, dev, cookie)
       
    1:     def pdf_run_glyph(self, resources, contents, dev, ctm, gstate, default_cs, fill_gstate, stroke_gstate):
               r"""Class-aware wrapper for `::pdf_run_glyph()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_run_glyph(self, resources, contents, dev, ctm, gstate, default_cs, fill_gstate, stroke_gstate)
       
    1:     def pdf_save_document(self, filename, opts):
               r"""Class-aware wrapper for `::pdf_save_document()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_save_document(self, filename, opts)
       
    1:     def pdf_save_journal(self, filename):
               r"""Class-aware wrapper for `::pdf_save_journal()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_save_journal(self, filename)
       
    1:     def pdf_save_snapshot(self, filename):
               r"""Class-aware wrapper for `::pdf_save_snapshot()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_save_snapshot(self, filename)
       
    1:     def pdf_select_layer_config(self, config_num):
               r"""Class-aware wrapper for `::pdf_select_layer_config()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_select_layer_config(self, config_num)
       
    1:     def pdf_select_layer_config_ui(self, ui):
               r"""Class-aware wrapper for `::pdf_select_layer_config_ui()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_select_layer_config_ui(self, ui)
       
    1:     def pdf_serialise_journal(self, out):
               r"""Class-aware wrapper for `::pdf_serialise_journal()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_serialise_journal(self, out)
       
    1:     def pdf_set_annot_field_value(self, widget, text, ignore_trigger_events):
               r"""Class-aware wrapper for `::pdf_set_annot_field_value()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_set_annot_field_value(self, widget, text, ignore_trigger_events)
       
    1:     def pdf_set_doc_event_callback(self, event_cb, free_event_data_cb, data):
               r"""Class-aware wrapper for `::pdf_set_doc_event_callback()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_set_doc_event_callback(self, event_cb, free_event_data_cb, data)
       
    1:     def pdf_set_document_language(self, lang):
               r"""Class-aware wrapper for `::pdf_set_document_language()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_set_document_language(self, lang)
       
    1:     def pdf_set_field_value(self, field, text, ignore_trigger_events):
               r"""Class-aware wrapper for `::pdf_set_field_value()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_set_field_value(self, field, text, ignore_trigger_events)
       
    1:     def pdf_set_layer_config_as_default(self):
               r"""Class-aware wrapper for `::pdf_set_layer_config_as_default()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_set_layer_config_as_default(self)
       
    1:     def pdf_set_page_labels(self, index, style, prefix, start):
               r"""Class-aware wrapper for `::pdf_set_page_labels()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_set_page_labels(self, index, style, prefix, start)
       
    1:     def pdf_set_populating_xref_trailer(self, trailer):
               r"""Class-aware wrapper for `::pdf_set_populating_xref_trailer()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_set_populating_xref_trailer(self, trailer)
       
    1:     def pdf_signature_byte_range(self, signature, byte_range):
               r"""Class-aware wrapper for `::pdf_signature_byte_range()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_signature_byte_range(self, signature, byte_range)
       
    1:     def pdf_signature_contents(self, signature, contents):
               r"""
               Class-aware wrapper for `::pdf_signature_contents()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_signature_contents(::pdf_obj *signature)` => `(size_t, char *contents)`
               """
>>>>>>         return _mupdf.PdfDocument_pdf_signature_contents(self, signature, contents)
       
    1:     def pdf_signature_hash_bytes(self, signature):
               r"""Class-aware wrapper for `::pdf_signature_hash_bytes()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_signature_hash_bytes(self, signature)
       
    1:     def pdf_signature_incremental_change_since_signing(self, signature):
               r"""Class-aware wrapper for `::pdf_signature_incremental_change_since_signing()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_signature_incremental_change_since_signing(self, signature)
       
    1:     def pdf_signature_is_signed(self, field):
               r"""Class-aware wrapper for `::pdf_signature_is_signed()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_signature_is_signed(self, field)
       
    1:     def pdf_signature_set_value(self, field, signer, stime):
               r"""Class-aware wrapper for `::pdf_signature_set_value()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_signature_set_value(self, field, signer, stime)
       
    1:     def pdf_subset_fonts(self, pages_len, pages):
               r"""Class-aware wrapper for `::pdf_subset_fonts()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_subset_fonts(self, pages_len, pages)
       
    1:     def pdf_subset_fonts2(self, pages):
               r"""Class-aware wrapper for `::pdf_subset_fonts2()`.   Swig-friendly wrapper for pdf_subset_fonts()."""
>>>>>>         return _mupdf.PdfDocument_pdf_subset_fonts2(self, pages)
       
    1:     def pdf_sync_open_pages(self):
               r"""Class-aware wrapper for `::pdf_sync_open_pages()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_sync_open_pages(self)
       
    1:     def pdf_toggle_layer_config_ui(self, ui):
               r"""Class-aware wrapper for `::pdf_toggle_layer_config_ui()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_toggle_layer_config_ui(self, ui)
       
    1:     def pdf_trailer(self):
               r"""Class-aware wrapper for `::pdf_trailer()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_trailer(self)
       
    1:     def pdf_undo(self):
               r"""Class-aware wrapper for `::pdf_undo()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_undo(self)
       
    1:     def pdf_undoredo_state(self, steps):
               r"""
               Class-aware wrapper for `::pdf_undoredo_state()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_undoredo_state()` => `(int, int steps)`
               """
>>>>>>         return _mupdf.PdfDocument_pdf_undoredo_state(self, steps)
       
    1:     def pdf_undoredo_step(self, step):
               r"""Class-aware wrapper for `::pdf_undoredo_step()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_undoredo_step(self, step)
       
    1:     def pdf_update_object(self, num, obj):
               r"""Class-aware wrapper for `::pdf_update_object()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_update_object(self, num, obj)
       
    1:     def pdf_update_stream(self, ref, buf, compressed):
               r"""Class-aware wrapper for `::pdf_update_stream()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_update_stream(self, ref, buf, compressed)
       
    1:     def pdf_update_xobject(self, xobj, bbox, mat, res, buffer):
               r"""Class-aware wrapper for `::pdf_update_xobject()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_update_xobject(self, xobj, bbox, mat, res, buffer)
       
    1:     def pdf_validate_change_history(self):
               r"""Class-aware wrapper for `::pdf_validate_change_history()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_validate_change_history(self)
       
    1:     def pdf_validate_changes(self, version):
               r"""Class-aware wrapper for `::pdf_validate_changes()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_validate_changes(self, version)
       
    1:     def pdf_version(self):
               r"""Class-aware wrapper for `::pdf_version()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_version(self)
       
    1:     def pdf_was_pure_xfa(self):
               r"""Class-aware wrapper for `::pdf_was_pure_xfa()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_was_pure_xfa(self)
       
    1:     def pdf_was_repaired(self):
               r"""Class-aware wrapper for `::pdf_was_repaired()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_was_repaired(self)
       
    1:     def pdf_write_document(self, out, opts):
               r"""Class-aware wrapper for `::pdf_write_document()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_write_document(self, out, opts)
       
    1:     def pdf_write_journal(self, out):
               r"""Class-aware wrapper for `::pdf_write_journal()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_write_journal(self, out)
       
    1:     def pdf_write_snapshot(self, out):
               r"""Class-aware wrapper for `::pdf_write_snapshot()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_write_snapshot(self, out)
       
    1:     def pdf_xref_ensure_incremental_object(self, num):
               r"""Class-aware wrapper for `::pdf_xref_ensure_incremental_object()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_xref_ensure_incremental_object(self, num)
       
    1:     def pdf_xref_ensure_local_object(self, num):
               r"""Class-aware wrapper for `::pdf_xref_ensure_local_object()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_xref_ensure_local_object(self, num)
       
    1:     def pdf_xref_entry_map(self, fn, arg):
               r"""Class-aware wrapper for `::pdf_xref_entry_map()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_xref_entry_map(self, fn, arg)
       
    1:     def pdf_xref_is_incremental(self, num):
               r"""Class-aware wrapper for `::pdf_xref_is_incremental()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_xref_is_incremental(self, num)
       
    1:     def pdf_xref_len(self):
               r"""Class-aware wrapper for `::pdf_xref_len()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_xref_len(self)
       
    1:     def pdf_xref_obj_is_unsaved_signature(self, obj):
               r"""Class-aware wrapper for `::pdf_xref_obj_is_unsaved_signature()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_xref_obj_is_unsaved_signature(self, obj)
       
    1:     def pdf_xref_remove_unsaved_signature(self, field):
               r"""Class-aware wrapper for `::pdf_xref_remove_unsaved_signature()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_xref_remove_unsaved_signature(self, field)
       
    1:     def pdf_xref_store_unsaved_signature(self, field, signer):
               r"""Class-aware wrapper for `::pdf_xref_store_unsaved_signature()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_xref_store_unsaved_signature(self, field, signer)
       
    1:     def pdf_zugferd_profile(self, version):
               r"""
               Class-aware wrapper for `::pdf_zugferd_profile()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_zugferd_profile()` => `(enum pdf_zugferd_profile, float version)`
               """
>>>>>>         return _mupdf.PdfDocument_pdf_zugferd_profile(self, version)
       
    1:     def pdf_zugferd_xml(self):
               r"""Class-aware wrapper for `::pdf_zugferd_xml()`."""
>>>>>>         return _mupdf.PdfDocument_pdf_zugferd_xml(self)
       
    1:     def super(self):
               r"""Returns wrapper for .super member."""
>>>>>>         return _mupdf.PdfDocument_super(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `pdf_create_document()`.
       
               |
       
               *Overload 2:*
               Constructor using `pdf_document_from_fz_document()`.
       
               |
       
               *Overload 3:*
               Constructor using `pdf_open_document()`.
       
               |
       
               *Overload 4:*
               Constructor using `pdf_open_document_with_stream()`.
       
               |
       
               *Overload 5:*
               Copy constructor using `pdf_keep_document()`.
       
               |
       
               *Overload 6:*
               Constructor using raw copy of pre-existing `::pdf_document`.
               """
>>>>>>         _mupdf.PdfDocument_swiginit(self, _mupdf.new_PdfDocument(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfDocument
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfDocument_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfDocument___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfDocument_m_internal_get, _mupdf.PdfDocument_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfDocument_s_num_instances_get, _mupdf.PdfDocument_s_num_instances_set)
       
       # Register PdfDocument in _mupdf:
    1: _mupdf.PdfDocument_swigregister(PdfDocument)
    2: class PdfFilespecParams(object):
    1:     r"""Wrapper class for struct `pdf_filespec_params`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_filespec_params`.
               """
>>>>>>         _mupdf.PdfFilespecParams_swiginit(self, _mupdf.new_PdfFilespecParams(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfFilespecParams
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfFilespecParams_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfFilespecParams___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfFilespecParams_m_internal_get, _mupdf.PdfFilespecParams_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfFilespecParams_s_num_instances_get, _mupdf.PdfFilespecParams_s_num_instances_set)
       
       # Register PdfFilespecParams in _mupdf:
    1: _mupdf.PdfFilespecParams_swigregister(PdfFilespecParams)
    2: class PdfFilterFactory(object):
    1:     r"""Wrapper class for struct `pdf_filter_factory`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_filter_factory`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_filter_factory`.
               """
>>>>>>         _mupdf.PdfFilterFactory_swiginit(self, _mupdf.new_PdfFilterFactory(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.PdfFilterFactory_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_PdfFilterFactory
    1:     filter = property(_mupdf.PdfFilterFactory_filter_get, _mupdf.PdfFilterFactory_filter_set)
    1:     options = property(_mupdf.PdfFilterFactory_options_get, _mupdf.PdfFilterFactory_options_set)
    1:     s_num_instances = property(_mupdf.PdfFilterFactory_s_num_instances_get, _mupdf.PdfFilterFactory_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.PdfFilterFactory_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfFilterFactory___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfFilterFactory___ne__(self, rhs)
       
       # Register PdfFilterFactory in _mupdf:
    1: _mupdf.PdfFilterFactory_swigregister(PdfFilterFactory)
    2: class PdfFilterFactory2(PdfFilterFactory):
    1:     r"""Wrapper class for struct pdf_filter_factory with virtual fns for each fnptr; this is for use as a SWIG Director class."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self):
               r"""== Constructor."""
>>>>>>         if self.__class__ == PdfFilterFactory2:
>>>>>>             _self = None
               else:
>>>>>>             _self = self
>>>>>>         _mupdf.PdfFilterFactory2_swiginit(self, _mupdf.new_PdfFilterFactory2(_self, ))
    1:     __swig_destroy__ = _mupdf.delete_PdfFilterFactory2
       
    1:     def use_virtual_filter(self, use=True):
               r"""
               These methods set the function pointers in *m_internal
               to point to internal callbacks that call our virtual methods.
               """
>>>>>>         return _mupdf.PdfFilterFactory2_use_virtual_filter(self, use)
       
    1:     def filter(self, arg_0, arg_1, arg_2, arg_3, arg_4, arg_5):
               r"""Default virtual method implementations; these all throw an exception."""
>>>>>>         return _mupdf.PdfFilterFactory2_filter(self, arg_0, arg_1, arg_2, arg_3, arg_4, arg_5)
    1:     def __disown__(self):
>>>>>>         self.this.disown()
>>>>>>         _mupdf.disown_PdfFilterFactory2(self)
>>>>>>         return weakref.proxy(self)
       
       # Register PdfFilterFactory2 in _mupdf:
    1: _mupdf.PdfFilterFactory2_swigregister(PdfFilterFactory2)
    2: class PdfFilterOptions(object):
    1:     r"""Wrapper class for struct `pdf_filter_options`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def add_factory(self, factory):
               r"""We use default copy constructor and operator=.  Appends `factory` to internal vector and updates this->filters."""
>>>>>>         return _mupdf.PdfFilterOptions_add_factory(self, factory)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor initialises all fields to null/zero.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_filter_options`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_filter_options`.
               """
>>>>>>         _mupdf.PdfFilterOptions_swiginit(self, _mupdf.new_PdfFilterOptions(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.PdfFilterOptions_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_PdfFilterOptions
    1:     recurse = property(_mupdf.PdfFilterOptions_recurse_get, _mupdf.PdfFilterOptions_recurse_set)
    1:     instance_forms = property(_mupdf.PdfFilterOptions_instance_forms_get, _mupdf.PdfFilterOptions_instance_forms_set)
    1:     ascii = property(_mupdf.PdfFilterOptions_ascii_get, _mupdf.PdfFilterOptions_ascii_set)
    1:     no_update = property(_mupdf.PdfFilterOptions_no_update_get, _mupdf.PdfFilterOptions_no_update_set)
    1:     opaque = property(_mupdf.PdfFilterOptions_opaque_get, _mupdf.PdfFilterOptions_opaque_set)
    1:     complete = property(_mupdf.PdfFilterOptions_complete_get, _mupdf.PdfFilterOptions_complete_set)
    1:     filters = property(_mupdf.PdfFilterOptions_filters_get, _mupdf.PdfFilterOptions_filters_set)
    1:     newlines = property(_mupdf.PdfFilterOptions_newlines_get, _mupdf.PdfFilterOptions_newlines_set)
    1:     s_num_instances = property(_mupdf.PdfFilterOptions_s_num_instances_get, _mupdf.PdfFilterOptions_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.PdfFilterOptions_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfFilterOptions___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfFilterOptions___ne__(self, rhs)
    1:     m_filters = property(_mupdf.PdfFilterOptions_m_filters_get, _mupdf.PdfFilterOptions_m_filters_set)
       
       # Register PdfFilterOptions in _mupdf:
    1: _mupdf.PdfFilterOptions_swigregister(PdfFilterOptions)
    2: class PdfFilterOptions2(PdfFilterOptions):
    1:     r"""Wrapper class for struct pdf_filter_options with virtual fns for each fnptr; this is for use as a SWIG Director class."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self):
               r"""== Constructor."""
>>>>>>         if self.__class__ == PdfFilterOptions2:
>>>>>>             _self = None
               else:
>>>>>>             _self = self
>>>>>>         _mupdf.PdfFilterOptions2_swiginit(self, _mupdf.new_PdfFilterOptions2(_self, ))
    1:     __swig_destroy__ = _mupdf.delete_PdfFilterOptions2
       
    1:     def use_virtual_complete(self, use=True):
               r"""
               These methods set the function pointers in *m_internal
               to point to internal callbacks that call our virtual methods.
               """
>>>>>>         return _mupdf.PdfFilterOptions2_use_virtual_complete(self, use)
       
    1:     def complete(self, arg_0, arg_1):
               r"""Default virtual method implementations; these all throw an exception."""
>>>>>>         return _mupdf.PdfFilterOptions2_complete(self, arg_0, arg_1)
    1:     def __disown__(self):
>>>>>>         self.this.disown()
>>>>>>         _mupdf.disown_PdfFilterOptions2(self)
>>>>>>         return weakref.proxy(self)
       
       # Register PdfFilterOptions2 in _mupdf:
    1: _mupdf.PdfFilterOptions2_swigregister(PdfFilterOptions2)
    2: class PdfFontDesc(object):
    1:     r"""Wrapper class for struct `pdf_font_desc`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_add_hmtx(self, lo, hi, w):
               r"""Class-aware wrapper for `::pdf_add_hmtx()`."""
>>>>>>         return _mupdf.PdfFontDesc_pdf_add_hmtx(self, lo, hi, w)
       
    1:     def pdf_add_vmtx(self, lo, hi, x, y, w):
               r"""Class-aware wrapper for `::pdf_add_vmtx()`."""
>>>>>>         return _mupdf.PdfFontDesc_pdf_add_vmtx(self, lo, hi, x, y, w)
       
    1:     def pdf_end_hmtx(self):
               r"""Class-aware wrapper for `::pdf_end_hmtx()`."""
>>>>>>         return _mupdf.PdfFontDesc_pdf_end_hmtx(self)
       
    1:     def pdf_end_vmtx(self):
               r"""Class-aware wrapper for `::pdf_end_vmtx()`."""
>>>>>>         return _mupdf.PdfFontDesc_pdf_end_vmtx(self)
       
    1:     def pdf_font_cid_to_gid(self, cid):
               r"""Class-aware wrapper for `::pdf_font_cid_to_gid()`."""
>>>>>>         return _mupdf.PdfFontDesc_pdf_font_cid_to_gid(self, cid)
       
    1:     def pdf_set_default_hmtx(self, w):
               r"""Class-aware wrapper for `::pdf_set_default_hmtx()`."""
>>>>>>         return _mupdf.PdfFontDesc_pdf_set_default_hmtx(self, w)
       
    1:     def pdf_set_default_vmtx(self, y, w):
               r"""Class-aware wrapper for `::pdf_set_default_vmtx()`."""
>>>>>>         return _mupdf.PdfFontDesc_pdf_set_default_vmtx(self, y, w)
       
    1:     def pdf_set_font_wmode(self, wmode):
               r"""Class-aware wrapper for `::pdf_set_font_wmode()`."""
>>>>>>         return _mupdf.PdfFontDesc_pdf_set_font_wmode(self, wmode)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `pdf_new_font_desc()`.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_font_desc`.
               """
>>>>>>         _mupdf.PdfFontDesc_swiginit(self, _mupdf.new_PdfFontDesc(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfFontDesc
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfFontDesc_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfFontDesc___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfFontDesc_m_internal_get, _mupdf.PdfFontDesc_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfFontDesc_s_num_instances_get, _mupdf.PdfFontDesc_s_num_instances_set)
       
       # Register PdfFontDesc in _mupdf:
    1: _mupdf.PdfFontDesc_swigregister(PdfFontDesc)
    2: class PdfFontResourceKey(object):
    1:     r"""Wrapper class for struct `pdf_font_resource_key`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_font_resource_key`.
               """
>>>>>>         _mupdf.PdfFontResourceKey_swiginit(self, _mupdf.new_PdfFontResourceKey(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfFontResourceKey
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfFontResourceKey_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfFontResourceKey___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfFontResourceKey_m_internal_get, _mupdf.PdfFontResourceKey_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfFontResourceKey_s_num_instances_get, _mupdf.PdfFontResourceKey_s_num_instances_set)
       
       # Register PdfFontResourceKey in _mupdf:
    1: _mupdf.PdfFontResourceKey_swigregister(PdfFontResourceKey)
    2: class PdfFunction(object):
    1:     r"""Wrapper class for struct `pdf_function`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_eval_function(self, _in, inlen, out, outlen):
               r"""
               Class-aware wrapper for `::pdf_eval_function()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_eval_function(const float *in, int inlen, int outlen)` => float out
               """
>>>>>>         return _mupdf.PdfFunction_pdf_eval_function(self, _in, inlen, out, outlen)
       
    1:     def pdf_function_size(self):
               r"""Class-aware wrapper for `::pdf_function_size()`."""
>>>>>>         return _mupdf.PdfFunction_pdf_function_size(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Copy constructor using `pdf_keep_function()`.
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_function`.
               """
>>>>>>         _mupdf.PdfFunction_swiginit(self, _mupdf.new_PdfFunction(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfFunction
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfFunction_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfFunction___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfFunction_m_internal_get, _mupdf.PdfFunction_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfFunction_s_num_instances_get, _mupdf.PdfFunction_s_num_instances_set)
       
       # Register PdfFunction in _mupdf:
    1: _mupdf.PdfFunction_swigregister(PdfFunction)
    2: class PdfGraftMap(object):
    1:     r"""Wrapper class for struct `pdf_graft_map`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_graft_mapped_object(self, obj):
               r"""Class-aware wrapper for `::pdf_graft_mapped_object()`."""
>>>>>>         return _mupdf.PdfGraftMap_pdf_graft_mapped_object(self, obj)
       
    1:     def pdf_graft_mapped_page(self, page_to, src, page_from):
               r"""Class-aware wrapper for `::pdf_graft_mapped_page()`."""
>>>>>>         return _mupdf.PdfGraftMap_pdf_graft_mapped_page(self, page_to, src, page_from)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `pdf_new_graft_map()`.
       
               |
       
               *Overload 2:*
               Copy constructor using `pdf_keep_graft_map()`.
       
               |
       
               *Overload 3:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 4:*
               Constructor using raw copy of pre-existing `::pdf_graft_map`.
               """
>>>>>>         _mupdf.PdfGraftMap_swiginit(self, _mupdf.new_PdfGraftMap(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfGraftMap
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfGraftMap_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfGraftMap___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfGraftMap_m_internal_get, _mupdf.PdfGraftMap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfGraftMap_s_num_instances_get, _mupdf.PdfGraftMap_s_num_instances_set)
       
       # Register PdfGraftMap in _mupdf:
    1: _mupdf.PdfGraftMap_swigregister(PdfGraftMap)
    2: class PdfGstate(object):
    1:     r"""Wrapper class for struct `pdf_gstate`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_gstate`.
               """
>>>>>>         _mupdf.PdfGstate_swiginit(self, _mupdf.new_PdfGstate(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfGstate
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfGstate_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfGstate___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfGstate_m_internal_get, _mupdf.PdfGstate_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfGstate_s_num_instances_get, _mupdf.PdfGstate_s_num_instances_set)
       
       # Register PdfGstate in _mupdf:
    1: _mupdf.PdfGstate_swigregister(PdfGstate)
    2: class PdfHintPage(object):
    1:     r"""Wrapper class for struct `pdf_hint_page`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_hint_page`.
               """
>>>>>>         _mupdf.PdfHintPage_swiginit(self, _mupdf.new_PdfHintPage(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfHintPage
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfHintPage_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfHintPage___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfHintPage_m_internal_get, _mupdf.PdfHintPage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfHintPage_s_num_instances_get, _mupdf.PdfHintPage_s_num_instances_set)
       
       # Register PdfHintPage in _mupdf:
    1: _mupdf.PdfHintPage_swigregister(PdfHintPage)
    2: class PdfHintShared(object):
    1:     r"""Wrapper class for struct `pdf_hint_shared`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_hint_shared`.
               """
>>>>>>         _mupdf.PdfHintShared_swiginit(self, _mupdf.new_PdfHintShared(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfHintShared
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfHintShared_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfHintShared___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfHintShared_m_internal_get, _mupdf.PdfHintShared_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfHintShared_s_num_instances_get, _mupdf.PdfHintShared_s_num_instances_set)
       
       # Register PdfHintShared in _mupdf:
    1: _mupdf.PdfHintShared_swigregister(PdfHintShared)
    2: class PdfHmtx(object):
    1:     r"""Wrapper class for struct `pdf_hmtx`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_hmtx`.
               """
>>>>>>         _mupdf.PdfHmtx_swiginit(self, _mupdf.new_PdfHmtx(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfHmtx
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfHmtx_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfHmtx___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfHmtx_m_internal_get, _mupdf.PdfHmtx_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfHmtx_s_num_instances_get, _mupdf.PdfHmtx_s_num_instances_set)
       
       # Register PdfHmtx in _mupdf:
    1: _mupdf.PdfHmtx_swigregister(PdfHmtx)
    2: class PdfImageRewriterOptions(object):
    1:     r"""Wrapper class for struct `pdf_image_rewriter_options`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_image_rewriter_options`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_image_rewriter_options`.
               """
>>>>>>         _mupdf.PdfImageRewriterOptions_swiginit(self, _mupdf.new_PdfImageRewriterOptions(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.PdfImageRewriterOptions_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_PdfImageRewriterOptions
    1:     color_lossless_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_method_set)
    1:     color_lossy_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_method_set)
    1:     color_lossless_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_threshold_set)
    1:     color_lossless_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_to_set)
    1:     color_lossy_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_threshold_set)
    1:     color_lossy_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_to_set)
    1:     color_lossless_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_recompress_method_set)
    1:     color_lossy_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_recompress_method_set)
    1:     color_lossy_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_recompress_quality_set)
    1:     color_lossless_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_recompress_quality_set)
    1:     gray_lossless_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_method_set)
    1:     gray_lossy_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_method_set)
    1:     gray_lossless_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_threshold_set)
    1:     gray_lossless_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_to_set)
    1:     gray_lossy_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_threshold_set)
    1:     gray_lossy_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_to_set)
    1:     gray_lossless_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_recompress_method_set)
    1:     gray_lossy_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_recompress_method_set)
    1:     gray_lossy_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_recompress_quality_set)
    1:     gray_lossless_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_recompress_quality_set)
    1:     bitonal_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_bitonal_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_bitonal_image_subsample_method_set)
    1:     bitonal_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_bitonal_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_bitonal_image_subsample_threshold_set)
    1:     bitonal_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_bitonal_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_bitonal_image_subsample_to_set)
    1:     bitonal_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_bitonal_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_bitonal_image_recompress_method_set)
    1:     bitonal_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_bitonal_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_bitonal_image_recompress_quality_set)
    1:     s_num_instances = property(_mupdf.PdfImageRewriterOptions_s_num_instances_get, _mupdf.PdfImageRewriterOptions_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.PdfImageRewriterOptions_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfImageRewriterOptions___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfImageRewriterOptions___ne__(self, rhs)
       
       # Register PdfImageRewriterOptions in _mupdf:
    1: _mupdf.PdfImageRewriterOptions_swigregister(PdfImageRewriterOptions)
    2: class PdfJournal(object):
    1:     r"""Wrapper class for struct `pdf_journal`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_discard_journal(self):
               r"""Class-aware wrapper for `::pdf_discard_journal()`."""
>>>>>>         return _mupdf.PdfJournal_pdf_discard_journal(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_journal`.
               """
>>>>>>         _mupdf.PdfJournal_swiginit(self, _mupdf.new_PdfJournal(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfJournal
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfJournal_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfJournal___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfJournal_m_internal_get, _mupdf.PdfJournal_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfJournal_s_num_instances_get, _mupdf.PdfJournal_s_num_instances_set)
       
       # Register PdfJournal in _mupdf:
    1: _mupdf.PdfJournal_swigregister(PdfJournal)
    2: class PdfJs(object):
    1:     r"""Wrapper class for struct `pdf_js`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_js_event_init(self, target, value, willCommit):
               r"""Class-aware wrapper for `::pdf_js_event_init()`."""
>>>>>>         return _mupdf.PdfJs_pdf_js_event_init(self, target, value, willCommit)
       
    1:     def pdf_js_event_init_keystroke(self, target, evt):
               r"""Class-aware wrapper for `::pdf_js_event_init_keystroke()`."""
>>>>>>         return _mupdf.PdfJs_pdf_js_event_init_keystroke(self, target, evt)
       
    1:     def pdf_js_event_result(self):
               r"""Class-aware wrapper for `::pdf_js_event_result()`."""
>>>>>>         return _mupdf.PdfJs_pdf_js_event_result(self)
       
    1:     def pdf_js_event_result_keystroke(self, evt):
               r"""Class-aware wrapper for `::pdf_js_event_result_keystroke()`."""
>>>>>>         return _mupdf.PdfJs_pdf_js_event_result_keystroke(self, evt)
       
    1:     def pdf_js_event_result_validate(self, newvalue):
               r"""
               Class-aware wrapper for `::pdf_js_event_result_validate()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_js_event_result_validate()` => `(int, char *newvalue)`
               """
>>>>>>         return _mupdf.PdfJs_pdf_js_event_result_validate(self, newvalue)
       
    1:     def pdf_js_event_value(self):
               r"""Class-aware wrapper for `::pdf_js_event_value()`."""
>>>>>>         return _mupdf.PdfJs_pdf_js_event_value(self)
       
    1:     def pdf_js_execute(self, name, code, result):
               r"""
               Class-aware wrapper for `::pdf_js_execute()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_js_execute(const char *name, const char *code)` => char *result
               """
>>>>>>         return _mupdf.PdfJs_pdf_js_execute(self, name, code, result)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_js`.
               """
>>>>>>         _mupdf.PdfJs_swiginit(self, _mupdf.new_PdfJs(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfJs
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfJs_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfJs___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfJs_m_internal_get, _mupdf.PdfJs_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfJs_s_num_instances_get, _mupdf.PdfJs_s_num_instances_set)
       
       # Register PdfJs in _mupdf:
    1: _mupdf.PdfJs_swigregister(PdfJs)
    2: class PdfJsConsole(object):
    1:     r"""Wrapper class for struct `pdf_js_console`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_js_console`.
               """
>>>>>>         _mupdf.PdfJsConsole_swiginit(self, _mupdf.new_PdfJsConsole(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfJsConsole
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfJsConsole_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfJsConsole___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfJsConsole_m_internal_get, _mupdf.PdfJsConsole_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfJsConsole_s_num_instances_get, _mupdf.PdfJsConsole_s_num_instances_set)
       
       # Register PdfJsConsole in _mupdf:
    1: _mupdf.PdfJsConsole_swigregister(PdfJsConsole)
    2: class PdfKeystrokeEvent(object):
    1:     r"""Wrapper class for struct `pdf_keystroke_event`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_keystroke_event`.
               """
>>>>>>         _mupdf.PdfKeystrokeEvent_swiginit(self, _mupdf.new_PdfKeystrokeEvent(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfKeystrokeEvent
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfKeystrokeEvent_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfKeystrokeEvent___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfKeystrokeEvent_m_internal_get, _mupdf.PdfKeystrokeEvent_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfKeystrokeEvent_s_num_instances_get, _mupdf.PdfKeystrokeEvent_s_num_instances_set)
       
       # Register PdfKeystrokeEvent in _mupdf:
    1: _mupdf.PdfKeystrokeEvent_swigregister(PdfKeystrokeEvent)
    2: class PdfLaunchUrlEvent(object):
    1:     r"""Wrapper class for struct `pdf_launch_url_event`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_launch_url_event`.
               """
>>>>>>         _mupdf.PdfLaunchUrlEvent_swiginit(self, _mupdf.new_PdfLaunchUrlEvent(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfLaunchUrlEvent
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfLaunchUrlEvent_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfLaunchUrlEvent___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfLaunchUrlEvent_m_internal_get, _mupdf.PdfLaunchUrlEvent_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfLaunchUrlEvent_s_num_instances_get, _mupdf.PdfLaunchUrlEvent_s_num_instances_set)
       
       # Register PdfLaunchUrlEvent in _mupdf:
    1: _mupdf.PdfLaunchUrlEvent_swigregister(PdfLaunchUrlEvent)
    2: class PdfLayerConfig(object):
    1:     r"""Wrapper class for struct `pdf_layer_config`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_layer_config`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_layer_config`.
               """
>>>>>>         _mupdf.PdfLayerConfig_swiginit(self, _mupdf.new_PdfLayerConfig(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.PdfLayerConfig_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_PdfLayerConfig
    1:     name = property(_mupdf.PdfLayerConfig_name_get, _mupdf.PdfLayerConfig_name_set)
    1:     creator = property(_mupdf.PdfLayerConfig_creator_get, _mupdf.PdfLayerConfig_creator_set)
    1:     s_num_instances = property(_mupdf.PdfLayerConfig_s_num_instances_get, _mupdf.PdfLayerConfig_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.PdfLayerConfig_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfLayerConfig___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfLayerConfig___ne__(self, rhs)
       
       # Register PdfLayerConfig in _mupdf:
    1: _mupdf.PdfLayerConfig_swigregister(PdfLayerConfig)
    2: class PdfLayerConfigUi(object):
    1:     r"""Wrapper class for struct `pdf_layer_config_ui`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor sets .text to null, .type to PDF_LAYER_UI_LABEL, and other fields to zero.
       
               |
       
               *Overload 2:*
               We use default copy constructor and operator=.  Constructor using raw copy of pre-existing `::pdf_layer_config_ui`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_layer_config_ui`.
               """
>>>>>>         _mupdf.PdfLayerConfigUi_swiginit(self, _mupdf.new_PdfLayerConfigUi(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.PdfLayerConfigUi_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_PdfLayerConfigUi
    1:     text = property(_mupdf.PdfLayerConfigUi_text_get, _mupdf.PdfLayerConfigUi_text_set)
    1:     depth = property(_mupdf.PdfLayerConfigUi_depth_get, _mupdf.PdfLayerConfigUi_depth_set)
    1:     type = property(_mupdf.PdfLayerConfigUi_type_get, _mupdf.PdfLayerConfigUi_type_set)
    1:     selected = property(_mupdf.PdfLayerConfigUi_selected_get, _mupdf.PdfLayerConfigUi_selected_set)
    1:     locked = property(_mupdf.PdfLayerConfigUi_locked_get, _mupdf.PdfLayerConfigUi_locked_set)
    1:     s_num_instances = property(_mupdf.PdfLayerConfigUi_s_num_instances_get, _mupdf.PdfLayerConfigUi_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.PdfLayerConfigUi_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfLayerConfigUi___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfLayerConfigUi___ne__(self, rhs)
       
       # Register PdfLayerConfigUi in _mupdf:
    1: _mupdf.PdfLayerConfigUi_swigregister(PdfLayerConfigUi)
    2: class PdfLexbuf(object):
    1:     r"""Wrapper class for struct `pdf_lexbuf`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_lexbuf_fin(self):
               r"""Class-aware wrapper for `::pdf_lexbuf_fin()`."""
>>>>>>         return _mupdf.PdfLexbuf_pdf_lexbuf_fin(self)
       
    1:     def pdf_lexbuf_grow(self):
               r"""Class-aware wrapper for `::pdf_lexbuf_grow()`."""
>>>>>>         return _mupdf.PdfLexbuf_pdf_lexbuf_grow(self)
       
    1:     def pdf_lexbuf_init(self, size):
               r"""Class-aware wrapper for `::pdf_lexbuf_init()`."""
>>>>>>         return _mupdf.PdfLexbuf_pdf_lexbuf_init(self, size)
    1:     __swig_destroy__ = _mupdf.delete_PdfLexbuf
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Constructor that calls pdf_lexbuf_init(size).
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_lexbuf`.
               """
>>>>>>         _mupdf.PdfLexbuf_swiginit(self, _mupdf.new_PdfLexbuf(*args))
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfLexbuf_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfLexbuf___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfLexbuf_m_internal_get, _mupdf.PdfLexbuf_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfLexbuf_s_num_instances_get, _mupdf.PdfLexbuf_s_num_instances_set)
       
       # Register PdfLexbuf in _mupdf:
    1: _mupdf.PdfLexbuf_swigregister(PdfLexbuf)
    2: class PdfLexbufLarge(object):
    1:     r"""Wrapper class for struct `pdf_lexbuf_large`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_lexbuf_large`.
               """
>>>>>>         _mupdf.PdfLexbufLarge_swiginit(self, _mupdf.new_PdfLexbufLarge(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfLexbufLarge
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfLexbufLarge_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfLexbufLarge___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfLexbufLarge_m_internal_get, _mupdf.PdfLexbufLarge_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfLexbufLarge_s_num_instances_get, _mupdf.PdfLexbufLarge_s_num_instances_set)
       
       # Register PdfLexbufLarge in _mupdf:
    1: _mupdf.PdfLexbufLarge_swigregister(PdfLexbufLarge)
    2: class PdfLockedFields(object):
    1:     r"""Wrapper class for struct `pdf_locked_fields`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_is_field_locked(self, name):
               r"""Class-aware wrapper for `::pdf_is_field_locked()`."""
>>>>>>         return _mupdf.PdfLockedFields_pdf_is_field_locked(self, name)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_locked_fields`.
               """
>>>>>>         _mupdf.PdfLockedFields_swiginit(self, _mupdf.new_PdfLockedFields(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfLockedFields
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfLockedFields_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfLockedFields___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfLockedFields_m_internal_get, _mupdf.PdfLockedFields_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfLockedFields_s_num_instances_get, _mupdf.PdfLockedFields_s_num_instances_set)
       
       # Register PdfLockedFields in _mupdf:
    1: _mupdf.PdfLockedFields_swigregister(PdfLockedFields)
    2: class PdfMailDocEvent(object):
    1:     r"""Wrapper class for struct `pdf_mail_doc_event`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_mail_doc_event`.
               """
>>>>>>         _mupdf.PdfMailDocEvent_swiginit(self, _mupdf.new_PdfMailDocEvent(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfMailDocEvent
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfMailDocEvent_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfMailDocEvent___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfMailDocEvent_m_internal_get, _mupdf.PdfMailDocEvent_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfMailDocEvent_s_num_instances_get, _mupdf.PdfMailDocEvent_s_num_instances_set)
       
       # Register PdfMailDocEvent in _mupdf:
    1: _mupdf.PdfMailDocEvent_swigregister(PdfMailDocEvent)
    2: class PdfMarkBits(object):
    1:     r"""Wrapper class for struct `pdf_mark_bits`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_mark_bits_reset(self):
               r"""Class-aware wrapper for `::pdf_mark_bits_reset()`."""
>>>>>>         return _mupdf.PdfMarkBits_pdf_mark_bits_reset(self)
       
    1:     def pdf_mark_bits_set(self, obj):
               r"""Class-aware wrapper for `::pdf_mark_bits_set()`."""
>>>>>>         return _mupdf.PdfMarkBits_pdf_mark_bits_set(self, obj)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `pdf_new_mark_bits()`.
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_mark_bits`.
               """
>>>>>>         _mupdf.PdfMarkBits_swiginit(self, _mupdf.new_PdfMarkBits(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfMarkBits
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfMarkBits_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfMarkBits___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfMarkBits_m_internal_get, _mupdf.PdfMarkBits_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfMarkBits_s_num_instances_get, _mupdf.PdfMarkBits_s_num_instances_set)
       
       # Register PdfMarkBits in _mupdf:
    1: _mupdf.PdfMarkBits_swigregister(PdfMarkBits)
    2: class PdfMarkList(object):
    1:     r"""Wrapper class for struct `pdf_mark_list`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_mark_list_check(self, obj):
               r"""Class-aware wrapper for `::pdf_mark_list_check()`."""
>>>>>>         return _mupdf.PdfMarkList_pdf_mark_list_check(self, obj)
       
    1:     def pdf_mark_list_free(self):
               r"""Class-aware wrapper for `::pdf_mark_list_free()`."""
>>>>>>         return _mupdf.PdfMarkList_pdf_mark_list_free(self)
       
    1:     def pdf_mark_list_init(self):
               r"""Class-aware wrapper for `::pdf_mark_list_init()`."""
>>>>>>         return _mupdf.PdfMarkList_pdf_mark_list_init(self)
       
    1:     def pdf_mark_list_pop(self):
               r"""Class-aware wrapper for `::pdf_mark_list_pop()`."""
>>>>>>         return _mupdf.PdfMarkList_pdf_mark_list_pop(self)
       
    1:     def pdf_mark_list_push(self, obj):
               r"""Class-aware wrapper for `::pdf_mark_list_push()`."""
>>>>>>         return _mupdf.PdfMarkList_pdf_mark_list_push(self, obj)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_mark_list`.
               """
>>>>>>         _mupdf.PdfMarkList_swiginit(self, _mupdf.new_PdfMarkList(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfMarkList
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfMarkList_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfMarkList___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfMarkList_m_internal_get, _mupdf.PdfMarkList_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfMarkList_s_num_instances_get, _mupdf.PdfMarkList_s_num_instances_set)
       
       # Register PdfMarkList in _mupdf:
    1: _mupdf.PdfMarkList_swigregister(PdfMarkList)
    2: class PdfMrange(object):
    1:     r"""Wrapper class for struct `pdf_mrange`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_mrange`.
               """
>>>>>>         _mupdf.PdfMrange_swiginit(self, _mupdf.new_PdfMrange(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfMrange
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfMrange_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfMrange___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfMrange_m_internal_get, _mupdf.PdfMrange_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfMrange_s_num_instances_get, _mupdf.PdfMrange_s_num_instances_set)
       
       # Register PdfMrange in _mupdf:
    1: _mupdf.PdfMrange_swigregister(PdfMrange)
    2: class PdfObj(object):
    1:     r"""Wrapper class for struct `pdf_obj`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    2:     @staticmethod
    2:     def pdf_new_text_string(s):
               r"""Class-aware wrapper for `::pdf_new_text_string()`."""
>>>>>>         return _mupdf.PdfObj_pdf_new_text_string(s)
       
    2:     @staticmethod
    2:     def pdf_new_dict(doc, initialcap):
               r"""Class-aware wrapper for `::pdf_new_dict()`."""
>>>>>>         return _mupdf.PdfObj_pdf_new_dict(doc, initialcap)
       
    1:     def pdf_array_contains(self, obj):
               r"""Class-aware wrapper for `::pdf_array_contains()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_contains(self, obj)
       
    1:     def pdf_array_delete(self, index):
               r"""Class-aware wrapper for `::pdf_array_delete()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_delete(self, index)
       
    1:     def pdf_array_find(self, obj):
               r"""Class-aware wrapper for `::pdf_array_find()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_find(self, obj)
       
    1:     def pdf_array_get(self, i):
               r"""Class-aware wrapper for `::pdf_array_get()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_get(self, i)
       
    1:     def pdf_array_get_bool(self, index):
               r"""Class-aware wrapper for `::pdf_array_get_bool()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_get_bool(self, index)
       
    1:     def pdf_array_get_int(self, index):
               r"""Class-aware wrapper for `::pdf_array_get_int()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_get_int(self, index)
       
    1:     def pdf_array_get_matrix(self, index):
               r"""Class-aware wrapper for `::pdf_array_get_matrix()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_get_matrix(self, index)
       
    1:     def pdf_array_get_name(self, index):
               r"""Class-aware wrapper for `::pdf_array_get_name()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_get_name(self, index)
       
    1:     def pdf_array_get_real(self, index):
               r"""Class-aware wrapper for `::pdf_array_get_real()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_get_real(self, index)
       
    1:     def pdf_array_get_rect(self, index):
               r"""Class-aware wrapper for `::pdf_array_get_rect()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_get_rect(self, index)
       
    1:     def pdf_array_get_string(self, index, sizep):
               r"""
               Class-aware wrapper for `::pdf_array_get_string()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_array_get_string(int index)` => `(const char *, size_t sizep)`
               """
>>>>>>         return _mupdf.PdfObj_pdf_array_get_string(self, index, sizep)
       
    1:     def pdf_array_get_text_string(self, index):
               r"""Class-aware wrapper for `::pdf_array_get_text_string()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_get_text_string(self, index)
       
    1:     def pdf_array_insert(self, obj, index):
               r"""Class-aware wrapper for `::pdf_array_insert()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_insert(self, obj, index)
       
    1:     def pdf_array_len(self):
               r"""Class-aware wrapper for `::pdf_array_len()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_len(self)
       
    1:     def pdf_array_push(self, obj):
               r"""Class-aware wrapper for `::pdf_array_push()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_push(self, obj)
       
    1:     def pdf_array_push_array(self, initial):
               r"""Class-aware wrapper for `::pdf_array_push_array()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_push_array(self, initial)
       
    1:     def pdf_array_push_bool(self, x):
               r"""Class-aware wrapper for `::pdf_array_push_bool()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_push_bool(self, x)
       
    1:     def pdf_array_push_dict(self, initial):
               r"""Class-aware wrapper for `::pdf_array_push_dict()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_push_dict(self, initial)
       
    1:     def pdf_array_push_int(self, x):
               r"""Class-aware wrapper for `::pdf_array_push_int()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_push_int(self, x)
       
    1:     def pdf_array_push_name(self, x):
               r"""Class-aware wrapper for `::pdf_array_push_name()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_push_name(self, x)
       
    1:     def pdf_array_push_real(self, x):
               r"""Class-aware wrapper for `::pdf_array_push_real()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_push_real(self, x)
       
    1:     def pdf_array_push_string(self, x, n):
               r"""Class-aware wrapper for `::pdf_array_push_string()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_push_string(self, x, n)
       
    1:     def pdf_array_push_text_string(self, x):
               r"""Class-aware wrapper for `::pdf_array_push_text_string()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_push_text_string(self, x)
       
    1:     def pdf_array_put(self, i, obj):
               r"""Class-aware wrapper for `::pdf_array_put()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_put(self, i, obj)
       
    1:     def pdf_array_put_array(self, i, initial):
               r"""Class-aware wrapper for `::pdf_array_put_array()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_put_array(self, i, initial)
       
    1:     def pdf_array_put_bool(self, i, x):
               r"""Class-aware wrapper for `::pdf_array_put_bool()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_put_bool(self, i, x)
       
    1:     def pdf_array_put_dict(self, i, initial):
               r"""Class-aware wrapper for `::pdf_array_put_dict()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_put_dict(self, i, initial)
       
    1:     def pdf_array_put_int(self, i, x):
               r"""Class-aware wrapper for `::pdf_array_put_int()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_put_int(self, i, x)
       
    1:     def pdf_array_put_name(self, i, x):
               r"""Class-aware wrapper for `::pdf_array_put_name()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_put_name(self, i, x)
       
    1:     def pdf_array_put_real(self, i, x):
               r"""Class-aware wrapper for `::pdf_array_put_real()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_put_real(self, i, x)
       
    1:     def pdf_array_put_string(self, i, x, n):
               r"""Class-aware wrapper for `::pdf_array_put_string()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_put_string(self, i, x, n)
       
    1:     def pdf_array_put_text_string(self, i, x):
               r"""Class-aware wrapper for `::pdf_array_put_text_string()`."""
>>>>>>         return _mupdf.PdfObj_pdf_array_put_text_string(self, i, x)
       
    1:     def pdf_button_field_on_state(self):
               r"""Class-aware wrapper for `::pdf_button_field_on_state()`."""
>>>>>>         return _mupdf.PdfObj_pdf_button_field_on_state(self)
       
    1:     def pdf_choice_field_option(self, exportval, i):
               r"""Class-aware wrapper for `::pdf_choice_field_option()`."""
>>>>>>         return _mupdf.PdfObj_pdf_choice_field_option(self, exportval, i)
       
    1:     def pdf_choice_field_option_count(self):
               r"""Class-aware wrapper for `::pdf_choice_field_option_count()`."""
>>>>>>         return _mupdf.PdfObj_pdf_choice_field_option_count(self)
       
    1:     def pdf_clean_obj(self):
               r"""Class-aware wrapper for `::pdf_clean_obj()`."""
>>>>>>         return _mupdf.PdfObj_pdf_clean_obj(self)
       
    1:     def pdf_copy_array(self):
               r"""Class-aware wrapper for `::pdf_copy_array()`."""
>>>>>>         return _mupdf.PdfObj_pdf_copy_array(self)
       
    1:     def pdf_copy_dict(self):
               r"""Class-aware wrapper for `::pdf_copy_dict()`."""
>>>>>>         return _mupdf.PdfObj_pdf_copy_dict(self)
       
    1:     def pdf_debug_obj(self):
               r"""Class-aware wrapper for `::pdf_debug_obj()`."""
>>>>>>         return _mupdf.PdfObj_pdf_debug_obj(self)
       
    1:     def pdf_debug_ref(self):
               r"""Class-aware wrapper for `::pdf_debug_ref()`."""
>>>>>>         return _mupdf.PdfObj_pdf_debug_ref(self)
       
    1:     def pdf_deep_copy_obj(self):
               r"""Class-aware wrapper for `::pdf_deep_copy_obj()`."""
>>>>>>         return _mupdf.PdfObj_pdf_deep_copy_obj(self)
       
    1:     def pdf_dict_del(self, key):
               r"""Class-aware wrapper for `::pdf_dict_del()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_del(self, key)
       
    1:     def pdf_dict_dels(self, key):
               r"""Class-aware wrapper for `::pdf_dict_dels()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_dels(self, key)
       
    1:     def pdf_dict_get_bool(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_bool()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_bool(self, key)
       
    1:     def pdf_dict_get_bool_default(self, key, _def):
               r"""Class-aware wrapper for `::pdf_dict_get_bool_default()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_bool_default(self, key, _def)
       
    1:     def pdf_dict_get_date(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_date()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_date(self, key)
       
    1:     def pdf_dict_get_inheritable(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_inheritable()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_inheritable(self, key)
       
    1:     def pdf_dict_get_inheritable_bool(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_inheritable_bool()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_inheritable_bool(self, key)
       
    1:     def pdf_dict_get_inheritable_date(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_inheritable_date()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_inheritable_date(self, key)
       
    1:     def pdf_dict_get_inheritable_int(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_inheritable_int()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_inheritable_int(self, key)
       
    1:     def pdf_dict_get_inheritable_int64(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_inheritable_int64()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_inheritable_int64(self, key)
       
    1:     def pdf_dict_get_inheritable_matrix(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_inheritable_matrix()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_inheritable_matrix(self, key)
       
    1:     def pdf_dict_get_inheritable_name(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_inheritable_name()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_inheritable_name(self, key)
       
    1:     def pdf_dict_get_inheritable_real(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_inheritable_real()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_inheritable_real(self, key)
       
    1:     def pdf_dict_get_inheritable_rect(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_inheritable_rect()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_inheritable_rect(self, key)
       
    1:     def pdf_dict_get_inheritable_string(self, key, sizep):
               r"""
               Class-aware wrapper for `::pdf_dict_get_inheritable_string()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_dict_get_inheritable_string(::pdf_obj *key)` => `(const char *, size_t sizep)`
               """
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_inheritable_string(self, key, sizep)
       
    1:     def pdf_dict_get_inheritable_text_string(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_inheritable_text_string()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_inheritable_text_string(self, key)
       
    1:     def pdf_dict_get_int(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_int()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_int(self, key)
       
    1:     def pdf_dict_get_int64(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_int64()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_int64(self, key)
       
    1:     def pdf_dict_get_int_default(self, key, _def):
               r"""Class-aware wrapper for `::pdf_dict_get_int_default()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_int_default(self, key, _def)
       
    1:     def pdf_dict_get_key(self, idx):
               r"""Class-aware wrapper for `::pdf_dict_get_key()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_key(self, idx)
       
    1:     def pdf_dict_get_matrix(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_matrix()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_matrix(self, key)
       
    1:     def pdf_dict_get_name(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_name()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_name(self, key)
       
    1:     def pdf_dict_get_point(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_point()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_point(self, key)
       
    1:     def pdf_dict_get_real(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_real()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_real(self, key)
       
    1:     def pdf_dict_get_real_default(self, key, _def):
               r"""Class-aware wrapper for `::pdf_dict_get_real_default()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_real_default(self, key, _def)
       
    1:     def pdf_dict_get_rect(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_rect()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_rect(self, key)
       
    1:     def pdf_dict_get_string(self, key, sizep):
               r"""
               Class-aware wrapper for `::pdf_dict_get_string()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_dict_get_string(::pdf_obj *key)` => `(const char *, size_t sizep)`
               """
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_string(self, key, sizep)
       
    1:     def pdf_dict_get_text_string(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_text_string()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_text_string(self, key)
       
    1:     def pdf_dict_get_text_string_opt(self, key):
               r"""Class-aware wrapper for `::pdf_dict_get_text_string_opt()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_text_string_opt(self, key)
       
    1:     def pdf_dict_get_val(self, idx):
               r"""Class-aware wrapper for `::pdf_dict_get_val()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_get_val(self, idx)
       
    1:     def pdf_dict_geta(self, key, abbrev):
               r"""Class-aware wrapper for `::pdf_dict_geta()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_geta(self, key, abbrev)
       
    1:     def pdf_dict_getp(self, path):
               r"""Class-aware wrapper for `::pdf_dict_getp()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_getp(self, path)
       
    1:     def pdf_dict_getp_inheritable(self, path):
               r"""Class-aware wrapper for `::pdf_dict_getp_inheritable()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_getp_inheritable(self, path)
       
    1:     def pdf_dict_gets(self, key):
               r"""Class-aware wrapper for `::pdf_dict_gets()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_gets(self, key)
       
    1:     def pdf_dict_gets_inheritable(self, key):
               r"""Class-aware wrapper for `::pdf_dict_gets_inheritable()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_gets_inheritable(self, key)
       
    1:     def pdf_dict_getsa(self, key, abbrev):
               r"""Class-aware wrapper for `::pdf_dict_getsa()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_getsa(self, key, abbrev)
       
    1:     def pdf_dict_len(self):
               r"""Class-aware wrapper for `::pdf_dict_len()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_len(self)
       
    1:     def pdf_dict_put(self, key, val):
               r"""Class-aware wrapper for `::pdf_dict_put()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put(self, key, val)
       
    1:     def pdf_dict_put_array(self, key, initial):
               r"""Class-aware wrapper for `::pdf_dict_put_array()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_array(self, key, initial)
       
    1:     def pdf_dict_put_bool(self, key, x):
               r"""Class-aware wrapper for `::pdf_dict_put_bool()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_bool(self, key, x)
       
    1:     def pdf_dict_put_date(self, key, time):
               r"""Class-aware wrapper for `::pdf_dict_put_date()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_date(self, key, time)
       
    1:     def pdf_dict_put_dict(self, key, initial):
               r"""Class-aware wrapper for `::pdf_dict_put_dict()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_dict(self, key, initial)
       
    1:     def pdf_dict_put_indirect(self, key, num):
               r"""Class-aware wrapper for `::pdf_dict_put_indirect()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_indirect(self, key, num)
       
    1:     def pdf_dict_put_int(self, key, x):
               r"""Class-aware wrapper for `::pdf_dict_put_int()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_int(self, key, x)
       
    1:     def pdf_dict_put_matrix(self, key, x):
               r"""Class-aware wrapper for `::pdf_dict_put_matrix()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_matrix(self, key, x)
       
    1:     def pdf_dict_put_name(self, key, x):
               r"""Class-aware wrapper for `::pdf_dict_put_name()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_name(self, key, x)
       
    1:     def pdf_dict_put_point(self, key, x):
               r"""Class-aware wrapper for `::pdf_dict_put_point()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_point(self, key, x)
       
    1:     def pdf_dict_put_real(self, key, x):
               r"""Class-aware wrapper for `::pdf_dict_put_real()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_real(self, key, x)
       
    1:     def pdf_dict_put_rect(self, key, x):
               r"""Class-aware wrapper for `::pdf_dict_put_rect()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_rect(self, key, x)
       
    1:     def pdf_dict_put_string(self, key, x, n):
               r"""Class-aware wrapper for `::pdf_dict_put_string()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_string(self, key, x, n)
       
    1:     def pdf_dict_put_text_string(self, key, x):
               r"""Class-aware wrapper for `::pdf_dict_put_text_string()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_text_string(self, key, x)
       
    1:     def pdf_dict_put_val_null(self, idx):
               r"""Class-aware wrapper for `::pdf_dict_put_val_null()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_put_val_null(self, idx)
       
    1:     def pdf_dict_putp(self, path, val):
               r"""Class-aware wrapper for `::pdf_dict_putp()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_putp(self, path, val)
       
    1:     def pdf_dict_puts(self, key, val):
               r"""Class-aware wrapper for `::pdf_dict_puts()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_puts(self, key, val)
       
    1:     def pdf_dict_puts_dict(self, key, initial):
               r"""Class-aware wrapper for `::pdf_dict_puts_dict()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dict_puts_dict(self, key, initial)
       
    1:     def pdf_dirty_obj(self):
               r"""Class-aware wrapper for `::pdf_dirty_obj()`."""
>>>>>>         return _mupdf.PdfObj_pdf_dirty_obj(self)
       
    1:     def pdf_field_border_style(self):
               r"""Class-aware wrapper for `::pdf_field_border_style()`."""
>>>>>>         return _mupdf.PdfObj_pdf_field_border_style(self)
       
    1:     def pdf_field_display(self):
               r"""Class-aware wrapper for `::pdf_field_display()`."""
>>>>>>         return _mupdf.PdfObj_pdf_field_display(self)
       
    1:     def pdf_field_flags(self):
               r"""Class-aware wrapper for `::pdf_field_flags()`."""
>>>>>>         return _mupdf.PdfObj_pdf_field_flags(self)
       
    1:     def pdf_field_label(self):
               r"""Class-aware wrapper for `::pdf_field_label()`."""
>>>>>>         return _mupdf.PdfObj_pdf_field_label(self)
       
    1:     def pdf_field_set_border_style(self, text):
               r"""Class-aware wrapper for `::pdf_field_set_border_style()`."""
>>>>>>         return _mupdf.PdfObj_pdf_field_set_border_style(self, text)
       
    1:     def pdf_field_set_button_caption(self, text):
               r"""Class-aware wrapper for `::pdf_field_set_button_caption()`."""
>>>>>>         return _mupdf.PdfObj_pdf_field_set_button_caption(self, text)
       
    1:     def pdf_field_set_display(self, d):
               r"""Class-aware wrapper for `::pdf_field_set_display()`."""
>>>>>>         return _mupdf.PdfObj_pdf_field_set_display(self, d)
       
    1:     def pdf_field_set_fill_color(self, col):
               r"""Class-aware wrapper for `::pdf_field_set_fill_color()`."""
>>>>>>         return _mupdf.PdfObj_pdf_field_set_fill_color(self, col)
       
    1:     def pdf_field_set_text_color(self, col):
               r"""Class-aware wrapper for `::pdf_field_set_text_color()`."""
>>>>>>         return _mupdf.PdfObj_pdf_field_set_text_color(self, col)
       
    1:     def pdf_field_type(self):
               r"""Class-aware wrapper for `::pdf_field_type()`."""
>>>>>>         return _mupdf.PdfObj_pdf_field_type(self)
       
    1:     def pdf_field_type_string(self):
               r"""Class-aware wrapper for `::pdf_field_type_string()`."""
>>>>>>         return _mupdf.PdfObj_pdf_field_type_string(self)
       
    1:     def pdf_field_value(self):
               r"""Class-aware wrapper for `::pdf_field_value()`."""
>>>>>>         return _mupdf.PdfObj_pdf_field_value(self)
       
    1:     def pdf_filter_xobject_instance(self, page_res, ctm, options, cycle_up):
               r"""Class-aware wrapper for `::pdf_filter_xobject_instance()`."""
>>>>>>         return _mupdf.PdfObj_pdf_filter_xobject_instance(self, page_res, ctm, options, cycle_up)
       
    1:     def pdf_flatten_inheritable_page_items(self):
               r"""Class-aware wrapper for `::pdf_flatten_inheritable_page_items()`."""
>>>>>>         return _mupdf.PdfObj_pdf_flatten_inheritable_page_items(self)
       
    1:     def pdf_get_bound_document(self):
               r"""Class-aware wrapper for `::pdf_get_bound_document()`."""
>>>>>>         return _mupdf.PdfObj_pdf_get_bound_document(self)
       
    1:     def pdf_get_filespec_params(self, out):
               r"""Class-aware wrapper for `::pdf_get_filespec_params()`."""
>>>>>>         return _mupdf.PdfObj_pdf_get_filespec_params(self, out)
       
    1:     def pdf_get_indirect_document(self):
               r"""Class-aware wrapper for `::pdf_get_indirect_document()`."""
>>>>>>         return _mupdf.PdfObj_pdf_get_indirect_document(self)
       
    1:     def pdf_intent_from_name(self):
               r"""Class-aware wrapper for `::pdf_intent_from_name()`."""
>>>>>>         return _mupdf.PdfObj_pdf_intent_from_name(self)
       
    1:     def pdf_is_array(self):
               r"""Class-aware wrapper for `::pdf_is_array()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_array(self)
       
    1:     def pdf_is_bool(self):
               r"""Class-aware wrapper for `::pdf_is_bool()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_bool(self)
       
    1:     def pdf_is_dict(self):
               r"""Class-aware wrapper for `::pdf_is_dict()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_dict(self)
       
    1:     def pdf_is_embedded_file(self):
               r"""Class-aware wrapper for `::pdf_is_embedded_file()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_embedded_file(self)
       
    1:     def pdf_is_filespec(self):
               r"""Class-aware wrapper for `::pdf_is_filespec()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_filespec(self)
       
    1:     def pdf_is_image_stream(self):
               r"""Class-aware wrapper for `::pdf_is_image_stream()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_image_stream(self)
       
    1:     def pdf_is_indirect(self):
               r"""Class-aware wrapper for `::pdf_is_indirect()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_indirect(self)
       
    1:     def pdf_is_int(self):
               r"""Class-aware wrapper for `::pdf_is_int()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_int(self)
       
    1:     def pdf_is_jpx_image(self):
               r"""Class-aware wrapper for `::pdf_is_jpx_image()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_jpx_image(self)
       
    1:     def pdf_is_name(self):
               r"""Class-aware wrapper for `::pdf_is_name()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_name(self)
       
    1:     def pdf_is_null(self):
               r"""Class-aware wrapper for `::pdf_is_null()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_null(self)
       
    1:     def pdf_is_number(self):
               r"""Class-aware wrapper for `::pdf_is_number()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_number(self)
       
    1:     def pdf_is_real(self):
               r"""Class-aware wrapper for `::pdf_is_real()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_real(self)
       
    1:     def pdf_is_stream(self):
               r"""Class-aware wrapper for `::pdf_is_stream()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_stream(self)
       
    1:     def pdf_is_string(self):
               r"""Class-aware wrapper for `::pdf_is_string()`."""
>>>>>>         return _mupdf.PdfObj_pdf_is_string(self)
       
    1:     def pdf_line_ending_from_name(self):
               r"""Class-aware wrapper for `::pdf_line_ending_from_name()`."""
>>>>>>         return _mupdf.PdfObj_pdf_line_ending_from_name(self)
       
    1:     def pdf_load_colorspace(self):
               r"""Class-aware wrapper for `::pdf_load_colorspace()`."""
>>>>>>         return _mupdf.PdfObj_pdf_load_colorspace(self)
       
    1:     def pdf_load_embedded_file_contents(self):
               r"""Class-aware wrapper for `::pdf_load_embedded_file_contents()`."""
>>>>>>         return _mupdf.PdfObj_pdf_load_embedded_file_contents(self)
       
    1:     def pdf_load_field_name(self):
               r"""Class-aware wrapper for `::pdf_load_field_name()`."""
>>>>>>         return _mupdf.PdfObj_pdf_load_field_name(self)
       
    1:     def pdf_load_function(self, _in, out):
               r"""Class-aware wrapper for `::pdf_load_function()`."""
>>>>>>         return _mupdf.PdfObj_pdf_load_function(self, _in, out)
       
    1:     def pdf_load_raw_stream(self):
               r"""Class-aware wrapper for `::pdf_load_raw_stream()`."""
>>>>>>         return _mupdf.PdfObj_pdf_load_raw_stream(self)
       
    1:     def pdf_load_stream(self):
               r"""Class-aware wrapper for `::pdf_load_stream()`."""
>>>>>>         return _mupdf.PdfObj_pdf_load_stream(self)
       
    1:     def pdf_load_stream_or_string_as_utf8(self):
               r"""Class-aware wrapper for `::pdf_load_stream_or_string_as_utf8()`."""
>>>>>>         return _mupdf.PdfObj_pdf_load_stream_or_string_as_utf8(self)
       
    1:     def pdf_lookup_field(self, name):
               r"""Class-aware wrapper for `::pdf_lookup_field()`."""
>>>>>>         return _mupdf.PdfObj_pdf_lookup_field(self, name)
       
    1:     def pdf_lookup_number(self, needle):
               r"""Class-aware wrapper for `::pdf_lookup_number()`."""
>>>>>>         return _mupdf.PdfObj_pdf_lookup_number(self, needle)
       
    1:     def pdf_mark_obj(self):
               r"""Class-aware wrapper for `::pdf_mark_obj()`."""
>>>>>>         return _mupdf.PdfObj_pdf_mark_obj(self)
       
    1:     def pdf_name_eq(self, b):
               r"""Class-aware wrapper for `::pdf_name_eq()`."""
>>>>>>         return _mupdf.PdfObj_pdf_name_eq(self, b)
       
    1:     def pdf_new_utf8_from_pdf_stream_obj(self):
               r"""Class-aware wrapper for `::pdf_new_utf8_from_pdf_stream_obj()`."""
>>>>>>         return _mupdf.PdfObj_pdf_new_utf8_from_pdf_stream_obj(self)
       
    1:     def pdf_new_utf8_from_pdf_string_obj(self):
               r"""Class-aware wrapper for `::pdf_new_utf8_from_pdf_string_obj()`."""
>>>>>>         return _mupdf.PdfObj_pdf_new_utf8_from_pdf_string_obj(self)
       
    1:     def pdf_obj_is_dirty(self):
               r"""Class-aware wrapper for `::pdf_obj_is_dirty()`."""
>>>>>>         return _mupdf.PdfObj_pdf_obj_is_dirty(self)
       
    1:     def pdf_obj_is_incremental(self):
               r"""Class-aware wrapper for `::pdf_obj_is_incremental()`."""
>>>>>>         return _mupdf.PdfObj_pdf_obj_is_incremental(self)
       
    1:     def pdf_obj_marked(self):
               r"""Class-aware wrapper for `::pdf_obj_marked()`."""
>>>>>>         return _mupdf.PdfObj_pdf_obj_marked(self)
       
    1:     def pdf_obj_memo(self, bit, memo):
               r"""
               Class-aware wrapper for `::pdf_obj_memo()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_obj_memo(int bit)` => `(int, int memo)`
               """
>>>>>>         return _mupdf.PdfObj_pdf_obj_memo(self, bit, memo)
       
    1:     def pdf_obj_parent_num(self):
               r"""Class-aware wrapper for `::pdf_obj_parent_num()`."""
>>>>>>         return _mupdf.PdfObj_pdf_obj_parent_num(self)
       
    1:     def pdf_obj_refs(self):
               r"""Class-aware wrapper for `::pdf_obj_refs()`."""
>>>>>>         return _mupdf.PdfObj_pdf_obj_refs(self)
       
    1:     def pdf_objcmp(self, b):
               r"""Class-aware wrapper for `::pdf_objcmp()`."""
>>>>>>         return _mupdf.PdfObj_pdf_objcmp(self, b)
       
    1:     def pdf_objcmp_deep(self, b):
               r"""Class-aware wrapper for `::pdf_objcmp_deep()`."""
>>>>>>         return _mupdf.PdfObj_pdf_objcmp_deep(self, b)
       
    1:     def pdf_objcmp_resolve(self, b):
               r"""Class-aware wrapper for `::pdf_objcmp_resolve()`."""
>>>>>>         return _mupdf.PdfObj_pdf_objcmp_resolve(self, b)
       
    1:     def pdf_open_raw_stream(self):
               r"""Class-aware wrapper for `::pdf_open_raw_stream()`."""
>>>>>>         return _mupdf.PdfObj_pdf_open_raw_stream(self)
       
    1:     def pdf_open_stream(self):
               r"""Class-aware wrapper for `::pdf_open_stream()`."""
>>>>>>         return _mupdf.PdfObj_pdf_open_stream(self)
       
    1:     def pdf_page_obj_transform(self, outbox, outctm):
               r"""Class-aware wrapper for `::pdf_page_obj_transform()`."""
>>>>>>         return _mupdf.PdfObj_pdf_page_obj_transform(self, outbox, outctm)
       
    1:     def pdf_page_obj_transform_box(self, outbox, out, box):
               r"""Class-aware wrapper for `::pdf_page_obj_transform_box()`."""
>>>>>>         return _mupdf.PdfObj_pdf_page_obj_transform_box(self, outbox, out, box)
       
    1:     def pdf_pin_document(self):
               r"""Class-aware wrapper for `::pdf_pin_document()`."""
>>>>>>         return _mupdf.PdfObj_pdf_pin_document(self)
       
    1:     def pdf_recolor_shade(self, reshade, opaque):
               r"""
               Class-aware wrapper for `::pdf_recolor_shade()`.
                       Recolor a shade.
               """
>>>>>>         return _mupdf.PdfObj_pdf_recolor_shade(self, reshade, opaque)
       
    1:     def pdf_resolve_indirect(self):
               r"""
               Class-aware wrapper for `::pdf_resolve_indirect()`.
                       Resolve an indirect object (or chain of objects).
       
                       This can cause xref reorganisations (solidifications etc) due to
                       repairs, so all held pdf_xref_entries should be considered
                       invalid after this call (other than the returned one).
               """
>>>>>>         return _mupdf.PdfObj_pdf_resolve_indirect(self)
       
    1:     def pdf_resolve_indirect_chain(self):
               r"""Class-aware wrapper for `::pdf_resolve_indirect_chain()`."""
>>>>>>         return _mupdf.PdfObj_pdf_resolve_indirect_chain(self)
       
    1:     def pdf_set_int(self, i):
               r"""Class-aware wrapper for `::pdf_set_int()`."""
>>>>>>         return _mupdf.PdfObj_pdf_set_int(self, i)
       
    1:     def pdf_set_obj_memo(self, bit, memo):
               r"""Class-aware wrapper for `::pdf_set_obj_memo()`."""
>>>>>>         return _mupdf.PdfObj_pdf_set_obj_memo(self, bit, memo)
       
    1:     def pdf_set_obj_parent(self, num):
               r"""Class-aware wrapper for `::pdf_set_obj_parent()`."""
>>>>>>         return _mupdf.PdfObj_pdf_set_obj_parent(self, num)
       
    1:     def pdf_set_str_len(self, newlen):
               r"""Class-aware wrapper for `::pdf_set_str_len()`."""
>>>>>>         return _mupdf.PdfObj_pdf_set_str_len(self, newlen)
       
    1:     def pdf_sort_dict(self):
               r"""Class-aware wrapper for `::pdf_sort_dict()`."""
>>>>>>         return _mupdf.PdfObj_pdf_sort_dict(self)
       
    1:     def pdf_store_item(self, val, itemsize):
               r"""Class-aware wrapper for `::pdf_store_item()`."""
>>>>>>         return _mupdf.PdfObj_pdf_store_item(self, val, itemsize)
       
    1:     def pdf_to_bool(self):
               r"""Class-aware wrapper for `::pdf_to_bool()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_bool(self)
       
    1:     def pdf_to_bool_default(self, _def):
               r"""Class-aware wrapper for `::pdf_to_bool_default()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_bool_default(self, _def)
       
    1:     def pdf_to_date(self):
               r"""Class-aware wrapper for `::pdf_to_date()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_date(self)
       
    1:     def pdf_to_gen(self):
               r"""Class-aware wrapper for `::pdf_to_gen()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_gen(self)
       
    1:     def pdf_to_int(self):
               r"""Class-aware wrapper for `::pdf_to_int()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_int(self)
       
    1:     def pdf_to_int64(self):
               r"""Class-aware wrapper for `::pdf_to_int64()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_int64(self)
       
    1:     def pdf_to_int_default(self, _def):
               r"""Class-aware wrapper for `::pdf_to_int_default()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_int_default(self, _def)
       
    1:     def pdf_to_matrix(self):
               r"""Class-aware wrapper for `::pdf_to_matrix()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_matrix(self)
       
    1:     def pdf_to_name(self):
               r"""Class-aware wrapper for `::pdf_to_name()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_name(self)
       
    1:     def pdf_to_num(self):
               r"""Class-aware wrapper for `::pdf_to_num()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_num(self)
       
    1:     def pdf_to_point(self, offset):
               r"""Class-aware wrapper for `::pdf_to_point()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_point(self, offset)
       
    1:     def pdf_to_quad(self, offset):
               r"""Class-aware wrapper for `::pdf_to_quad()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_quad(self, offset)
       
    1:     def pdf_to_real(self):
               r"""Class-aware wrapper for `::pdf_to_real()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_real(self)
       
    1:     def pdf_to_real_default(self, _def):
               r"""Class-aware wrapper for `::pdf_to_real_default()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_real_default(self, _def)
       
    1:     def pdf_to_rect(self):
               r"""Class-aware wrapper for `::pdf_to_rect()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_rect(self)
       
    1:     def pdf_to_str_buf(self):
               r"""Class-aware wrapper for `::pdf_to_str_buf()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_str_buf(self)
       
    1:     def pdf_to_str_len(self):
               r"""Class-aware wrapper for `::pdf_to_str_len()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_str_len(self)
       
    1:     def pdf_to_string(self, sizep):
               r"""
               Class-aware wrapper for `::pdf_to_string()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_to_string()` => `(const char *, size_t sizep)`
               """
>>>>>>         return _mupdf.PdfObj_pdf_to_string(self, sizep)
       
    1:     def pdf_to_text_string(self):
               r"""Class-aware wrapper for `::pdf_to_text_string()`."""
>>>>>>         return _mupdf.PdfObj_pdf_to_text_string(self)
       
    1:     def pdf_unmark_obj(self):
               r"""Class-aware wrapper for `::pdf_unmark_obj()`."""
>>>>>>         return _mupdf.PdfObj_pdf_unmark_obj(self)
       
    1:     def pdf_verify_embedded_file_checksum(self):
               r"""Class-aware wrapper for `::pdf_verify_embedded_file_checksum()`."""
>>>>>>         return _mupdf.PdfObj_pdf_verify_embedded_file_checksum(self)
       
    1:     def pdf_walk_tree(self, kid_name, arrive, leave, arg, names, values):
               r"""
               Class-aware wrapper for `::pdf_walk_tree()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_walk_tree(::pdf_obj *kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, ::pdf_obj **names, ::pdf_obj **values)` => `()`
               """
>>>>>>         return _mupdf.PdfObj_pdf_walk_tree(self, kid_name, arrive, leave, arg, names, values)
       
    1:     def pdf_xobject_bbox(self):
               r"""Class-aware wrapper for `::pdf_xobject_bbox()`."""
>>>>>>         return _mupdf.PdfObj_pdf_xobject_bbox(self)
       
    1:     def pdf_xobject_colorspace(self):
               r"""Class-aware wrapper for `::pdf_xobject_colorspace()`."""
>>>>>>         return _mupdf.PdfObj_pdf_xobject_colorspace(self)
       
    1:     def pdf_xobject_isolated(self):
               r"""Class-aware wrapper for `::pdf_xobject_isolated()`."""
>>>>>>         return _mupdf.PdfObj_pdf_xobject_isolated(self)
       
    1:     def pdf_xobject_knockout(self):
               r"""Class-aware wrapper for `::pdf_xobject_knockout()`."""
>>>>>>         return _mupdf.PdfObj_pdf_xobject_knockout(self)
       
    1:     def pdf_xobject_matrix(self):
               r"""Class-aware wrapper for `::pdf_xobject_matrix()`."""
>>>>>>         return _mupdf.PdfObj_pdf_xobject_matrix(self)
       
    1:     def pdf_xobject_resources(self):
               r"""Class-aware wrapper for `::pdf_xobject_resources()`."""
>>>>>>         return _mupdf.PdfObj_pdf_xobject_resources(self)
       
    1:     def pdf_xobject_transparency(self):
               r"""Class-aware wrapper for `::pdf_xobject_transparency()`."""
>>>>>>         return _mupdf.PdfObj_pdf_xobject_transparency(self)
       
    1:     def pdf_dict_get(self, *args):
               r"""
               *Overload 1:*
               Class-aware wrapper for `::pdf_dict_get()`.
       
               |
       
               *Overload 2:*
               Typesafe wrapper for looking up things such as PDF_ENUM_NAME_Annots.
               """
>>>>>>         return _mupdf.PdfObj_pdf_dict_get(self, *args)
       
    1:     def pdf_load_field_name2(self):
               r"""Alternative to `pdf_load_field_name()` that returns a std::string."""
>>>>>>         return _mupdf.PdfObj_pdf_load_field_name2(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `pdf_new_action_from_link()`.
       
               |
       
               *Overload 2:*
               Constructor using `pdf_new_array()`.
       
               |
       
               *Overload 3:*
               Constructor using `pdf_new_date()`.
       
               |
       
               *Overload 4:*
               Constructor using `pdf_new_dest_from_link()`.
       
               |
       
               *Overload 5:*
               Constructor using `pdf_new_indirect()`.
       
               |
       
               *Overload 6:*
               Constructor using `pdf_new_int()`.
       
               |
       
               *Overload 7:*
               Constructor using `pdf_new_matrix()`.
       
               |
       
               *Overload 8:*
               Constructor using `pdf_new_name()`.
       
               |
       
               *Overload 9:*
               Constructor using `pdf_new_point()`.
       
               |
       
               *Overload 10:*
               Constructor using `pdf_new_real()`.
       
               |
       
               *Overload 11:*
               Constructor using `pdf_new_rect()`.
       
               |
       
               *Overload 12:*
               Constructor using `pdf_new_string()`.
       
               |
       
               *Overload 13:*
               Constructor using `pdf_new_xobject()`.
       
               |
       
               *Overload 14:*
               Copy constructor using `pdf_keep_obj()`.
       
               |
       
               *Overload 15:*
               Constructor using raw copy of pre-existing `::pdf_obj`.
       
               |
       
               *Overload 16:*
               Constructor using raw copy of pre-existing `::pdf_obj`.
               """
  601:         _mupdf.PdfObj_swiginit(self, _mupdf.new_PdfObj(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfObj
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfObj_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfObj___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfObj_m_internal_get, _mupdf.PdfObj_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfObj_s_num_instances_get, _mupdf.PdfObj_s_num_instances_set)
       
       # Register PdfObj in _mupdf:
    1: _mupdf.PdfObj_swigregister(PdfObj)
    2: class PdfObjectLabels(object):
    1:     r"""Wrapper class for struct `pdf_object_labels`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_label_object(self, num, callback, arg):
               r"""Class-aware wrapper for `::pdf_label_object()`."""
>>>>>>         return _mupdf.PdfObjectLabels_pdf_label_object(self, num, callback, arg)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_object_labels`.
               """
>>>>>>         _mupdf.PdfObjectLabels_swiginit(self, _mupdf.new_PdfObjectLabels(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfObjectLabels
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfObjectLabels_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfObjectLabels___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfObjectLabels_m_internal_get, _mupdf.PdfObjectLabels_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfObjectLabels_s_num_instances_get, _mupdf.PdfObjectLabels_s_num_instances_set)
       
       # Register PdfObjectLabels in _mupdf:
    1: _mupdf.PdfObjectLabels_swigregister(PdfObjectLabels)
    2: class PdfOcgDescriptor(object):
    1:     r"""Wrapper class for struct `pdf_ocg_descriptor`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_ocg_descriptor`.
               """
>>>>>>         _mupdf.PdfOcgDescriptor_swiginit(self, _mupdf.new_PdfOcgDescriptor(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfOcgDescriptor
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfOcgDescriptor_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfOcgDescriptor___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfOcgDescriptor_m_internal_get, _mupdf.PdfOcgDescriptor_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfOcgDescriptor_s_num_instances_get, _mupdf.PdfOcgDescriptor_s_num_instances_set)
       
       # Register PdfOcgDescriptor in _mupdf:
    1: _mupdf.PdfOcgDescriptor_swigregister(PdfOcgDescriptor)
    2: class PdfPage(object):
    1:     r"""Wrapper class for struct `pdf_page`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_bound_page(self, box):
               r"""Class-aware wrapper for `::pdf_bound_page()`."""
>>>>>>         return _mupdf.PdfPage_pdf_bound_page(self, box)
       
    1:     def pdf_clip_page(self, clip):
               r"""Class-aware wrapper for `::pdf_clip_page()`."""
>>>>>>         return _mupdf.PdfPage_pdf_clip_page(self, clip)
       
    1:     def pdf_count_page_associated_files(self):
               r"""Class-aware wrapper for `::pdf_count_page_associated_files()`."""
>>>>>>         return _mupdf.PdfPage_pdf_count_page_associated_files(self)
       
    1:     def pdf_create_annot(self, type):
               r"""Class-aware wrapper for `::pdf_create_annot()`."""
>>>>>>         return _mupdf.PdfPage_pdf_create_annot(self, type)
       
    1:     def pdf_create_annot_raw(self, type):
               r"""Class-aware wrapper for `::pdf_create_annot_raw()`."""
>>>>>>         return _mupdf.PdfPage_pdf_create_annot_raw(self, type)
       
    1:     def pdf_create_link(self, bbox, uri):
               r"""Class-aware wrapper for `::pdf_create_link()`."""
>>>>>>         return _mupdf.PdfPage_pdf_create_link(self, bbox, uri)
       
    1:     def pdf_create_signature_widget(self, name):
               r"""Class-aware wrapper for `::pdf_create_signature_widget()`."""
>>>>>>         return _mupdf.PdfPage_pdf_create_signature_widget(self, name)
       
    1:     def pdf_delete_annot(self, annot):
               r"""Class-aware wrapper for `::pdf_delete_annot()`."""
>>>>>>         return _mupdf.PdfPage_pdf_delete_annot(self, annot)
       
    1:     def pdf_delete_link(self, link):
               r"""Class-aware wrapper for `::pdf_delete_link()`."""
>>>>>>         return _mupdf.PdfPage_pdf_delete_link(self, link)
       
    1:     def pdf_first_annot(self):
               r"""Class-aware wrapper for `::pdf_first_annot()`."""
>>>>>>         return _mupdf.PdfPage_pdf_first_annot(self)
       
    1:     def pdf_first_widget(self):
               r"""Class-aware wrapper for `::pdf_first_widget()`."""
>>>>>>         return _mupdf.PdfPage_pdf_first_widget(self)
       
    1:     def pdf_load_links(self):
               r"""Class-aware wrapper for `::pdf_load_links()`."""
>>>>>>         return _mupdf.PdfPage_pdf_load_links(self)
       
    1:     def pdf_new_link(self, rect, uri, obj):
               r"""Class-aware wrapper for `::pdf_new_link()`."""
>>>>>>         return _mupdf.PdfPage_pdf_new_link(self, rect, uri, obj)
       
    1:     def pdf_new_pixmap_from_page_contents_with_separations_and_usage(self, ctm, cs, seps, alpha, usage, box):
               r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_separations_and_usage()`."""
>>>>>>         return _mupdf.PdfPage_pdf_new_pixmap_from_page_contents_with_separations_and_usage(self, ctm, cs, seps, alpha, usage, box)
       
    1:     def pdf_new_pixmap_from_page_contents_with_usage(self, ctm, cs, alpha, usage, box):
               r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_usage()`."""
>>>>>>         return _mupdf.PdfPage_pdf_new_pixmap_from_page_contents_with_usage(self, ctm, cs, alpha, usage, box)
       
    1:     def pdf_new_pixmap_from_page_with_separations_and_usage(self, ctm, cs, seps, alpha, usage, box):
               r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`."""
>>>>>>         return _mupdf.PdfPage_pdf_new_pixmap_from_page_with_separations_and_usage(self, ctm, cs, seps, alpha, usage, box)
       
    1:     def pdf_new_pixmap_from_page_with_usage(self, ctm, cs, alpha, usage, box):
               r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_with_usage()`."""
>>>>>>         return _mupdf.PdfPage_pdf_new_pixmap_from_page_with_usage(self, ctm, cs, alpha, usage, box)
       
    1:     def pdf_nuke_annots(self):
               r"""Class-aware wrapper for `::pdf_nuke_annots()`."""
>>>>>>         return _mupdf.PdfPage_pdf_nuke_annots(self)
       
    1:     def pdf_nuke_links(self):
               r"""Class-aware wrapper for `::pdf_nuke_links()`."""
>>>>>>         return _mupdf.PdfPage_pdf_nuke_links(self)
       
    1:     def pdf_nuke_page(self):
               r"""Class-aware wrapper for `::pdf_nuke_page()`."""
>>>>>>         return _mupdf.PdfPage_pdf_nuke_page(self)
       
    1:     def pdf_page_associated_file(self, idx):
               r"""Class-aware wrapper for `::pdf_page_associated_file()`."""
>>>>>>         return _mupdf.PdfPage_pdf_page_associated_file(self, idx)
       
    1:     def pdf_page_contents(self):
               r"""Class-aware wrapper for `::pdf_page_contents()`."""
>>>>>>         return _mupdf.PdfPage_pdf_page_contents(self)
       
    1:     def pdf_page_event_close(self):
               r"""Class-aware wrapper for `::pdf_page_event_close()`."""
>>>>>>         return _mupdf.PdfPage_pdf_page_event_close(self)
       
    1:     def pdf_page_event_open(self):
               r"""Class-aware wrapper for `::pdf_page_event_open()`."""
>>>>>>         return _mupdf.PdfPage_pdf_page_event_open(self)
       
    1:     def pdf_page_group(self):
               r"""Class-aware wrapper for `::pdf_page_group()`."""
>>>>>>         return _mupdf.PdfPage_pdf_page_group(self)
       
    1:     def pdf_page_has_transparency(self):
               r"""Class-aware wrapper for `::pdf_page_has_transparency()`."""
>>>>>>         return _mupdf.PdfPage_pdf_page_has_transparency(self)
       
    1:     def pdf_page_presentation(self, transition, duration):
               r"""
               Class-aware wrapper for `::pdf_page_presentation()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_page_presentation(::fz_transition *transition)` => `(fz_transition *, float duration)`
               """
>>>>>>         return _mupdf.PdfPage_pdf_page_presentation(self, transition, duration)
       
    1:     def pdf_page_resources(self):
               r"""Class-aware wrapper for `::pdf_page_resources()`."""
>>>>>>         return _mupdf.PdfPage_pdf_page_resources(self)
       
    1:     def pdf_page_separations(self):
               r"""Class-aware wrapper for `::pdf_page_separations()`."""
>>>>>>         return _mupdf.PdfPage_pdf_page_separations(self)
       
    1:     def pdf_page_transform(self, mediabox, ctm):
               r"""Class-aware wrapper for `::pdf_page_transform()`."""
>>>>>>         return _mupdf.PdfPage_pdf_page_transform(self, mediabox, ctm)
       
    1:     def pdf_page_transform_box(self, mediabox, ctm, box):
               r"""Class-aware wrapper for `::pdf_page_transform_box()`."""
>>>>>>         return _mupdf.PdfPage_pdf_page_transform_box(self, mediabox, ctm, box)
       
    1:     def pdf_run_page(self, dev, ctm, cookie):
               r"""Class-aware wrapper for `::pdf_run_page()`."""
>>>>>>         return _mupdf.PdfPage_pdf_run_page(self, dev, ctm, cookie)
       
    1:     def pdf_run_page_annots(self, dev, ctm, cookie):
               r"""Class-aware wrapper for `::pdf_run_page_annots()`."""
>>>>>>         return _mupdf.PdfPage_pdf_run_page_annots(self, dev, ctm, cookie)
       
    1:     def pdf_run_page_annots_with_usage(self, dev, ctm, usage, cookie):
               r"""Class-aware wrapper for `::pdf_run_page_annots_with_usage()`."""
>>>>>>         return _mupdf.PdfPage_pdf_run_page_annots_with_usage(self, dev, ctm, usage, cookie)
       
    1:     def pdf_run_page_contents(self, dev, ctm, cookie):
               r"""Class-aware wrapper for `::pdf_run_page_contents()`."""
>>>>>>         return _mupdf.PdfPage_pdf_run_page_contents(self, dev, ctm, cookie)
       
    1:     def pdf_run_page_contents_with_usage(self, dev, ctm, usage, cookie):
               r"""Class-aware wrapper for `::pdf_run_page_contents_with_usage()`."""
>>>>>>         return _mupdf.PdfPage_pdf_run_page_contents_with_usage(self, dev, ctm, usage, cookie)
       
    1:     def pdf_run_page_widgets(self, dev, ctm, cookie):
               r"""Class-aware wrapper for `::pdf_run_page_widgets()`."""
>>>>>>         return _mupdf.PdfPage_pdf_run_page_widgets(self, dev, ctm, cookie)
       
    1:     def pdf_run_page_widgets_with_usage(self, dev, ctm, usage, cookie):
               r"""Class-aware wrapper for `::pdf_run_page_widgets_with_usage()`."""
>>>>>>         return _mupdf.PdfPage_pdf_run_page_widgets_with_usage(self, dev, ctm, usage, cookie)
       
    1:     def pdf_run_page_with_usage(self, dev, ctm, usage, cookie):
               r"""Class-aware wrapper for `::pdf_run_page_with_usage()`."""
>>>>>>         return _mupdf.PdfPage_pdf_run_page_with_usage(self, dev, ctm, usage, cookie)
       
    1:     def pdf_set_page_box(self, box, rect):
               r"""Class-aware wrapper for `::pdf_set_page_box()`."""
>>>>>>         return _mupdf.PdfPage_pdf_set_page_box(self, box, rect)
       
    1:     def pdf_sync_annots(self):
               r"""Class-aware wrapper for `::pdf_sync_annots()`."""
>>>>>>         return _mupdf.PdfPage_pdf_sync_annots(self)
       
    1:     def pdf_sync_links(self):
               r"""Class-aware wrapper for `::pdf_sync_links()`."""
>>>>>>         return _mupdf.PdfPage_pdf_sync_links(self)
       
    1:     def pdf_sync_page(self):
               r"""Class-aware wrapper for `::pdf_sync_page()`."""
>>>>>>         return _mupdf.PdfPage_pdf_sync_page(self)
       
    1:     def pdf_update_page(self):
               r"""Class-aware wrapper for `::pdf_update_page()`."""
>>>>>>         return _mupdf.PdfPage_pdf_update_page(self)
       
    1:     def super(self):
               r"""Returns wrapper for .super member."""
>>>>>>         return _mupdf.PdfPage_super(self)
       
    1:     def doc(self):
               r"""Returns wrapper for .doc member."""
>>>>>>         return _mupdf.PdfPage_doc(self)
       
    1:     def obj(self):
               r"""Returns wrapper for .obj member."""
>>>>>>         return _mupdf.PdfPage_obj(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Copy constructor using `pdf_keep_page()`.
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_page`.
               """
>>>>>>         _mupdf.PdfPage_swiginit(self, _mupdf.new_PdfPage(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfPage
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfPage_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfPage___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfPage_m_internal_get, _mupdf.PdfPage_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfPage_s_num_instances_get, _mupdf.PdfPage_s_num_instances_set)
       
       # Register PdfPage in _mupdf:
    1: _mupdf.PdfPage_swigregister(PdfPage)
    2: class PdfPattern(object):
    1:     r"""Wrapper class for struct `pdf_pattern`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Copy constructor using `pdf_keep_pattern()`.
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_pattern`.
               """
>>>>>>         _mupdf.PdfPattern_swiginit(self, _mupdf.new_PdfPattern(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfPattern
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfPattern_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfPattern___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfPattern_m_internal_get, _mupdf.PdfPattern_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfPattern_s_num_instances_get, _mupdf.PdfPattern_s_num_instances_set)
       
       # Register PdfPattern in _mupdf:
    1: _mupdf.PdfPattern_swigregister(PdfPattern)
    2: class PdfPkcs7DistinguishedName(object):
    1:     r"""Wrapper class for struct `pdf_pkcs7_distinguished_name`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_signature_drop_distinguished_name(self):
               r"""Class-aware wrapper for `::pdf_signature_drop_distinguished_name()`."""
>>>>>>         return _mupdf.PdfPkcs7DistinguishedName_pdf_signature_drop_distinguished_name(self)
       
    1:     def pdf_signature_format_distinguished_name(self):
               r"""Class-aware wrapper for `::pdf_signature_format_distinguished_name()`."""
>>>>>>         return _mupdf.PdfPkcs7DistinguishedName_pdf_signature_format_distinguished_name(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_pkcs7_distinguished_name`.
               """
>>>>>>         _mupdf.PdfPkcs7DistinguishedName_swiginit(self, _mupdf.new_PdfPkcs7DistinguishedName(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfPkcs7DistinguishedName
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfPkcs7DistinguishedName_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfPkcs7DistinguishedName___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfPkcs7DistinguishedName_m_internal_get, _mupdf.PdfPkcs7DistinguishedName_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfPkcs7DistinguishedName_s_num_instances_get, _mupdf.PdfPkcs7DistinguishedName_s_num_instances_set)
       
       # Register PdfPkcs7DistinguishedName in _mupdf:
    1: _mupdf.PdfPkcs7DistinguishedName_swigregister(PdfPkcs7DistinguishedName)
    2: class PdfPkcs7Signer(object):
    1:     r"""Wrapper class for struct `pdf_pkcs7_signer`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_pkcs7_signer`.
               """
>>>>>>         _mupdf.PdfPkcs7Signer_swiginit(self, _mupdf.new_PdfPkcs7Signer(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfPkcs7Signer
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfPkcs7Signer_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfPkcs7Signer___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfPkcs7Signer_m_internal_get, _mupdf.PdfPkcs7Signer_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfPkcs7Signer_s_num_instances_get, _mupdf.PdfPkcs7Signer_s_num_instances_set)
       
       # Register PdfPkcs7Signer in _mupdf:
    1: _mupdf.PdfPkcs7Signer_swigregister(PdfPkcs7Signer)
    2: class PdfPkcs7Verifier(object):
    1:     r"""Wrapper class for struct `pdf_pkcs7_verifier`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_pkcs7_verifier`.
               """
>>>>>>         _mupdf.PdfPkcs7Verifier_swiginit(self, _mupdf.new_PdfPkcs7Verifier(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfPkcs7Verifier
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfPkcs7Verifier_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfPkcs7Verifier___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfPkcs7Verifier_m_internal_get, _mupdf.PdfPkcs7Verifier_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfPkcs7Verifier_s_num_instances_get, _mupdf.PdfPkcs7Verifier_s_num_instances_set)
       
       # Register PdfPkcs7Verifier in _mupdf:
    1: _mupdf.PdfPkcs7Verifier_swigregister(PdfPkcs7Verifier)
    2: class PdfProcessor(object):
    1:     r"""Wrapper class for struct `pdf_processor`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    2:     @staticmethod
    2:     def pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts):
               r"""Class-aware wrapper for `::pdf_new_color_filter()`."""
>>>>>>         return _mupdf.PdfProcessor_pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts)
       
    1:     def pdf_close_processor(self):
               r"""Class-aware wrapper for `::pdf_close_processor()`."""
>>>>>>         return _mupdf.PdfProcessor_pdf_close_processor(self)
       
    1:     def pdf_process_annot(self, annot, cookie):
               r"""Class-aware wrapper for `::pdf_process_annot()`."""
>>>>>>         return _mupdf.PdfProcessor_pdf_process_annot(self, annot, cookie)
       
    1:     def pdf_process_contents(self, doc, res, stm, cookie, out_res):
               r"""
               Class-aware wrapper for `::pdf_process_contents()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_process_contents(::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, ::fz_cookie *cookie, ::pdf_obj **out_res)` =>
               """
>>>>>>         return _mupdf.PdfProcessor_pdf_process_contents(self, doc, res, stm, cookie, out_res)
       
    1:     def pdf_process_glyph(self, doc, resources, contents):
               r"""Class-aware wrapper for `::pdf_process_glyph()`."""
>>>>>>         return _mupdf.PdfProcessor_pdf_process_glyph(self, doc, resources, contents)
       
    1:     def pdf_process_raw_contents(self, doc, stmobj, cookie):
               r"""Class-aware wrapper for `::pdf_process_raw_contents()`."""
>>>>>>         return _mupdf.PdfProcessor_pdf_process_raw_contents(self, doc, stmobj, cookie)
       
    1:     def pdf_processor_pop_resources(self):
               r"""Class-aware wrapper for `::pdf_processor_pop_resources()`."""
>>>>>>         return _mupdf.PdfProcessor_pdf_processor_pop_resources(self)
       
    1:     def pdf_processor_push_resources(self, res):
               r"""Class-aware wrapper for `::pdf_processor_push_resources()`."""
>>>>>>         return _mupdf.PdfProcessor_pdf_processor_push_resources(self, res)
       
    1:     def pdf_reset_processor(self):
               r"""Class-aware wrapper for `::pdf_reset_processor()`."""
>>>>>>         return _mupdf.PdfProcessor_pdf_reset_processor(self)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `pdf_new_buffer_processor()`.
       
               |
       
               *Overload 2:*
               Constructor using `pdf_new_output_processor()`.
       
               |
       
               *Overload 3:*
               Constructor using `pdf_new_run_processor()`.
       
               |
       
               *Overload 4:*
               Constructor using `pdf_new_sanitize_filter()`.
       
               |
       
               *Overload 5:*
               Copy constructor using `pdf_keep_processor()`.
       
               |
       
               *Overload 6:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 7:*
               Constructor using raw copy of pre-existing `::pdf_processor`.
               """
>>>>>>         _mupdf.PdfProcessor_swiginit(self, _mupdf.new_PdfProcessor(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfProcessor
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfProcessor_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfProcessor___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfProcessor_m_internal_get, _mupdf.PdfProcessor_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfProcessor_s_num_instances_get, _mupdf.PdfProcessor_s_num_instances_set)
       
       # Register PdfProcessor in _mupdf:
    1: _mupdf.PdfProcessor_swigregister(PdfProcessor)
    2: class PdfProcessor2(PdfProcessor):
    1:     r"""Wrapper class for struct pdf_processor with virtual fns for each fnptr; this is for use as a SWIG Director class."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self):
               r"""== Constructor."""
>>>>>>         if self.__class__ == PdfProcessor2:
>>>>>>             _self = None
               else:
>>>>>>             _self = self
>>>>>>         _mupdf.PdfProcessor2_swiginit(self, _mupdf.new_PdfProcessor2(_self, ))
    1:     __swig_destroy__ = _mupdf.delete_PdfProcessor2
       
    1:     def use_virtual_close_processor(self, use=True):
               r"""
               These methods set the function pointers in *m_internal
               to point to internal callbacks that call our virtual methods.
               """
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_close_processor(self, use)
       
    1:     def use_virtual_drop_processor(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_drop_processor(self, use)
       
    1:     def use_virtual_reset_processor(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_reset_processor(self, use)
       
    1:     def use_virtual_push_resources(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_push_resources(self, use)
       
    1:     def use_virtual_pop_resources(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_pop_resources(self, use)
       
    1:     def use_virtual_op_w(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_w(self, use)
       
    1:     def use_virtual_op_j(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_j(self, use)
       
    1:     def use_virtual_op_J(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_J(self, use)
       
    1:     def use_virtual_op_M(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_M(self, use)
       
    1:     def use_virtual_op_d(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_d(self, use)
       
    1:     def use_virtual_op_ri(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_ri(self, use)
       
    1:     def use_virtual_op_i(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_i(self, use)
       
    1:     def use_virtual_op_gs_begin(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_gs_begin(self, use)
       
    1:     def use_virtual_op_gs_BM(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_gs_BM(self, use)
       
    1:     def use_virtual_op_gs_ca(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_gs_ca(self, use)
       
    1:     def use_virtual_op_gs_CA(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_gs_CA(self, use)
       
    1:     def use_virtual_op_gs_SMask(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_gs_SMask(self, use)
       
    1:     def use_virtual_op_gs_end(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_gs_end(self, use)
       
    1:     def use_virtual_op_q(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_q(self, use)
       
    1:     def use_virtual_op_Q(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Q(self, use)
       
    1:     def use_virtual_op_cm(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_cm(self, use)
       
    1:     def use_virtual_op_m(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_m(self, use)
       
    1:     def use_virtual_op_l(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_l(self, use)
       
    1:     def use_virtual_op_c(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_c(self, use)
       
    1:     def use_virtual_op_v(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_v(self, use)
       
    1:     def use_virtual_op_y(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_y(self, use)
       
    1:     def use_virtual_op_h(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_h(self, use)
       
    1:     def use_virtual_op_re(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_re(self, use)
       
    1:     def use_virtual_op_S(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_S(self, use)
       
    1:     def use_virtual_op_s(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_s(self, use)
       
    1:     def use_virtual_op_F(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_F(self, use)
       
    1:     def use_virtual_op_f(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_f(self, use)
       
    1:     def use_virtual_op_fstar(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_fstar(self, use)
       
    1:     def use_virtual_op_B(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_B(self, use)
       
    1:     def use_virtual_op_Bstar(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Bstar(self, use)
       
    1:     def use_virtual_op_b(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_b(self, use)
       
    1:     def use_virtual_op_bstar(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_bstar(self, use)
       
    1:     def use_virtual_op_n(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_n(self, use)
       
    1:     def use_virtual_op_W(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_W(self, use)
       
    1:     def use_virtual_op_Wstar(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Wstar(self, use)
       
    1:     def use_virtual_op_BT(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_BT(self, use)
       
    1:     def use_virtual_op_ET(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_ET(self, use)
       
    1:     def use_virtual_op_Tc(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Tc(self, use)
       
    1:     def use_virtual_op_Tw(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Tw(self, use)
       
    1:     def use_virtual_op_Tz(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Tz(self, use)
       
    1:     def use_virtual_op_TL(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_TL(self, use)
       
    1:     def use_virtual_op_Tf(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Tf(self, use)
       
    1:     def use_virtual_op_Tr(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Tr(self, use)
       
    1:     def use_virtual_op_Ts(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Ts(self, use)
       
    1:     def use_virtual_op_Td(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Td(self, use)
       
    1:     def use_virtual_op_TD(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_TD(self, use)
       
    1:     def use_virtual_op_Tm(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Tm(self, use)
       
    1:     def use_virtual_op_Tstar(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Tstar(self, use)
       
    1:     def use_virtual_op_TJ(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_TJ(self, use)
       
    1:     def use_virtual_op_Tj(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Tj(self, use)
       
    1:     def use_virtual_op_squote(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_squote(self, use)
       
    1:     def use_virtual_op_dquote(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_dquote(self, use)
       
    1:     def use_virtual_op_d0(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_d0(self, use)
       
    1:     def use_virtual_op_d1(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_d1(self, use)
       
    1:     def use_virtual_op_CS(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_CS(self, use)
       
    1:     def use_virtual_op_cs(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_cs(self, use)
       
    1:     def use_virtual_op_SC_pattern(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_SC_pattern(self, use)
       
    1:     def use_virtual_op_sc_pattern(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_sc_pattern(self, use)
       
    1:     def use_virtual_op_SC_shade(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_SC_shade(self, use)
       
    1:     def use_virtual_op_sc_shade(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_sc_shade(self, use)
       
    1:     def use_virtual_op_SC_color(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_SC_color(self, use)
       
    1:     def use_virtual_op_sc_color(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_sc_color(self, use)
       
    1:     def use_virtual_op_G(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_G(self, use)
       
    1:     def use_virtual_op_g(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_g(self, use)
       
    1:     def use_virtual_op_RG(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_RG(self, use)
       
    1:     def use_virtual_op_rg(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_rg(self, use)
       
    1:     def use_virtual_op_K(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_K(self, use)
       
    1:     def use_virtual_op_k(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_k(self, use)
       
    1:     def use_virtual_op_BI(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_BI(self, use)
       
    1:     def use_virtual_op_sh(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_sh(self, use)
       
    1:     def use_virtual_op_Do_image(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Do_image(self, use)
       
    1:     def use_virtual_op_Do_form(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_Do_form(self, use)
       
    1:     def use_virtual_op_MP(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_MP(self, use)
       
    1:     def use_virtual_op_DP(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_DP(self, use)
       
    1:     def use_virtual_op_BMC(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_BMC(self, use)
       
    1:     def use_virtual_op_BDC(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_BDC(self, use)
       
    1:     def use_virtual_op_EMC(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_EMC(self, use)
       
    1:     def use_virtual_op_BX(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_BX(self, use)
       
    1:     def use_virtual_op_EX(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_EX(self, use)
       
    1:     def use_virtual_op_gs_OP(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_gs_OP(self, use)
       
    1:     def use_virtual_op_gs_op(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_gs_op(self, use)
       
    1:     def use_virtual_op_gs_OPM(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_gs_OPM(self, use)
       
    1:     def use_virtual_op_gs_UseBlackPtComp(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_gs_UseBlackPtComp(self, use)
       
    1:     def use_virtual_op_EOD(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_EOD(self, use)
       
    1:     def use_virtual_op_END(self, use=True):
>>>>>>         return _mupdf.PdfProcessor2_use_virtual_op_END(self, use)
       
    1:     def close_processor(self, arg_0):
               r"""Default virtual method implementations; these all throw an exception."""
>>>>>>         return _mupdf.PdfProcessor2_close_processor(self, arg_0)
       
    1:     def drop_processor(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_drop_processor(self, arg_0)
       
    1:     def reset_processor(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_reset_processor(self, arg_0)
       
    1:     def push_resources(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_push_resources(self, arg_0, arg_2)
       
    1:     def pop_resources(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_pop_resources(self, arg_0)
       
    1:     def op_w(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_w(self, arg_0, arg_2)
       
    1:     def op_j(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_j(self, arg_0, arg_2)
       
    1:     def op_J(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_J(self, arg_0, arg_2)
       
    1:     def op_M(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_M(self, arg_0, arg_2)
       
    1:     def op_d(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_d(self, arg_0, arg_2, arg_3)
       
    1:     def op_ri(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_ri(self, arg_0, arg_2)
       
    1:     def op_i(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_i(self, arg_0, arg_2)
       
    1:     def op_gs_begin(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_gs_begin(self, arg_0, arg_2, arg_3)
       
    1:     def op_gs_BM(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_gs_BM(self, arg_0, arg_2)
       
    1:     def op_gs_ca(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_gs_ca(self, arg_0, arg_2)
       
    1:     def op_gs_CA(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_gs_CA(self, arg_0, arg_2)
       
    1:     def op_gs_SMask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6):
>>>>>>         return _mupdf.PdfProcessor2_op_gs_SMask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6)
       
    1:     def op_gs_end(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_gs_end(self, arg_0)
       
    1:     def op_q(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_q(self, arg_0)
       
    1:     def op_Q(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_Q(self, arg_0)
       
    1:     def op_cm(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
>>>>>>         return _mupdf.PdfProcessor2_op_cm(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)
       
    1:     def op_m(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_m(self, arg_0, arg_2, arg_3)
       
    1:     def op_l(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_l(self, arg_0, arg_2, arg_3)
       
    1:     def op_c(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
>>>>>>         return _mupdf.PdfProcessor2_op_c(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)
       
    1:     def op_v(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.PdfProcessor2_op_v(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def op_y(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.PdfProcessor2_op_y(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def op_h(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_h(self, arg_0)
       
    1:     def op_re(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.PdfProcessor2_op_re(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def op_S(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_S(self, arg_0)
       
    1:     def op_s(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_s(self, arg_0)
       
    1:     def op_F(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_F(self, arg_0)
       
    1:     def op_f(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_f(self, arg_0)
       
    1:     def op_fstar(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_fstar(self, arg_0)
       
    1:     def op_B(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_B(self, arg_0)
       
    1:     def op_Bstar(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_Bstar(self, arg_0)
       
    1:     def op_b(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_b(self, arg_0)
       
    1:     def op_bstar(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_bstar(self, arg_0)
       
    1:     def op_n(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_n(self, arg_0)
       
    1:     def op_W(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_W(self, arg_0)
       
    1:     def op_Wstar(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_Wstar(self, arg_0)
       
    1:     def op_BT(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_BT(self, arg_0)
       
    1:     def op_ET(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_ET(self, arg_0)
       
    1:     def op_Tc(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_Tc(self, arg_0, arg_2)
       
    1:     def op_Tw(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_Tw(self, arg_0, arg_2)
       
    1:     def op_Tz(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_Tz(self, arg_0, arg_2)
       
    1:     def op_TL(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_TL(self, arg_0, arg_2)
       
    1:     def op_Tf(self, arg_0, arg_2, arg_3, arg_4):
>>>>>>         return _mupdf.PdfProcessor2_op_Tf(self, arg_0, arg_2, arg_3, arg_4)
       
    1:     def op_Tr(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_Tr(self, arg_0, arg_2)
       
    1:     def op_Ts(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_Ts(self, arg_0, arg_2)
       
    1:     def op_Td(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_Td(self, arg_0, arg_2, arg_3)
       
    1:     def op_TD(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_TD(self, arg_0, arg_2, arg_3)
       
    1:     def op_Tm(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
>>>>>>         return _mupdf.PdfProcessor2_op_Tm(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)
       
    1:     def op_Tstar(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_Tstar(self, arg_0)
       
    1:     def op_TJ(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_TJ(self, arg_0, arg_2)
       
    1:     def op_Tj(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_Tj(self, arg_0, arg_2, arg_3)
       
    1:     def op_squote(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_squote(self, arg_0, arg_2, arg_3)
       
    1:     def op_dquote(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.PdfProcessor2_op_dquote(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def op_d0(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_d0(self, arg_0, arg_2, arg_3)
       
    1:     def op_d1(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
>>>>>>         return _mupdf.PdfProcessor2_op_d1(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)
       
    1:     def op_CS(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_CS(self, arg_0, arg_2, arg_3)
       
    1:     def op_cs(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_cs(self, arg_0, arg_2, arg_3)
       
    1:     def op_SC_pattern(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.PdfProcessor2_op_SC_pattern(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def op_sc_pattern(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.PdfProcessor2_op_sc_pattern(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def op_SC_shade(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_SC_shade(self, arg_0, arg_2, arg_3)
       
    1:     def op_sc_shade(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_sc_shade(self, arg_0, arg_2, arg_3)
       
    1:     def op_SC_color(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_SC_color(self, arg_0, arg_2, arg_3)
       
    1:     def op_sc_color(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_sc_color(self, arg_0, arg_2, arg_3)
       
    1:     def op_G(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_G(self, arg_0, arg_2)
       
    1:     def op_g(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_g(self, arg_0, arg_2)
       
    1:     def op_RG(self, arg_0, arg_2, arg_3, arg_4):
>>>>>>         return _mupdf.PdfProcessor2_op_RG(self, arg_0, arg_2, arg_3, arg_4)
       
    1:     def op_rg(self, arg_0, arg_2, arg_3, arg_4):
>>>>>>         return _mupdf.PdfProcessor2_op_rg(self, arg_0, arg_2, arg_3, arg_4)
       
    1:     def op_K(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.PdfProcessor2_op_K(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def op_k(self, arg_0, arg_2, arg_3, arg_4, arg_5):
>>>>>>         return _mupdf.PdfProcessor2_op_k(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def op_BI(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_BI(self, arg_0, arg_2, arg_3)
       
    1:     def op_sh(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_sh(self, arg_0, arg_2, arg_3)
       
    1:     def op_Do_image(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_Do_image(self, arg_0, arg_2, arg_3)
       
    1:     def op_Do_form(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfProcessor2_op_Do_form(self, arg_0, arg_2, arg_3)
       
    1:     def op_MP(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_MP(self, arg_0, arg_2)
       
    1:     def op_DP(self, arg_0, arg_2, arg_3, arg_4):
>>>>>>         return _mupdf.PdfProcessor2_op_DP(self, arg_0, arg_2, arg_3, arg_4)
       
    1:     def op_BMC(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_BMC(self, arg_0, arg_2)
       
    1:     def op_BDC(self, arg_0, arg_2, arg_3, arg_4):
>>>>>>         return _mupdf.PdfProcessor2_op_BDC(self, arg_0, arg_2, arg_3, arg_4)
       
    1:     def op_EMC(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_EMC(self, arg_0)
       
    1:     def op_BX(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_BX(self, arg_0)
       
    1:     def op_EX(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_EX(self, arg_0)
       
    1:     def op_gs_OP(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_gs_OP(self, arg_0, arg_2)
       
    1:     def op_gs_op(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_gs_op(self, arg_0, arg_2)
       
    1:     def op_gs_OPM(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_gs_OPM(self, arg_0, arg_2)
       
    1:     def op_gs_UseBlackPtComp(self, arg_0, arg_2):
>>>>>>         return _mupdf.PdfProcessor2_op_gs_UseBlackPtComp(self, arg_0, arg_2)
       
    1:     def op_EOD(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_EOD(self, arg_0)
       
    1:     def op_END(self, arg_0):
>>>>>>         return _mupdf.PdfProcessor2_op_END(self, arg_0)
    1:     def __disown__(self):
>>>>>>         self.this.disown()
>>>>>>         _mupdf.disown_PdfProcessor2(self)
>>>>>>         return weakref.proxy(self)
       
       # Register PdfProcessor2 in _mupdf:
    1: _mupdf.PdfProcessor2_swigregister(PdfProcessor2)
    2: class PdfRange(object):
    1:     r"""Wrapper class for struct `pdf_range`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_range`.
               """
>>>>>>         _mupdf.PdfRange_swiginit(self, _mupdf.new_PdfRange(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfRange
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfRange_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfRange___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfRange_m_internal_get, _mupdf.PdfRange_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfRange_s_num_instances_get, _mupdf.PdfRange_s_num_instances_set)
       
       # Register PdfRange in _mupdf:
    1: _mupdf.PdfRange_swigregister(PdfRange)
    2: class PdfRecolorOptions(object):
    1:     r"""Wrapper class for struct `pdf_recolor_options`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_recolor_options`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_recolor_options`.
               """
>>>>>>         _mupdf.PdfRecolorOptions_swiginit(self, _mupdf.new_PdfRecolorOptions(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.PdfRecolorOptions_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_PdfRecolorOptions
    1:     num_comp = property(_mupdf.PdfRecolorOptions_num_comp_get, _mupdf.PdfRecolorOptions_num_comp_set)
    1:     s_num_instances = property(_mupdf.PdfRecolorOptions_s_num_instances_get, _mupdf.PdfRecolorOptions_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.PdfRecolorOptions_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfRecolorOptions___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfRecolorOptions___ne__(self, rhs)
       
       # Register PdfRecolorOptions in _mupdf:
    1: _mupdf.PdfRecolorOptions_swigregister(PdfRecolorOptions)
    2: class PdfRedactOptions(object):
    1:     r"""Wrapper class for struct `pdf_redact_options`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_redact_options`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_redact_options`.
               """
>>>>>>         _mupdf.PdfRedactOptions_swiginit(self, _mupdf.new_PdfRedactOptions(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.PdfRedactOptions_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_PdfRedactOptions
    1:     black_boxes = property(_mupdf.PdfRedactOptions_black_boxes_get, _mupdf.PdfRedactOptions_black_boxes_set)
    1:     image_method = property(_mupdf.PdfRedactOptions_image_method_get, _mupdf.PdfRedactOptions_image_method_set)
    1:     line_art = property(_mupdf.PdfRedactOptions_line_art_get, _mupdf.PdfRedactOptions_line_art_set)
    1:     text = property(_mupdf.PdfRedactOptions_text_get, _mupdf.PdfRedactOptions_text_set)
    1:     s_num_instances = property(_mupdf.PdfRedactOptions_s_num_instances_get, _mupdf.PdfRedactOptions_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.PdfRedactOptions_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfRedactOptions___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfRedactOptions___ne__(self, rhs)
       
       # Register PdfRedactOptions in _mupdf:
    1: _mupdf.PdfRedactOptions_swigregister(PdfRedactOptions)
    2: class PdfResourceStack(object):
    1:     r"""Wrapper class for struct `pdf_resource_stack`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_lookup_resource(self, type, name):
               r"""Class-aware wrapper for `::pdf_lookup_resource()`."""
>>>>>>         return _mupdf.PdfResourceStack_pdf_lookup_resource(self, type, name)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_resource_stack`.
               """
>>>>>>         _mupdf.PdfResourceStack_swiginit(self, _mupdf.new_PdfResourceStack(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfResourceStack
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfResourceStack_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfResourceStack___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfResourceStack_m_internal_get, _mupdf.PdfResourceStack_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfResourceStack_s_num_instances_get, _mupdf.PdfResourceStack_s_num_instances_set)
       
       # Register PdfResourceStack in _mupdf:
    1: _mupdf.PdfResourceStack_swigregister(PdfResourceStack)
    2: class PdfRevPageMap(object):
    1:     r"""Wrapper class for struct `pdf_rev_page_map`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_rev_page_map`.
               """
>>>>>>         _mupdf.PdfRevPageMap_swiginit(self, _mupdf.new_PdfRevPageMap(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfRevPageMap
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfRevPageMap_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfRevPageMap___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfRevPageMap_m_internal_get, _mupdf.PdfRevPageMap_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfRevPageMap_s_num_instances_get, _mupdf.PdfRevPageMap_s_num_instances_set)
       
       # Register PdfRevPageMap in _mupdf:
    1: _mupdf.PdfRevPageMap_swigregister(PdfRevPageMap)
    2: class PdfSanitizeFilterOptions(object):
    1:     r"""Wrapper class for struct `pdf_sanitize_filter_options`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               We use default copy constructor and operator=.  Default constructor, sets each member to default value.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_sanitize_filter_options`.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_sanitize_filter_options`.
               """
>>>>>>         _mupdf.PdfSanitizeFilterOptions_swiginit(self, _mupdf.new_PdfSanitizeFilterOptions(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.PdfSanitizeFilterOptions_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_PdfSanitizeFilterOptions
    1:     opaque = property(_mupdf.PdfSanitizeFilterOptions_opaque_get, _mupdf.PdfSanitizeFilterOptions_opaque_set)
    1:     image_filter = property(_mupdf.PdfSanitizeFilterOptions_image_filter_get, _mupdf.PdfSanitizeFilterOptions_image_filter_set)
    1:     text_filter = property(_mupdf.PdfSanitizeFilterOptions_text_filter_get, _mupdf.PdfSanitizeFilterOptions_text_filter_set)
    1:     after_text_object = property(_mupdf.PdfSanitizeFilterOptions_after_text_object_get, _mupdf.PdfSanitizeFilterOptions_after_text_object_set)
    1:     culler = property(_mupdf.PdfSanitizeFilterOptions_culler_get, _mupdf.PdfSanitizeFilterOptions_culler_set)
    1:     s_num_instances = property(_mupdf.PdfSanitizeFilterOptions_s_num_instances_get, _mupdf.PdfSanitizeFilterOptions_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.PdfSanitizeFilterOptions_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfSanitizeFilterOptions___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfSanitizeFilterOptions___ne__(self, rhs)
       
       # Register PdfSanitizeFilterOptions in _mupdf:
    1: _mupdf.PdfSanitizeFilterOptions_swigregister(PdfSanitizeFilterOptions)
    2: class PdfSanitizeFilterOptions2(PdfSanitizeFilterOptions):
    1:     r"""Wrapper class for struct pdf_sanitize_filter_options with virtual fns for each fnptr; this is for use as a SWIG Director class."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self):
               r"""== Constructor."""
>>>>>>         if self.__class__ == PdfSanitizeFilterOptions2:
>>>>>>             _self = None
               else:
>>>>>>             _self = self
>>>>>>         _mupdf.PdfSanitizeFilterOptions2_swiginit(self, _mupdf.new_PdfSanitizeFilterOptions2(_self, ))
    1:     __swig_destroy__ = _mupdf.delete_PdfSanitizeFilterOptions2
       
    1:     def use_virtual_image_filter(self, use=True):
               r"""
               These methods set the function pointers in *m_internal
               to point to internal callbacks that call our virtual methods.
               """
>>>>>>         return _mupdf.PdfSanitizeFilterOptions2_use_virtual_image_filter(self, use)
       
    1:     def use_virtual_text_filter(self, use=True):
>>>>>>         return _mupdf.PdfSanitizeFilterOptions2_use_virtual_text_filter(self, use)
       
    1:     def use_virtual_after_text_object(self, use=True):
>>>>>>         return _mupdf.PdfSanitizeFilterOptions2_use_virtual_after_text_object(self, use)
       
    1:     def use_virtual_culler(self, use=True):
>>>>>>         return _mupdf.PdfSanitizeFilterOptions2_use_virtual_culler(self, use)
       
    1:     def image_filter(self, arg_0, arg_2, arg_3, arg_4, arg_5):
               r"""Default virtual method implementations; these all throw an exception."""
>>>>>>         return _mupdf.PdfSanitizeFilterOptions2_image_filter(self, arg_0, arg_2, arg_3, arg_4, arg_5)
       
    1:     def text_filter(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6):
>>>>>>         return _mupdf.PdfSanitizeFilterOptions2_text_filter(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6)
       
    1:     def after_text_object(self, arg_0, arg_2, arg_3, arg_4):
>>>>>>         return _mupdf.PdfSanitizeFilterOptions2_after_text_object(self, arg_0, arg_2, arg_3, arg_4)
       
    1:     def culler(self, arg_0, arg_2, arg_3):
>>>>>>         return _mupdf.PdfSanitizeFilterOptions2_culler(self, arg_0, arg_2, arg_3)
    1:     def __disown__(self):
>>>>>>         self.this.disown()
>>>>>>         _mupdf.disown_PdfSanitizeFilterOptions2(self)
>>>>>>         return weakref.proxy(self)
       
       # Register PdfSanitizeFilterOptions2 in _mupdf:
    1: _mupdf.PdfSanitizeFilterOptions2_swigregister(PdfSanitizeFilterOptions2)
    2: class PdfTextObjectState(object):
    1:     r"""Wrapper class for struct `pdf_text_object_state`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_tos_get_text(self):
               r"""Class-aware wrapper for `::pdf_tos_get_text()`."""
>>>>>>         return _mupdf.PdfTextObjectState_pdf_tos_get_text(self)
       
    1:     def pdf_tos_make_trm(self, text, fontdesc, cid, trm, adv):
               r"""
               Class-aware wrapper for `::pdf_tos_make_trm()`.
       
               This method has out-params. Python/C# wrappers look like:
                       `pdf_tos_make_trm(::pdf_text_state *text, ::pdf_font_desc *fontdesc, int cid, ::fz_matrix *trm)` => `(int, float adv)`
               """
>>>>>>         return _mupdf.PdfTextObjectState_pdf_tos_make_trm(self, text, fontdesc, cid, trm, adv)
       
    1:     def pdf_tos_move_after_char(self):
               r"""Class-aware wrapper for `::pdf_tos_move_after_char()`."""
>>>>>>         return _mupdf.PdfTextObjectState_pdf_tos_move_after_char(self)
       
    1:     def pdf_tos_newline(self, leading):
               r"""Class-aware wrapper for `::pdf_tos_newline()`."""
>>>>>>         return _mupdf.PdfTextObjectState_pdf_tos_newline(self, leading)
       
    1:     def pdf_tos_reset(self, render):
               r"""Class-aware wrapper for `::pdf_tos_reset()`."""
>>>>>>         return _mupdf.PdfTextObjectState_pdf_tos_reset(self, render)
       
    1:     def pdf_tos_set_matrix(self, a, b, c, d, e, f):
               r"""Class-aware wrapper for `::pdf_tos_set_matrix()`."""
>>>>>>         return _mupdf.PdfTextObjectState_pdf_tos_set_matrix(self, a, b, c, d, e, f)
       
    1:     def pdf_tos_translate(self, tx, ty):
               r"""Class-aware wrapper for `::pdf_tos_translate()`."""
>>>>>>         return _mupdf.PdfTextObjectState_pdf_tos_translate(self, tx, ty)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_text_object_state`.
               """
>>>>>>         _mupdf.PdfTextObjectState_swiginit(self, _mupdf.new_PdfTextObjectState(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfTextObjectState
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfTextObjectState_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfTextObjectState___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfTextObjectState_m_internal_get, _mupdf.PdfTextObjectState_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfTextObjectState_s_num_instances_get, _mupdf.PdfTextObjectState_s_num_instances_set)
       
       # Register PdfTextObjectState in _mupdf:
    1: _mupdf.PdfTextObjectState_swigregister(PdfTextObjectState)
    2: class PdfTextState(object):
    1:     r"""Wrapper class for struct `pdf_text_state`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_text_state`.
               """
>>>>>>         _mupdf.PdfTextState_swiginit(self, _mupdf.new_PdfTextState(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfTextState
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfTextState_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfTextState___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfTextState_m_internal_get, _mupdf.PdfTextState_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfTextState_s_num_instances_get, _mupdf.PdfTextState_s_num_instances_set)
       
       # Register PdfTextState in _mupdf:
    1: _mupdf.PdfTextState_swigregister(PdfTextState)
    2: class PdfUnsavedSig(object):
    1:     r"""Wrapper class for struct `pdf_unsaved_sig`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_unsaved_sig`.
               """
>>>>>>         _mupdf.PdfUnsavedSig_swiginit(self, _mupdf.new_PdfUnsavedSig(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfUnsavedSig
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfUnsavedSig_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfUnsavedSig___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfUnsavedSig_m_internal_get, _mupdf.PdfUnsavedSig_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfUnsavedSig_s_num_instances_get, _mupdf.PdfUnsavedSig_s_num_instances_set)
       
       # Register PdfUnsavedSig in _mupdf:
    1: _mupdf.PdfUnsavedSig_swigregister(PdfUnsavedSig)
    2: class PdfVmtx(object):
    1:     r"""Wrapper class for struct `pdf_vmtx`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_vmtx`.
               """
>>>>>>         _mupdf.PdfVmtx_swiginit(self, _mupdf.new_PdfVmtx(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfVmtx
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfVmtx_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfVmtx___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfVmtx_m_internal_get, _mupdf.PdfVmtx_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfVmtx_s_num_instances_get, _mupdf.PdfVmtx_s_num_instances_set)
       
       # Register PdfVmtx in _mupdf:
    1: _mupdf.PdfVmtx_swigregister(PdfVmtx)
    2: class PdfWriteOptions(object):
    1:     r"""Wrapper class for struct `pdf_write_options`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def pdf_parse_write_options(self, args):
               r"""We use default copy constructor and operator=.  Class-aware wrapper for `::pdf_parse_write_options()`."""
>>>>>>         return _mupdf.PdfWriteOptions_pdf_parse_write_options(self, args)
       
    1:     def opwd_utf8_set_value(self, text):
               r"""Copies <text> into opwd_utf8[]."""
>>>>>>         return _mupdf.PdfWriteOptions_opwd_utf8_set_value(self, text)
       
    1:     def upwd_utf8_set_value(self, text):
               r"""Copies <text> into upwd_utf8[]."""
>>>>>>         return _mupdf.PdfWriteOptions_upwd_utf8_set_value(self, text)
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, makes copy of pdf_default_write_options.
       
               |
       
               *Overload 2:*
               Copy constructor using raw memcopy().
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_write_options`.
       
               |
       
               *Overload 4:*
               Constructor using raw copy of pre-existing `::pdf_write_options`.
               """
>>>>>>         _mupdf.PdfWriteOptions_swiginit(self, _mupdf.new_PdfWriteOptions(*args))
       
    1:     def internal(self, *args):
               r"""
               *Overload 1:*
               Access as underlying struct.
       
               |
       
               *Overload 2:*
               Access as underlying struct.
               """
>>>>>>         return _mupdf.PdfWriteOptions_internal(self, *args)
    1:     __swig_destroy__ = _mupdf.delete_PdfWriteOptions
    1:     do_incremental = property(_mupdf.PdfWriteOptions_do_incremental_get, _mupdf.PdfWriteOptions_do_incremental_set)
    1:     do_pretty = property(_mupdf.PdfWriteOptions_do_pretty_get, _mupdf.PdfWriteOptions_do_pretty_set)
    1:     do_ascii = property(_mupdf.PdfWriteOptions_do_ascii_get, _mupdf.PdfWriteOptions_do_ascii_set)
    1:     do_compress = property(_mupdf.PdfWriteOptions_do_compress_get, _mupdf.PdfWriteOptions_do_compress_set)
    1:     do_compress_images = property(_mupdf.PdfWriteOptions_do_compress_images_get, _mupdf.PdfWriteOptions_do_compress_images_set)
    1:     do_compress_fonts = property(_mupdf.PdfWriteOptions_do_compress_fonts_get, _mupdf.PdfWriteOptions_do_compress_fonts_set)
    1:     do_decompress = property(_mupdf.PdfWriteOptions_do_decompress_get, _mupdf.PdfWriteOptions_do_decompress_set)
    1:     do_garbage = property(_mupdf.PdfWriteOptions_do_garbage_get, _mupdf.PdfWriteOptions_do_garbage_set)
    1:     do_linear = property(_mupdf.PdfWriteOptions_do_linear_get, _mupdf.PdfWriteOptions_do_linear_set)
    1:     do_clean = property(_mupdf.PdfWriteOptions_do_clean_get, _mupdf.PdfWriteOptions_do_clean_set)
    1:     do_sanitize = property(_mupdf.PdfWriteOptions_do_sanitize_get, _mupdf.PdfWriteOptions_do_sanitize_set)
    1:     do_appearance = property(_mupdf.PdfWriteOptions_do_appearance_get, _mupdf.PdfWriteOptions_do_appearance_set)
    1:     do_encrypt = property(_mupdf.PdfWriteOptions_do_encrypt_get, _mupdf.PdfWriteOptions_do_encrypt_set)
    1:     dont_regenerate_id = property(_mupdf.PdfWriteOptions_dont_regenerate_id_get, _mupdf.PdfWriteOptions_dont_regenerate_id_set)
    1:     permissions = property(_mupdf.PdfWriteOptions_permissions_get, _mupdf.PdfWriteOptions_permissions_set)
    1:     opwd_utf8 = property(_mupdf.PdfWriteOptions_opwd_utf8_get, _mupdf.PdfWriteOptions_opwd_utf8_set)
    1:     upwd_utf8 = property(_mupdf.PdfWriteOptions_upwd_utf8_get, _mupdf.PdfWriteOptions_upwd_utf8_set)
    1:     do_snapshot = property(_mupdf.PdfWriteOptions_do_snapshot_get, _mupdf.PdfWriteOptions_do_snapshot_set)
    1:     do_preserve_metadata = property(_mupdf.PdfWriteOptions_do_preserve_metadata_get, _mupdf.PdfWriteOptions_do_preserve_metadata_set)
    1:     do_use_objstms = property(_mupdf.PdfWriteOptions_do_use_objstms_get, _mupdf.PdfWriteOptions_do_use_objstms_set)
    1:     compression_effort = property(_mupdf.PdfWriteOptions_compression_effort_get, _mupdf.PdfWriteOptions_compression_effort_set)
    1:     do_labels = property(_mupdf.PdfWriteOptions_do_labels_get, _mupdf.PdfWriteOptions_do_labels_set)
    1:     s_num_instances = property(_mupdf.PdfWriteOptions_s_num_instances_get, _mupdf.PdfWriteOptions_s_num_instances_set)
       
    1:     def to_string(self):
               r"""Returns string containing our members, labelled and inside (...), using operator<<."""
>>>>>>         return _mupdf.PdfWriteOptions_to_string(self)
       
    1:     def __eq__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfWriteOptions___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
               r"""Comparison method."""
>>>>>>         return _mupdf.PdfWriteOptions___ne__(self, rhs)
       
       # Register PdfWriteOptions in _mupdf:
    1: _mupdf.PdfWriteOptions_swigregister(PdfWriteOptions)
    2: class PdfXrange(object):
    1:     r"""Wrapper class for struct `pdf_xrange`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_xrange`.
               """
>>>>>>         _mupdf.PdfXrange_swiginit(self, _mupdf.new_PdfXrange(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfXrange
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfXrange_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfXrange___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfXrange_m_internal_get, _mupdf.PdfXrange_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfXrange_s_num_instances_get, _mupdf.PdfXrange_s_num_instances_set)
       
       # Register PdfXrange in _mupdf:
    1: _mupdf.PdfXrange_swigregister(PdfXrange)
    2: class PdfXref(object):
    1:     r"""Wrapper class for struct `pdf_xref`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               == Constructors.  Constructor using `pdf_new_local_xref()`.
       
               |
       
               *Overload 2:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 3:*
               Constructor using raw copy of pre-existing `::pdf_xref`.
               """
>>>>>>         _mupdf.PdfXref_swiginit(self, _mupdf.new_PdfXref(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfXref
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfXref_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfXref___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfXref_m_internal_get, _mupdf.PdfXref_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfXref_s_num_instances_get, _mupdf.PdfXref_s_num_instances_set)
       
       # Register PdfXref in _mupdf:
    1: _mupdf.PdfXref_swigregister(PdfXref)
    2: class PdfXrefEntry(object):
    1:     r"""Wrapper class for struct `pdf_xref_entry`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_xref_entry`.
               """
>>>>>>         _mupdf.PdfXrefEntry_swiginit(self, _mupdf.new_PdfXrefEntry(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfXrefEntry
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfXrefEntry_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfXrefEntry___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfXrefEntry_m_internal_get, _mupdf.PdfXrefEntry_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfXrefEntry_s_num_instances_get, _mupdf.PdfXrefEntry_s_num_instances_set)
       
       # Register PdfXrefEntry in _mupdf:
    1: _mupdf.PdfXrefEntry_swigregister(PdfXrefEntry)
    2: class PdfXrefSubsec(object):
    1:     r"""Wrapper class for struct `pdf_xref_subsec`. Not copyable or assignable."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, *args):
               r"""
               *Overload 1:*
               Default constructor, sets `m_internal` to null.
       
               |
       
               *Overload 2:*
               Constructor using raw copy of pre-existing `::pdf_xref_subsec`.
               """
>>>>>>         _mupdf.PdfXrefSubsec_swiginit(self, _mupdf.new_PdfXrefSubsec(*args))
    1:     __swig_destroy__ = _mupdf.delete_PdfXrefSubsec
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.PdfXrefSubsec_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.PdfXrefSubsec___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.PdfXrefSubsec_m_internal_get, _mupdf.PdfXrefSubsec_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.PdfXrefSubsec_s_num_instances_get, _mupdf.PdfXrefSubsec_s_num_instances_set)
       
       # Register PdfXrefSubsec in _mupdf:
    1: _mupdf.PdfXrefSubsec_swigregister(PdfXrefSubsec)
       
    1: def num_instances():
           r"""Returns map from class name (for example FzDocument) to s_num_instances."""
>>>>>>     return _mupdf.num_instances()
    2: class FzLinkIterator(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, item):
>>>>>>         _mupdf.FzLinkIterator_swiginit(self, _mupdf.new_FzLinkIterator(item))
       
    1:     def __increment__(self):
>>>>>>         return _mupdf.FzLinkIterator___increment__(self)
       
    1:     def __eq__(self, rhs):
>>>>>>         return _mupdf.FzLinkIterator___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
>>>>>>         return _mupdf.FzLinkIterator___ne__(self, rhs)
       
    1:     def __ref__(self):
>>>>>>         return _mupdf.FzLinkIterator___ref__(self)
       
    1:     def __deref__(self):
>>>>>>         return _mupdf.FzLinkIterator___deref__(self)
    1:     __swig_destroy__ = _mupdf.delete_FzLinkIterator
       
    1:     def fz_set_link_rect(self, rect):
               r"""Class-aware wrapper for `::fz_set_link_rect()`."""
>>>>>>         return _mupdf.FzLinkIterator_fz_set_link_rect(self, rect)
       
    1:     def fz_set_link_uri(self, uri):
               r"""Class-aware wrapper for `::fz_set_link_uri()`."""
>>>>>>         return _mupdf.FzLinkIterator_fz_set_link_uri(self, uri)
       
    1:     def begin(self):
               r"""Used for iteration over linked list of FzLink items starting at fz_link::."""
>>>>>>         return _mupdf.FzLinkIterator_begin(self)
       
    1:     def end(self):
               r"""Used for iteration over linked list of FzLink items starting at fz_link::."""
>>>>>>         return _mupdf.FzLinkIterator_end(self)
       
    1:     def refs(self):
>>>>>>         return _mupdf.FzLinkIterator_refs(self)
       
    1:     def next(self):
>>>>>>         return _mupdf.FzLinkIterator_next(self)
       
    1:     def rect(self):
>>>>>>         return _mupdf.FzLinkIterator_rect(self)
       
    1:     def uri(self):
>>>>>>         return _mupdf.FzLinkIterator_uri(self)
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzLinkIterator_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzLinkIterator___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzLinkIterator_m_internal_get, _mupdf.FzLinkIterator_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzLinkIterator_s_num_instances_get, _mupdf.FzLinkIterator_s_num_instances_set)
       
       # Register FzLinkIterator in _mupdf:
    1: _mupdf.FzLinkIterator_swigregister(FzLinkIterator)
    2: class FzStextBlockIterator(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, item):
>>>>>>         _mupdf.FzStextBlockIterator_swiginit(self, _mupdf.new_FzStextBlockIterator(item))
       
    1:     def __increment__(self):
>>>>>>         return _mupdf.FzStextBlockIterator___increment__(self)
       
    1:     def __eq__(self, rhs):
>>>>>>         return _mupdf.FzStextBlockIterator___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
>>>>>>         return _mupdf.FzStextBlockIterator___ne__(self, rhs)
       
    1:     def __ref__(self):
>>>>>>         return _mupdf.FzStextBlockIterator___ref__(self)
       
    1:     def __deref__(self):
>>>>>>         return _mupdf.FzStextBlockIterator___deref__(self)
    1:     __swig_destroy__ = _mupdf.delete_FzStextBlockIterator
       
    1:     def begin(self):
               r"""Used for iteration over linked list of FzStextChar items starting at fz_stext_char::first_char."""
>>>>>>         return _mupdf.FzStextBlockIterator_begin(self)
       
    1:     def end(self):
               r"""Used for iteration over linked list of FzStextChar items starting at fz_stext_char::first_char."""
>>>>>>         return _mupdf.FzStextBlockIterator_end(self)
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStextBlockIterator_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStextBlockIterator___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStextBlockIterator_m_internal_get, _mupdf.FzStextBlockIterator_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStextBlockIterator_s_num_instances_get, _mupdf.FzStextBlockIterator_s_num_instances_set)
       
       # Register FzStextBlockIterator in _mupdf:
    1: _mupdf.FzStextBlockIterator_swigregister(FzStextBlockIterator)
    2: class FzStextLineIterator(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, item):
>>>>>>         _mupdf.FzStextLineIterator_swiginit(self, _mupdf.new_FzStextLineIterator(item))
       
    1:     def __increment__(self):
>>>>>>         return _mupdf.FzStextLineIterator___increment__(self)
       
    1:     def __eq__(self, rhs):
>>>>>>         return _mupdf.FzStextLineIterator___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
>>>>>>         return _mupdf.FzStextLineIterator___ne__(self, rhs)
       
    1:     def __ref__(self):
>>>>>>         return _mupdf.FzStextLineIterator___ref__(self)
       
    1:     def __deref__(self):
>>>>>>         return _mupdf.FzStextLineIterator___deref__(self)
    1:     __swig_destroy__ = _mupdf.delete_FzStextLineIterator
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStextLineIterator_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStextLineIterator___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStextLineIterator_m_internal_get, _mupdf.FzStextLineIterator_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStextLineIterator_s_num_instances_get, _mupdf.FzStextLineIterator_s_num_instances_set)
       
       # Register FzStextLineIterator in _mupdf:
    1: _mupdf.FzStextLineIterator_swigregister(FzStextLineIterator)
    2: class FzStextPageIterator(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, item):
>>>>>>         _mupdf.FzStextPageIterator_swiginit(self, _mupdf.new_FzStextPageIterator(item))
       
    1:     def __increment__(self):
>>>>>>         return _mupdf.FzStextPageIterator___increment__(self)
       
    1:     def __eq__(self, rhs):
>>>>>>         return _mupdf.FzStextPageIterator___eq__(self, rhs)
       
    1:     def __ne__(self, rhs):
>>>>>>         return _mupdf.FzStextPageIterator___ne__(self, rhs)
       
    1:     def __ref__(self):
>>>>>>         return _mupdf.FzStextPageIterator___ref__(self)
       
    1:     def __deref__(self):
>>>>>>         return _mupdf.FzStextPageIterator___deref__(self)
    1:     __swig_destroy__ = _mupdf.delete_FzStextPageIterator
       
    1:     def i_transform(self):
               r"""Returns m_internal.u.i.transform if m_internal->type is FZ_STEXT_BLOCK_IMAGE, else throws."""
>>>>>>         return _mupdf.FzStextPageIterator_i_transform(self)
       
    1:     def i_image(self):
               r"""Returns m_internal.u.i.image if m_internal->type is FZ_STEXT_BLOCK_IMAGE, else throws."""
>>>>>>         return _mupdf.FzStextPageIterator_i_image(self)
       
    1:     def begin(self):
               r"""Used for iteration over linked list of FzStextLine items starting at fz_stext_line::u.t.first_line."""
>>>>>>         return _mupdf.FzStextPageIterator_begin(self)
       
    1:     def end(self):
               r"""Used for iteration over linked list of FzStextLine items starting at fz_stext_line::u.t.first_line."""
>>>>>>         return _mupdf.FzStextPageIterator_end(self)
       
    1:     def m_internal_value(self):
               r"""Return numerical value of .m_internal; helps with Python debugging."""
>>>>>>         return _mupdf.FzStextPageIterator_m_internal_value(self)
       
    1:     def __nonzero__(self):
>>>>>>         return _mupdf.FzStextPageIterator___nonzero__(self)
    1:     __bool__ = __nonzero__
       
       
    1:     m_internal = property(_mupdf.FzStextPageIterator_m_internal_get, _mupdf.FzStextPageIterator_m_internal_set, doc=r"""Pointer to wrapped data.""")
    1:     s_num_instances = property(_mupdf.FzStextPageIterator_s_num_instances_get, _mupdf.FzStextPageIterator_s_num_instances_set)
       
       # Register FzStextPageIterator in _mupdf:
    1: _mupdf.FzStextPageIterator_swigregister(FzStextPageIterator)
       
    1: def fz_aa_level():
           r"""
           Class-aware wrapper for `::fz_aa_level()`.
               Get the number of bits of antialiasing we are
               using (for graphics). Between 0 and 8.
           """
>>>>>>     return _mupdf.fz_aa_level()
       
    1: def fz_abs(f):
           r"""
           Class-aware wrapper for `::fz_abs()`.
               Some standard math functions, done as static inlines for speed.
               People with compilers that do not adequately implement inline
               may like to reimplement these using macros.
           """
>>>>>>     return _mupdf.fz_abs(f)
       
    1: def fz_absi(i):
           r"""Class-aware wrapper for `::fz_absi()`."""
>>>>>>     return _mupdf.fz_absi(i)
       
    1: def fz_add_layout_char(block, x, w, p):
           r"""
           Class-aware wrapper for `::fz_add_layout_char()`.
               Add a new char to the line at the end of the layout block.
           """
>>>>>>     return _mupdf.fz_add_layout_char(block, x, w, p)
       
    1: def fz_add_layout_line(block, x, y, h, p):
           r"""
           Class-aware wrapper for `::fz_add_layout_line()`.
               Add a new line to the end of the layout block.
           """
>>>>>>     return _mupdf.fz_add_layout_line(block, x, y, h, p)
       
    1: def fz_add_separation(sep, name, cs, cs_channel):
           r"""
           Class-aware wrapper for `::fz_add_separation()`.
               Add a separation (null terminated name, colorspace)
           """
>>>>>>     return _mupdf.fz_add_separation(sep, name, cs, cs_channel)
       
    1: def fz_add_separation_equivalents(sep, rgba, cmyk, name):
           r"""
           Class-aware wrapper for `::fz_add_separation_equivalents()`.
               Add a separation with equivalents (null terminated name,
               colorspace)
       
               (old, deprecated)
           """
>>>>>>     return _mupdf.fz_add_separation_equivalents(sep, rgba, cmyk, name)
       
    1: def fz_adjust_rect_for_stroke(rect, stroke, ctm):
           r"""
           Class-aware wrapper for `::fz_adjust_rect_for_stroke()`.
               Given a rectangle (assumed to be the bounding box for a path),
               expand it to allow for the expansion of the bbox that would be
               seen by stroking the path with the given stroke state and
               transform.
           """
>>>>>>     return _mupdf.fz_adjust_rect_for_stroke(rect, stroke, ctm)
       
    1: def fz_advance_glyph(font, glyph, wmode):
           r"""
           Class-aware wrapper for `::fz_advance_glyph()`.
               Return the advance for a given glyph.
       
               font: The font to look for the glyph in.
       
               glyph: The glyph to find the advance for.
       
               wmode: 1 for vertical mode, 0 for horizontal.
       
               Returns the advance for the glyph.
           """
>>>>>>     return _mupdf.fz_advance_glyph(font, glyph, wmode)
       
    1: def fz_aes_crypt_cbc(ctx, mode, length, iv, input, output):
           r"""
           Class-aware wrapper for `::fz_aes_crypt_cbc()`.
               AES block processing. Encrypts or Decrypts (according to mode,
               which must match what was initially set up) length bytes (which
               must be a multiple of 16), using (and modifying) the insertion
               vector iv, reading from input, and writing to output.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_aes_crypt_cbc(ctx, mode, length, iv, input, output)
       
    1: def fz_aes_setkey_dec(ctx, key, keysize):
           r"""
           Class-aware wrapper for `::fz_aes_setkey_dec()`.
               AES decryption initialization. Fills in the supplied context
               and prepares for decryption using the given key.
       
               Returns non-zero for error (key size other than 128/192/256).
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_aes_setkey_dec(ctx, key, keysize)
       
    1: def fz_aes_setkey_enc(ctx, key, keysize):
           r"""
           Class-aware wrapper for `::fz_aes_setkey_enc()`.
               AES encryption initialization. Fills in the supplied context
               and prepares for encryption using the given key.
       
               Returns non-zero for error (key size other than 128/192/256).
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_aes_setkey_enc(ctx, key, keysize)
       
    1: def fz_alpha_from_gray(gray):
           r"""Class-aware wrapper for `::fz_alpha_from_gray()`."""
>>>>>>     return _mupdf.fz_alpha_from_gray(gray)
       
    1: def fz_append_base64(out, data, size, newline):
           r"""
           Class-aware wrapper for `::fz_append_base64()`.
               Write a base64 encoded data block, optionally with periodic newlines.
           """
>>>>>>     return _mupdf.fz_append_base64(out, data, size, newline)
       
    1: def fz_append_base64_buffer(out, data, newline):
           r"""
           Class-aware wrapper for `::fz_append_base64_buffer()`.
               Append a base64 encoded fz_buffer, optionally with periodic newlines.
           """
>>>>>>     return _mupdf.fz_append_base64_buffer(out, data, newline)
       
    1: def fz_append_bits(buf, value, count):
           r"""Class-aware wrapper for `::fz_append_bits()`."""
>>>>>>     return _mupdf.fz_append_bits(buf, value, count)
       
    1: def fz_append_bits_pad(buf):
           r"""Class-aware wrapper for `::fz_append_bits_pad()`."""
>>>>>>     return _mupdf.fz_append_bits_pad(buf)
       
    1: def fz_append_buffer(destination, source):
           r"""
           Class-aware wrapper for `::fz_append_buffer()`.
               Append the contents of the source buffer onto the end of the
               destination buffer, extending automatically as required.
       
               Ownership of buffers does not change.
           """
>>>>>>     return _mupdf.fz_append_buffer(destination, source)
       
    1: def fz_append_byte(buf, c):
           r"""Class-aware wrapper for `::fz_append_byte()`."""
>>>>>>     return _mupdf.fz_append_byte(buf, c)
       
    1: def fz_append_data(buf, data, len):
           r"""
           Class-aware wrapper for `::fz_append_data()`.
               fz_append_*: Append data to a buffer.
       
               The buffer will automatically grow as required.
           """
>>>>>>     return _mupdf.fz_append_data(buf, data, len)
       
    1: def fz_append_image_as_data_uri(out, image):
           r"""Class-aware wrapper for `::fz_append_image_as_data_uri()`."""
>>>>>>     return _mupdf.fz_append_image_as_data_uri(out, image)
       
    1: def fz_append_int16_be(buf, x):
           r"""Class-aware wrapper for `::fz_append_int16_be()`."""
>>>>>>     return _mupdf.fz_append_int16_be(buf, x)
       
    1: def fz_append_int16_le(buf, x):
           r"""Class-aware wrapper for `::fz_append_int16_le()`."""
>>>>>>     return _mupdf.fz_append_int16_le(buf, x)
       
    1: def fz_append_int32_be(buf, x):
           r"""Class-aware wrapper for `::fz_append_int32_be()`."""
>>>>>>     return _mupdf.fz_append_int32_be(buf, x)
       
    1: def fz_append_int32_le(buf, x):
           r"""Class-aware wrapper for `::fz_append_int32_le()`."""
>>>>>>     return _mupdf.fz_append_int32_le(buf, x)
       
    1: def fz_append_json(buf, value):
           r"""Class-aware wrapper for `::fz_append_json()`."""
>>>>>>     return _mupdf.fz_append_json(buf, value)
       
    1: def fz_append_pdf_string(buffer, text):
           r"""
           Class-aware wrapper for `::fz_append_pdf_string()`.
               fz_append_pdf_string: Append a string with PDF syntax quotes and
               escapes.
       
               The buffer will automatically grow as required.
           """
>>>>>>     return _mupdf.fz_append_pdf_string(buffer, text)
       
    1: def fz_append_pixmap_as_data_uri(out, pixmap):
           r"""Class-aware wrapper for `::fz_append_pixmap_as_data_uri()`."""
>>>>>>     return _mupdf.fz_append_pixmap_as_data_uri(out, pixmap)
       
    1: def fz_append_rune(buf, c):
           r"""Class-aware wrapper for `::fz_append_rune()`."""
>>>>>>     return _mupdf.fz_append_rune(buf, c)
       
    1: def fz_append_string(buf, data):
           r"""Class-aware wrapper for `::fz_append_string()`."""
>>>>>>     return _mupdf.fz_append_string(buf, data)
       
    1: def fz_arc4_encrypt(state, dest, src, len):
           r"""
           Class-aware wrapper for `::fz_arc4_encrypt()`.
               RC4 block encrypt operation; encrypt src into dst (both of
               length len) updating the RC4 state as we go.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_arc4_encrypt(state, dest, src, len)
       
    1: def fz_arc4_final(state):
           r"""
           Class-aware wrapper for `::fz_arc4_final()`.
               RC4 finalization. Zero the context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_arc4_final(state)
       
    1: def fz_arc4_init(state, key, len):
           r"""
           Class-aware wrapper for `::fz_arc4_init()`.
               RC4 initialization. Begins an RC4 operation, writing a new
               context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_arc4_init(state, key, len)
       
    1: def fz_archive_format(arch):
           r"""
           Class-aware wrapper for `::fz_archive_format()`.
               Return a pointer to a string describing the format of the
               archive.
       
               The lifetime of the string is unspecified (in current
               implementations the string will persist until the archive
               is closed, but this is not guaranteed).
           """
>>>>>>     return _mupdf.fz_archive_format(arch)
       
    1: def fz_atof(s):
           r"""
           Class-aware wrapper for `::fz_atof()`.
               Range checking atof
           """
>>>>>>     return _mupdf.fz_atof(s)
       
    1: def fz_atoi(s):
           r"""
           Class-aware wrapper for `::fz_atoi()`.
               atoi that copes with NULL
           """
>>>>>>     return _mupdf.fz_atoi(s)
       
    1: def fz_atoi64(s):
           r"""
           Class-aware wrapper for `::fz_atoi64()`.
               64bit atoi that copes with NULL
           """
>>>>>>     return _mupdf.fz_atoi64(s)
       
    1: def fz_atoz(s):
           r"""
           Class-aware wrapper for `::fz_atoz()`.
               size_t atoi that copes with NULL.
       
               NOTE: limited to 63bits. Negative numbers
               are returned as 0.
           """
>>>>>>     return _mupdf.fz_atoz(s)
       
    1: def fz_authenticate_password(doc, password):
           r"""
           Class-aware wrapper for `::fz_authenticate_password()`.
               Test if the given password can decrypt the document.
       
               password: The password string to be checked. Some document
               specifications do not specify any particular text encoding, so
               neither do we.
       
               Returns 0 for failure to authenticate, non-zero for success.
       
               For PDF documents, further information can be given by examining
               the bits in the return code.
       
                       Bit 0 => No password required
                       Bit 1 => User password authenticated
                       Bit 2 => Owner password authenticated
           """
>>>>>>     return _mupdf.fz_authenticate_password(doc, password)
       
    1: def fz_autowarp_pixmap(src, points):
           r"""Class-aware wrapper for `::fz_autowarp_pixmap()`."""
>>>>>>     return _mupdf.fz_autowarp_pixmap(src, points)
       
    1: def fz_available(stm, max):
           r"""
           Class-aware wrapper for `::fz_available()`.
               Ask how many bytes are available immediately from
               a given stream.
       
               stm: The stream to read from.
       
               max: A hint for the underlying stream; the maximum number of
               bytes that we are sure we will want to read. If you do not know
               this number, give 1.
       
               Returns the number of bytes immediately available between the
               read and write pointers. This number is guaranteed only to be 0
               if we have hit EOF. The number of bytes returned here need have
               no relation to max (could be larger, could be smaller).
           """
>>>>>>     return _mupdf.fz_available(stm, max)
       
    1: def fz_barcode_type_from_string(str):
           r"""
           Class-aware wrapper for `::fz_barcode_type_from_string()`.
               Helper function to search the above list (case insensitively)
               for an exact match. Returns FZ_BARCODE_NONE if no match found.
           """
>>>>>>     return _mupdf.fz_barcode_type_from_string(str)
       
    1: def fz_base_colorspace(cs):
           r"""
           Class-aware wrapper for `::fz_base_colorspace()`.
               Get the 'base' colorspace for a colorspace.
       
               For indexed colorspaces, this is the colorspace the index
               decodes into. For all other colorspaces, it is the colorspace
               itself.
       
               The returned colorspace is 'borrowed' (i.e. no additional
               references are taken or dropped).
           """
>>>>>>     return _mupdf.fz_base_colorspace(cs)
       
    1: def fz_basename(path):
           r"""
           Class-aware wrapper for `::fz_basename()`.
               Find the filename component in a path.
           """
>>>>>>     return _mupdf.fz_basename(path)
       
    1: def fz_begin_group(dev, area, cs, isolated, knockout, blendmode, alpha):
           r"""Class-aware wrapper for `::fz_begin_group()`."""
>>>>>>     return _mupdf.fz_begin_group(dev, area, cs, isolated, knockout, blendmode, alpha)
       
    1: def fz_begin_layer(dev, layer_name):
           r"""Class-aware wrapper for `::fz_begin_layer()`."""
>>>>>>     return _mupdf.fz_begin_layer(dev, layer_name)
       
    1: def fz_begin_mask(dev, area, luminosity, colorspace, bc, color_params):
           r"""Class-aware wrapper for `::fz_begin_mask()`."""
>>>>>>     return _mupdf.fz_begin_mask(dev, area, luminosity, colorspace, bc, color_params)
       
    1: def fz_begin_metatext(dev, meta, text):
           r"""Class-aware wrapper for `::fz_begin_metatext()`."""
>>>>>>     return _mupdf.fz_begin_metatext(dev, meta, text)
       
    1: def fz_begin_page(wri, mediabox):
           r"""
           Class-aware wrapper for `::fz_begin_page()`.
               Called to start the process of writing a page to
               a document.
       
               mediabox: page size rectangle in points.
       
               Returns a borrowed fz_device to write page contents to. This
               should be kept if required, and only dropped if it was kept.
           """
>>>>>>     return _mupdf.fz_begin_page(wri, mediabox)
       
    1: def fz_begin_structure(dev, standard, raw, idx):
           r"""Class-aware wrapper for `::fz_begin_structure()`."""
>>>>>>     return _mupdf.fz_begin_structure(dev, standard, raw, idx)
       
    1: def fz_begin_tile(dev, area, view, xstep, ystep, ctm):
           r"""Class-aware wrapper for `::fz_begin_tile()`."""
>>>>>>     return _mupdf.fz_begin_tile(dev, area, view, xstep, ystep, ctm)
       
    1: def fz_begin_tile_id(dev, area, view, xstep, ystep, ctm, id):
           r"""Class-aware wrapper for `::fz_begin_tile_id()`."""
>>>>>>     return _mupdf.fz_begin_tile_id(dev, area, view, xstep, ystep, ctm, id)
       
    1: def fz_begin_tile_tid(dev, area, view, xstep, ystep, ctm, id, doc_id):
           r"""Class-aware wrapper for `::fz_begin_tile_tid()`."""
>>>>>>     return _mupdf.fz_begin_tile_tid(dev, area, view, xstep, ystep, ctm, id, doc_id)
       
    1: def fz_bidi_fragment_text(text, textlen, baseDir, callback, arg, flags):
           r"""
            Class-aware wrapper for `::fz_bidi_fragment_text()`.
       
               This function has out-params. Python/C# wrappers look like:
                       `fz_bidi_fragment_text(const uint32_t *text, size_t textlen, ::fz_bidi_fragment_fn *callback, void *arg, int flags)` => ::fz_bidi_direction baseDir
       
                       Partitions the given Unicode sequence into one or more
                       unidirectional fragments and invokes the given callback
                       function for each fragment.
       
                       For example, if directionality of text is:
                                       0123456789
                                       rrlllrrrrr,
                       we'll invoke callback with:
                                       &text[0], length == 2
                                       &text[2], length == 3
                                       &text[5], length == 5
       
                       :type text: int, in
           :param text:        start of Unicode sequence
                               :type textlen: int, in
           :param textlen:   number of Unicodes to analyse
                               :type baseDir: int, in
           :param baseDir:   direction of paragraph (specify FZ_BIDI_NEUTRAL to force auto-detection)
                               :type callback: ::fz_bidi_fragment_fn, in
           :param callback:  function to be called for each fragment
                               :type arg: void, in
           :param arg: data to be passed to the callback function
                               :type flags: int, in
           :param flags:     flags to control operation (see fz_bidi_flags above)
           """
>>>>>>     return _mupdf.fz_bidi_fragment_text(text, textlen, baseDir, callback, arg, flags)
       
    1: def fz_bitmap_details(bitmap, w, h, n, stride):
           r"""
           Class-aware wrapper for `::fz_bitmap_details()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_bitmap_details(::fz_bitmap *bitmap)` => `(int w, int h, int n, int stride)`
       
               Retrieve details of a given bitmap.
       
               bitmap: The bitmap to query.
       
               w: Pointer to storage to retrieve width (or NULL).
       
               h: Pointer to storage to retrieve height (or NULL).
       
               n: Pointer to storage to retrieve number of color components (or
               NULL).
       
               stride: Pointer to storage to retrieve bitmap stride (or NULL).
           """
>>>>>>     return _mupdf.fz_bitmap_details(bitmap, w, h, n, stride)
       
    1: def fz_blendmode_name(blendmode):
           r"""
           Class-aware wrapper for `::fz_blendmode_name()`.
               Map from enumeration to blend mode string.
       
               The string is static, with arbitrary lifespan.
           """
>>>>>>     return _mupdf.fz_blendmode_name(blendmode)
       
    1: def fz_bound_display_list(list):
           r"""
           Class-aware wrapper for `::fz_bound_display_list()`.
               Return the bounding box of the page recorded in a display list.
           """
>>>>>>     return _mupdf.fz_bound_display_list(list)
       
    1: def fz_bound_glyph(font, gid, trm):
           r"""
           Class-aware wrapper for `::fz_bound_glyph()`.
               Return a bbox for a given glyph in a font.
       
               font: The font to look for the glyph in.
       
               gid: The glyph to bound.
       
               trm: The matrix to apply to the glyph before bounding.
       
               Returns rectangle by value containing the bounds of the given
               glyph.
           """
>>>>>>     return _mupdf.fz_bound_glyph(font, gid, trm)
       
    1: def fz_bound_page(page):
           r"""
           Class-aware wrapper for `::fz_bound_page()`.
               Determine the size of a page at 72 dpi.
           """
>>>>>>     return _mupdf.fz_bound_page(page)
       
    1: def fz_bound_page_box(page, box):
           r"""Class-aware wrapper for `::fz_bound_page_box()`."""
>>>>>>     return _mupdf.fz_bound_page_box(page, box)
       
    1: def fz_bound_path(path, stroke, ctm):
           r"""
           Class-aware wrapper for `::fz_bound_path()`.
               Return a bounding rectangle for a path.
       
               path: The path to bound.
       
               stroke: If NULL, the bounding rectangle given is for
               the filled path. If non-NULL the bounding rectangle
               given is for the path stroked with the given attributes.
       
               ctm: The matrix to apply to the path during stroking.
       
               r: Pointer to a fz_rect which will be used to hold
               the result.
       
               Returns r, updated to contain the bounding rectangle.
           """
>>>>>>     return _mupdf.fz_bound_path(path, stroke, ctm)
       
    1: def fz_bound_shade(shade, ctm):
           r"""
           Class-aware wrapper for `::fz_bound_shade()`.
               Bound a given shading.
       
               shade: The shade to bound.
       
               ctm: The transform to apply to the shade before bounding.
       
               r: Pointer to storage to put the bounds in.
       
               Returns r, updated to contain the bounds for the shading.
           """
>>>>>>     return _mupdf.fz_bound_shade(shade, ctm)
       
    1: def fz_bound_text(text, stroke, ctm):
           r"""
           Class-aware wrapper for `::fz_bound_text()`.
               Find the bounds of a given text object.
       
               text: The text object to find the bounds of.
       
               stroke: Pointer to the stroke attributes (for stroked
               text), or NULL (for filled text).
       
               ctm: The matrix in use.
       
               r: pointer to storage for the bounds.
       
               Returns a pointer to r, which is updated to contain the
               bounding box for the text object.
           """
>>>>>>     return _mupdf.fz_bound_text(text, stroke, ctm)
       
    1: def fz_box_type_from_string(name):
           r"""Class-aware wrapper for `::fz_box_type_from_string()`."""
>>>>>>     return _mupdf.fz_box_type_from_string(name)
       
    1: def fz_brotli_bound(size):
           r"""
           Class-aware wrapper for `::fz_brotli_bound()`.
               Returns the upper bound on the
               size of brotli compressed data of length size.
           """
>>>>>>     return _mupdf.fz_brotli_bound(size)
       
    1: def fz_buffer_extract(buf, data):
           r"""
           Class-aware wrapper for `::fz_buffer_extract()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_buffer_extract(::fz_buffer *buf)` => `(size_t, unsigned char *data)`
       
               Take ownership of buffer contents.
       
               Performs the same task as fz_buffer_storage, but ownership of
               the data buffer returns with this call. The buffer is left
               empty.
       
               Note: Bad things may happen if this is called on a buffer with
               multiple references that is being used from multiple threads.
       
               data: Pointer to place to retrieve data pointer.
       
               Returns length of stream.
           """
>>>>>>     return _mupdf.fz_buffer_extract(buf, data)
       
    1: def fz_buffer_storage(buf, datap):
           r"""
           Class-aware wrapper for `::fz_buffer_storage()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_buffer_storage(::fz_buffer *buf)` => `(size_t, unsigned char *datap)`
       
               Retrieve internal memory of buffer.
       
               datap: Output parameter that will be pointed to the data.
       
               Returns the current size of the data in bytes.
           """
>>>>>>     return _mupdf.fz_buffer_storage(buf, datap)
       
    1: def fz_calculate_font_ascender_descender(font):
           r"""
           Class-aware wrapper for `::fz_calculate_font_ascender_descender()`.
               Ensure that a font has its ascender/descender values calculated
               from the actual bbox of the glyphs.
       
               Note, that we combine the declared values from the font (or the
               default values if those are not present) with the actual bbox to
               get the final result. So this can only cause ascender/descender
               to move further apart!
           """
>>>>>>     return _mupdf.fz_calculate_font_ascender_descender(font)
       
    1: def fz_calloc(count, size):
           r"""
           Class-aware wrapper for `::fz_calloc()`.
               Allocate array of memory of count entries of size bytes.
               Clears the memory to zero.
       
               Throws exception in the event of failure to allocate.
           """
>>>>>>     return _mupdf.fz_calloc(count, size)
       
    1: def fz_calloc_no_throw(count, size):
           r"""
           Class-aware wrapper for `::fz_calloc_no_throw()`.
               fz_calloc equivalent that returns NULL rather than throwing
               exceptions.
           """
>>>>>>     return _mupdf.fz_calloc_no_throw(count, size)
       
    1: def fz_caught():
           r"""
           Class-aware wrapper for `::fz_caught()`.
               Within an fz_catch() block, retrieve the error code for
               the current exception.
       
               This assumes no intervening use of fz_try/fz_catch.
           """
>>>>>>     return _mupdf.fz_caught()
       
    1: def fz_caught_errno():
           r"""Class-aware wrapper for `::fz_caught_errno()`."""
>>>>>>     return _mupdf.fz_caught_errno()
       
    1: def fz_caught_message():
           r"""
           Class-aware wrapper for `::fz_caught_message()`.
               Within an fz_catch() block, retrieve the formatted message
               string for the current exception.
       
               This assumes no intervening use of fz_try/fz_catch.
           """
>>>>>>     return _mupdf.fz_caught_message()
       
    1: def fz_chartorune(rune, str):
           r"""
           Class-aware wrapper for `::fz_chartorune()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_chartorune(const char *str)` => `(int, int rune)`
       
               UTF8 decode a single rune from a sequence of chars.
       
               rune: Pointer to an int to assign the decoded 'rune' to.
               (0xFFFD on error).
       
               str: Pointer to a UTF8 encoded string.
       
               Returns the number of bytes consumed.
           """
>>>>>>     return _mupdf.fz_chartorune(rune, str)
       
    1: def fz_chartorunen(rune, str, n):
           r"""
           Class-aware wrapper for `::fz_chartorunen()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_chartorunen(const char *str, size_t n)` => `(int, int rune)`
       
               UTF8 decode a single rune from a sequence of chars
               of given length.
       
               rune: Pointer to an int to assign the decoded 'rune' to.
               (0xFFFD on error).
       
               str: Pointer to a UTF8 encoded string.
       
               n: The number of bytes available at str.
       
               Returns the number of bytes consumed.
           """
>>>>>>     return _mupdf.fz_chartorunen(rune, str, n)
       
    1: def fz_clamp(x, min, max):
           r"""Class-aware wrapper for `::fz_clamp()`."""
>>>>>>     return _mupdf.fz_clamp(x, min, max)
       
    1: def fz_clamp64(x, min, max):
           r"""Class-aware wrapper for `::fz_clamp64()`."""
>>>>>>     return _mupdf.fz_clamp64(x, min, max)
       
    1: def fz_clamp_color(cs, _in, out):
           r"""
           Class-aware wrapper for `::fz_clamp_color()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_clamp_color(::fz_colorspace *cs, const float *in)` => float out
       
               Clamp the samples in a color to the correct ranges for a
               given colorspace.
           """
>>>>>>     return _mupdf.fz_clamp_color(cs, _in, out)
       
    1: def fz_clamp_location(doc, loc):
           r"""
           Class-aware wrapper for `::fz_clamp_location()`.
               Clamps a location into valid chapter/page range. (First clamps
               the chapter into range, then the page into range).
           """
>>>>>>     return _mupdf.fz_clamp_location(doc, loc)
       
    1: def fz_clampd(x, min, max):
           r"""Class-aware wrapper for `::fz_clampd()`."""
>>>>>>     return _mupdf.fz_clampd(x, min, max)
       
    1: def fz_clampi(x, min, max):
           r"""Class-aware wrapper for `::fz_clampi()`."""
>>>>>>     return _mupdf.fz_clampi(x, min, max)
       
    1: def fz_clampp(x, min, max):
           r"""Class-aware wrapper for `::fz_clampp()`."""
>>>>>>     return _mupdf.fz_clampp(x, min, max)
       
    1: def fz_classify_stext_rect(page, classification, rect):
           r"""Class-aware wrapper for `::fz_classify_stext_rect()`."""
>>>>>>     return _mupdf.fz_classify_stext_rect(page, classification, rect)
       
    1: def fz_cleanname(name):
           r"""
           Class-aware wrapper for `::fz_cleanname()`.
               rewrite path to the shortest string that names the same path.
       
               Eliminates multiple and trailing slashes, interprets "." and
               "..". Overwrites the string in place.
           """
>>>>>>     return _mupdf.fz_cleanname(name)
       
    1: def fz_cleanname_strdup(name):
           r"""
           Class-aware wrapper for `::fz_cleanname_strdup()`.
               rewrite path to the shortest string that names the same path.
       
               Eliminates multiple and trailing slashes, interprets "." and
               "..". Allocates a new string that the caller must free.
           """
>>>>>>     return _mupdf.fz_cleanname_strdup(name)
       
    1: def fz_clear_bitmap(bit):
           r"""
           Class-aware wrapper for `::fz_clear_bitmap()`.
               Set the entire bitmap to 0.
       
               Never throws exceptions.
           """
>>>>>>     return _mupdf.fz_clear_bitmap(bit)
       
    1: def fz_clear_buffer(buf):
           r"""
           Class-aware wrapper for `::fz_clear_buffer()`.
               Empties the buffer. Storage is not freed, but is held ready
               to be reused as the buffer is refilled.
       
               Never throws exceptions.
           """
>>>>>>     return _mupdf.fz_clear_buffer(buf)
       
    1: def fz_clear_pixmap(pix):
           r"""
           Class-aware wrapper for `::fz_clear_pixmap()`.
               Sets all components (including alpha) of
               all pixels in a pixmap to 0.
       
               pix: The pixmap to clear.
           """
>>>>>>     return _mupdf.fz_clear_pixmap(pix)
       
    1: def fz_clear_pixmap_rect_with_value(pix, value, r):
           r"""
           Class-aware wrapper for `::fz_clear_pixmap_rect_with_value()`.
               Clears a subrect of a pixmap with the given value.
       
               pix: The pixmap to clear.
       
               value: Values in the range 0 to 255 are valid. Each component
               sample for each pixel in the pixmap will be set to this value,
               while alpha will always be set to 255 (non-transparent).
       
               r: the rectangle.
           """
>>>>>>     return _mupdf.fz_clear_pixmap_rect_with_value(pix, value, r)
       
    1: def fz_clear_pixmap_with_value(pix, value):
           r"""
           Class-aware wrapper for `::fz_clear_pixmap_with_value()`.
               Clears a pixmap with the given value.
       
               pix: The pixmap to clear.
       
               value: Values in the range 0 to 255 are valid. Each component
               sample for each pixel in the pixmap will be set to this value,
               while alpha will always be set to 255 (non-transparent).
       
               This function is horrible, and should be removed from the
               API and replaced with a less magic one.
           """
>>>>>>     return _mupdf.fz_clear_pixmap_with_value(pix, value)
       
    1: def fz_clip_image_mask(dev, image, ctm, scissor):
           r"""Class-aware wrapper for `::fz_clip_image_mask()`."""
>>>>>>     return _mupdf.fz_clip_image_mask(dev, image, ctm, scissor)
       
    1: def fz_clip_path(dev, path, even_odd, ctm, scissor):
           r"""Class-aware wrapper for `::fz_clip_path()`."""
>>>>>>     return _mupdf.fz_clip_path(dev, path, even_odd, ctm, scissor)
       
    1: def fz_clip_stroke_path(dev, path, stroke, ctm, scissor):
           r"""Class-aware wrapper for `::fz_clip_stroke_path()`."""
>>>>>>     return _mupdf.fz_clip_stroke_path(dev, path, stroke, ctm, scissor)
       
    1: def fz_clip_stroke_text(dev, text, stroke, ctm, scissor):
           r"""Class-aware wrapper for `::fz_clip_stroke_text()`."""
>>>>>>     return _mupdf.fz_clip_stroke_text(dev, text, stroke, ctm, scissor)
       
    1: def fz_clip_text(dev, text, ctm, scissor):
           r"""Class-aware wrapper for `::fz_clip_text()`."""
>>>>>>     return _mupdf.fz_clip_text(dev, text, ctm, scissor)
       
    1: def fz_clone_buffer(buf):
           r"""
           Class-aware wrapper for `::fz_clone_buffer()`.
               Make a new buffer, containing a copy of the data used in
               the original.
           """
>>>>>>     return _mupdf.fz_clone_buffer(buf)
       
    1: def fz_clone_default_colorspaces(base):
           r"""
           Class-aware wrapper for `::fz_clone_default_colorspaces()`.
               Returns a reference to a newly cloned default colorspaces
               structure.
       
               The new clone may safely be altered without fear of race
               conditions as the caller is the only reference holder.
           """
>>>>>>     return _mupdf.fz_clone_default_colorspaces(base)
       
    1: def fz_clone_path(path):
           r"""
           Class-aware wrapper for `::fz_clone_path()`.
               Clone the data for a path.
       
               This is used in preference to fz_keep_path when a whole
               new copy of a path is required, rather than just a shared
               pointer. This probably indicates that the path is about to
               be modified.
       
               path: path to clone.
       
               Throws exceptions on failure to allocate.
           """
>>>>>>     return _mupdf.fz_clone_path(path)
       
    1: def fz_clone_pixmap(old):
           r"""
           Class-aware wrapper for `::fz_clone_pixmap()`.
               Clone a pixmap, copying the pixels and associated data to new
               storage.
       
               The reference count of 'old' is unchanged.
           """
>>>>>>     return _mupdf.fz_clone_pixmap(old)
       
    1: def fz_clone_pixmap_area_with_different_seps(src, bbox, dcs, seps, color_params, default_cs):
           r"""Class-aware wrapper for `::fz_clone_pixmap_area_with_different_seps()`."""
>>>>>>     return _mupdf.fz_clone_pixmap_area_with_different_seps(src, bbox, dcs, seps, color_params, default_cs)
       
    1: def fz_clone_separations_for_overprint(seps):
           r"""
           Class-aware wrapper for `::fz_clone_separations_for_overprint()`.
               Return a separations object with all the spots in the input
               separations object that are set to composite, reset to be
               enabled. If there ARE no spots in the object, this returns
               NULL. If the object already has all its spots enabled, then
               just returns another handle on the same object.
           """
>>>>>>     return _mupdf.fz_clone_separations_for_overprint(seps)
       
    1: def fz_clone_stroke_state(stroke):
           r"""
           Class-aware wrapper for `::fz_clone_stroke_state()`.
               Create an identical stroke_state structure and return a
               reference to it.
       
               stroke: The stroke state reference to clone.
       
               Exceptions may be thrown in the event of a failure to
               allocate.
           """
>>>>>>     return _mupdf.fz_clone_stroke_state(stroke)
       
    1: def fz_close_band_writer(writer):
           r"""
           Class-aware wrapper for `::fz_close_band_writer()`.
               Finishes up the output and closes the band writer. After this
               call no more headers or bands may be written.
           """
>>>>>>     return _mupdf.fz_close_band_writer(writer)
       
    1: def fz_close_device(dev):
           r"""
           Class-aware wrapper for `::fz_close_device()`.
               Signal the end of input, and flush any buffered output.
               This is NOT called implicitly on fz_drop_device. This
               may throw exceptions.
           """
>>>>>>     return _mupdf.fz_close_device(dev)
       
    1: def fz_close_document_writer(wri):
           r"""
           Class-aware wrapper for `::fz_close_document_writer()`.
               Called to end the process of writing
               pages to a document.
       
               This writes any file level trailers required. After this
               completes successfully the file is up to date and complete.
           """
>>>>>>     return _mupdf.fz_close_document_writer(wri)
       
    1: def fz_close_output(arg_0):
           r"""
           Class-aware wrapper for `::fz_close_output()`.
               Flush pending output and close an output stream.
           """
>>>>>>     return _mupdf.fz_close_output(arg_0)
       
    1: def fz_close_zip_writer(zip):
           r"""
           Class-aware wrapper for `::fz_close_zip_writer()`.
               Close the zip file for writing.
       
               This flushes any pending data to the file. This can throw
               exceptions.
           """
>>>>>>     return _mupdf.fz_close_zip_writer(zip)
       
    1: def fz_closepath(path):
           r"""
           Class-aware wrapper for `::fz_closepath()`.
               Close the current subpath.
       
               path: The path to modify.
       
               Throws exceptions on failure to allocate, attempting to modify
               a packed path, and illegal path closes (i.e. closing a non open
               path).
           """
>>>>>>     return _mupdf.fz_closepath(path)
       
    1: def fz_colorspace_colorant(cs, n):
           r"""
           Class-aware wrapper for `::fz_colorspace_colorant()`.
               Retrieve a the name for a colorant.
       
               Returns a pointer with the same lifespan as the colorspace.
           """
>>>>>>     return _mupdf.fz_colorspace_colorant(cs, n)
       
    1: def fz_colorspace_device_n_has_cmyk(cs):
           r"""
           Class-aware wrapper for `::fz_colorspace_device_n_has_cmyk()`.
               True if DeviceN color space has cyan magenta yellow or black as
               one of its colorants.
           """
>>>>>>     return _mupdf.fz_colorspace_device_n_has_cmyk(cs)
       
    1: def fz_colorspace_device_n_has_only_cmyk(cs):
           r"""
           Class-aware wrapper for `::fz_colorspace_device_n_has_only_cmyk()`.
               True if DeviceN color space has only colorants from the CMYK set.
           """
>>>>>>     return _mupdf.fz_colorspace_device_n_has_only_cmyk(cs)
       
    1: def fz_colorspace_digest(cs, digest):
           r"""
           Class-aware wrapper for `::fz_colorspace_digest()`.
               Get checksum of underlying ICC profile.
           """
>>>>>>     return _mupdf.fz_colorspace_digest(cs, digest)
       
    1: def fz_colorspace_is_cmyk(cs):
           r"""Class-aware wrapper for `::fz_colorspace_is_cmyk()`."""
>>>>>>     return _mupdf.fz_colorspace_is_cmyk(cs)
       
    1: def fz_colorspace_is_device(cs):
           r"""Class-aware wrapper for `::fz_colorspace_is_device()`."""
>>>>>>     return _mupdf.fz_colorspace_is_device(cs)
       
    1: def fz_colorspace_is_device_cmyk(cs):
           r"""Class-aware wrapper for `::fz_colorspace_is_device_cmyk()`."""
>>>>>>     return _mupdf.fz_colorspace_is_device_cmyk(cs)
       
    1: def fz_colorspace_is_device_gray(cs):
           r"""Class-aware wrapper for `::fz_colorspace_is_device_gray()`."""
>>>>>>     return _mupdf.fz_colorspace_is_device_gray(cs)
       
    1: def fz_colorspace_is_device_n(cs):
           r"""Class-aware wrapper for `::fz_colorspace_is_device_n()`."""
>>>>>>     return _mupdf.fz_colorspace_is_device_n(cs)
       
    1: def fz_colorspace_is_gray(cs):
           r"""
           Class-aware wrapper for `::fz_colorspace_is_gray()`.
               Tests for particular types of colorspaces
           """
>>>>>>     return _mupdf.fz_colorspace_is_gray(cs)
       
    1: def fz_colorspace_is_icc(cs):
           r"""Class-aware wrapper for `::fz_colorspace_is_icc()`."""
>>>>>>     return _mupdf.fz_colorspace_is_icc(cs)
       
    1: def fz_colorspace_is_indexed(cs):
           r"""Class-aware wrapper for `::fz_colorspace_is_indexed()`."""
>>>>>>     return _mupdf.fz_colorspace_is_indexed(cs)
       
    1: def fz_colorspace_is_lab(cs):
           r"""Class-aware wrapper for `::fz_colorspace_is_lab()`."""
>>>>>>     return _mupdf.fz_colorspace_is_lab(cs)
       
    1: def fz_colorspace_is_lab_icc(cs):
           r"""Class-aware wrapper for `::fz_colorspace_is_lab_icc()`."""
>>>>>>     return _mupdf.fz_colorspace_is_lab_icc(cs)
       
    1: def fz_colorspace_is_rgb(cs):
           r"""Class-aware wrapper for `::fz_colorspace_is_rgb()`."""
>>>>>>     return _mupdf.fz_colorspace_is_rgb(cs)
       
    1: def fz_colorspace_is_subtractive(cs):
           r"""
           Class-aware wrapper for `::fz_colorspace_is_subtractive()`.
               True for CMYK, Separation and DeviceN colorspaces.
           """
>>>>>>     return _mupdf.fz_colorspace_is_subtractive(cs)
       
    1: def fz_colorspace_n(cs):
           r"""
           Class-aware wrapper for `::fz_colorspace_n()`.
               Query the number of colorants in a colorspace.
           """
>>>>>>     return _mupdf.fz_colorspace_n(cs)
       
    1: def fz_colorspace_name(cs):
           r"""
           Class-aware wrapper for `::fz_colorspace_name()`.
               Query the name of a colorspace.
       
               The returned string has the same lifespan as the colorspace
               does. Caller should not free it.
           """
>>>>>>     return _mupdf.fz_colorspace_name(cs)
       
    1: def fz_colorspace_name_colorant(cs, n, name):
           r"""
           Class-aware wrapper for `::fz_colorspace_name_colorant()`.
               Assign a name for a given colorant in a colorspace.
       
               Used while initially setting up a colorspace. The string is
               copied into local storage, so need not be retained by the
               caller.
           """
>>>>>>     return _mupdf.fz_colorspace_name_colorant(cs, n, name)
       
    1: def fz_colorspace_type(cs):
           r"""
           Class-aware wrapper for `::fz_colorspace_type()`.
               Query the type of colorspace.
           """
>>>>>>     return _mupdf.fz_colorspace_type(cs)
       
    1: def fz_compare_separations(sep1, sep2):
           r"""
           Class-aware wrapper for `::fz_compare_separations()`.
               Compare 2 separations structures (or NULLs).
       
               Return 0 if identical, non-zero if not identical.
           """
>>>>>>     return _mupdf.fz_compare_separations(sep1, sep2)
       
    1: def fz_compress_brotli(dest, compressed_length, source, source_length, level):
           r"""
            Class-aware wrapper for `::fz_compress_brotli()`.
       
               This function has out-params. Python/C# wrappers look like:
                       `fz_compress_brotli(unsigned char *dest, const unsigned char *source, size_t source_length, ::fz_brotli_level level)` => size_t compressed_length
       
                       Compress source_length bytes of data starting
                       at source, into a buffer of length *destLen, starting at dest.
           compressed_length will be updated on exit to contain the size
                       actually used.
           """
>>>>>>     return _mupdf.fz_compress_brotli(dest, compressed_length, source, source_length, level)
       
    1: def fz_compress_ccitt_fax_g3(data, columns, rows, stride):
           r"""
           Class-aware wrapper for `::fz_compress_ccitt_fax_g3()`.
               Compress bitmap data as CCITT Group 3 1D fax image.
               Creates a stream assuming the default PDF parameters,
               except the number of columns.
           """
>>>>>>     return _mupdf.fz_compress_ccitt_fax_g3(data, columns, rows, stride)
       
    1: def fz_compress_ccitt_fax_g4(data, columns, rows, stride):
           r"""
           Class-aware wrapper for `::fz_compress_ccitt_fax_g4()`.
               Compress bitmap data as CCITT Group 4 2D fax image.
               Creates a stream assuming the default PDF parameters, except
               K=-1 and the number of columns.
           """
>>>>>>     return _mupdf.fz_compress_ccitt_fax_g4(data, columns, rows, stride)
       
    1: def fz_compressed_buffer_size(buffer):
           r"""
           Class-aware wrapper for `::fz_compressed_buffer_size()`.
               Return the storage size used for a buffer and its data.
               Used in implementing store handling.
       
               Never throws exceptions.
           """
>>>>>>     return _mupdf.fz_compressed_buffer_size(buffer)
       
    1: def fz_compressed_image_buffer(image):
           r"""
           Class-aware wrapper for `::fz_compressed_image_buffer()`.
               Retrieve the underlying compressed data for an image.
       
               Returns a pointer to the underlying data buffer for an image,
               or NULL if this image is not based upon a compressed data
               buffer.
       
               This is not a reference counted structure, so no reference is
               returned. Lifespan is limited to that of the image itself.
           """
>>>>>>     return _mupdf.fz_compressed_image_buffer(image)
       
    1: def fz_compressed_image_type(image):
           r"""
           Class-aware wrapper for `::fz_compressed_image_type()`.
               Return the type of a compressed image.
       
               Any non-compressed image will have the type returned as UNKNOWN.
           """
>>>>>>     return _mupdf.fz_compressed_image_type(image)
       
    1: def fz_concat(left, right):
           r"""
           Class-aware wrapper for `::fz_concat()`.
               Multiply two matrices.
       
               The order of the two matrices are important since matrix
               multiplication is not commutative.
       
               Returns result.
           """
>>>>>>     return _mupdf.fz_concat(left, right)
       
    1: def fz_contains_rect(a, b):
           r"""
           Class-aware wrapper for `::fz_contains_rect()`.
               Test rectangle inclusion.
       
               Return true if a entirely contains b.
           """
>>>>>>     return _mupdf.fz_contains_rect(a, b)
       
    1: def fz_convert_color(ss, sv, ds, dv, _is, params):
           r"""
           Class-aware wrapper for `::fz_convert_color()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_convert_color(::fz_colorspace *ss, const float *sv, ::fz_colorspace *ds, ::fz_colorspace *is, ::fz_color_params params)` => float dv
       
               Convert color values sv from colorspace ss into colorvalues dv
               for colorspace ds, via an optional intervening space is,
               respecting the given color_params.
           """
>>>>>>     return _mupdf.fz_convert_color(ss, sv, ds, dv, _is, params)
       
    1: def fz_convert_error(code):
           r"""
           Class-aware wrapper for `::fz_convert_error()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_convert_error()` => `(const char *, int code)`
           """
>>>>>>     return _mupdf.fz_convert_error(code)
       
    1: def fz_convert_indexed_pixmap_to_base(src):
           r"""
           Class-aware wrapper for `::fz_convert_indexed_pixmap_to_base()`.
               Convert pixmap from indexed to base colorspace.
       
               This creates a new bitmap containing the converted pixmap data.
           """
>>>>>>     return _mupdf.fz_convert_indexed_pixmap_to_base(src)
       
    1: def fz_convert_pixmap(pix, cs_des, prf, default_cs, color_params, keep_alpha):
           r"""
           Class-aware wrapper for `::fz_convert_pixmap()`.
               Convert an existing pixmap to a desired
               colorspace. Other properties of the pixmap, such as resolution
               and position are copied to the converted pixmap.
       
               pix: The pixmap to convert.
       
               default_cs: If NULL pix->colorspace is used. It is possible that
               the data may need to be interpreted as one of the color spaces
               in default_cs.
       
               cs_des: Desired colorspace, may be NULL to denote alpha-only.
       
               prf: Proofing color space through which we need to convert.
       
               color_params: Parameters that may be used in conversion (e.g.
               ri).
       
               keep_alpha: If 0 any alpha component is removed, otherwise
               alpha is kept if present in the pixmap.
           """
>>>>>>     return _mupdf.fz_convert_pixmap(pix, cs_des, prf, default_cs, color_params, keep_alpha)
       
    1: def fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, dst_color, color_params):
           r"""
           Class-aware wrapper for `::fz_convert_separation_colors()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_convert_separation_colors(::fz_colorspace *src_cs, const float *src_color, ::fz_separations *dst_seps, ::fz_colorspace *dst_cs, ::fz_color_params color_params)` => float dst_color
       
               Convert a color given in terms of one colorspace,
               to a color in terms of another colorspace/separations.
           """
>>>>>>     return _mupdf.fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, dst_color, color_params)
       
    1: def fz_convert_separation_pixmap_to_base(src):
           r"""
           Class-aware wrapper for `::fz_convert_separation_pixmap_to_base()`.
               Convert pixmap from DeviceN/Separation to base colorspace.
       
               This creates a new bitmap containing the converted pixmap data.
           """
>>>>>>     return _mupdf.fz_convert_separation_pixmap_to_base(src)
       
    1: def fz_copy_option(val, dest, maxlen):
           r"""
           Class-aware wrapper for `::fz_copy_option()`.
               Copy an option (val) into a destination buffer (dest), of maxlen
               bytes.
       
               Returns the number of bytes (including terminator) that did not
               fit. If val is maxlen or greater bytes in size, it will be left
               unterminated.
           """
>>>>>>     return _mupdf.fz_copy_option(val, dest, maxlen)
       
    1: def fz_copy_pixmap_rect(dest, src, r, default_cs):
           r"""Class-aware wrapper for `::fz_copy_pixmap_rect()`."""
>>>>>>     return _mupdf.fz_copy_pixmap_rect(dest, src, r, default_cs)
       
    1: def fz_copy_rectangle(page, area, crlf):
           r"""
           Class-aware wrapper for `::fz_copy_rectangle()`.
               Return a newly allocated UTF-8 string with the text for a given
               selection rectangle.
       
               crlf: If true, write "\r\n" style line endings (otherwise "\n"
               only).
           """
>>>>>>     return _mupdf.fz_copy_rectangle(page, area, crlf)
       
    1: def fz_copy_selection(page, a, b, crlf):
           r"""
           Class-aware wrapper for `::fz_copy_selection()`.
               Return a newly allocated UTF-8 string with the text for a given
               selection.
       
               crlf: If true, write "\r\n" style line endings (otherwise "\n"
               only).
           """
>>>>>>     return _mupdf.fz_copy_selection(page, a, b, crlf)
       
    1: def fz_count_active_separations(seps):
           r"""
           Class-aware wrapper for `::fz_count_active_separations()`.
               Return the number of active separations.
           """
>>>>>>     return _mupdf.fz_count_active_separations(seps)
       
    1: def fz_count_archive_entries(arch):
           r"""
           Class-aware wrapper for `::fz_count_archive_entries()`.
               Number of entries in archive.
       
               Will always return a value >= 0.
       
               May throw an exception if this type of archive cannot count the
               entries (such as a directory).
           """
>>>>>>     return _mupdf.fz_count_archive_entries(arch)
       
    1: def fz_count_chapter_pages(doc, chapter):
           r"""
           Class-aware wrapper for `::fz_count_chapter_pages()`.
               Return the number of pages in a chapter.
               May return 0.
           """
>>>>>>     return _mupdf.fz_count_chapter_pages(doc, chapter)
       
    1: def fz_count_chapters(doc):
           r"""
           Class-aware wrapper for `::fz_count_chapters()`.
               Return the number of chapters in the document.
               At least 1.
           """
>>>>>>     return _mupdf.fz_count_chapters(doc)
       
    1: def fz_count_pages(doc):
           r"""
           Class-aware wrapper for `::fz_count_pages()`.
               Return the number of pages in document
       
               May return 0 for documents with no pages.
           """
>>>>>>     return _mupdf.fz_count_pages(doc)
       
    1: def fz_count_separations(sep):
           r"""Class-aware wrapper for `::fz_count_separations()`."""
>>>>>>     return _mupdf.fz_count_separations(sep)
       
    1: def fz_create_link(page, bbox, uri):
           r"""
           Class-aware wrapper for `::fz_create_link()`.
               Create a new link on a page.
           """
>>>>>>     return _mupdf.fz_create_link(page, bbox, uri)
       
    1: def fz_currentpoint(path):
           r"""
           Class-aware wrapper for `::fz_currentpoint()`.
               Return the current point that a path has
               reached or (0,0) if empty.
       
               path: path to return the current point of.
           """
>>>>>>     return _mupdf.fz_currentpoint(path)
       
    1: def fz_curveto(path, x0, y0, x1, y1, x2, y2):
           r"""
           Class-aware wrapper for `::fz_curveto()`.
               Append a 'curveto' command to an open path. (For a
               cubic bezier).
       
               path: The path to modify.
       
               x0, y0: The coordinates of the first control point for the
               curve.
       
               x1, y1: The coordinates of the second control point for the
               curve.
       
               x2, y2: The end coordinates for the curve.
       
               Throws exceptions on failure to allocate, or attempting to
               modify a packed path.
           """
>>>>>>     return _mupdf.fz_curveto(path, x0, y0, x1, y1, x2, y2)
       
    1: def fz_curvetov(path, x1, y1, x2, y2):
           r"""
           Class-aware wrapper for `::fz_curvetov()`.
               Append a 'curvetov' command to an open path. (For a
               cubic bezier with the first control coordinate equal to
               the start point).
       
               path: The path to modify.
       
               x1, y1: The coordinates of the second control point for the
               curve.
       
               x2, y2: The end coordinates for the curve.
       
               Throws exceptions on failure to allocate, or attempting to
               modify a packed path.
           """
>>>>>>     return _mupdf.fz_curvetov(path, x1, y1, x2, y2)
       
    1: def fz_curvetoy(path, x0, y0, x2, y2):
           r"""
           Class-aware wrapper for `::fz_curvetoy()`.
               Append a 'curvetoy' command to an open path. (For a
               cubic bezier with the second control coordinate equal to
               the end point).
       
               path: The path to modify.
       
               x0, y0: The coordinates of the first control point for the
               curve.
       
               x2, y2: The end coordinates for the curve (and the second
               control coordinate).
       
               Throws exceptions on failure to allocate, or attempting to
               modify a packed path.
           """
>>>>>>     return _mupdf.fz_curvetoy(path, x0, y0, x2, y2)
       
    1: def fz_debug_store(out):
           r"""
           Class-aware wrapper for `::fz_debug_store()`.
               Output debugging information for the current state of the store
               to the given output channel.
           """
>>>>>>     return _mupdf.fz_debug_store(out)
       
    1: def fz_debug_xml(item, level):
           r"""
           Class-aware wrapper for `::fz_debug_xml()`.
               Pretty-print an XML tree to stdout. (Deprecated, use
               fz_output_xml in preference).
           """
>>>>>>     return _mupdf.fz_debug_xml(item, level)
       
    1: def fz_decode_barcode_from_display_list(type, list, subarea, rotate):
           r"""
           Class-aware wrapper for `::fz_decode_barcode_from_display_list()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_decode_barcode_from_display_list(::fz_display_list *list, ::fz_rect subarea, int rotate)` => `(char *, ::fz_barcode_type type)`
       
               Decode a barcode from a display list.
       
               type: NULL, or a pointer to recieve the barcode type decoded.
               list: The display list to render to get the barcode.
               subarea: subarea of the page to decode.
               rotate: 0, 90, 180, or 270.
       
               returns the decoded value.
           """
>>>>>>     return _mupdf.fz_decode_barcode_from_display_list(type, list, subarea, rotate)
       
    1: def fz_decode_barcode_from_display_list2(type, list, subarea, rotate):
           r"""
           Class-aware wrapper for `::fz_decode_barcode_from_display_list2()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_decode_barcode_from_display_list2(::fz_display_list *list, ::fz_rect subarea, int rotate)` => `(std::string, ::fz_barcode_type type)`
             SWIG-friendly wrapper for fz_decode_barcode_from_display_list(),
           avoiding leak of the returned string.
           """
>>>>>>     return _mupdf.fz_decode_barcode_from_display_list2(type, list, subarea, rotate)
       
    1: def fz_decode_barcode_from_page(type, page, subarea, rotate):
           r"""
           Class-aware wrapper for `::fz_decode_barcode_from_page()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_decode_barcode_from_page(::fz_page *page, ::fz_rect subarea, int rotate)` => `(char *, ::fz_barcode_type type)`
       
               Decode a barcode from a page.
       
               type: NULL, or a pointer to recieve the barcode type decoded.
               page: The page to decode.
               subarea: subarea of the page to decode.
               rotate: 0, 90, 180, or 270.
       
               returns the decoded value.
           """
>>>>>>     return _mupdf.fz_decode_barcode_from_page(type, page, subarea, rotate)
       
    1: def fz_decode_barcode_from_page2(type, page, subarea, rotate):
           r"""
           Class-aware wrapper for `::fz_decode_barcode_from_page2()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_decode_barcode_from_page2(::fz_page *page, ::fz_rect subarea, int rotate)` => `(std::string, ::fz_barcode_type type)`
             SWIG-friendly wrapper for fz_decode_barcode_from_page(), avoiding
           leak of the returned string.
           """
>>>>>>     return _mupdf.fz_decode_barcode_from_page2(type, page, subarea, rotate)
       
    1: def fz_decode_barcode_from_pixmap(type, pix, rotate):
           r"""
           Class-aware wrapper for `::fz_decode_barcode_from_pixmap()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_decode_barcode_from_pixmap(::fz_pixmap *pix, int rotate)` => `(char *, ::fz_barcode_type type)`
       
               Decode a barcode from a pixmap.
       
               type: NULL, or a pointer to recieve the barcode type decoded.
               pix: The pixmap to decode.
               rotate: 0, 90, 180, or 270.
       
               returns the decoded value as an fz_malloced block. Should
               be fz_free'd by the caller.
           """
>>>>>>     return _mupdf.fz_decode_barcode_from_pixmap(type, pix, rotate)
       
    1: def fz_decode_barcode_from_pixmap2(type, pix, rotate):
           r"""
           Class-aware wrapper for `::fz_decode_barcode_from_pixmap2()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_decode_barcode_from_pixmap2(::fz_pixmap *pix, int rotate)` => `(std::string, ::fz_barcode_type type)`
             SWIG-friendly wrapper for fz_decode_barcode_from_pixmap(), avoiding
           leak of the returned string.
           """
>>>>>>     return _mupdf.fz_decode_barcode_from_pixmap2(type, pix, rotate)
       
    1: def fz_decode_tile(pix, decode):
           r"""Class-aware wrapper for `::fz_decode_tile()`."""
>>>>>>     return _mupdf.fz_decode_tile(pix, decode)
       
    1: def fz_decode_uri(s):
           r"""
            Class-aware wrapper for `::fz_decode_uri()`.
           Return a new string representing the unencoded version of the given URI.
           This decodes all escape sequences except those that would result in a reserved
           character that are part of the URI syntax (; / ? : @ & = + $ , #).
           """
>>>>>>     return _mupdf.fz_decode_uri(s)
       
    1: def fz_decode_uri_component(s):
           r"""
            Class-aware wrapper for `::fz_decode_uri_component()`.
           Return a new string representing the unencoded version of the given URI component.
           This decodes all escape sequences!
           """
>>>>>>     return _mupdf.fz_decode_uri_component(s)
       
    1: def fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor, l2extra):
           r"""
           Class-aware wrapper for `::fz_decomp_image_from_stream()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_decomp_image_from_stream(::fz_stream *stm, ::fz_compressed_image *image, ::fz_irect *subarea, int indexed, int l2factor)` => `(fz_pixmap *, int l2extra)`
       
               Decode a subarea of a compressed image. l2factor is the amount
               of subsampling inbuilt to the stream (i.e. performed by the
               decoder). If non NULL, l2extra is the extra amount of
               subsampling that should be performed by this routine. This will
               be updated on exit to the amount of subsampling that is still
               required to be done.
       
               Returns a kept reference.
           """
>>>>>>     return _mupdf.fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor, l2extra)
       
    1: def fz_decouple_type3_font(font, t3doc):
           r"""Class-aware wrapper for `::fz_decouple_type3_font()`."""
>>>>>>     return _mupdf.fz_decouple_type3_font(font, t3doc)
       
    1: def fz_default_cmyk(default_cs):
           r"""Class-aware wrapper for `::fz_default_cmyk()`."""
>>>>>>     return _mupdf.fz_default_cmyk(default_cs)
       
    1: def fz_default_error_callback(user, message):
           r"""
           Class-aware wrapper for `::fz_default_error_callback()`.
               FIXME: Better not to expose fz_default_error_callback, and
               fz_default_warning callback and to allow 'NULL' to be used
               int fz_set_xxxx_callback to mean "defaults".
       
               FIXME: Do we need/want functions like
               fz_error_callback(ctx, message) to allow callers to inject
               stuff into the error/warning streams?
       
               The default error callback. Declared publicly just so that the
               error callback can be set back to this after it has been
               overridden.
           """
>>>>>>     return _mupdf.fz_default_error_callback(user, message)
       
    1: def fz_default_gray(default_cs):
           r"""
           Class-aware wrapper for `::fz_default_gray()`.
               Retrieve default colorspaces (typically page local).
       
               If default_cs is non NULL, the default is retrieved from there,
               otherwise the global default is retrieved.
       
               These return borrowed references that should not be dropped,
               unless they are kept first.
           """
>>>>>>     return _mupdf.fz_default_gray(default_cs)
       
    1: def fz_default_halftone(num_comps):
           r"""
           Class-aware wrapper for `::fz_default_halftone()`.
               Create a 'default' halftone structure
               for the given number of components.
       
               num_comps: The number of components to use.
       
               Returns a simple default halftone. The default halftone uses
               the same halftone tile for each plane, which may not be ideal
               for all purposes.
           """
>>>>>>     return _mupdf.fz_default_halftone(num_comps)
       
    1: def fz_default_output_intent(default_cs):
           r"""Class-aware wrapper for `::fz_default_output_intent()`."""
>>>>>>     return _mupdf.fz_default_output_intent(default_cs)
       
    1: def fz_default_rgb(default_cs):
           r"""Class-aware wrapper for `::fz_default_rgb()`."""
>>>>>>     return _mupdf.fz_default_rgb(default_cs)
       
    1: def fz_default_warning_callback(user, message):
           r"""
           Class-aware wrapper for `::fz_default_warning_callback()`.
               The default warning callback. Declared publicly just so that
               the warning callback can be set back to this after it has been
               overridden.
           """
>>>>>>     return _mupdf.fz_default_warning_callback(user, message)
       
    1: def fz_defer_reap_end():
           r"""
           Class-aware wrapper for `::fz_defer_reap_end()`.
               Decrement the defer reap count.
       
               If the defer reap count returns to 0, and the store
               has reapable objects in, a reap pass will begin.
       
               Call this at the end of a process during which you
               potentially might drop many reapable objects.
       
               It is vital that every fz_defer_reap_start is matched
               by a fz_defer_reap_end call.
           """
>>>>>>     return _mupdf.fz_defer_reap_end()
       
    1: def fz_defer_reap_start():
           r"""
           Class-aware wrapper for `::fz_defer_reap_start()`.
               Increment the defer reap count.
       
               No reap operations will take place (except for those
               triggered by an immediate failed malloc) until the
               defer reap count returns to 0.
       
               Call this at the start of a process during which you
               potentially might drop many reapable objects.
       
               It is vital that every fz_defer_reap_start is matched
               by a fz_defer_reap_end call.
           """
>>>>>>     return _mupdf.fz_defer_reap_start()
       
    1: def fz_deflate(dest, compressed_length, source, source_length, level):
           r"""
           Class-aware wrapper for `::fz_deflate()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_deflate(unsigned char *dest, const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => size_t compressed_length
       
               Compress source_length bytes of data starting
               at source, into a buffer of length *compressed_length, starting at
               dest. *compressed_length will be updated on exit to contain the size
               actually used.
           """
>>>>>>     return _mupdf.fz_deflate(dest, compressed_length, source, source_length, level)
       
    1: def fz_deflate_bound(size):
           r"""
           Class-aware wrapper for `::fz_deflate_bound()`.
               Returns the upper bound on the
               size of flated data of length size.
           """
>>>>>>     return _mupdf.fz_deflate_bound(size)
       
    1: def fz_delete_link(page, link):
           r"""
           Class-aware wrapper for `::fz_delete_link()`.
               Delete an existing link on a page.
           """
>>>>>>     return _mupdf.fz_delete_link(page, link)
       
    1: def fz_deskew_pixmap(src, degrees, border):
           r"""Class-aware wrapper for `::fz_deskew_pixmap()`."""
>>>>>>     return _mupdf.fz_deskew_pixmap(src, degrees, border)
       
    1: def fz_detach_xml(node):
           r"""
           Class-aware wrapper for `::fz_detach_xml()`.
               Detach a node from the tree, unlinking it from its parent,
               and setting the document root to the node.
           """
>>>>>>     return _mupdf.fz_detach_xml(node)
       
    1: def fz_detect_document(points, src):
           r"""Class-aware wrapper for `::fz_detect_document()`."""
>>>>>>     return _mupdf.fz_detect_document(points, src)
       
    1: def fz_detect_skew(pixmap):
           r"""Class-aware wrapper for `::fz_detect_skew()`."""
>>>>>>     return _mupdf.fz_detect_skew(pixmap)
       
    1: def fz_device_bgr():
           r"""Class-aware wrapper for `::fz_device_bgr()`."""
>>>>>>     return _mupdf.fz_device_bgr()
       
    1: def fz_device_cmyk():
           r"""Class-aware wrapper for `::fz_device_cmyk()`."""
>>>>>>     return _mupdf.fz_device_cmyk()
       
    1: def fz_device_current_scissor(dev):
           r"""
           Class-aware wrapper for `::fz_device_current_scissor()`.
               Find current scissor region as tracked by the device.
           """
>>>>>>     return _mupdf.fz_device_current_scissor(dev)
       
    1: def fz_device_gray():
           r"""
           Class-aware wrapper for `::fz_device_gray()`.
               Retrieve global default colorspaces.
       
               These return borrowed references that should not be dropped,
               unless they are kept first.
           """
>>>>>>     return _mupdf.fz_device_gray()
       
    1: def fz_device_lab():
           r"""Class-aware wrapper for `::fz_device_lab()`."""
>>>>>>     return _mupdf.fz_device_lab()
       
    1: def fz_device_rgb():
           r"""Class-aware wrapper for `::fz_device_rgb()`."""
>>>>>>     return _mupdf.fz_device_rgb()
       
    1: def fz_dirname(dir, path, dirsize):
           r"""
           Class-aware wrapper for `::fz_dirname()`.
               extract the directory component from a path.
           """
>>>>>>     return _mupdf.fz_dirname(dir, path, dirsize)
       
    1: def fz_disable_device_hints(dev, hints):
           r"""
           Class-aware wrapper for `::fz_disable_device_hints()`.
               Disable (clear) hint bits within the hint bitfield for a device.
           """
>>>>>>     return _mupdf.fz_disable_device_hints(dev, hints)
       
    1: def fz_disable_icc():
           r"""
           Class-aware wrapper for `::fz_disable_icc()`.
               Disable icc profile based operation.
           """
>>>>>>     return _mupdf.fz_disable_icc()
       
    1: def fz_display_list_is_empty(list):
           r"""
           Class-aware wrapper for `::fz_display_list_is_empty()`.
               Check for a display list being empty
       
               list: The list to check.
       
               Returns true if empty, false otherwise.
           """
>>>>>>     return _mupdf.fz_display_list_is_empty(list)
       
    1: def fz_div255(c, a):
           r"""
           Class-aware wrapper for `::fz_div255()`.
               Undo alpha premultiplication.
           """
>>>>>>     return _mupdf.fz_div255(c, a)
       
    1: def fz_do_always():
           r"""Class-aware wrapper for `::fz_do_always()`."""
>>>>>>     return _mupdf.fz_do_always()
       
    1: def fz_do_catch():
           r"""Class-aware wrapper for `::fz_do_catch()`."""
>>>>>>     return _mupdf.fz_do_catch()
       
    1: def fz_do_try():
           r"""Class-aware wrapper for `::fz_do_try()`."""
>>>>>>     return _mupdf.fz_do_try()
       
    1: def fz_document_handler_open(handler, stream, accel, dir, recognize_state):
           r"""
           Class-aware wrapper for `::fz_document_handler_open()`.   Helper for calling `fz_document_handler::open` function pointer via
           Swig from Python/C#.
           """
>>>>>>     return _mupdf.fz_document_handler_open(handler, stream, accel, dir, recognize_state)
       
    1: def fz_document_handler_recognize(handler, magic):
           r"""
           Class-aware wrapper for `::fz_document_handler_recognize()`.   Helper for calling a `fz_document_handler::recognize` function
           pointer via Swig from Python/C#.
           """
>>>>>>     return _mupdf.fz_document_handler_recognize(handler, magic)
       
    1: def fz_document_output_intent(doc):
           r"""
           Class-aware wrapper for `::fz_document_output_intent()`.
               Find the output intent colorspace if the document has defined
               one.
       
               Returns a borrowed reference that should not be dropped, unless
               it is kept first.
           """
>>>>>>     return _mupdf.fz_document_output_intent(doc)
       
    1: def fz_document_supports_accelerator(doc):
           r"""
           Class-aware wrapper for `::fz_document_supports_accelerator()`.
               Query if the document supports the saving of accelerator data.
           """
>>>>>>     return _mupdf.fz_document_supports_accelerator(doc)
       
    1: def fz_dom_add_attribute(elt, att, value):
           r"""
           Class-aware wrapper for `::fz_dom_add_attribute()`.
               Add an attribute to an element.
       
               Ownership of att and value remain with the caller.
           """
>>>>>>     return _mupdf.fz_dom_add_attribute(elt, att, value)
       
    1: def fz_dom_append_child(parent, child):
           r"""
           Class-aware wrapper for `::fz_dom_append_child()`.
               Insert an element as the last child of a parent, unlinking the
               child from its current position if required.
           """
>>>>>>     return _mupdf.fz_dom_append_child(parent, child)
       
    1: def fz_dom_attribute(elt, att):
           r"""
           Class-aware wrapper for `::fz_dom_attribute()`.
               Retrieve the value of a given attribute from a given element.
       
               Returns a borrowed pointer to the value or NULL if not found.
           """
>>>>>>     return _mupdf.fz_dom_attribute(elt, att)
       
    1: def fz_dom_body(dom):
           r"""
           Class-aware wrapper for `::fz_dom_body()`.
               Return a borrowed reference for the 'body' element of
               the given DOM.
           """
>>>>>>     return _mupdf.fz_dom_body(dom)
       
    1: def fz_dom_clone(elt):
           r"""
           Class-aware wrapper for `::fz_dom_clone()`.
               Clone an element (and its children).
       
               A borrowed reference to the clone is returned. The clone is not
               yet linked into the DOM.
           """
>>>>>>     return _mupdf.fz_dom_clone(elt)
       
    1: def fz_dom_create_element(dom, tag):
           r"""
           Class-aware wrapper for `::fz_dom_create_element()`.
               Create an element of a given tag type for the given DOM.
       
               The element is not linked into the DOM yet.
           """
>>>>>>     return _mupdf.fz_dom_create_element(dom, tag)
       
    1: def fz_dom_create_text_node(dom, text):
           r"""
           Class-aware wrapper for `::fz_dom_create_text_node()`.
               Create a text node for the given DOM.
       
               The element is not linked into the DOM yet.
           """
>>>>>>     return _mupdf.fz_dom_create_text_node(dom, text)
       
    1: def fz_dom_document_element(dom):
           r"""
           Class-aware wrapper for `::fz_dom_document_element()`.
               Return a borrowed reference for the document (the top
               level element) of the DOM.
           """
>>>>>>     return _mupdf.fz_dom_document_element(dom)
       
    1: def fz_dom_find(elt, tag, att, match):
           r"""
           Class-aware wrapper for `::fz_dom_find()`.
               Find the first element matching the requirements in a depth first traversal from elt.
       
               The tagname must match tag, unless tag is NULL, when all tag names are considered to match.
       
               If att is NULL, then all tags match.
               Otherwise:
                       If match is NULL, then only nodes that have an att attribute match.
                       If match is non-NULL, then only nodes that have an att attribute that matches match match.
       
               Returns NULL (if no match found), or a borrowed reference to the first matching element.
           """
>>>>>>     return _mupdf.fz_dom_find(elt, tag, att, match)
       
    1: def fz_dom_find_next(elt, tag, att, match):
           r"""
           Class-aware wrapper for `::fz_dom_find_next()`.
               Find the next element matching the requirements.
           """
>>>>>>     return _mupdf.fz_dom_find_next(elt, tag, att, match)
       
    1: def fz_dom_first_child(elt):
           r"""
           Class-aware wrapper for `::fz_dom_first_child()`.
               Return a borrowed reference to the first child of a node,
               or NULL if there isn't one.
           """
>>>>>>     return _mupdf.fz_dom_first_child(elt)
       
    1: def fz_dom_get_attribute(elt, i, att):
           r"""
           Class-aware wrapper for `::fz_dom_get_attribute()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_dom_get_attribute(::fz_xml *elt, int i)` => `(const char *, const char *att)`
       
               Enumerate through the attributes of an element.
       
               Call with i=0,1,2,3... to enumerate attributes.
       
               On return *att and the return value will be NULL if there are not
               that many attributes to read. Otherwise, *att will be filled in
               with a borrowed pointer to the attribute name, and the return
               value will be a borrowed pointer to the value.
           """
>>>>>>     return _mupdf.fz_dom_get_attribute(elt, i, att)
       
    1: def fz_dom_insert_after(node, new_elt):
           r"""
           Class-aware wrapper for `::fz_dom_insert_after()`.
               Insert an element (new_elt), after another element (node),
               unlinking the new_elt from its current position if required.
           """
>>>>>>     return _mupdf.fz_dom_insert_after(node, new_elt)
       
    1: def fz_dom_insert_before(node, new_elt):
           r"""
           Class-aware wrapper for `::fz_dom_insert_before()`.
               Insert an element (new_elt), before another element (node),
               unlinking the new_elt from its current position if required.
           """
>>>>>>     return _mupdf.fz_dom_insert_before(node, new_elt)
       
    1: def fz_dom_next(elt):
           r"""
           Class-aware wrapper for `::fz_dom_next()`.
               Return a borrowed reference to the next sibling of a node,
               or NULL if there isn't one.
           """
>>>>>>     return _mupdf.fz_dom_next(elt)
       
    1: def fz_dom_parent(elt):
           r"""
           Class-aware wrapper for `::fz_dom_parent()`.
               Return a borrowed reference to the parent of a node,
               or NULL if there isn't one.
           """
>>>>>>     return _mupdf.fz_dom_parent(elt)
       
    1: def fz_dom_previous(elt):
           r"""
           Class-aware wrapper for `::fz_dom_previous()`.
               Return a borrowed reference to the previous sibling of a node,
               or NULL if there isn't one.
           """
>>>>>>     return _mupdf.fz_dom_previous(elt)
       
    1: def fz_dom_remove(elt):
           r"""
           Class-aware wrapper for `::fz_dom_remove()`.
               Remove an element from the DOM. The element can be added back elsewhere
               if required.
       
               No reference counting changes for the element.
           """
>>>>>>     return _mupdf.fz_dom_remove(elt)
       
    1: def fz_dom_remove_attribute(elt, att):
           r"""
           Class-aware wrapper for `::fz_dom_remove_attribute()`.
               Remove an attribute from an element.
           """
>>>>>>     return _mupdf.fz_dom_remove_attribute(elt, att)
       
    1: def fz_draw_story(story, dev, ctm):
           r"""Class-aware wrapper for `::fz_draw_story()`."""
>>>>>>     return _mupdf.fz_draw_story(story, dev, ctm)
       
    1: def fz_dump_glyph_cache_stats(out):
           r"""
           Class-aware wrapper for `::fz_dump_glyph_cache_stats()`.
               Dump debug statistics for the glyph cache.
           """
>>>>>>     return _mupdf.fz_dump_glyph_cache_stats(out)
       
    1: def fz_duplicate_glyph_names_from_unicode(unicode):
           r"""Class-aware wrapper for `::fz_duplicate_glyph_names_from_unicode()`."""
>>>>>>     return _mupdf.fz_duplicate_glyph_names_from_unicode(unicode)
       
    1: def fz_empty_store():
           r"""
           Class-aware wrapper for `::fz_empty_store()`.
               Evict every item from the store.
           """
>>>>>>     return _mupdf.fz_empty_store()
       
    1: def fz_enable_device_hints(dev, hints):
           r"""
           Class-aware wrapper for `::fz_enable_device_hints()`.
               Enable (set) hint bits within the hint bitfield for a device.
           """
>>>>>>     return _mupdf.fz_enable_device_hints(dev, hints)
       
    1: def fz_enable_icc():
           r"""
           Class-aware wrapper for `::fz_enable_icc()`.
               Enable icc profile based operation.
           """
>>>>>>     return _mupdf.fz_enable_icc()
       
    1: def fz_encode_character(font, unicode):
           r"""
           Class-aware wrapper for `::fz_encode_character()`.
               Find the glyph id for a given unicode
               character within a font.
       
               font: The font to look for the unicode character in.
       
               unicode: The unicode character to encode.
       
               Returns the glyph id for the given unicode value, or 0 if
               unknown.
           """
>>>>>>     return _mupdf.fz_encode_character(font, unicode)
       
    1: def fz_encode_character_by_glyph_name(font, glyphname):
           r"""
           Class-aware wrapper for `::fz_encode_character_by_glyph_name()`.
               Encode character.
       
               Either by direct lookup of glyphname within a font, or, failing
               that, by mapping glyphname to unicode and thence to the glyph
               index within the given font.
       
               Returns zero for type3 fonts.
           """
>>>>>>     return _mupdf.fz_encode_character_by_glyph_name(font, glyphname)
       
    1: def fz_encode_character_sc(font, unicode):
           r"""
           Class-aware wrapper for `::fz_encode_character_sc()`.
               Encode character, preferring small-caps variant if available.
       
               font: The font to look for the unicode character in.
       
               unicode: The unicode character to encode.
       
               Returns the glyph id for the given unicode value, or 0 if
               unknown.
           """
>>>>>>     return _mupdf.fz_encode_character_sc(font, unicode)
       
    1: def fz_encode_character_with_fallback(font, unicode, script, language, out_font):
           r"""
           Class-aware wrapper for `::fz_encode_character_with_fallback()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_encode_character_with_fallback(::fz_font *font, int unicode, int script, int language, ::fz_font **out_font)` => `(int)`
       
               Find the glyph id for
               a given unicode character within a font, falling back to
               an alternative if not found.
       
               font: The font to look for the unicode character in.
       
               unicode: The unicode character to encode.
       
               script: The script in use.
       
               language: The language in use.
       
               out_font: The font handle in which the given glyph represents
               the requested unicode character. The caller does not own the
               reference it is passed, so should call fz_keep_font if it is
               not simply to be used immediately.
       
               Returns the glyph id for the given unicode value in the supplied
               font (and sets *out_font to font) if it is present. Otherwise
               an alternative fallback font (based on script/language) is
               searched for. If the glyph is found therein, *out_font is set
               to this reference, and the glyph reference is returned. If it
               cannot be found anywhere, the function returns 0.
           """
>>>>>>     return _mupdf.fz_encode_character_with_fallback(font, unicode, script, language, out_font)
       
    1: def fz_encode_uri(s):
           r"""
            Class-aware wrapper for `::fz_encode_uri()`.
           Return a new string representing the provided string encoded as a URI.
           """
>>>>>>     return _mupdf.fz_encode_uri(s)
       
    1: def fz_encode_uri_component(s):
           r"""
            Class-aware wrapper for `::fz_encode_uri_component()`.
           Return a new string representing the provided string encoded as an URI component.
           This also encodes the special reserved characters (; / ? : @ & = + $ , #).
           """
>>>>>>     return _mupdf.fz_encode_uri_component(s)
       
    1: def fz_encode_uri_pathname(s):
           r"""
            Class-aware wrapper for `::fz_encode_uri_pathname()`.
           Return a new string representing the provided string encoded as an URI path name.
           This also encodes the special reserved characters except /.
           """
>>>>>>     return _mupdf.fz_encode_uri_pathname(s)
       
    1: def fz_end_group(dev):
           r"""Class-aware wrapper for `::fz_end_group()`."""
>>>>>>     return _mupdf.fz_end_group(dev)
       
    1: def fz_end_layer(dev):
           r"""Class-aware wrapper for `::fz_end_layer()`."""
>>>>>>     return _mupdf.fz_end_layer(dev)
       
    1: def fz_end_mask(dev):
           r"""Class-aware wrapper for `::fz_end_mask()`."""
>>>>>>     return _mupdf.fz_end_mask(dev)
       
    1: def fz_end_mask_tr(dev, fn):
           r"""Class-aware wrapper for `::fz_end_mask_tr()`."""
>>>>>>     return _mupdf.fz_end_mask_tr(dev, fn)
       
    1: def fz_end_metatext(dev):
           r"""Class-aware wrapper for `::fz_end_metatext()`."""
>>>>>>     return _mupdf.fz_end_metatext(dev)
       
    1: def fz_end_page(wri):
           r"""
           Class-aware wrapper for `::fz_end_page()`.
               Called to end the process of writing a page to a
               document.
           """
>>>>>>     return _mupdf.fz_end_page(wri)
       
    1: def fz_end_structure(dev):
           r"""Class-aware wrapper for `::fz_end_structure()`."""
>>>>>>     return _mupdf.fz_end_structure(dev)
       
    1: def fz_end_throw_on_repair():
           r"""Class-aware wrapper for `::fz_end_throw_on_repair()`."""
>>>>>>     return _mupdf.fz_end_throw_on_repair()
       
    1: def fz_end_tile(dev):
           r"""Class-aware wrapper for `::fz_end_tile()`."""
>>>>>>     return _mupdf.fz_end_tile(dev)
       
    1: def fz_enumerate_font_cmap(font, cb, opaque):
           r"""
           Class-aware wrapper for `::fz_enumerate_font_cmap()`.
               Enumerate a cmap using a callback.
           """
>>>>>>     return _mupdf.fz_enumerate_font_cmap(font, cb, opaque)
       
    1: def fz_enumerate_font_cmap2(font):
           r"""Class-aware wrapper for `::fz_enumerate_font_cmap2()`.   SWIG-friendly wrapper for fz_enumerate_font_cmap()."""
>>>>>>     return _mupdf.fz_enumerate_font_cmap2(font)
       
    1: def fz_error_callback(user):
           r"""
           Class-aware wrapper for `::fz_error_callback()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_error_callback()` => `(fz_error_cb *, void *user)`
       
               Retrieve the currently set error callback, or NULL if none
               has been set. Optionally, if user is non-NULL, the user pointer
               given when the warning callback was set is also passed back to
               the caller.
           """
>>>>>>     return _mupdf.fz_error_callback(user)
       
    1: def fz_eval_function(func, _in, inlen, out, outlen):
           r"""
           Class-aware wrapper for `::fz_eval_function()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_eval_function(::fz_function *func, const float *in, int inlen, int outlen)` => float out
           """
>>>>>>     return _mupdf.fz_eval_function(func, _in, inlen, out, outlen)
       
    1: def fz_expand_irect(a, expand):
           r"""Class-aware wrapper for `::fz_expand_irect()`."""
>>>>>>     return _mupdf.fz_expand_irect(a, expand)
       
    1: def fz_expand_rect(b, expand):
           r"""
           Class-aware wrapper for `::fz_expand_rect()`.
               Expand a bbox by a given amount in all directions.
           """
>>>>>>     return _mupdf.fz_expand_rect(b, expand)
       
    1: def fz_extract_ttf_from_ttc(font):
           r"""Class-aware wrapper for `::fz_extract_ttf_from_ttc()`."""
>>>>>>     return _mupdf.fz_extract_ttf_from_ttc(font)
       
    1: def fz_file_exists(path):
           r"""
           Class-aware wrapper for `::fz_file_exists()`.
               Return true if the named file exists and is readable.
           """
>>>>>>     return _mupdf.fz_file_exists(path)
       
    1: def fz_fill_image(dev, image, ctm, alpha, color_params):
           r"""Class-aware wrapper for `::fz_fill_image()`."""
>>>>>>     return _mupdf.fz_fill_image(dev, image, ctm, alpha, color_params)
       
    1: def fz_fill_image_mask(dev, image, ctm, colorspace, color, alpha, color_params):
           r"""Class-aware wrapper for `::fz_fill_image_mask()`."""
>>>>>>     return _mupdf.fz_fill_image_mask(dev, image, ctm, colorspace, color, alpha, color_params)
       
    1: def fz_fill_path(dev, path, even_odd, ctm, colorspace, color, alpha, color_params):
           r"""
           Class-aware wrapper for `::fz_fill_path()`.
               Device calls; graphics primitives and containers.
           """
>>>>>>     return _mupdf.fz_fill_path(dev, path, even_odd, ctm, colorspace, color, alpha, color_params)
       
    1: def fz_fill_pixmap_from_display_list(list, ctm, pix):
           r"""Class-aware wrapper for `::fz_fill_pixmap_from_display_list()`."""
>>>>>>     return _mupdf.fz_fill_pixmap_from_display_list(list, ctm, pix)
       
    1: def fz_fill_pixmap_with_color(pix, colorspace, color, color_params):
           r"""
           Class-aware wrapper for `::fz_fill_pixmap_with_color()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_fill_pixmap_with_color(::fz_pixmap *pix, ::fz_colorspace *colorspace, ::fz_color_params color_params)` => float color
       
               Fill pixmap with solid color.
           """
>>>>>>     return _mupdf.fz_fill_pixmap_with_color(pix, colorspace, color, color_params)
       
    1: def fz_fill_shade(dev, shade, ctm, alpha, color_params):
           r"""Class-aware wrapper for `::fz_fill_shade()`."""
>>>>>>     return _mupdf.fz_fill_shade(dev, shade, ctm, alpha, color_params)
       
    1: def fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params):
           r"""Class-aware wrapper for `::fz_fill_text()`."""
>>>>>>     return _mupdf.fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params)
       
    1: def fz_filter_store(fn, arg, type):
           r"""
           Class-aware wrapper for `::fz_filter_store()`.
               Filter every element in the store with a matching type with the
               given function.
       
               If the function returns 1 for an element, drop the element.
           """
>>>>>>     return _mupdf.fz_filter_store(fn, arg, type)
       
    1: def fz_find_item(drop, key, type):
           r"""
           Class-aware wrapper for `::fz_find_item()`.
               Find an item within the store.
       
               drop: The function used to free the value (to ensure we get a
               value of the correct type).
       
               key: The key used to index the item.
       
               type: Functions used to manipulate the key.
       
               Returns NULL for not found, otherwise returns a pointer to the
               value indexed by key to which a reference has been taken.
           """
>>>>>>     return _mupdf.fz_find_item(drop, key, type)
       
    1: def fz_find_table_within_bounds(page, bounds):
           r"""
           Class-aware wrapper for `::fz_find_table_within_bounds()`.
               Interpret the bounded contents of a given stext page as
               a table.
       
               The page contents will be rewritten to contain a Table
               structure with the identified content in it.
       
               This uses the same logic as for fz_table_hunt, without the
               actual hunting. fz_table_hunt hunts to find possible bounds
               for multiple tables on the page; this routine just finds a
               single table contained within the given rectangle.
       
               Returns the stext_block list that contains the content of
               the table.
           """
>>>>>>     return _mupdf.fz_find_table_within_bounds(page, bounds)
       
    1: def fz_flush_output(out):
           r"""
           Class-aware wrapper for `::fz_flush_output()`.
               Flush unwritten data.
           """
>>>>>>     return _mupdf.fz_flush_output(out)
       
    1: def fz_flush_warnings():
           r"""
           Class-aware wrapper for `::fz_flush_warnings()`.
               Flush any repeated warnings.
       
               Repeated warnings are buffered, counted and eventually printed
               along with the number of repetitions. Call fz_flush_warnings
               to force printing of the latest buffered warning and the
               number of repetitions, for example to make sure that all
               warnings are printed before exiting an application.
           """
>>>>>>     return _mupdf.fz_flush_warnings()
       
    1: def fz_font_ascender(font):
           r"""
           Class-aware wrapper for `::fz_font_ascender()`.
               Retrieve font ascender in ems.
           """
>>>>>>     return _mupdf.fz_font_ascender(font)
       
    1: def fz_font_bbox(font):
           r"""
           Class-aware wrapper for `::fz_font_bbox()`.
               Retrieve the font bbox.
       
               font: The font to query.
       
               Returns the font bbox by value; it is valid only if
               fz_font_flags(font)->invalid_bbox is zero.
           """
>>>>>>     return _mupdf.fz_font_bbox(font)
       
    1: def fz_font_descender(font):
           r"""
           Class-aware wrapper for `::fz_font_descender()`.
               Retrieve font descender in ems.
           """
>>>>>>     return _mupdf.fz_font_descender(font)
       
    1: def fz_font_digest(font, digest):
           r"""
           Class-aware wrapper for `::fz_font_digest()`.
               Retrieve the MD5 digest for the font's data.
           """
>>>>>>     return _mupdf.fz_font_digest(font, digest)
       
    1: def fz_font_ft_face(font):
           r"""
           Class-aware wrapper for `::fz_font_ft_face()`.
               Retrieve the FT_Face handle
               for the font.
       
               font: The font to query
       
               Returns the FT_Face handle for the font, or NULL
               if not a freetype handled font. (Cast to void *
               to avoid nasty header exposure).
           """
>>>>>>     return _mupdf.fz_font_ft_face(font)
       
    1: def fz_font_is_bold(font):
           r"""
           Class-aware wrapper for `::fz_font_is_bold()`.
               Query whether the font flags say that this font is bold.
           """
>>>>>>     return _mupdf.fz_font_is_bold(font)
       
    1: def fz_font_is_italic(font):
           r"""
           Class-aware wrapper for `::fz_font_is_italic()`.
               Query whether the font flags say that this font is italic.
           """
>>>>>>     return _mupdf.fz_font_is_italic(font)
       
    1: def fz_font_is_monospaced(font):
           r"""
           Class-aware wrapper for `::fz_font_is_monospaced()`.
               Query whether the font flags say that this font is monospaced.
           """
>>>>>>     return _mupdf.fz_font_is_monospaced(font)
       
    1: def fz_font_is_serif(font):
           r"""
           Class-aware wrapper for `::fz_font_is_serif()`.
               Query whether the font flags say that this font is serif.
           """
>>>>>>     return _mupdf.fz_font_is_serif(font)
       
    1: def fz_font_name(font):
           r"""
           Class-aware wrapper for `::fz_font_name()`.
               Retrieve a pointer to the name of the font.
       
               font: The font to query.
       
               Returns a pointer to an internal copy of the font name.
               Will never be NULL, but may be the empty string.
           """
>>>>>>     return _mupdf.fz_font_name(font)
       
    1: def fz_font_t3_procs(font):
           r"""
           Class-aware wrapper for `::fz_font_t3_procs()`.
               Retrieve the Type3 procs
               for a font.
       
               font: The font to query
       
               Returns the t3_procs pointer. Will be NULL for a
               non type-3 font.
           """
>>>>>>     return _mupdf.fz_font_t3_procs(font)
       
    1: def fz_format_double(fmt, value):
           r"""
           Class-aware wrapper for `::fz_format_double()`.   Swig-friendly and typesafe way to do fz_snprintf(fmt, value). `fmt`
           must end with one of 'efg' otherwise we throw an exception.
           """
>>>>>>     return _mupdf.fz_format_double(fmt, value)
       
    1: def fz_format_link_uri(doc, dest):
           r"""
           Class-aware wrapper for `::fz_format_link_uri()`.
               Format an internal link to a page number, location, and possible viewing parameters,
               suitable for use with fz_create_link.
       
               Returns a newly allocated string that the caller must free.
           """
>>>>>>     return _mupdf.fz_format_link_uri(doc, dest)
       
    1: def fz_format_output_path(path, size, fmt, page):
           r"""
           Class-aware wrapper for `::fz_format_output_path()`.
               create output file name using a template.
       
               If the path contains %[0-9]*d, the first such pattern will be
               replaced with the page number. If the template does not contain
               such a pattern, the page number will be inserted before the
               filename extension. If the template does not have a filename
               extension, the page number will be added to the end.
           """
>>>>>>     return _mupdf.fz_format_output_path(path, size, fmt, page)
       
    1: def fz_free(p):
           r"""
           Class-aware wrapper for `::fz_free()`.
               Free a previously allocated block of memory.
       
               fz_free(ctx, NULL) does nothing.
       
               Never throws exceptions.
           """
>>>>>>     return _mupdf.fz_free(p)
       
    1: def fz_free_aligned(p):
           r"""
           Class-aware wrapper for `::fz_free_aligned()`.
               fz_free equivalent, for blocks allocated via fz_malloc_aligned.
           """
>>>>>>     return _mupdf.fz_free_aligned(p)
       
    1: def fz_ft_lock():
           r"""Class-aware wrapper for `::fz_ft_lock()`."""
>>>>>>     return _mupdf.fz_ft_lock()
       
    1: def fz_ft_lock_held():
           r"""Class-aware wrapper for `::fz_ft_lock_held()`."""
>>>>>>     return _mupdf.fz_ft_lock_held()
       
    1: def fz_ft_unlock():
           r"""Class-aware wrapper for `::fz_ft_unlock()`."""
>>>>>>     return _mupdf.fz_ft_unlock()
       
    1: def fz_function_size(func):
           r"""Class-aware wrapper for `::fz_function_size()`."""
>>>>>>     return _mupdf.fz_function_size(func)
       
    1: def fz_gamma_pixmap(pix, gamma):
           r"""
           Class-aware wrapper for `::fz_gamma_pixmap()`.
               Apply gamma correction to a pixmap. All components
               of all pixels are modified (except alpha, which is unchanged).
       
               gamma: The gamma value to apply; 1.0 for no change.
           """
>>>>>>     return _mupdf.fz_gamma_pixmap(pix, gamma)
       
    1: def fz_generate_transition(tpix, opix, npix, time, trans):
           r"""
           Class-aware wrapper for `::fz_generate_transition()`.
               Generate a frame of a transition.
       
               tpix: Target pixmap
               opix: Old pixmap
               npix: New pixmap
               time: Position within the transition (0 to 256)
               trans: Transition details
       
               Returns 1 if successfully generated a frame.
       
               Note: Pixmaps must include alpha.
           """
>>>>>>     return _mupdf.fz_generate_transition(tpix, opix, npix, time, trans)
       
    1: def fz_get_glyph_name(font, glyph, buf, size):
           r"""
           Class-aware wrapper for `::fz_get_glyph_name()`.
               Find the name of a glyph
       
               font: The font to look for the glyph in.
       
               glyph: The glyph id to look for.
       
               buf: Pointer to a buffer for the name to be inserted into.
       
               size: The size of the buffer.
       
               If a font contains a name table, then the name of the glyph
               will be returned in the supplied buffer. Otherwise a name
               is synthesised. The name will be truncated to fit in
               the buffer.
           """
>>>>>>     return _mupdf.fz_get_glyph_name(font, glyph, buf, size)
       
    1: def fz_get_glyph_name2(font, glyph):
           r"""
           Class-aware wrapper for `::fz_get_glyph_name2()`.
           C++ alternative to fz_get_glyph_name() that returns information in a std::string.
           """
>>>>>>     return _mupdf.fz_get_glyph_name2(font, glyph)
       
    1: def fz_get_pixmap_from_image(image, subarea, ctm, w, h):
           r"""
           Class-aware wrapper for `::fz_get_pixmap_from_image()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_get_pixmap_from_image(::fz_image *image, const ::fz_irect *subarea, ::fz_matrix *ctm)` => `(fz_pixmap *, int w, int h)`
       
               Called to get a handle to a pixmap from an image.
       
               image: The image to retrieve a pixmap from.
       
               subarea: The subarea of the image that we actually care about
               (or NULL to indicate the whole image).
       
               ctm: Optional, unless subarea is given. If given, then on
               entry this is the transform that will be applied to the complete
               image. It should be updated on exit to the transform to apply to
               the given subarea of the image. This is used to calculate the
               desired width/height for subsampling.
       
               w: If non-NULL, a pointer to an int to be updated on exit to the
               width (in pixels) that the scaled output will cover.
       
               h: If non-NULL, a pointer to an int to be updated on exit to the
               height (in pixels) that the scaled output will cover.
       
               Returns a non NULL kept pixmap pointer. May throw exceptions.
           """
>>>>>>     return _mupdf.fz_get_pixmap_from_image(image, subarea, ctm, w, h)
       
    1: def fz_get_unscaled_pixmap_from_image(image):
           r"""
           Class-aware wrapper for `::fz_get_unscaled_pixmap_from_image()`.
               Calls fz_get_pixmap_from_image() with ctm, subarea, w and h all set to NULL.
           """
>>>>>>     return _mupdf.fz_get_unscaled_pixmap_from_image(image)
       
    1: def fz_getopt(nargc, nargv, ostr):
           r"""
           Class-aware wrapper for `::fz_getopt()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_getopt(int nargc, const char *ostr)` => `(int, char *nargv)`
       
               Identical to fz_getopt_long, but with a NULL longopts field, signifying no long
               options.
           """
>>>>>>     return _mupdf.fz_getopt(nargc, nargv, ostr)
       
    1: def fz_getopt_long(nargc, nargv, ostr, longopts):
           r"""
           Class-aware wrapper for `::fz_getopt_long()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_getopt_long(int nargc, const char *ostr, const ::fz_getopt_long_options *longopts)` => `(int, char *nargv)`
       
               Simple functions/variables for use in tools.
       
               ostr = option string. Comprises single letter options, followed by : if there
               is an argument to the option.
       
               longopts: NULL (indicating no long options), or a pointer to an array of
               longoptions, terminated by an entry with option == NULL.
       
               In the event of matching a single char option, this function will normally
               return the char. The exception to this is when the option requires an
               argument and none is supplied; in this case we return ':'.
       
               In the event of matching a long option, this function returns 0, with fz_optlong
               set to point to the matching option.
       
               A long option entry may be followed with : to indicate there is an argument to the
               option. If the need for an argument is specified in this way, and no argument is
               given, an error will be displayed and argument processing will stop. If an argument
               is given, and the long option record contains a non-null flag pointer, then the code
               will decode the argument and fill in that flag pointer. Specifically,
               case-insensitive matches to 'yes', 'no', 'true' and 'false' will cause a value of 0
               or 1 as appropriate to be written; failing this the arg will be interpreted as a
               decimal integer using atoi.
       
               A long option entry may be followed by an list of options (e.g. myoption=foo|bar|baz)
               and the option will be passed to fz_opt_from_list. The return value of that will be
               placed in fz_optitem. If the return value of that function is -1, then an error will
               be displayed and argument processing will stop.
       
               In the event of reaching the end of the arg list or '--', this function returns EOF.
       
               In the event of failing to match anything, an error is printed, and we return '?'.
       
               If an argument is expected for the option, then fz_optarg will be returned pointing
               at the start of the argument. Examples of supported argument formats: '-r500', '-r 500',
               '--resolution 500', '--resolution=500'.
           """
>>>>>>     return _mupdf.fz_getopt_long(nargc, nargv, ostr, longopts)
       
    1: def fz_glyph_bbox(glyph):
           r"""
           Class-aware wrapper for `::fz_glyph_bbox()`.
               Return the bounding box of the glyph in pixels.
           """
>>>>>>     return _mupdf.fz_glyph_bbox(glyph)
       
    1: def fz_glyph_bbox_no_ctx(src):
           r"""Class-aware wrapper for `::fz_glyph_bbox_no_ctx()`."""
>>>>>>     return _mupdf.fz_glyph_bbox_no_ctx(src)
       
    1: def fz_glyph_cacheable(font, gid):
           r"""
           Class-aware wrapper for `::fz_glyph_cacheable()`.
               Determine if a given glyph in a font
               is cacheable. Certain glyphs in a type 3 font cannot safely
               be cached, as their appearance depends on the enclosing
               graphic state.
       
               font: The font to look for the glyph in.
       
               gif: The glyph to query.
       
               Returns non-zero if cacheable, 0 if not.
           """
>>>>>>     return _mupdf.fz_glyph_cacheable(font, gid)
       
    1: def fz_glyph_height(glyph):
           r"""
           Class-aware wrapper for `::fz_glyph_height()`.
               Return the height of the glyph in pixels.
           """
>>>>>>     return _mupdf.fz_glyph_height(glyph)
       
    1: def fz_glyph_name_from_unicode_sc(unicode):
           r"""Class-aware wrapper for `::fz_glyph_name_from_unicode_sc()`."""
>>>>>>     return _mupdf.fz_glyph_name_from_unicode_sc(unicode)
       
    1: def fz_glyph_width(glyph):
           r"""
           Class-aware wrapper for `::fz_glyph_width()`.
               Return the width of the glyph in pixels.
           """
>>>>>>     return _mupdf.fz_glyph_width(glyph)
       
    1: def fz_graphics_aa_level():
           r"""
           Class-aware wrapper for `::fz_graphics_aa_level()`.
               Get the number of bits of antialiasing we are
               using for graphics. Between 0 and 8.
           """
>>>>>>     return _mupdf.fz_graphics_aa_level()
       
    1: def fz_graphics_min_line_width():
           r"""
           Class-aware wrapper for `::fz_graphics_min_line_width()`.
               Get the minimum line width to be
               used for stroked lines.
       
               min_line_width: The minimum line width to use (in pixels).
           """
>>>>>>     return _mupdf.fz_graphics_min_line_width()
       
    1: def fz_gridfit_matrix(as_tiled, m):
           r"""
           Class-aware wrapper for `::fz_gridfit_matrix()`.
               Grid fit a matrix.
       
               as_tiled = 0 => adjust the matrix so that the image of the unit
               square completely covers any pixel that was touched by the
               image of the unit square under the original matrix.
       
               as_tiled = 1 => adjust the matrix so that the corners of the
               image of the unit square align with the closest integer corner
               of the image of the unit square under the original matrix.
           """
>>>>>>     return _mupdf.fz_gridfit_matrix(as_tiled, m)
       
    1: def fz_grisu(f, s, exp):
           r"""
           Class-aware wrapper for `::fz_grisu()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_grisu(float f, char *s)` => `(int, int exp)`
           """
>>>>>>     return _mupdf.fz_grisu(f, s, exp)
       
    1: def fz_grow_buffer(buf):
           r"""
           Class-aware wrapper for `::fz_grow_buffer()`.
               Make some space within a buffer (i.e. ensure that
               capacity > size).
           """
>>>>>>     return _mupdf.fz_grow_buffer(buf)
       
    1: def fz_has_archive_entry(arch, name):
           r"""
           Class-aware wrapper for `::fz_has_archive_entry()`.
               Check if entry by given name exists.
       
               If named entry does not exist 0 will be returned, if it does
               exist 1 is returned.
       
               name: Entry name to look for, this must be an exact match to
               the entry name in the archive.
           """
>>>>>>     return _mupdf.fz_has_archive_entry(arch, name)
       
    1: def fz_has_option(opts, key, val):
           r"""
           Class-aware wrapper for `::fz_has_option()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_has_option(const char *opts, const char *key)` => `(int, const char *val)`
       
               Look for a given option (key) in the opts string. Return 1 if
               it has it, and update *val to point to the value within opts.
           """
>>>>>>     return _mupdf.fz_has_option(opts, key, val)
       
    1: def fz_has_permission(doc, p):
           r"""
           Class-aware wrapper for `::fz_has_permission()`.
               Check permission flags on document.
           """
>>>>>>     return _mupdf.fz_has_permission(doc, p)
       
    1: def fz_hash_filter(table, state, callback):
           r"""
           Class-aware wrapper for `::fz_hash_filter()`.
               Iterate over the entries in a hash table, removing all the ones where callback returns true.
               Does NOT free the value of the entry, so the caller is expected to take care of this.
           """
>>>>>>     return _mupdf.fz_hash_filter(table, state, callback)
       
    1: def fz_hash_find(table, key):
           r"""
           Class-aware wrapper for `::fz_hash_find()`.
               Search for a matching hash within the table, and return the
               associated value.
           """
>>>>>>     return _mupdf.fz_hash_find(table, key)
       
    1: def fz_hash_for_each(table, state, callback):
           r"""
           Class-aware wrapper for `::fz_hash_for_each()`.
               Iterate over the entries in a hash table.
           """
>>>>>>     return _mupdf.fz_hash_for_each(table, state, callback)
       
    1: def fz_hash_insert(table, key, val):
           r"""
           Class-aware wrapper for `::fz_hash_insert()`.
               Insert a new key/value pair into the hash table.
       
               If an existing entry with the same key is found, no change is
               made to the hash table, and a pointer to the existing value is
               returned.
       
               If no existing entry with the same key is found, ownership of
               val passes in, key is copied, and NULL is returned.
           """
>>>>>>     return _mupdf.fz_hash_insert(table, key, val)
       
    1: def fz_hash_remove(table, key):
           r"""
           Class-aware wrapper for `::fz_hash_remove()`.
               Remove the entry for a given key.
       
               The value is NOT freed, so the caller is expected to take care
               of this.
           """
>>>>>>     return _mupdf.fz_hash_remove(table, key)
       
    1: def fz_hb_lock():
           r"""
           Class-aware wrapper for `::fz_hb_lock()`.
               Lock against Harfbuzz being called
               simultaneously in several threads. This reuses
               FZ_LOCK_FREETYPE.
           """
>>>>>>     return _mupdf.fz_hb_lock()
       
    1: def fz_hb_unlock():
           r"""
           Class-aware wrapper for `::fz_hb_unlock()`.
               Unlock after a Harfbuzz call. This reuses
               FZ_LOCK_FREETYPE.
           """
>>>>>>     return _mupdf.fz_hb_unlock()
       
    1: def fz_highlight_selection(page, a, b, quads, max_quads):
           r"""
           Class-aware wrapper for `::fz_highlight_selection()`.
               Return a list of quads to highlight lines inside the selection
               points.
           """
>>>>>>     return _mupdf.fz_highlight_selection(page, a, b, quads, max_quads)
       
    1: def fz_highlight_selection2(page, a, b, max_quads):
           r"""
           Class-aware wrapper for `::fz_highlight_selection2()`.
           C++ alternative to fz_highlight_selection() that returns quads in a
           std::vector.
           """
>>>>>>     return _mupdf.fz_highlight_selection2(page, a, b, max_quads)
       
    1: def fz_ignore_error():
           r"""Class-aware wrapper for `::fz_ignore_error()`."""
>>>>>>     return _mupdf.fz_ignore_error()
       
    1: def fz_ignore_text(dev, text, ctm):
           r"""Class-aware wrapper for `::fz_ignore_text()`."""
>>>>>>     return _mupdf.fz_ignore_text(dev, text, ctm)
       
    1: def fz_image_orientation(image):
           r"""
           Class-aware wrapper for `::fz_image_orientation()`.
               Request the natural orientation of an image.
       
               This is for images (such as JPEG) that can contain internal
               specifications of rotation/flips. This is ignored by all the
               internal decode/rendering routines, but can be used by callers
               (such as the image document handler) to respect such
               specifications.
       
               The values used by MuPDF are as follows, with the equivalent
               Exif specifications given for information:
       
               0: Undefined
               1: 0 degree ccw rotation. (Exif = 1)
               2: 90 degree ccw rotation. (Exif = 8)
               3: 180 degree ccw rotation. (Exif = 3)
               4: 270 degree ccw rotation. (Exif = 6)
               5: flip on X. (Exif = 2)
               6: flip on X, then rotate ccw by 90 degrees. (Exif = 5)
               7: flip on X, then rotate ccw by 180 degrees. (Exif = 4)
               8: flip on X, then rotate ccw by 270 degrees. (Exif = 7)
           """
>>>>>>     return _mupdf.fz_image_orientation(image)
       
    1: def fz_image_orientation_matrix(image):
           r"""Class-aware wrapper for `::fz_image_orientation_matrix()`."""
>>>>>>     return _mupdf.fz_image_orientation_matrix(image)
       
    1: def fz_image_resolution(image, xres, yres):
           r"""
           Class-aware wrapper for `::fz_image_resolution()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_image_resolution(::fz_image *image)` => `(int xres, int yres)`
       
               Request the natural resolution
               of an image.
       
               xres, yres: Pointers to ints to be updated with the
               natural resolution of an image (or a sensible default
               if not encoded).
           """
>>>>>>     return _mupdf.fz_image_resolution(image, xres, yres)
       
    1: def fz_image_size(im):
           r"""
           Class-aware wrapper for `::fz_image_size()`.
               Return the size of the storage used by an image.
           """
>>>>>>     return _mupdf.fz_image_size(im)
       
    1: def fz_image_type_name(type):
           r"""
           Class-aware wrapper for `::fz_image_type_name()`.
               Map from FZ_IMAGE_* value to string.
       
               The returned string is static and therefore must not be freed.
           """
>>>>>>     return _mupdf.fz_image_type_name(type)
       
    1: def fz_include_point_in_rect(r, p):
           r"""
           Class-aware wrapper for `::fz_include_point_in_rect()`.
               Expand a bbox to include a given point.
               To create a rectangle that encompasses a sequence of points, the
               rectangle must first be set to be the empty rectangle at one of
               the points before including the others.
           """
>>>>>>     return _mupdf.fz_include_point_in_rect(r, p)
       
    1: def fz_init_text_decoder(dec, encoding):
           r"""Class-aware wrapper for `::fz_init_text_decoder()`."""
>>>>>>     return _mupdf.fz_init_text_decoder(dec, encoding)
       
    1: def fz_install_load_system_font_funcs(f, f_cjk, f_fallback):
           r"""
           Class-aware wrapper for `::fz_install_load_system_font_funcs()`.
               Install functions to allow MuPDF to request fonts from the
               system.
       
               Only one set of hooks can be in use at a time.
           """
>>>>>>     return _mupdf.fz_install_load_system_font_funcs(f, f_cjk, f_fallback)
       
    1: def fz_install_load_system_font_funcs2(args):
           r"""
           Class-aware wrapper for `::fz_install_load_system_font_funcs2()`.
           Alternative to fz_install_load_system_font_funcs() that takes args in a
           struct, to allow use from Python/C# via Swig Directors.
           """
>>>>>>     return _mupdf.fz_install_load_system_font_funcs2(args)
       
    1: def fz_int2_heap_debug(heap):
           r"""Class-aware wrapper for `::fz_int2_heap_debug()`."""
>>>>>>     return _mupdf.fz_int2_heap_debug(heap)
       
    1: def fz_int2_heap_dump(out, heap):
           r"""Class-aware wrapper for `::fz_int2_heap_dump()`."""
>>>>>>     return _mupdf.fz_int2_heap_dump(out, heap)
       
    1: def fz_int2_heap_insert(heap, v):
           r"""Class-aware wrapper for `::fz_int2_heap_insert()`."""
>>>>>>     return _mupdf.fz_int2_heap_insert(heap, v)
       
    1: def fz_int2_heap_sort(heap):
           r"""Class-aware wrapper for `::fz_int2_heap_sort()`."""
>>>>>>     return _mupdf.fz_int2_heap_sort(heap)
       
    1: def fz_int2_heap_uniq(heap):
           r"""Class-aware wrapper for `::fz_int2_heap_uniq()`."""
>>>>>>     return _mupdf.fz_int2_heap_uniq(heap)
       
    1: def fz_int_heap_debug(heap):
           r"""Class-aware wrapper for `::fz_int_heap_debug()`."""
>>>>>>     return _mupdf.fz_int_heap_debug(heap)
       
    1: def fz_int_heap_dump(out, heap):
           r"""Class-aware wrapper for `::fz_int_heap_dump()`."""
>>>>>>     return _mupdf.fz_int_heap_dump(out, heap)
       
    1: def fz_int_heap_insert(heap, v):
           r"""Class-aware wrapper for `::fz_int_heap_insert()`."""
>>>>>>     return _mupdf.fz_int_heap_insert(heap, v)
       
    1: def fz_int_heap_sort(heap):
           r"""Class-aware wrapper for `::fz_int_heap_sort()`."""
>>>>>>     return _mupdf.fz_int_heap_sort(heap)
       
    1: def fz_int_heap_uniq(heap):
           r"""Class-aware wrapper for `::fz_int_heap_uniq()`."""
>>>>>>     return _mupdf.fz_int_heap_uniq(heap)
       
    1: def fz_intersect_irect(a, b):
           r"""
           Class-aware wrapper for `::fz_intersect_irect()`.
               Compute intersection of two bounding boxes.
       
               Similar to fz_intersect_rect but operates on two bounding
               boxes instead of two rectangles.
           """
>>>>>>     return _mupdf.fz_intersect_irect(a, b)
       
    1: def fz_intersect_rect(a, b):
           r"""
           Class-aware wrapper for `::fz_intersect_rect()`.
               Compute intersection of two rectangles.
       
               Given two rectangles, update the first to be the smallest
               axis-aligned rectangle that covers the area covered by both
               given rectangles. If either rectangle is empty then the
               intersection is also empty. If either rectangle is infinite
               then the intersection is simply the non-infinite rectangle.
               Should both rectangles be infinite, then the intersection is
               also infinite.
           """
>>>>>>     return _mupdf.fz_intersect_rect(a, b)
       
    1: def fz_intptr_heap_debug(heap):
           r"""Class-aware wrapper for `::fz_intptr_heap_debug()`."""
>>>>>>     return _mupdf.fz_intptr_heap_debug(heap)
       
    1: def fz_intptr_heap_dump(out, heap):
           r"""Class-aware wrapper for `::fz_intptr_heap_dump()`."""
>>>>>>     return _mupdf.fz_intptr_heap_dump(out, heap)
       
    1: def fz_intptr_heap_insert(heap, v):
           r"""Class-aware wrapper for `::fz_intptr_heap_insert()`."""
>>>>>>     return _mupdf.fz_intptr_heap_insert(heap, v)
       
    1: def fz_intptr_heap_sort(heap):
           r"""Class-aware wrapper for `::fz_intptr_heap_sort()`."""
>>>>>>     return _mupdf.fz_intptr_heap_sort(heap)
       
    1: def fz_intptr_heap_uniq(heap):
           r"""Class-aware wrapper for `::fz_intptr_heap_uniq()`."""
>>>>>>     return _mupdf.fz_intptr_heap_uniq(heap)
       
    1: def fz_invert_bitmap(bmp):
           r"""
           Class-aware wrapper for `::fz_invert_bitmap()`.
               Invert bitmap.
       
               Never throws exceptions.
           """
>>>>>>     return _mupdf.fz_invert_bitmap(bmp)
       
    1: def fz_invert_matrix(matrix):
           r"""
           Class-aware wrapper for `::fz_invert_matrix()`.
               Create an inverse matrix.
       
               matrix: Matrix to invert. A degenerate matrix, where the
               determinant is equal to zero, can not be inverted and the
               original matrix is returned instead.
       
               Returns inverse.
           """
>>>>>>     return _mupdf.fz_invert_matrix(matrix)
       
    1: def fz_invert_pixmap(pix):
           r"""
           Class-aware wrapper for `::fz_invert_pixmap()`.
               Invert all the pixels in a pixmap. All components (process and
               spots) of all pixels are inverted (except alpha, which is
               unchanged).
           """
>>>>>>     return _mupdf.fz_invert_pixmap(pix)
       
    1: def fz_invert_pixmap_alpha(pix):
           r"""
           Class-aware wrapper for `::fz_invert_pixmap_alpha()`.
               Invert the alpha of all the pixels in a pixmap.
           """
>>>>>>     return _mupdf.fz_invert_pixmap_alpha(pix)
       
    1: def fz_invert_pixmap_luminance(pix):
           r"""
           Class-aware wrapper for `::fz_invert_pixmap_luminance()`.
               Transform the pixels in a pixmap so that luminance of each
               pixel is inverted, and the chrominance remains unchanged (as
               much as accuracy allows).
       
               All components of all pixels are inverted (except alpha, which
               is unchanged). Only supports Grey and RGB bitmaps.
           """
>>>>>>     return _mupdf.fz_invert_pixmap_luminance(pix)
       
    1: def fz_invert_pixmap_raw(pix):
           r"""
           Class-aware wrapper for `::fz_invert_pixmap_raw()`.
               Invert all the pixels in a non-premultiplied pixmap in a
               very naive manner.
           """
>>>>>>     return _mupdf.fz_invert_pixmap_raw(pix)
       
    1: def fz_invert_pixmap_rect(image, rect):
           r"""
           Class-aware wrapper for `::fz_invert_pixmap_rect()`.
               Invert all the pixels in a given rectangle of a (premultiplied)
               pixmap. All components of all pixels in the rectangle are
               inverted (except alpha, which is unchanged).
           """
>>>>>>     return _mupdf.fz_invert_pixmap_rect(image, rect)
       
    1: def fz_irect_from_rect(rect):
           r"""
           Class-aware wrapper for `::fz_irect_from_rect()`.
               Convert a rect into the minimal bounding box
               that covers the rectangle.
       
               Coordinates in a bounding box are integers, so rounding of the
               rects coordinates takes place. The top left corner is rounded
               upwards and left while the bottom right corner is rounded
               downwards and to the right.
           """
>>>>>>     return _mupdf.fz_irect_from_rect(rect)
       
    1: def fz_irect_height(r):
           r"""
           Class-aware wrapper for `::fz_irect_height()`.
               Return the height of an irect. Invalid irects return 0.
           """
>>>>>>     return _mupdf.fz_irect_height(r)
       
    1: def fz_irect_width(r):
           r"""
           Class-aware wrapper for `::fz_irect_width()`.
               Return the width of an irect. Invalid irects return 0.
           """
>>>>>>     return _mupdf.fz_irect_width(r)
       
    1: def fz_is_cfb_archive(file):
           r"""
           Class-aware wrapper for `::fz_is_cfb_archive()`.
               Detect if stream object is a cfb archive.
       
               Assumes that the stream object is seekable.
           """
>>>>>>     return _mupdf.fz_is_cfb_archive(file)
       
    1: def fz_is_directory(path):
           r"""
           Class-aware wrapper for `::fz_is_directory()`.
               Determine if a given path is a directory.
       
               In the case of the path not existing, or having no access
               we will return 0.
           """
>>>>>>     return _mupdf.fz_is_directory(path)
       
    1: def fz_is_document_reflowable(doc):
           r"""
           Class-aware wrapper for `::fz_is_document_reflowable()`.
               Is the document reflowable.
       
               Returns 1 to indicate reflowable documents, otherwise 0.
           """
>>>>>>     return _mupdf.fz_is_document_reflowable(doc)
       
    1: def fz_is_empty_irect(r):
           r"""Class-aware wrapper for `::fz_is_empty_irect()`."""
>>>>>>     return _mupdf.fz_is_empty_irect(r)
       
    1: def fz_is_empty_quad(q):
           r"""
           Class-aware wrapper for `::fz_is_empty_quad()`.
               Is a quad empty?
           """
>>>>>>     return _mupdf.fz_is_empty_quad(q)
       
    1: def fz_is_empty_rect(r):
           r"""
           Class-aware wrapper for `::fz_is_empty_rect()`.
               Check if rectangle is empty.
       
               An empty rectangle is defined as one whose area is zero.
               All invalid rectangles are empty.
           """
>>>>>>     return _mupdf.fz_is_empty_rect(r)
       
    1: def fz_is_eof(stm):
           r"""
           Class-aware wrapper for `::fz_is_eof()`.
               Query if the stream has reached EOF (during normal bytewise
               reading).
       
               See fz_is_eof_bits for the equivalent function for bitwise
               reading.
           """
>>>>>>     return _mupdf.fz_is_eof(stm)
       
    1: def fz_is_eof_bits(stm):
           r"""
           Class-aware wrapper for `::fz_is_eof_bits()`.
               Query if the stream has reached EOF (during bitwise
               reading).
       
               See fz_is_eof for the equivalent function for bytewise
               reading.
           """
>>>>>>     return _mupdf.fz_is_eof_bits(stm)
       
    1: def fz_is_external_link(uri):
           r"""
           Class-aware wrapper for `::fz_is_external_link()`.
               Query whether a link is external to a document (determined by
               uri containing a ':', intended to match with '://' which
               separates the scheme from the scheme specific parts in URIs).
           """
>>>>>>     return _mupdf.fz_is_external_link(uri)
       
    1: def fz_is_identity(m):
           r"""Class-aware wrapper for `::fz_is_identity()`."""
>>>>>>     return _mupdf.fz_is_identity(m)
       
    1: def fz_is_infinite_irect(r):
           r"""
           Class-aware wrapper for `::fz_is_infinite_irect()`.
               Check if an integer rectangle
               is infinite.
           """
>>>>>>     return _mupdf.fz_is_infinite_irect(r)
       
    1: def fz_is_infinite_quad(q):
           r"""
           Class-aware wrapper for `::fz_is_infinite_quad()`.
               Is a quad infinite?
           """
>>>>>>     return _mupdf.fz_is_infinite_quad(q)
       
    1: def fz_is_infinite_rect(r):
           r"""
           Class-aware wrapper for `::fz_is_infinite_rect()`.
               Check if rectangle is infinite.
           """
>>>>>>     return _mupdf.fz_is_infinite_rect(r)
       
    1: def fz_is_irect_inside_irect(inner, outer):
           r"""
           Class-aware wrapper for `::fz_is_irect_inside_irect()`.
               Inclusion test for irects.
       
               rects are assumed to be both open or both closed.
       
               No invalid rect can include any other rect.
               No invalid rect can be included by any rect.
               Empty (point) rects can include themselves.
               Empty (line) rects can include many (subline) rects.
           """
>>>>>>     return _mupdf.fz_is_irect_inside_irect(inner, outer)
       
    1: def fz_is_libarchive_archive(file):
           r"""
           Class-aware wrapper for `::fz_is_libarchive_archive()`.
               Detect if stream object is an archive supported by libarchive.
       
               Assumes that the stream object is seekable.
           """
>>>>>>     return _mupdf.fz_is_libarchive_archive(file)
       
    1: def fz_is_lossy_image(image):
           r"""Class-aware wrapper for `::fz_is_lossy_image()`."""
>>>>>>     return _mupdf.fz_is_lossy_image(image)
       
    1: def fz_is_page_range(s):
           r"""
            Class-aware wrapper for `::fz_is_page_range()`.
                       Check and parse string into page ranges:
           ,?(-?+|N)(-(-?+|N))?/
           """
>>>>>>     return _mupdf.fz_is_page_range(s)
       
    1: def fz_is_pixmap_monochrome(pixmap):
           r"""
           Class-aware wrapper for `::fz_is_pixmap_monochrome()`.
               Check if the pixmap is a 1-channel image containing samples with
               only values 0 and 255
           """
>>>>>>     return _mupdf.fz_is_pixmap_monochrome(pixmap)
       
    1: def fz_is_point_inside_irect(x, y, r):
           r"""
           Class-aware wrapper for `::fz_is_point_inside_irect()`.
               Inclusion test for irects. (Rect is assumed to be open, i.e.
               top right corner is not included).
           """
>>>>>>     return _mupdf.fz_is_point_inside_irect(x, y, r)
       
    1: def fz_is_point_inside_quad(p, q):
           r"""
           Class-aware wrapper for `::fz_is_point_inside_quad()`.
               Inclusion test for quads.
           """
>>>>>>     return _mupdf.fz_is_point_inside_quad(p, q)
       
    1: def fz_is_point_inside_rect(p, r):
           r"""
           Class-aware wrapper for `::fz_is_point_inside_rect()`.
               Inclusion test for rects. (Rect is assumed to be open, i.e.
               top right corner is not included).
           """
>>>>>>     return _mupdf.fz_is_point_inside_rect(p, r)
       
    1: def fz_is_pow2(a):
           r"""Class-aware wrapper for `::fz_is_pow2()`."""
>>>>>>     return _mupdf.fz_is_pow2(a)
       
    1: def fz_is_quad_inside_quad(needle, haystack):
           r"""
           Class-aware wrapper for `::fz_is_quad_inside_quad()`.
               Inclusion test for quad in quad.
       
               This may break down if quads are not 'well formed'.
           """
>>>>>>     return _mupdf.fz_is_quad_inside_quad(needle, haystack)
       
    1: def fz_is_quad_intersecting_quad(a, b):
           r"""
           Class-aware wrapper for `::fz_is_quad_intersecting_quad()`.
               Intersection test for quads.
       
               This may break down if quads are not 'well formed'.
           """
>>>>>>     return _mupdf.fz_is_quad_intersecting_quad(a, b)
       
    1: def fz_is_rect_inside_rect(inner, outer):
           r"""
           Class-aware wrapper for `::fz_is_rect_inside_rect()`.
               Inclusion test for rects.
       
               rects are assumed to be both open or both closed.
       
               No invalid rect can include any other rect.
               No invalid rect can be included by any rect.
               Empty (point) rects can include themselves.
               Empty (line) rects can include many (subline) rects.
           """
>>>>>>     return _mupdf.fz_is_rect_inside_rect(inner, outer)
       
    1: def fz_is_rectilinear(m):
           r"""
           Class-aware wrapper for `::fz_is_rectilinear()`.
               Check if a transformation is rectilinear.
       
               Rectilinear means that no shearing is present and that any
               rotations present are a multiple of 90 degrees. Usually this
               is used to make sure that axis-aligned rectangles before the
               transformation are still axis-aligned rectangles afterwards.
           """
>>>>>>     return _mupdf.fz_is_rectilinear(m)
       
    1: def fz_is_tar_archive(file):
           r"""
           Class-aware wrapper for `::fz_is_tar_archive()`.
               Detect if stream object is a tar archive.
       
               Assumes that the stream object is seekable.
           """
>>>>>>     return _mupdf.fz_is_tar_archive(file)
       
    1: def fz_is_valid_blend_colorspace(cs):
           r"""
           Class-aware wrapper for `::fz_is_valid_blend_colorspace()`.
               Check to see that a colorspace is appropriate to be used as
               a blending space (i.e. only grey, rgb or cmyk).
           """
>>>>>>     return _mupdf.fz_is_valid_blend_colorspace(cs)
       
    1: def fz_is_valid_irect(r):
           r"""
           Class-aware wrapper for `::fz_is_valid_irect()`.
               Check if an integer rectangle is valid.
           """
>>>>>>     return _mupdf.fz_is_valid_irect(r)
       
    1: def fz_is_valid_quad(q):
           r"""
           Class-aware wrapper for `::fz_is_valid_quad()`.
               Is a quad valid?
           """
>>>>>>     return _mupdf.fz_is_valid_quad(q)
       
    1: def fz_is_valid_rect(r):
           r"""
           Class-aware wrapper for `::fz_is_valid_rect()`.
               Check if rectangle is valid.
           """
>>>>>>     return _mupdf.fz_is_valid_rect(r)
       
    1: def fz_is_valid_xml_char(c):
           r"""Class-aware wrapper for `::fz_is_valid_xml_char()`."""
>>>>>>     return _mupdf.fz_is_valid_xml_char(c)
       
    1: def fz_is_valid_xml_string(s):
           r"""Class-aware wrapper for `::fz_is_valid_xml_string()`."""
>>>>>>     return _mupdf.fz_is_valid_xml_string(s)
       
    1: def fz_is_zip_archive(file):
           r"""
           Class-aware wrapper for `::fz_is_zip_archive()`.
               Detect if stream object is a zip archive.
       
               Assumes that the stream object is seekable.
           """
>>>>>>     return _mupdf.fz_is_zip_archive(file)
       
    1: def fz_iso8859_1_from_unicode(u):
           r"""Class-aware wrapper for `::fz_iso8859_1_from_unicode()`."""
>>>>>>     return _mupdf.fz_iso8859_1_from_unicode(u)
       
    1: def fz_iso8859_7_from_unicode(u):
           r"""Class-aware wrapper for `::fz_iso8859_7_from_unicode()`."""
>>>>>>     return _mupdf.fz_iso8859_7_from_unicode(u)
       
    1: def fz_jbig2_globals_data(globals):
           r"""
           Class-aware wrapper for `::fz_jbig2_globals_data()`.
               Return buffer containing jbig2 globals data stream.
           """
>>>>>>     return _mupdf.fz_jbig2_globals_data(globals)
       
    1: def fz_json_array_length(array):
           r"""Class-aware wrapper for `::fz_json_array_length()`."""
>>>>>>     return _mupdf.fz_json_array_length(array)
       
    1: def fz_json_array_push(pool, array, item):
           r"""Class-aware wrapper for `::fz_json_array_push()`."""
>>>>>>     return _mupdf.fz_json_array_push(pool, array, item)
       
    1: def fz_json_is_array(json):
           r"""Class-aware wrapper for `::fz_json_is_array()`."""
>>>>>>     return _mupdf.fz_json_is_array(json)
       
    1: def fz_json_is_boolean(json):
           r"""Class-aware wrapper for `::fz_json_is_boolean()`."""
>>>>>>     return _mupdf.fz_json_is_boolean(json)
       
    1: def fz_json_is_null(json):
           r"""Class-aware wrapper for `::fz_json_is_null()`."""
>>>>>>     return _mupdf.fz_json_is_null(json)
       
    1: def fz_json_is_number(json):
           r"""Class-aware wrapper for `::fz_json_is_number()`."""
>>>>>>     return _mupdf.fz_json_is_number(json)
       
    1: def fz_json_is_object(json):
           r"""Class-aware wrapper for `::fz_json_is_object()`."""
>>>>>>     return _mupdf.fz_json_is_object(json)
       
    1: def fz_json_is_string(json):
           r"""Class-aware wrapper for `::fz_json_is_string()`."""
>>>>>>     return _mupdf.fz_json_is_string(json)
       
    1: def fz_json_object_set(pool, object, key, item):
           r"""Class-aware wrapper for `::fz_json_object_set()`."""
>>>>>>     return _mupdf.fz_json_object_set(pool, object, key, item)
       
    1: def fz_json_to_boolean(json):
           r"""Class-aware wrapper for `::fz_json_to_boolean()`."""
>>>>>>     return _mupdf.fz_json_to_boolean(json)
       
    1: def fz_json_to_number(json):
           r"""Class-aware wrapper for `::fz_json_to_number()`."""
>>>>>>     return _mupdf.fz_json_to_number(json)
       
    1: def fz_json_to_string(json):
           r"""Class-aware wrapper for `::fz_json_to_string()`."""
>>>>>>     return _mupdf.fz_json_to_string(json)
       
    1: def fz_koi8u_from_unicode(u):
           r"""Class-aware wrapper for `::fz_koi8u_from_unicode()`."""
>>>>>>     return _mupdf.fz_koi8u_from_unicode(u)
       
    1: def fz_last_page(doc):
           r"""
           Class-aware wrapper for `::fz_last_page()`.
               Function to get the location for the last page in the document.
               Using this can be far more efficient in some cases than calling
               fz_count_pages and using the page number.
           """
>>>>>>     return _mupdf.fz_last_page(doc)
       
    1: def fz_layout_document(doc, w, h, em):
           r"""
           Class-aware wrapper for `::fz_layout_document()`.
               Layout reflowable document types.
       
               w, h: Page size in points.
               em: Default font size in points.
           """
>>>>>>     return _mupdf.fz_layout_document(doc, w, h, em)
       
    1: def fz_linecap_from_string(s):
           r"""Class-aware wrapper for `::fz_linecap_from_string()`."""
>>>>>>     return _mupdf.fz_linecap_from_string(s)
       
    1: def fz_linejoin_from_string(s):
           r"""Class-aware wrapper for `::fz_linejoin_from_string()`."""
>>>>>>     return _mupdf.fz_linejoin_from_string(s)
       
    1: def fz_lineto(path, x, y):
           r"""
           Class-aware wrapper for `::fz_lineto()`.
               Append a 'lineto' command to an open path.
       
               path: The path to modify.
       
               x, y: The coordinate to line to.
       
               Throws exceptions on failure to allocate, or attempting to
               modify a packed path.
           """
>>>>>>     return _mupdf.fz_lineto(path, x, y)
       
    1: def fz_list_archive_entry(arch, idx):
           r"""
           Class-aware wrapper for `::fz_list_archive_entry()`.
               Get listed name of entry position idx.
       
               idx: Must be a value >= 0 < return value from
               fz_count_archive_entries. If not in range NULL will be
               returned.
       
               May throw an exception if this type of archive cannot list the
               entries (such as a directory).
           """
>>>>>>     return _mupdf.fz_list_archive_entry(arch, idx)
       
    1: def fz_load_bmp_subimage(buf, len, subimage):
           r"""Class-aware wrapper for `::fz_load_bmp_subimage()`."""
>>>>>>     return _mupdf.fz_load_bmp_subimage(buf, len, subimage)
       
    1: def fz_load_bmp_subimage_count(buf, len):
           r"""Class-aware wrapper for `::fz_load_bmp_subimage_count()`."""
>>>>>>     return _mupdf.fz_load_bmp_subimage_count(buf, len)
       
    1: def fz_load_chapter_page(doc, chapter, page):
           r"""
           Class-aware wrapper for `::fz_load_chapter_page()`.
               Load a page.
       
               After fz_load_page is it possible to retrieve the size of the
               page using fz_bound_page, or to render the page using
               fz_run_page_*. Free the page by calling fz_drop_page.
       
               chapter: chapter number, 0 is the first chapter of the document.
               number: page number, 0 is the first page of the chapter.
           """
>>>>>>     return _mupdf.fz_load_chapter_page(doc, chapter, page)
       
    1: def fz_load_fallback_font(script, language, serif, bold, italic):
           r"""
           Class-aware wrapper for `::fz_load_fallback_font()`.
               Try to load a fallback font for the
               given combination of font attributes. Whether a font is
               present or not will depend on the configuration in which
               MuPDF is built.
       
               script: The script desired (e.g. UCDN_SCRIPT_KATAKANA).
       
               language: The language desired (e.g. FZ_LANG_ja).
       
               serif: 1 if serif desired, 0 otherwise.
       
               bold: 1 if bold desired, 0 otherwise.
       
               italic: 1 if italic desired, 0 otherwise.
       
               Returns a new font handle, or NULL if not available.
           """
>>>>>>     return _mupdf.fz_load_fallback_font(script, language, serif, bold, italic)
       
    1: def fz_load_jbig2_globals(buf):
           r"""
           Class-aware wrapper for `::fz_load_jbig2_globals()`.
               Create a jbig2 globals record from a buffer.
       
               Immutable once created.
           """
>>>>>>     return _mupdf.fz_load_jbig2_globals(buf)
       
    1: def fz_load_jbig2_subimage(buf, len, subimage):
           r"""Class-aware wrapper for `::fz_load_jbig2_subimage()`."""
>>>>>>     return _mupdf.fz_load_jbig2_subimage(buf, len, subimage)
       
    1: def fz_load_jbig2_subimage_count(buf, len):
           r"""Class-aware wrapper for `::fz_load_jbig2_subimage_count()`."""
>>>>>>     return _mupdf.fz_load_jbig2_subimage_count(buf, len)
       
    1: def fz_load_jpx(data, size, cs):
           r"""
           Class-aware wrapper for `::fz_load_jpx()`.
               Exposed for PDF.
           """
>>>>>>     return _mupdf.fz_load_jpx(data, size, cs)
       
    1: def fz_load_links(page):
           r"""
           Class-aware wrapper for `::fz_load_links()`.
               Load the list of links for a page.
       
               Returns a linked list of all the links on the page, each with
               its clickable region and link destination. Each link is
               reference counted so drop and free the list of links by
               calling fz_drop_link on the pointer return from fz_load_links.
       
               page: Page obtained from fz_load_page.
           """
>>>>>>     return _mupdf.fz_load_links(page)
       
    1: def fz_load_outline(doc):
           r"""
           Class-aware wrapper for `::fz_load_outline()`.
               Load the hierarchical document outline.
       
               Should be freed by fz_drop_outline.
           """
>>>>>>     return _mupdf.fz_load_outline(doc)
       
    1: def fz_load_outline_from_iterator(iter):
           r"""
           Class-aware wrapper for `::fz_load_outline_from_iterator()`.
               Routine to implement the old Structure based API from an iterator.
           """
>>>>>>     return _mupdf.fz_load_outline_from_iterator(iter)
       
    1: def fz_load_page(doc, number):
           r"""
           Class-aware wrapper for `::fz_load_page()`.
               Load a given page number from a document. This may be much less
               efficient than loading by location (chapter+page) for some
               document types.
           """
>>>>>>     return _mupdf.fz_load_page(doc, number)
       
    1: def fz_load_pnm_subimage(buf, len, subimage):
           r"""Class-aware wrapper for `::fz_load_pnm_subimage()`."""
>>>>>>     return _mupdf.fz_load_pnm_subimage(buf, len, subimage)
       
    1: def fz_load_pnm_subimage_count(buf, len):
           r"""Class-aware wrapper for `::fz_load_pnm_subimage_count()`."""
>>>>>>     return _mupdf.fz_load_pnm_subimage_count(buf, len)
       
    1: def fz_load_system_cjk_font(name, ordering, serif):
           r"""
           Class-aware wrapper for `::fz_load_system_cjk_font()`.
               Attempt to load a given font from
               the system.
       
               name: The name of the desired font.
       
               ordering: The ordering to load the font from (e.g. FZ_ADOBE_KOREA)
       
               serif: 1 if serif desired, 0 otherwise.
       
               Returns a new font handle, or NULL if no matching font was found
               (or on error).
           """
>>>>>>     return _mupdf.fz_load_system_cjk_font(name, ordering, serif)
       
    1: def fz_load_system_font(name, bold, italic, needs_exact_metrics):
           r"""
           Class-aware wrapper for `::fz_load_system_font()`.
               Attempt to load a given font from the system.
       
               name: The name of the desired font.
       
               bold: 1 if bold desired, 0 otherwise.
       
               italic: 1 if italic desired, 0 otherwise.
       
               needs_exact_metrics: 1 if an exact metrical match is required,
               0 otherwise.
       
               Returns a new font handle, or NULL if no matching font was found
               (or on error).
           """
>>>>>>     return _mupdf.fz_load_system_font(name, bold, italic, needs_exact_metrics)
       
    1: def fz_load_tiff_subimage(buf, len, subimage):
           r"""Class-aware wrapper for `::fz_load_tiff_subimage()`."""
>>>>>>     return _mupdf.fz_load_tiff_subimage(buf, len, subimage)
       
    1: def fz_load_tiff_subimage_count(buf, len):
           r"""
           Class-aware wrapper for `::fz_load_tiff_subimage_count()`.
               Exposed for CBZ.
           """
>>>>>>     return _mupdf.fz_load_tiff_subimage_count(buf, len)
       
    1: def fz_load_user_css(filename):
           r"""
           Class-aware wrapper for `::fz_load_user_css()`.
               Set the user stylesheet by loading the source from a file.
               If the file is missing, do nothing.
           """
>>>>>>     return _mupdf.fz_load_user_css(filename)
       
    1: def fz_location_from_page_number(doc, number):
           r"""
           Class-aware wrapper for `::fz_location_from_page_number()`.
               Converts from page number to chapter+page. This may cause many
               chapters to be laid out in order to calculate the number of
               pages within those chapters.
           """
>>>>>>     return _mupdf.fz_location_from_page_number(doc, number)
       
    1: def fz_lock(lock):
           r"""
           Class-aware wrapper for `::fz_lock()`.
               Lock one of the user supplied mutexes.
           """
>>>>>>     return _mupdf.fz_lock(lock)
       
    1: def fz_log_error(str):
           r"""
           Class-aware wrapper for `::fz_log_error()`.
               Log a (preformatted) string to the registered
               error stream (stderr by default).
           """
>>>>>>     return _mupdf.fz_log_error(str)
       
    1: def fz_lookup_base14_font(name, len):
           r"""
           Class-aware wrapper for `::fz_lookup_base14_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_lookup_base14_font(const char *name)` => `(const unsigned char *, int len)`
       
               Search the builtin base14 fonts for a match.
               Whether a given font is present or not will depend on the
               configuration in which MuPDF is built.
       
               name: The name of the font desired.
       
               len: Pointer to a place to receive the length of the discovered
               font buffer.
       
               Returns a pointer to the font file data, or NULL if not present.
           """
>>>>>>     return _mupdf.fz_lookup_base14_font(name, len)
       
    1: def fz_lookup_blendmode(name):
           r"""
           Class-aware wrapper for `::fz_lookup_blendmode()`.
               Map from (case sensitive) blend mode string to enumeration.
           """
>>>>>>     return _mupdf.fz_lookup_blendmode(name)
       
    1: def fz_lookup_bookmark(doc, mark):
           r"""
           Class-aware wrapper for `::fz_lookup_bookmark()`.
               Find a bookmark and return its page number.
           """
>>>>>>     return _mupdf.fz_lookup_bookmark(doc, mark)
       
    1: def fz_lookup_builtin_font(name, bold, italic, len):
           r"""
           Class-aware wrapper for `::fz_lookup_builtin_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_lookup_builtin_font(const char *name, int bold, int italic)` => `(const unsigned char *, int len)`
       
               Search the builtin fonts for a match.
               Whether a given font is present or not will depend on the
               configuration in which MuPDF is built.
       
               name: The name of the font desired.
       
               bold: 1 if bold desired, 0 otherwise.
       
               italic: 1 if italic desired, 0 otherwise.
       
               len: Pointer to a place to receive the length of the discovered
               font buffer.
       
               Returns a pointer to the font file data, or NULL if not present.
           """
>>>>>>     return _mupdf.fz_lookup_builtin_font(name, bold, italic, len)
       
    1: def fz_lookup_cjk_font(ordering, len, index):
           r"""
           Class-aware wrapper for `::fz_lookup_cjk_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_lookup_cjk_font(int ordering)` => `(const unsigned char *, int len, int index)`
       
               Search the builtin cjk fonts for a match.
               Whether a font is present or not will depend on the
               configuration in which MuPDF is built.
       
               ordering: The desired ordering of the font (e.g. FZ_ADOBE_KOREA).
       
               len: Pointer to a place to receive the length of the discovered
               font buffer.
       
               Returns a pointer to the font file data, or NULL if not present.
           """
>>>>>>     return _mupdf.fz_lookup_cjk_font(ordering, len, index)
       
    1: def fz_lookup_cjk_font_by_language(lang, len, subfont):
           r"""
           Class-aware wrapper for `::fz_lookup_cjk_font_by_language()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_lookup_cjk_font_by_language(const char *lang)` => `(const unsigned char *, int len, int subfont)`
       
               Search the builtin cjk fonts for a match for a given language.
               Whether a font is present or not will depend on the
               configuration in which MuPDF is built.
       
               lang: Pointer to a (case sensitive) language string (e.g.
               "ja", "ko", "zh-Hant" etc).
       
               len: Pointer to a place to receive the length of the discovered
               font buffer.
       
               subfont: Pointer to a place to store the subfont index of the
               discovered font.
       
               Returns a pointer to the font file data, or NULL if not present.
           """
>>>>>>     return _mupdf.fz_lookup_cjk_font_by_language(lang, len, subfont)
       
    1: def fz_lookup_cjk_ordering_by_language(name):
           r"""
           Class-aware wrapper for `::fz_lookup_cjk_ordering_by_language()`.
               Return the matching FZ_ADOBE_* ordering
               for the given language tag, such as "zh-Hant", "zh-Hans", "ja", or "ko".
           """
>>>>>>     return _mupdf.fz_lookup_cjk_ordering_by_language(name)
       
    1: def fz_lookup_image_type(type):
           r"""
           Class-aware wrapper for `::fz_lookup_image_type()`.
               Map from (case sensitive) image type string to FZ_IMAGE_*
               type value.
           """
>>>>>>     return _mupdf.fz_lookup_image_type(type)
       
    1: def fz_lookup_metadata(doc, key, buf, size):
           r"""
           Class-aware wrapper for `::fz_lookup_metadata()`.
               Retrieve document meta data strings.
       
               doc: The document to query.
       
               key: Which meta data key to retrieve...
       
               Basic information:
                       'format'        -- Document format and version.
                       'encryption'    -- Description of the encryption used.
       
               From the document information dictionary:
                       'info:Title'
                       'info:Author'
                       'info:Subject'
                       'info:Keywords'
                       'info:Creator'
                       'info:Producer'
                       'info:CreationDate'
                       'info:ModDate'
       
               buf: The buffer to hold the results (a nul-terminated UTF-8
               string).
       
               size: Size of 'buf'.
       
               Returns the number of bytes need to store the string plus terminator
               (will be larger than 'size' if the output was truncated), or -1 if the
               key is not recognized or found.
           """
>>>>>>     return _mupdf.fz_lookup_metadata(doc, key, buf, size)
       
    1: def fz_lookup_metadata2(doc, key):
           r"""
           Class-aware wrapper for `::fz_lookup_metadata2()`.
           C++ alternative to `fz_lookup_metadata()` that returns a `std::string`
           or calls `fz_throw()` if not found.
           """
>>>>>>     return _mupdf.fz_lookup_metadata2(doc, key)
       
    1: def fz_lookup_noto_boxes_font(len):
           r"""
           Class-aware wrapper for `::fz_lookup_noto_boxes_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_lookup_noto_boxes_font()` => `(const unsigned char *, int len)`
           """
>>>>>>     return _mupdf.fz_lookup_noto_boxes_font(len)
       
    1: def fz_lookup_noto_emoji_font(len):
           r"""
           Class-aware wrapper for `::fz_lookup_noto_emoji_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_lookup_noto_emoji_font()` => `(const unsigned char *, int len)`
           """
>>>>>>     return _mupdf.fz_lookup_noto_emoji_font(len)
       
    1: def fz_lookup_noto_font(script, lang, len, subfont):
           r"""
           Class-aware wrapper for `::fz_lookup_noto_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_lookup_noto_font(int script, int lang)` => `(const unsigned char *, int len, int subfont)`
       
               Search the builtin noto fonts for a match.
               Whether a font is present or not will depend on the
               configuration in which MuPDF is built.
       
               script: The script desired (e.g. UCDN_SCRIPT_KATAKANA).
       
               lang: The language desired (e.g. FZ_LANG_ja).
       
               len: Pointer to a place to receive the length of the discovered
               font buffer.
       
               Returns a pointer to the font file data, or NULL if not present.
           """
>>>>>>     return _mupdf.fz_lookup_noto_font(script, lang, len, subfont)
       
    1: def fz_lookup_noto_math_font(len):
           r"""
           Class-aware wrapper for `::fz_lookup_noto_math_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_lookup_noto_math_font()` => `(const unsigned char *, int len)`
       
               Search the builtin noto fonts specific symbol fonts.
               Whether a font is present or not will depend on the
               configuration in which MuPDF is built.
           """
>>>>>>     return _mupdf.fz_lookup_noto_math_font(len)
       
    1: def fz_lookup_noto_music_font(len):
           r"""
           Class-aware wrapper for `::fz_lookup_noto_music_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_lookup_noto_music_font()` => `(const unsigned char *, int len)`
           """
>>>>>>     return _mupdf.fz_lookup_noto_music_font(len)
       
    1: def fz_lookup_noto_stem_from_script(script, language):
           r"""
           Class-aware wrapper for `::fz_lookup_noto_stem_from_script()`.
               Look up the Noto font file name for a given script.
               From the returned font stem, you can look for Noto fonts on the system in the form:
                       Noto(Sans|Serif)${STEM}-Regular.(otf|ttf)
           """
>>>>>>     return _mupdf.fz_lookup_noto_stem_from_script(script, language)
       
    1: def fz_lookup_noto_symbol1_font(len):
           r"""
           Class-aware wrapper for `::fz_lookup_noto_symbol1_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_lookup_noto_symbol1_font()` => `(const unsigned char *, int len)`
           """
>>>>>>     return _mupdf.fz_lookup_noto_symbol1_font(len)
       
    1: def fz_lookup_noto_symbol2_font(len):
           r"""
           Class-aware wrapper for `::fz_lookup_noto_symbol2_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_lookup_noto_symbol2_font()` => `(const unsigned char *, int len)`
           """
>>>>>>     return _mupdf.fz_lookup_noto_symbol2_font(len)
       
    1: def fz_lookup_rendering_intent(name):
           r"""
           Class-aware wrapper for `::fz_lookup_rendering_intent()`.
               Map from (case sensitive) rendering intent string to enumeration
               value.
           """
>>>>>>     return _mupdf.fz_lookup_rendering_intent(name)
       
    1: def fz_lookup_script_name(script, language):
           r"""Class-aware wrapper for `::fz_lookup_script_name()`."""
>>>>>>     return _mupdf.fz_lookup_script_name(script, language)
       
    1: def fz_make_bookmark(doc, loc):
           r"""
           Class-aware wrapper for `::fz_make_bookmark()`.
               Create a bookmark for the given page, which can be used to find
               the same location after the document has been laid out with
               different parameters.
           """
>>>>>>     return _mupdf.fz_make_bookmark(doc, loc)
       
    1: def fz_make_irect(x0, y0, x1, y1):
           r"""Class-aware wrapper for `::fz_make_irect()`."""
>>>>>>     return _mupdf.fz_make_irect(x0, y0, x1, y1)
       
    1: def fz_make_location(chapter, page):
           r"""
           Class-aware wrapper for `::fz_make_location()`.
               Simple constructor for fz_locations.
           """
>>>>>>     return _mupdf.fz_make_location(chapter, page)
       
    1: def fz_make_matrix(a, b, c, d, e, f):
           r"""Class-aware wrapper for `::fz_make_matrix()`."""
>>>>>>     return _mupdf.fz_make_matrix(a, b, c, d, e, f)
       
    1: def fz_make_point(x, y):
           r"""Class-aware wrapper for `::fz_make_point()`."""
>>>>>>     return _mupdf.fz_make_point(x, y)
       
    1: def fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y):
           r"""
           Class-aware wrapper for `::fz_make_quad()`.
               Inline convenience construction function.
           """
>>>>>>     return _mupdf.fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y)
       
    1: def fz_make_rect(x0, y0, x1, y1):
           r"""Class-aware wrapper for `::fz_make_rect()`."""
>>>>>>     return _mupdf.fz_make_rect(x0, y0, x1, y1)
       
    1: def fz_malloc(size):
           r"""
           Class-aware wrapper for `::fz_malloc()`.
               Allocate uninitialized memory of a given size.
               Does NOT clear the memory!
       
               May return NULL for size = 0.
       
               Throws exception in the event of failure to allocate.
           """
>>>>>>     return _mupdf.fz_malloc(size)
       
    1: def fz_malloc_aligned(size, align):
           r"""
           Class-aware wrapper for `::fz_malloc_aligned()`.
               fz_malloc equivalent, except that the block is guaranteed aligned.
               Block must be freed later using fz_free_aligned.
           """
>>>>>>     return _mupdf.fz_malloc_aligned(size, align)
       
    1: def fz_malloc_no_throw(size):
           r"""
           Class-aware wrapper for `::fz_malloc_no_throw()`.
               fz_malloc equivalent that returns NULL rather than throwing
               exceptions.
           """
>>>>>>     return _mupdf.fz_malloc_no_throw(size)
       
    1: def fz_matrix_expansion(m):
           r"""
           Class-aware wrapper for `::fz_matrix_expansion()`.
               Calculate average scaling factor of matrix.
           """
>>>>>>     return _mupdf.fz_matrix_expansion(m)
       
    1: def fz_matrix_max_expansion(m):
           r"""
           Class-aware wrapper for `::fz_matrix_max_expansion()`.
               Find the largest expansion performed by this matrix.
               (i.e. max(abs(m.a),abs(m.b),abs(m.c),abs(m.d))
           """
>>>>>>     return _mupdf.fz_matrix_max_expansion(m)
       
    1: def fz_max(a, b):
           r"""Class-aware wrapper for `::fz_max()`."""
>>>>>>     return _mupdf.fz_max(a, b)
       
    1: def fz_maxi(a, b):
           r"""Class-aware wrapper for `::fz_maxi()`."""
>>>>>>     return _mupdf.fz_maxi(a, b)
       
    1: def fz_maxi64(a, b):
           r"""Class-aware wrapper for `::fz_maxi64()`."""
>>>>>>     return _mupdf.fz_maxi64(a, b)
       
    1: def fz_maxz(a, b):
           r"""Class-aware wrapper for `::fz_maxz()`."""
>>>>>>     return _mupdf.fz_maxz(a, b)
       
    1: def fz_md5_buffer(buffer, digest):
           r"""
           Class-aware wrapper for `::fz_md5_buffer()`.
               Create an MD5 digest from buffer contents.
       
               Never throws exceptions.
           """
>>>>>>     return _mupdf.fz_md5_buffer(buffer, digest)
       
    1: def fz_md5_final(state, digest):
           r"""
           Class-aware wrapper for `::fz_md5_final()`.
               MD5 finalization. Ends an MD5 message-digest operation, writing
               the message digest and zeroizing the context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_md5_final(state, digest)
       
    1: def fz_md5_final2(md5):
           r"""
           Class-aware wrapper for `::fz_md5_final2()`.
           C++ alternative to fz_md5_final() that returns the digest by value.
           """
>>>>>>     return _mupdf.fz_md5_final2(md5)
       
    1: def fz_md5_init(state):
           r"""
           Class-aware wrapper for `::fz_md5_init()`.
               MD5 initialization. Begins an MD5 operation, writing a new
               context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_md5_init(state)
       
    1: def fz_md5_pixmap(pixmap, digest):
           r"""Class-aware wrapper for `::fz_md5_pixmap()`."""
>>>>>>     return _mupdf.fz_md5_pixmap(pixmap, digest)
       
    1: def fz_md5_pixmap2(pixmap):
           r"""
           Class-aware wrapper for `::fz_md5_pixmap2()`.
           C++ alternative to `fz_md5_pixmap()` that returns the digest by value.
           """
>>>>>>     return _mupdf.fz_md5_pixmap2(pixmap)
       
    1: def fz_md5_update(state, input, inlen):
           r"""
           Class-aware wrapper for `::fz_md5_update()`.
               MD5 block update operation. Continues an MD5 message-digest
               operation, processing another message block, and updating the
               context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_md5_update(state, input, inlen)
       
    1: def fz_md5_update_int64(state, i):
           r"""
           Class-aware wrapper for `::fz_md5_update_int64()`.
               MD5 block update operation. Continues an MD5 message-digest
               operation, processing an int64, and updating the context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_md5_update_int64(state, i)
       
    1: def fz_measure_string(user_font, trm, s, wmode, bidi_level, markup_dir, language):
           r"""
           Class-aware wrapper for `::fz_measure_string()`.
               Measure the advance width of a UTF8 string should it be added to a text object.
       
               This uses the same layout algorithms as fz_show_string, and can be used
               to calculate text alignment adjustments.
           """
>>>>>>     return _mupdf.fz_measure_string(user_font, trm, s, wmode, bidi_level, markup_dir, language)
       
    1: def fz_memmem(haystack, haystacklen, needle, needlelen):
           r"""
           Class-aware wrapper for `::fz_memmem()`.
               Find the start of the first occurrence of the substring needle in haystack.
           """
>>>>>>     return _mupdf.fz_memmem(haystack, haystacklen, needle, needlelen)
       
    1: def fz_memrnd(block, len):
           r"""
           Class-aware wrapper for `::fz_memrnd()`.
               Fill block with len bytes of pseudo-randomness.
           """
>>>>>>     return _mupdf.fz_memrnd(block, len)
       
    1: def fz_min(a, b):
           r"""Class-aware wrapper for `::fz_min()`."""
>>>>>>     return _mupdf.fz_min(a, b)
       
    1: def fz_mini(a, b):
           r"""Class-aware wrapper for `::fz_mini()`."""
>>>>>>     return _mupdf.fz_mini(a, b)
       
    1: def fz_mini64(a, b):
           r"""Class-aware wrapper for `::fz_mini64()`."""
>>>>>>     return _mupdf.fz_mini64(a, b)
       
    1: def fz_minz(a, b):
           r"""Class-aware wrapper for `::fz_minz()`."""
>>>>>>     return _mupdf.fz_minz(a, b)
       
    1: def fz_mkdir(path):
           r"""Class-aware wrapper for `::fz_mkdir()`."""
>>>>>>     return _mupdf.fz_mkdir(path)
       
    1: def fz_morph_error(fromcode, tocode):
           r"""
           Class-aware wrapper for `::fz_morph_error()`.
               Called within a catch block this modifies the current
               exception's code. If it's of type 'fromcode' it is
               modified to 'tocode'. Typically used for 'downgrading'
               exception severity.
           """
>>>>>>     return _mupdf.fz_morph_error(fromcode, tocode)
       
    1: def fz_mount_multi_archive(arch_, sub, path):
           r"""
           Class-aware wrapper for `::fz_mount_multi_archive()`.
               Add an archive to the set of archives handled by a multi
               archive.
       
               If path is NULL, then the archive contents will appear at the
               top level, otherwise, the archives contents will appear prefixed
               by path.
           """
>>>>>>     return _mupdf.fz_mount_multi_archive(arch_, sub, path)
       
    1: def fz_moveto(path, x, y):
           r"""
           Class-aware wrapper for `::fz_moveto()`.
               Append a 'moveto' command to a path.
               This 'opens' a path.
       
               path: The path to modify.
       
               x, y: The coordinate to move to.
       
               Throws exceptions on failure to allocate, or attempting to
               modify a packed path.
           """
>>>>>>     return _mupdf.fz_moveto(path, x, y)
       
    1: def fz_mul255(a, b):
           r"""
           Class-aware wrapper for `::fz_mul255()`.
               Multiply scaled two integers in the 0..255 range
           """
>>>>>>     return _mupdf.fz_mul255(a, b)
       
    1: def fz_needs_password(doc):
           r"""
           Class-aware wrapper for `::fz_needs_password()`.
               Check if a document is encrypted with a
               non-blank password.
           """
>>>>>>     return _mupdf.fz_needs_password(doc)
       
    1: def fz_new_archive_of_size(file, size):
           r"""Class-aware wrapper for `::fz_new_archive_of_size()`."""
>>>>>>     return _mupdf.fz_new_archive_of_size(file, size)
       
    1: def fz_new_barcode_image(type, value, size, ec_level, quiet, hrt):
           r"""
           Class-aware wrapper for `::fz_new_barcode_image()`.
               Create an fz_image from a barcode definition.
       
               type: The type of barcode to create.
               value: The value of the barcode.
               size: The size of the barcode.
               ec_level: error correction level 0-8.
               quiet: whether to include quiet zones (0 or 1).
               hrt: whether to include human readable text below the barcode (0 or 1).
       
               returns a created fz_image.
           """
>>>>>>     return _mupdf.fz_new_barcode_image(type, value, size, ec_level, quiet, hrt)
       
    1: def fz_new_barcode_pixmap(type, value, size, ec_level, quiet, hrt):
           r"""
           Class-aware wrapper for `::fz_new_barcode_pixmap()`.
               Create an fz_pixmap from a barcode definition.
       
               type: The type of barcode to create.
               value: The value of the barcode.
               size: The size of the barcode.
               ec_level: error correction level 0-8.
               quiet: whether to include quiet zones (0 or 1).
               hrt: whether to include human readable text below the barcode (0 or 1).
       
               returns a created fz_pixmap.
           """
>>>>>>     return _mupdf.fz_new_barcode_pixmap(type, value, size, ec_level, quiet, hrt)
       
    1: def fz_new_base14_font(name):
           r"""
           Class-aware wrapper for `::fz_new_base14_font()`.
               Create a new font from one of the built-in fonts.
           """
>>>>>>     return _mupdf.fz_new_base14_font(name)
       
    1: def fz_new_bbox_device(rectp):
           r"""
           Class-aware wrapper for `::fz_new_bbox_device()`.
               Create a device to compute the bounding
               box of all marks on a page.
       
               The returned bounding box will be the union of all bounding
               boxes of all objects on a page.
           """
>>>>>>     return _mupdf.fz_new_bbox_device(rectp)
       
    1: def fz_new_bitmap(w, h, n, xres, yres):
           r"""
           Class-aware wrapper for `::fz_new_bitmap()`.
               Create a new bitmap.
       
               w, h: Width and Height for the bitmap
       
               n: Number of color components (assumed to be a divisor of 8)
       
               xres, yres: X and Y resolutions (in pixels per inch).
       
               Returns pointer to created bitmap structure. The bitmap
               data is uninitialised.
           """
>>>>>>     return _mupdf.fz_new_bitmap(w, h, n, xres, yres)
       
    1: def fz_new_bitmap_from_image(img, ht):
           r"""
           Class-aware wrapper for `::fz_new_bitmap_from_image()`.
               Make a bitmap from a pixmap and a halftone.
       
               img: The image to generate from. Currently must be a single
               color component with no alpha.
       
               ht: The halftone to use. NULL implies the default halftone.
       
               Returns the resultant bitmap. Throws exceptions in the case of
               failure to allocate.
           """
>>>>>>     return _mupdf.fz_new_bitmap_from_image(img, ht)
       
    1: def fz_new_bitmap_from_pixmap(pix, ht):
           r"""
           Class-aware wrapper for `::fz_new_bitmap_from_pixmap()`.
               Make a bitmap from a pixmap and a halftone.
       
               pix: The pixmap to generate from. Currently must be a single
               color component with no alpha.
       
               ht: The halftone to use. NULL implies the default halftone.
       
               Returns the resultant bitmap. Throws exceptions in the case of
               failure to allocate.
           """
>>>>>>     return _mupdf.fz_new_bitmap_from_pixmap(pix, ht)
       
    1: def fz_new_bitmap_from_pixmap_band(pix, ht, band_start):
           r"""
           Class-aware wrapper for `::fz_new_bitmap_from_pixmap_band()`.
               Make a bitmap from a pixmap and a
               halftone, allowing for the position of the pixmap within an
               overall banded rendering.
       
               pix: The pixmap to generate from. Currently must be a single
               color component with no alpha.
       
               ht: The halftone to use. NULL implies the default halftone.
       
               band_start: Vertical offset within the overall banded rendering
               (in pixels)
       
               Returns the resultant bitmap. Throws exceptions in the case of
               failure to allocate.
           """
>>>>>>     return _mupdf.fz_new_bitmap_from_pixmap_band(pix, ht, band_start)
       
    1: def fz_new_brotli_data(compressed_length, source, source_length, level):
           r"""
            Class-aware wrapper for `::fz_new_brotli_data()`.
       
               This function has out-params. Python/C# wrappers look like:
                       `fz_new_brotli_data(const unsigned char *source, size_t source_length, ::fz_brotli_level level)` => `(unsigned char *, size_t compressed_length)`
       
                       Compress source_length bytes of data starting
                       at source, into a new memory block malloced for that purpose.
           compressed_length is updated on exit to contain the size used.
                       Ownership of the block is returned from this function, and the
                       caller is therefore responsible for freeing it. The block may be
                       considerably larger than is actually required. The caller is
                       free to fz_realloc it down if it wants to.
           """
>>>>>>     return _mupdf.fz_new_brotli_data(compressed_length, source, source_length, level)
       
    1: def fz_new_brotli_data_from_buffer(compressed_length, buffer, level):
           r"""
           Class-aware wrapper for `::fz_new_brotli_data_from_buffer()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_new_brotli_data_from_buffer(::fz_buffer *buffer, ::fz_brotli_level level)` => `(unsigned char *, size_t compressed_length)`
       
               Compress the contents of a fz_buffer into a
               new block malloced for that purpose. *compressed_length is
               updated on exit to contain the size used. Ownership of the block
               is returned from this function, and the caller is therefore
               responsible for freeing it. The block may be considerably larger
               than is actually required. The caller is free to fz_realloc it
               down if it wants to.
           """
>>>>>>     return _mupdf.fz_new_brotli_data_from_buffer(compressed_length, buffer, level)
       
    1: def fz_new_buffer(capacity):
           r"""Class-aware wrapper for `::fz_new_buffer()`."""
>>>>>>     return _mupdf.fz_new_buffer(capacity)
       
    1: def fz_new_buffer_from_base64(data, size):
           r"""
           Class-aware wrapper for `::fz_new_buffer_from_base64()`.
               Create a new buffer with data decoded from a base64 input string.
           """
>>>>>>     return _mupdf.fz_new_buffer_from_base64(data, size)
       
    1: def fz_new_buffer_from_copied_data(data, size):
           r"""
           Class-aware wrapper for `::fz_new_buffer_from_copied_data()`.
               Create a new buffer containing a copy of the passed data.
           """
>>>>>>     return _mupdf.fz_new_buffer_from_copied_data(data, size)
       
    1: def fz_new_buffer_from_data(data, size):
           r"""
           Class-aware wrapper for `::fz_new_buffer_from_data()`.
               Create a new buffer with existing data.
       
               data: Pointer to existing data.
               size: Size of existing data.
       
               Takes ownership of data. Does not make a copy. Calls fz_free on
               the data when the buffer is deallocated. Do not use 'data' after
               passing to this function.
       
               Returns pointer to new buffer. Throws exception on allocation
               failure.
           """
>>>>>>     return _mupdf.fz_new_buffer_from_data(data, size)
       
    1: def fz_new_buffer_from_display_list(list, options):
           r"""Class-aware wrapper for `::fz_new_buffer_from_display_list()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_display_list(list, options)
       
    1: def fz_new_buffer_from_image_as_jpeg(image, color_params, quality, invert_cmyk):
           r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_jpeg()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_image_as_jpeg(image, color_params, quality, invert_cmyk)
       
    1: def fz_new_buffer_from_image_as_jpx(image, color_params, quality):
           r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_jpx()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_image_as_jpx(image, color_params, quality)
       
    1: def fz_new_buffer_from_image_as_pam(image, color_params):
           r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pam()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_image_as_pam(image, color_params)
       
    1: def fz_new_buffer_from_image_as_pbm(image, color_params):
           r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pbm()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_image_as_pbm(image, color_params)
       
    1: def fz_new_buffer_from_image_as_pkm(image, color_params):
           r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pkm()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_image_as_pkm(image, color_params)
       
    1: def fz_new_buffer_from_image_as_png(image, color_params):
           r"""
           Class-aware wrapper for `::fz_new_buffer_from_image_as_png()`.
               Re-encode a given image as a PNG into a buffer.
       
               Ownership of the buffer is returned.
           """
>>>>>>     return _mupdf.fz_new_buffer_from_image_as_png(image, color_params)
       
    1: def fz_new_buffer_from_image_as_pnm(image, color_params):
           r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_pnm()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_image_as_pnm(image, color_params)
       
    1: def fz_new_buffer_from_image_as_psd(image, color_params):
           r"""Class-aware wrapper for `::fz_new_buffer_from_image_as_psd()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_image_as_psd(image, color_params)
       
    1: def fz_new_buffer_from_page(page, options):
           r"""Class-aware wrapper for `::fz_new_buffer_from_page()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_page(page, options)
       
    1: def fz_new_buffer_from_page_number(doc, number, options):
           r"""Class-aware wrapper for `::fz_new_buffer_from_page_number()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_page_number(doc, number, options)
       
    1: def fz_new_buffer_from_page_with_format(page, format, options, transform, cookie):
           r"""
           Class-aware wrapper for `::fz_new_buffer_from_page_with_format()`.
               Returns an fz_buffer containing a page after conversion to specified format.
       
               page: The page to convert.
               format, options: Passed to fz_new_document_writer_with_output() internally.
               transform, cookie: Passed to fz_run_page() internally.
           """
>>>>>>     return _mupdf.fz_new_buffer_from_page_with_format(page, format, options, transform, cookie)
       
    1: def fz_new_buffer_from_pixmap_as_jpeg(pixmap, color_params, quality, invert_cmyk):
           r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpeg()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_pixmap_as_jpeg(pixmap, color_params, quality, invert_cmyk)
       
    1: def fz_new_buffer_from_pixmap_as_jpx(pix, color_params, quality):
           r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpx()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_pixmap_as_jpx(pix, color_params, quality)
       
    1: def fz_new_buffer_from_pixmap_as_pam(pixmap, color_params):
           r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pam()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_pixmap_as_pam(pixmap, color_params)
       
    1: def fz_new_buffer_from_pixmap_as_pbm(pixmap, color_params):
           r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pbm()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_pixmap_as_pbm(pixmap, color_params)
       
    1: def fz_new_buffer_from_pixmap_as_pkm(pixmap, color_params):
           r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pkm()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_pixmap_as_pkm(pixmap, color_params)
       
    1: def fz_new_buffer_from_pixmap_as_png(pixmap, color_params):
           r"""
           Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_png()`.
               Re-encode a given pixmap as a PNG into a buffer.
       
               Ownership of the buffer is returned.
           """
>>>>>>     return _mupdf.fz_new_buffer_from_pixmap_as_png(pixmap, color_params)
       
    1: def fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params):
           r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params)
       
    1: def fz_new_buffer_from_pixmap_as_psd(pix, color_params):
           r"""Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_psd()`."""
>>>>>>     return _mupdf.fz_new_buffer_from_pixmap_as_psd(pix, color_params)
       
    1: def fz_new_buffer_from_shared_data(data, size):
           r"""
           Class-aware wrapper for `::fz_new_buffer_from_shared_data()`.
               Like fz_new_buffer, but does not take ownership.
           """
>>>>>>     return _mupdf.fz_new_buffer_from_shared_data(data, size)
       
    1: def fz_new_buffer_from_stext_page(text):
           r"""
           Class-aware wrapper for `::fz_new_buffer_from_stext_page()`.
               Convert structured text into plain text.
           """
>>>>>>     return _mupdf.fz_new_buffer_from_stext_page(text)
       
    1: def fz_new_builtin_font(name, is_bold, is_italic):
           r"""Class-aware wrapper for `::fz_new_builtin_font()`."""
>>>>>>     return _mupdf.fz_new_builtin_font(name, is_bold, is_italic)
       
    1: def fz_new_cal_gray_colorspace(wp, bp, gamma):
           r"""
           Class-aware wrapper for `::fz_new_cal_gray_colorspace()`.
               Create a calibrated gray colorspace.
       
               The returned reference should be dropped when it is finished
               with.
       
               Colorspaces are immutable once created.
           """
>>>>>>     return _mupdf.fz_new_cal_gray_colorspace(wp, bp, gamma)
       
    1: def fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix):
           r"""
           Class-aware wrapper for `::fz_new_cal_rgb_colorspace()`.
               Create a calibrated rgb colorspace.
       
               The returned reference should be dropped when it is finished
               with.
       
               Colorspaces are immutable once created.
           """
>>>>>>     return _mupdf.fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix)
       
    1: def fz_new_cjk_font(ordering):
           r"""Class-aware wrapper for `::fz_new_cjk_font()`."""
>>>>>>     return _mupdf.fz_new_cjk_font(ordering)
       
    1: def fz_new_colorspace(type, flags, n, name):
           r"""
           Class-aware wrapper for `::fz_new_colorspace()`.
               Creates a new colorspace instance and returns a reference.
       
               No internal checking is done that the colorspace type (e.g.
               CMYK) matches with the flags (e.g. FZ_COLORSPACE_HAS_CMYK) or
               colorant count (n) or name.
       
               The reference should be dropped when it is finished with.
       
               Colorspaces are immutable once created (with the exception of
               setting up colorant names for separation spaces).
           """
>>>>>>     return _mupdf.fz_new_colorspace(type, flags, n, name)
       
    1: def fz_new_compressed_buffer():
           r"""
           Class-aware wrapper for `::fz_new_compressed_buffer()`.
               Create a new, UNKNOWN format, compressed_buffer.
           """
>>>>>>     return _mupdf.fz_new_compressed_buffer()
       
    1: def fz_new_default_colorspaces():
           r"""
           Class-aware wrapper for `::fz_new_default_colorspaces()`.
               Create a new default colorspace structure with values inherited
               from the context, and return a reference to it.
       
               These can be overridden using fz_set_default_xxxx.
       
               These should not be overridden while more than one caller has
               the reference for fear of race conditions.
       
               The caller should drop this reference once finished with it.
           """
>>>>>>     return _mupdf.fz_new_default_colorspaces()
       
    1: def fz_new_deflated_data(compressed_length, source, source_length, level):
           r"""
            Class-aware wrapper for `::fz_new_deflated_data()`.
       
               This function has out-params. Python/C# wrappers look like:
                       `fz_new_deflated_data(const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`
       
                       Compress source_length bytes of data starting
                       at source, into a new memory block malloced for that purpose.
           compressed_length is updated on exit to contain the size used.
                       Ownership of the block is returned from this function, and the
                       caller is therefore responsible for freeing it. The block may be
                       considerably larger than is actually required. The caller is
                       free to fz_realloc it down if it wants to.
           """
>>>>>>     return _mupdf.fz_new_deflated_data(compressed_length, source, source_length, level)
       
    1: def fz_new_deflated_data_from_buffer(compressed_length, buffer, level):
           r"""
           Class-aware wrapper for `::fz_new_deflated_data_from_buffer()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_new_deflated_data_from_buffer(::fz_buffer *buffer, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`
       
               Compress the contents of a fz_buffer into a
               new block malloced for that purpose. *compressed_length is
               updated on exit to contain the size used. Ownership of the block
               is returned from this function, and the caller is therefore
               responsible for freeing it. The block may be considerably larger
               than is actually required. The caller is free to fz_realloc it
               down if it wants to.
           """
>>>>>>     return _mupdf.fz_new_deflated_data_from_buffer(compressed_length, buffer, level)
       
    1: def fz_new_device_of_size(size):
           r"""
           Class-aware wrapper for `::fz_new_device_of_size()`.
               Devices are created by calls to device implementations, for
               instance: foo_new_device(). These will be implemented by calling
               fz_new_derived_device(ctx, foo_device) where foo_device is a
               structure "derived from" fz_device, for instance
               typedef struct { fz_device base;  ...extras...} foo_device;
           """
>>>>>>     return _mupdf.fz_new_device_of_size(size)
       
    1: def fz_new_display_list(mediabox):
           r"""
           Class-aware wrapper for `::fz_new_display_list()`.
               Create an empty display list.
       
               A display list contains drawing commands (text, images, etc.).
               Use fz_new_list_device for populating the list.
       
               mediabox: Bounds of the page (in points) represented by the
               display list.
           """
>>>>>>     return _mupdf.fz_new_display_list(mediabox)
       
    1: def fz_new_display_list_from_page(page):
           r"""
           Class-aware wrapper for `::fz_new_display_list_from_page()`.
               Create a display list.
       
               Ownership of the display list is returned to the caller.
           """
>>>>>>     return _mupdf.fz_new_display_list_from_page(page)
       
    1: def fz_new_display_list_from_page_contents(page):
           r"""
           Class-aware wrapper for `::fz_new_display_list_from_page_contents()`.
               Create a display list from page contents (no annotations).
       
               Ownership of the display list is returned to the caller.
           """
>>>>>>     return _mupdf.fz_new_display_list_from_page_contents(page)
       
    1: def fz_new_display_list_from_page_number(doc, number):
           r"""Class-aware wrapper for `::fz_new_display_list_from_page_number()`."""
>>>>>>     return _mupdf.fz_new_display_list_from_page_number(doc, number)
       
    1: def fz_new_display_list_from_svg(buf, base_uri, dir, w, h):
           r"""
           Class-aware wrapper for `::fz_new_display_list_from_svg()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_new_display_list_from_svg(::fz_buffer *buf, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`
       
               Parse an SVG document into a display-list.
           """
>>>>>>     return _mupdf.fz_new_display_list_from_svg(buf, base_uri, dir, w, h)
       
    1: def fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir, w, h):
           r"""
           Class-aware wrapper for `::fz_new_display_list_from_svg_xml()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_new_display_list_from_svg_xml(::fz_xml_doc *xmldoc, ::fz_xml *xml, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`
       
               Parse an SVG document into a display-list.
           """
>>>>>>     return _mupdf.fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir, w, h)
       
    1: def fz_new_document_of_size(size):
           r"""
           Class-aware wrapper for `::fz_new_document_of_size()`.
               New documents are typically created by calls like
               foo_new_document(fz_context *ctx, ...). These work by
               deriving a new document type from fz_document, for instance:
               typedef struct { fz_document base; ...extras... } foo_document;
               These are allocated by calling
               fz_new_derived_document(ctx, foo_document)
           """
>>>>>>     return _mupdf.fz_new_document_of_size(size)
       
    1: def fz_new_dom(tag):
           r"""
           Class-aware wrapper for `::fz_new_dom()`.
               Make new xml dom root element.
           """
>>>>>>     return _mupdf.fz_new_dom(tag)
       
    1: def fz_new_dom_node(dom, tag):
           r"""
           Class-aware wrapper for `::fz_new_dom_node()`.
               Create a new dom node.
       
               This will NOT be linked in yet.
           """
>>>>>>     return _mupdf.fz_new_dom_node(dom, tag)
       
    1: def fz_new_dom_text_node(dom, text):
           r"""
           Class-aware wrapper for `::fz_new_dom_text_node()`.
               Create a new dom text node.
       
               This will NOT be linked in yet.
           """
>>>>>>     return _mupdf.fz_new_dom_text_node(dom, text)
       
    1: def fz_new_draw_device(transform, dest):
           r"""
           Class-aware wrapper for `::fz_new_draw_device()`.
               Create a device to draw on a pixmap.
       
               dest: Target pixmap for the draw device. See fz_new_pixmap*
               for how to obtain a pixmap. The pixmap is not cleared by the
               draw device, see fz_clear_pixmap* for how to clear it prior to
               calling fz_new_draw_device. Free the device by calling
               fz_drop_device.
       
               transform: Transform from user space in points to device space
               in pixels.
           """
>>>>>>     return _mupdf.fz_new_draw_device(transform, dest)
       
    1: def fz_new_draw_device_type3(transform, dest):
           r"""Class-aware wrapper for `::fz_new_draw_device_type3()`."""
>>>>>>     return _mupdf.fz_new_draw_device_type3(transform, dest)
       
    1: def fz_new_draw_device_with_bbox(transform, dest, clip):
           r"""
           Class-aware wrapper for `::fz_new_draw_device_with_bbox()`.
               Create a device to draw on a pixmap.
       
               dest: Target pixmap for the draw device. See fz_new_pixmap*
               for how to obtain a pixmap. The pixmap is not cleared by the
               draw device, see fz_clear_pixmap* for how to clear it prior to
               calling fz_new_draw_device. Free the device by calling
               fz_drop_device.
       
               transform: Transform from user space in points to device space
               in pixels.
       
               clip: Bounding box to restrict any marking operations of the
               draw device.
           """
>>>>>>     return _mupdf.fz_new_draw_device_with_bbox(transform, dest, clip)
       
    1: def fz_new_draw_device_with_bbox_proof(transform, dest, clip, cs):
           r"""
           Class-aware wrapper for `::fz_new_draw_device_with_bbox_proof()`.
               Create a device to draw on a pixmap.
       
               dest: Target pixmap for the draw device. See fz_new_pixmap*
               for how to obtain a pixmap. The pixmap is not cleared by the
               draw device, see fz_clear_pixmap* for how to clear it prior to
               calling fz_new_draw_device. Free the device by calling
               fz_drop_device.
       
               transform: Transform from user space in points to device space
               in pixels.
       
               clip: Bounding box to restrict any marking operations of the
               draw device.
       
               proof_cs: Color space to render to prior to mapping to color
               space defined by pixmap.
           """
>>>>>>     return _mupdf.fz_new_draw_device_with_bbox_proof(transform, dest, clip, cs)
       
    1: def fz_new_draw_device_with_options(options, mediabox, pixmap):
           r"""
           Class-aware wrapper for `::fz_new_draw_device_with_options()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_new_draw_device_with_options(const ::fz_draw_options *options, ::fz_rect mediabox, ::fz_pixmap **pixmap)` => `(fz_device *)`
       
               Create a new pixmap and draw device, using the specified options.
       
               options: Options to configure the draw device, and choose the
               resolution and colorspace.
       
               mediabox: The bounds of the page in points.
       
               pixmap: An out parameter containing the newly created pixmap.
           """
>>>>>>     return _mupdf.fz_new_draw_device_with_options(options, mediabox, pixmap)
       
    1: def fz_new_draw_device_with_proof(transform, dest, proof_cs):
           r"""
           Class-aware wrapper for `::fz_new_draw_device_with_proof()`.
               Create a device to draw on a pixmap.
       
               dest: Target pixmap for the draw device. See fz_new_pixmap*
               for how to obtain a pixmap. The pixmap is not cleared by the
               draw device, see fz_clear_pixmap* for how to clear it prior to
               calling fz_new_draw_device. Free the device by calling
               fz_drop_device.
       
               transform: Transform from user space in points to device space
               in pixels.
       
               proof_cs: Intermediate color space to map though when mapping to
               color space defined by pixmap.
           """
>>>>>>     return _mupdf.fz_new_draw_device_with_proof(transform, dest, proof_cs)
       
    1: def fz_new_font_from_buffer(name, buffer, index, use_glyph_bbox):
           r"""
           Class-aware wrapper for `::fz_new_font_from_buffer()`.
               Create a new font from a font file in a fz_buffer.
       
               Fonts created in this way, will be eligible for embedding by default.
       
               name: Name of font (leave NULL to use name from font).
       
               buffer: Buffer to load from.
       
               index: Which font from the file to load (0 for default).
       
               use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.
       
               Returns new font handle, or throws exception on error.
           """
>>>>>>     return _mupdf.fz_new_font_from_buffer(name, buffer, index, use_glyph_bbox)
       
    1: def fz_new_font_from_file(name, path, index, use_glyph_bbox):
           r"""
           Class-aware wrapper for `::fz_new_font_from_file()`.
               Create a new font from a font file.
       
               Fonts created in this way, will be eligible for embedding by default.
       
               name: Name of font (leave NULL to use name from font).
       
               path: File path to load from.
       
               index: Which font from the file to load (0 for default).
       
               use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.
       
               Returns new font handle, or throws exception on error.
           """
>>>>>>     return _mupdf.fz_new_font_from_file(name, path, index, use_glyph_bbox)
       
    1: def fz_new_font_from_memory(name, data, len, index, use_glyph_bbox):
           r"""
           Class-aware wrapper for `::fz_new_font_from_memory()`.
               Create a new font from a font file in memory.
       
               Fonts created in this way, will be eligible for embedding by default.
       
               name: Name of font (leave NULL to use name from font).
       
               data: Pointer to the font file data.
       
               len: Length of the font file data.
       
               index: Which font from the file to load (0 for default).
       
               use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.
       
               Returns new font handle, or throws exception on error.
           """
>>>>>>     return _mupdf.fz_new_font_from_memory(name, data, len, index, use_glyph_bbox)
       
    1: def fz_new_function_of_size(size, size2, m, n, eval, drop):
           r"""Class-aware wrapper for `::fz_new_function_of_size()`."""
>>>>>>     return _mupdf.fz_new_function_of_size(size, size2, m, n, eval, drop)
       
    1: def fz_new_icc_colorspace(type, flags, name, buf):
           r"""
           Class-aware wrapper for `::fz_new_icc_colorspace()`.
               Create a colorspace from an ICC profile supplied in buf.
       
               Limited checking is done to ensure that the colorspace type is
               appropriate for the supplied ICC profile.
       
               An additional reference is taken to buf, which will be dropped
               on destruction. Ownership is NOT passed in.
       
               The returned reference should be dropped when it is finished
               with.
       
               Colorspaces are immutable once created.
           """
>>>>>>     return _mupdf.fz_new_icc_colorspace(type, flags, name, buf)
       
    1: def fz_new_image_from_buffer(buffer):
           r"""
           Class-aware wrapper for `::fz_new_image_from_buffer()`.
               Create a new image from a
               buffer of data, inferring its type from the format
               of the data.
           """
>>>>>>     return _mupdf.fz_new_image_from_buffer(buffer)
       
    1: def fz_new_image_from_compressed_buffer(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask):
           r"""
           Class-aware wrapper for `::fz_new_image_from_compressed_buffer()`.
               Create an image based on
               the data in the supplied compressed buffer.
       
               w,h: Width and height of the created image.
       
               bpc: Bits per component.
       
               colorspace: The colorspace (determines the number of components,
               and any color conversions required while decoding).
       
               xres, yres: The X and Y resolutions respectively.
       
               interpolate: 1 if interpolation should be used when decoding
               this image, 0 otherwise.
       
               imagemask: 1 if this is an imagemask (i.e. transparency bitmap
               mask), 0 otherwise.
       
               decode: NULL, or a pointer to to a decode array. The default
               decode array is [0 1] (repeated n times, for n color components).
       
               colorkey: NULL, or a pointer to a colorkey array. The default
               colorkey array is [0 255] (repeated n times, for n color
               components).
       
               buffer: Buffer of compressed data and compression parameters.
               Ownership of this reference is passed in.
       
               mask: NULL, or another image to use as a mask for this one.
               A new reference is taken to this image. Supplying a masked
               image as a mask to another image is illegal!
           """
>>>>>>     return _mupdf.fz_new_image_from_compressed_buffer(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask)
       
    1: def fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask):
           r"""
           Class-aware wrapper for `::fz_new_image_from_compressed_buffer2()`.   Swig-friendly wrapper for fz_new_image_from_compressed_buffer(),
           uses specified `decode` and `colorkey` if they are not null (in which
           case we assert that they have size `2*fz_colorspace_n(colorspace)`).
           """
>>>>>>     return _mupdf.fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask)
       
    1: def fz_new_image_from_display_list(w, h, list):
           r"""
           Class-aware wrapper for `::fz_new_image_from_display_list()`.
               Create a new image from a display list.
       
               w, h: The conceptual width/height of the image.
       
               transform: The matrix that needs to be applied to the given
               list to make it render to the unit square.
       
               list: The display list.
           """
>>>>>>     return _mupdf.fz_new_image_from_display_list(w, h, list)
       
    1: def fz_new_image_from_file(path):
           r"""
           Class-aware wrapper for `::fz_new_image_from_file()`.
               Create a new image from the contents
               of a file, inferring its type from the format of the
               data.
           """
>>>>>>     return _mupdf.fz_new_image_from_file(path)
       
    1: def fz_new_image_from_pixmap(pixmap, mask):
           r"""
           Class-aware wrapper for `::fz_new_image_from_pixmap()`.
               Create an image from the given
               pixmap.
       
               pixmap: The pixmap to base the image upon. A new reference
               to this is taken.
       
               mask: NULL, or another image to use as a mask for this one.
               A new reference is taken to this image. Supplying a masked
               image as a mask to another image is illegal!
           """
>>>>>>     return _mupdf.fz_new_image_from_pixmap(pixmap, mask)
       
    1: def fz_new_image_from_svg(buf, base_uri, dir):
           r"""
           Class-aware wrapper for `::fz_new_image_from_svg()`.
               Create a scalable image from an SVG document.
           """
>>>>>>     return _mupdf.fz_new_image_from_svg(buf, base_uri, dir)
       
    1: def fz_new_image_from_svg_xml(xmldoc, xml, base_uri, dir):
           r"""
           Class-aware wrapper for `::fz_new_image_from_svg_xml()`.
               Create a scalable image from an SVG document.
           """
>>>>>>     return _mupdf.fz_new_image_from_svg_xml(xmldoc, xml, base_uri, dir)
       
    1: def fz_new_image_of_size(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, mask, size, get_pixmap, get_size, drop):
           r"""
           Class-aware wrapper for `::fz_new_image_of_size()`.
               Internal function to make a new fz_image structure
               for a derived class.
       
               w,h: Width and height of the created image.
       
               bpc: Bits per component.
       
               colorspace: The colorspace (determines the number of components,
               and any color conversions required while decoding).
       
               xres, yres: The X and Y resolutions respectively.
       
               interpolate: 1 if interpolation should be used when decoding
               this image, 0 otherwise.
       
               imagemask: 1 if this is an imagemask (i.e. transparent), 0
               otherwise.
       
               decode: NULL, or a pointer to to a decode array. The default
               decode array is [0 1] (repeated n times, for n color components).
       
               colorkey: NULL, or a pointer to a colorkey array. The default
               colorkey array is [0 255] (repeated n times, for n color
               components).
       
               mask: NULL, or another image to use as a mask for this one.
               A new reference is taken to this image. Supplying a masked
               image as a mask to another image is illegal!
       
               size: The size of the required allocated structure (the size of
               the derived structure).
       
               get: The function to be called to obtain a decoded pixmap.
       
               get_size: The function to be called to return the storage size
               used by this image.
       
               drop: The function to be called to dispose of this image once
               the last reference is dropped.
       
               Returns a pointer to an allocated structure of the required size,
               with the first sizeof(fz_image) bytes initialised as appropriate
               given the supplied parameters, and the other bytes set to zero.
           """
>>>>>>     return _mupdf.fz_new_image_of_size(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, mask, size, get_pixmap, get_size, drop)
       
    1: def fz_new_indexed_colorspace(base, high, lookup):
           r"""
           Class-aware wrapper for `::fz_new_indexed_colorspace()`.
               Create an indexed colorspace.
       
               The supplied lookup table is high palette entries long. Each
               entry is n bytes long, where n is given by the number of
               colorants in the base colorspace, one byte per colorant.
       
               Ownership of lookup is passed it; it will be freed on
               destruction, so must be heap allocated.
       
               The colorspace will keep an additional reference to the base
               colorspace that will be dropped on destruction.
       
               The returned reference should be dropped when it is finished
               with.
       
               Colorspaces are immutable once created.
           """
>>>>>>     return _mupdf.fz_new_indexed_colorspace(base, high, lookup)
       
    1: def fz_new_link_of_size(size, rect, uri):
           r"""
           Class-aware wrapper for `::fz_new_link_of_size()`.
               Create a new link record.
       
               next is set to NULL with the expectation that the caller will
               handle the linked list setup. Internal function.
       
               Different document types will be implemented by deriving from
               fz_link. This macro allocates such derived structures, and
               initialises the base sections.
           """
>>>>>>     return _mupdf.fz_new_link_of_size(size, rect, uri)
       
    1: def fz_new_list_device(list):
           r"""
           Class-aware wrapper for `::fz_new_list_device()`.
               Create a rendering device for a display list.
       
               When the device is rendering a page it will populate the
               display list with drawing commands (text, images, etc.). The
               display list can later be reused to render a page many times
               without having to re-interpret the page from the document file
               for each rendering. Once the device is no longer needed, free
               it with fz_drop_device.
       
               list: A display list that the list device takes a reference to.
           """
>>>>>>     return _mupdf.fz_new_list_device(list)
       
    1: def fz_new_multi_archive():
           r"""
           Class-aware wrapper for `::fz_new_multi_archive()`.
               Create a new multi archive (initially empty).
           """
>>>>>>     return _mupdf.fz_new_multi_archive()
       
    1: def fz_new_ocr_device(target, ctm, mediabox, with_list, language, datadir, progress, progress_arg):
           r"""
           Class-aware wrapper for `::fz_new_ocr_device()`.
               Create a device to OCR the text on the page.
       
               Renders the page internally to a bitmap that is then OCRd. Text
               is then forwarded onto the target device.
       
               target: The target device to receive the OCRd text.
       
               ctm: The transform to apply to the mediabox to get the size for
               the rendered page image. Also used to calculate the resolution
               for the page image. In general, this will be the same as the CTM
               that you pass to fz_run_page (or fz_run_display_list) to feed
               this device.
       
               mediabox: The mediabox (in points). Combined with the CTM to get
               the bounds of the pixmap used internally for the rendered page
               image.
       
               with_list: If with_list is false, then all non-text operations
               are forwarded instantly to the target device. This results in
               the target device seeing all NON-text operations, followed by
               all the text operations (derived from OCR).
       
               If with_list is true, then all the marking operations are
               collated into a display list which is then replayed to the
               target device at the end.
       
               language: NULL (for "eng"), or a pointer to a string to describe
               the languages/scripts that should be used for OCR (e.g.
               "eng,ara").
       
               datadir: NULL (for ""), or a pointer to a path string otherwise
               provided to Tesseract in the TESSDATA_PREFIX environment variable.
       
               progress: NULL, or function to be called periodically to indicate
               progress. Return 0 to continue, or 1 to cancel. progress_arg is
               returned as the void *. The int is a value between 0 and 100 to
               indicate progress.
       
               progress_arg: A void * value to be parrotted back to the progress
               function.
           """
>>>>>>     return _mupdf.fz_new_ocr_device(target, ctm, mediabox, with_list, language, datadir, progress, progress_arg)
       
    1: def fz_new_outline():
           r"""
           Class-aware wrapper for `::fz_new_outline()`.
               Create a new outline entry with zeroed fields for the caller
               to fill in.
           """
>>>>>>     return _mupdf.fz_new_outline()
       
    1: def fz_new_page_of_size(size, doc):
           r"""
           Class-aware wrapper for `::fz_new_page_of_size()`.
               Different document types will be implemented by deriving from
               fz_page. This macro allocates such derived structures, and
               initialises the base sections.
           """
>>>>>>     return _mupdf.fz_new_page_of_size(size, doc)
       
    1: def fz_new_path():
           r"""
           Class-aware wrapper for `::fz_new_path()`.
               Create a new (empty) path structure.
           """
>>>>>>     return _mupdf.fz_new_path()
       
    1: def fz_new_pdf_document_from_fz_document(ptr):
           r"""Class-aware wrapper for `::fz_new_pdf_document_from_fz_document()`."""
>>>>>>     return _mupdf.fz_new_pdf_document_from_fz_document(ptr)
       
    1: def fz_new_pixmap(cs, w, h, seps, alpha):
           r"""
           Class-aware wrapper for `::fz_new_pixmap()`.
               Create a new pixmap, with its origin at (0,0)
       
               cs: The colorspace to use for the pixmap, or NULL for an alpha
               plane/mask.
       
               w: The width of the pixmap (in pixels)
       
               h: The height of the pixmap (in pixels)
       
               seps: Details of separations.
       
               alpha: 0 for no alpha, 1 for alpha.
       
               Returns a pointer to the new pixmap. Throws exception on failure
               to allocate.
           """
>>>>>>     return _mupdf.fz_new_pixmap(cs, w, h, seps, alpha)
       
    1: def fz_new_pixmap_from_alpha_channel(src):
           r"""Class-aware wrapper for `::fz_new_pixmap_from_alpha_channel()`."""
>>>>>>     return _mupdf.fz_new_pixmap_from_alpha_channel(src)
       
    1: def fz_new_pixmap_from_color_and_mask(color, mask):
           r"""Class-aware wrapper for `::fz_new_pixmap_from_color_and_mask()`."""
>>>>>>     return _mupdf.fz_new_pixmap_from_color_and_mask(color, mask)
       
    1: def fz_new_pixmap_from_display_list(list, ctm, cs, alpha):
           r"""
           Class-aware wrapper for `::fz_new_pixmap_from_display_list()`.
               Render the page to a pixmap using the transform and colorspace.
       
               Ownership of the pixmap is returned to the caller.
           """
>>>>>>     return _mupdf.fz_new_pixmap_from_display_list(list, ctm, cs, alpha)
       
    1: def fz_new_pixmap_from_display_list_with_separations(list, ctm, cs, seps, alpha):
           r"""
           Class-aware wrapper for `::fz_new_pixmap_from_display_list_with_separations()`.
               Render the page contents with control over spot colors.
       
               Ownership of the pixmap is returned to the caller.
           """
>>>>>>     return _mupdf.fz_new_pixmap_from_display_list_with_separations(list, ctm, cs, seps, alpha)
       
    1: def fz_new_pixmap_from_page(page, ctm, cs, alpha):
           r"""Class-aware wrapper for `::fz_new_pixmap_from_page()`."""
>>>>>>     return _mupdf.fz_new_pixmap_from_page(page, ctm, cs, alpha)
       
    1: def fz_new_pixmap_from_page_contents(page, ctm, cs, alpha):
           r"""
           Class-aware wrapper for `::fz_new_pixmap_from_page_contents()`.
               Render the page contents without annotations.
       
               Ownership of the pixmap is returned to the caller.
           """
>>>>>>     return _mupdf.fz_new_pixmap_from_page_contents(page, ctm, cs, alpha)
       
    1: def fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha):
           r"""Class-aware wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`."""
>>>>>>     return _mupdf.fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha)
       
    1: def fz_new_pixmap_from_page_number(doc, number, ctm, cs, alpha):
           r"""Class-aware wrapper for `::fz_new_pixmap_from_page_number()`."""
>>>>>>     return _mupdf.fz_new_pixmap_from_page_number(doc, number, ctm, cs, alpha)
       
    1: def fz_new_pixmap_from_page_number_with_separations(doc, number, ctm, cs, seps, alpha):
           r"""Class-aware wrapper for `::fz_new_pixmap_from_page_number_with_separations()`."""
>>>>>>     return _mupdf.fz_new_pixmap_from_page_number_with_separations(doc, number, ctm, cs, seps, alpha)
       
    1: def fz_new_pixmap_from_page_with_separations(page, ctm, cs, seps, alpha):
           r"""Class-aware wrapper for `::fz_new_pixmap_from_page_with_separations()`."""
>>>>>>     return _mupdf.fz_new_pixmap_from_page_with_separations(page, ctm, cs, seps, alpha)
       
    1: def fz_new_pixmap_from_pixmap(pixmap, rect):
           r"""
           Class-aware wrapper for `::fz_new_pixmap_from_pixmap()`.
               Create a new pixmap that represents a subarea of the specified
               pixmap. A reference is taken to this pixmap that will be dropped
               on destruction.
       
               The supplied rectangle must be wholly contained within the
               original pixmap.
       
               Returns a pointer to the new pixmap. Throws exception on failure
               to allocate.
           """
>>>>>>     return _mupdf.fz_new_pixmap_from_pixmap(pixmap, rect)
       
    1: def fz_new_pixmap_with_bbox(colorspace, bbox, seps, alpha):
           r"""
           Class-aware wrapper for `::fz_new_pixmap_with_bbox()`.
               Create a pixmap of a given size, location and pixel format.
       
               The bounding box specifies the size of the created pixmap and
               where it will be located. The colorspace determines the number
               of components per pixel. Alpha is always present. Pixmaps are
               reference counted, so drop references using fz_drop_pixmap.
       
               colorspace: Colorspace format used for the created pixmap. The
               pixmap will keep a reference to the colorspace.
       
               bbox: Bounding box specifying location/size of created pixmap.
       
               seps: Details of separations.
       
               alpha: 0 for no alpha, 1 for alpha.
       
               Returns a pointer to the new pixmap. Throws exception on failure
               to allocate.
           """
>>>>>>     return _mupdf.fz_new_pixmap_with_bbox(colorspace, bbox, seps, alpha)
       
    1: def fz_new_pixmap_with_bbox_and_data(colorspace, rect, seps, alpha, samples):
           r"""
           Class-aware wrapper for `::fz_new_pixmap_with_bbox_and_data()`.
               Create a pixmap of a given size, location and pixel format,
               using the supplied data block.
       
               The bounding box specifies the size of the created pixmap and
               where it will be located. The colorspace determines the number
               of components per pixel. Alpha is always present. Pixmaps are
               reference counted, so drop references using fz_drop_pixmap.
       
               colorspace: Colorspace format used for the created pixmap. The
               pixmap will keep a reference to the colorspace.
       
               rect: Bounding box specifying location/size of created pixmap.
       
               seps: Details of separations.
       
               alpha: Number of alpha planes (0 or 1).
       
               samples: The data block to keep the samples in.
       
               Returns a pointer to the new pixmap. Throws exception on failure
               to allocate.
           """
>>>>>>     return _mupdf.fz_new_pixmap_with_bbox_and_data(colorspace, rect, seps, alpha, samples)
       
    1: def fz_new_pixmap_with_data(colorspace, w, h, seps, alpha, stride, samples):
           r"""
           Class-aware wrapper for `::fz_new_pixmap_with_data()`.
               Create a new pixmap, with its origin at
               (0,0) using the supplied data block.
       
               cs: The colorspace to use for the pixmap, or NULL for an alpha
               plane/mask.
       
               w: The width of the pixmap (in pixels)
       
               h: The height of the pixmap (in pixels)
       
               seps: Details of separations.
       
               alpha: 0 for no alpha, 1 for alpha.
       
               stride: The byte offset from the pixel data in a row to the
               pixel data in the next row.
       
               samples: The data block to keep the samples in.
       
               Returns a pointer to the new pixmap. Throws exception on failure to
               allocate.
           """
>>>>>>     return _mupdf.fz_new_pixmap_with_data(colorspace, w, h, seps, alpha, stride, samples)
       
    1: def fz_new_separations(controllable):
           r"""
           Class-aware wrapper for `::fz_new_separations()`.
               Create a new separations structure (initially empty)
           """
>>>>>>     return _mupdf.fz_new_separations(controllable)
       
    1: def fz_new_stext_device(page, options):
           r"""
           Class-aware wrapper for `::fz_new_stext_device()`.
               Create a device to extract the text on a page.
       
               Gather the text on a page into blocks and lines.
       
               The reading order is taken from the order the text is drawn in
               the source file, so may not be accurate.
       
               page: The text page to which content should be added. This will
               usually be a newly created (empty) text page, but it can be one
               containing data already (for example when merging multiple
               pages, or watermarking).
       
               options: Options to configure the stext device.
           """
>>>>>>     return _mupdf.fz_new_stext_device(page, options)
       
    1: def fz_new_stext_device_for_page(stext_page, opts, chapter_num, page_num, mediabox):
           r"""
           Class-aware wrapper for `::fz_new_stext_device_for_page()`.
               Create a device to extract the text on a page into an existing
               fz_stext_page structure.
       
               Gather the text on a page into blocks and lines.
       
               The reading order is taken from the order the text is drawn in
               the source file, so may not be accurate.
       
               stext_page: The text page to which content should be added. This will
               usually be a newly created (empty) text page, but it can be one
               containing data already (for example when merging multiple
               pages, or watermarking).
       
               options: Options to configure the stext device.
       
               The next 2 parameters are copied into the fz_stext_page structure's
               ids section, so only have to be valid if you expect to interrogate
               that section later.
       
               chapter_num: The chapter number that this page came from.
       
               page_num: The page number that this page came from.
       
               The final parameter is copied into the fz_stext_page structure's
               ids section. The mediabox for the enture fz_stext_page is unioned
               with this, so pass fz_empty_bbox if you don't care about getting
               a valid value back from the ids section, but you don't want to
               upset the value in the page->mediabox field.
       
               mediabox: The mediabox for this page.
           """
>>>>>>     return _mupdf.fz_new_stext_device_for_page(stext_page, opts, chapter_num, page_num, mediabox)
       
    1: def fz_new_stext_struct(page, standard, raw, index):
           r"""Class-aware wrapper for `::fz_new_stext_struct()`."""
>>>>>>     return _mupdf.fz_new_stext_struct(page, standard, raw, index)
       
    1: def fz_new_store_context(max):
           r"""
           Class-aware wrapper for `::fz_new_store_context()`.
               Create a new store inside the context
       
               max: The maximum size (in bytes) that the store is allowed to
               grow to. FZ_STORE_UNLIMITED means no limit.
           """
>>>>>>     return _mupdf.fz_new_store_context(max)
       
    1: def fz_new_stream(state, next, drop):
           r"""
           Class-aware wrapper for `::fz_new_stream()`.
               Create a new stream object with the given
               internal state and function pointers.
       
               state: Internal state (opaque to everything but implementation).
       
               next: Should provide the next set of bytes (up to max) of stream
               data. Return the number of bytes read, or EOF when there is no
               more data.
       
               drop: Should clean up and free the internal state. May not
               throw exceptions.
           """
>>>>>>     return _mupdf.fz_new_stream(state, next, drop)
       
    1: def fz_new_string(str):
           r"""Class-aware wrapper for `::fz_new_string()`."""
>>>>>>     return _mupdf.fz_new_string(str)
       
    1: def fz_new_stroke_state():
           r"""
           Class-aware wrapper for `::fz_new_stroke_state()`.
               Create a new (empty) stroke state structure (with no dash
               data) and return a reference to it.
       
               Throws exception on failure to allocate.
           """
>>>>>>     return _mupdf.fz_new_stroke_state()
       
    1: def fz_new_stroke_state_with_dash_len(len):
           r"""
           Class-aware wrapper for `::fz_new_stroke_state_with_dash_len()`.
               Create a new (empty) stroke state structure, with room for
               dash data of the given length, and return a reference to it.
       
               len: The number of dash elements to allow room for.
       
               Throws exception on failure to allocate.
           """
>>>>>>     return _mupdf.fz_new_stroke_state_with_dash_len(len)
       
    1: def fz_new_svg_device(out, page_width, page_height, text_format, reuse_images):
           r"""
           Class-aware wrapper for `::fz_new_svg_device()`.
               Create a device that outputs (single page) SVG files to
               the given output stream.
       
               Equivalent to fz_new_svg_device_with_id passing id = NULL.
           """
>>>>>>     return _mupdf.fz_new_svg_device(out, page_width, page_height, text_format, reuse_images)
       
    1: def fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images, id):
           r"""
           Class-aware wrapper for `::fz_new_svg_device_with_id()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_new_svg_device_with_id(::fz_output *out, float page_width, float page_height, int text_format, int reuse_images)` => `(fz_device *, int id)`
       
               Create a device that outputs (single page) SVG files to
               the given output stream.
       
               output: The output stream to send the constructed SVG page to.
       
               page_width, page_height: The page dimensions to use (in points).
       
               text_format: How to emit text. One of the following values:
                       FZ_SVG_TEXT_AS_TEXT: As <text> elements with possible
                       layout errors and mismatching fonts.
                       FZ_SVG_TEXT_AS_PATH: As <path> elements with exact
                       visual appearance.
       
               reuse_images: Share image resources using <symbol> definitions.
       
               id: ID parameter to keep generated IDs unique across SVG files.
           """
>>>>>>     return _mupdf.fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images, id)
       
    1: def fz_new_test_device(is_color, threshold, options, passthrough):
           r"""
           Class-aware wrapper for `::fz_new_test_device()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_new_test_device(float threshold, int options, ::fz_device *passthrough)` => `(fz_device *, int is_color)`
       
               Create a device to test for features.
       
               Currently only tests for the presence of non-grayscale colors.
       
               is_color: Possible values returned:
                       0: Definitely greyscale
                       1: Probably color (all colors were grey, but there
                       were images or shadings in a non grey colorspace).
                       2: Definitely color
       
               threshold: The difference from grayscale that will be tolerated.
               Typical values to use are either 0 (be exact) and 0.02 (allow an
               imperceptible amount of slop).
       
               options: A set of bitfield options, from the FZ_TEST_OPT set.
       
               passthrough: A device to pass all calls through to, or NULL.
               If set, then the test device can both test and pass through to
               an underlying device (like, say, the display list device). This
               means that a display list can be created and at the end we'll
               know if it's colored or not.
       
               In the absence of a passthrough device, the device will throw
               an exception to stop page interpretation when color is found.
           """
>>>>>>     return _mupdf.fz_new_test_device(is_color, threshold, options, passthrough)
       
    1: def fz_new_text():
           r"""
           Class-aware wrapper for `::fz_new_text()`.
               Create a new empty fz_text object.
       
               Throws exception on failure to allocate.
           """
>>>>>>     return _mupdf.fz_new_text()
       
    1: def fz_new_trace_device(out):
           r"""
           Class-aware wrapper for `::fz_new_trace_device()`.
               Create a device to print a debug trace of all device calls.
           """
>>>>>>     return _mupdf.fz_new_trace_device(out)
       
    1: def fz_new_tree_archive(tree):
           r"""
           Class-aware wrapper for `::fz_new_tree_archive()`.
               Create an archive that holds named buffers.
       
               tree can either be a preformed tree with fz_buffers as values,
               or it can be NULL for an empty tree.
           """
>>>>>>     return _mupdf.fz_new_tree_archive(tree)
       
    1: def fz_new_type3_font(name, matrix):
           r"""
           Class-aware wrapper for `::fz_new_type3_font()`.
               Create a new (empty) type3 font.
       
               name: Name of font (or NULL).
       
               matrix: Font matrix.
       
               Returns a new font handle, or throws exception on
               allocation failure.
           """
>>>>>>     return _mupdf.fz_new_type3_font(name, matrix)
       
    1: def fz_new_xhtml_document_from_document(old_doc, opts):
           r"""
           Class-aware wrapper for `::fz_new_xhtml_document_from_document()`.
               Use text extraction to convert the input document into XHTML,
               then open the result as a new document that can be reflowed.
           """
>>>>>>     return _mupdf.fz_new_xhtml_document_from_document(old_doc, opts)
       
    1: def fz_new_xmltext_device(out):
           r"""
           Class-aware wrapper for `::fz_new_xmltext_device()`.
               Create a device to output raw information.
           """
>>>>>>     return _mupdf.fz_new_xmltext_device(out)
       
    1: def fz_next_page(doc, loc):
           r"""
           Class-aware wrapper for `::fz_next_page()`.
               Function to get the location of the next page (allowing for the
               end of chapters etc). If at the end of the document, returns the
               current location.
           """
>>>>>>     return _mupdf.fz_next_page(doc, loc)
       
    1: def fz_normalize_vector(p):
           r"""
           Class-aware wrapper for `::fz_normalize_vector()`.
               Normalize a vector to length one.
           """
>>>>>>     return _mupdf.fz_normalize_vector(p)
       
    1: def fz_open_a85d(chain):
           r"""
           Class-aware wrapper for `::fz_open_a85d()`.
               a85d filter performs ASCII 85 Decoding of data read
               from the chained filter.
           """
>>>>>>     return _mupdf.fz_open_a85d(chain)
       
    1: def fz_open_accelerated_document(filename, accel):
           r"""
           Class-aware wrapper for `::fz_open_accelerated_document()`.
               Open a document file and read its basic structure so pages and
               objects can be located. MuPDF will try to repair broken
               documents (without actually changing the file contents).
       
               The returned fz_document is used when calling most other
               document related functions.
       
               filename: a path to a file as it would be given to open(2).
           """
>>>>>>     return _mupdf.fz_open_accelerated_document(filename, accel)
       
    1: def fz_open_accelerated_document_with_stream(magic, stream, accel):
           r"""
           Class-aware wrapper for `::fz_open_accelerated_document_with_stream()`.
               Open a document using the specified stream object rather than
               opening a file on disk.
       
               magic: a string used to detect document type; either a file name
               or mime-type.
       
               stream: a stream of the document contents.
       
               accel: NULL, or a stream of the 'accelerator' contents for this document.
       
               NOTE: The caller retains ownership of 'stream' and 'accel' - the document will
               take its own references if required.
           """
>>>>>>     return _mupdf.fz_open_accelerated_document_with_stream(magic, stream, accel)
       
    1: def fz_open_accelerated_document_with_stream_and_dir(magic, stream, accel, dir):
           r"""
           Class-aware wrapper for `::fz_open_accelerated_document_with_stream_and_dir()`.
               Open a document using the specified stream object rather than
               opening a file on disk.
       
               magic: a string used to detect document type; either a file name
               or mime-type.
       
               stream: a stream of the document contents.
       
               accel: NULL, or a stream of the 'accelerator' contents for this document.
       
               dir: NULL, or the 'directory context' for the stream contents.
       
               NOTE: The caller retains ownership of 'stream', 'accel' and 'dir' - the document will
               take its own references if required.
           """
>>>>>>     return _mupdf.fz_open_accelerated_document_with_stream_and_dir(magic, stream, accel, dir)
       
    1: def fz_open_aesd(chain, key, keylen):
           r"""
           Class-aware wrapper for `::fz_open_aesd()`.
               aesd filter performs AES decoding of data read from the chained
               filter using the supplied key.
           """
>>>>>>     return _mupdf.fz_open_aesd(chain, key, keylen)
       
    1: def fz_open_ahxd(chain):
           r"""
           Class-aware wrapper for `::fz_open_ahxd()`.
               ahxd filter performs ASCII Hex decoding of data read
               from the chained filter.
           """
>>>>>>     return _mupdf.fz_open_ahxd(chain)
       
    1: def fz_open_arc4(chain, key, keylen):
           r"""
           Class-aware wrapper for `::fz_open_arc4()`.
               arc4 filter performs RC4 decoding of data read from the chained
               filter using the supplied key.
           """
>>>>>>     return _mupdf.fz_open_arc4(chain, key, keylen)
       
    1: def fz_open_archive(filename):
           r"""
           Class-aware wrapper for `::fz_open_archive()`.
               Open a zip or tar archive
       
               Open a file and identify its archive type based on the archive
               signature contained inside.
       
               filename: a path to a file as it would be given to open(2).
           """
>>>>>>     return _mupdf.fz_open_archive(filename)
       
    1: def fz_open_archive_entry(arch, name):
           r"""
           Class-aware wrapper for `::fz_open_archive_entry()`.
               Opens an archive entry as a stream.
       
               name: Entry name to look for, this must be an exact match to
               the entry name in the archive.
       
               Throws an exception if a matching entry cannot be found.
           """
>>>>>>     return _mupdf.fz_open_archive_entry(arch, name)
       
    1: def fz_open_archive_with_stream(file):
           r"""
           Class-aware wrapper for `::fz_open_archive_with_stream()`.
               Open zip or tar archive stream.
       
               Open an archive using a seekable stream object rather than
               opening a file or directory on disk.
           """
>>>>>>     return _mupdf.fz_open_archive_with_stream(file)
       
    1: def fz_open_brotlid(chain):
           r"""
           Class-aware wrapper for `::fz_open_brotlid()`.
               brotlid filter performs Brotli decoding of data read
               from the chained filter.
           """
>>>>>>     return _mupdf.fz_open_brotlid(chain)
       
    1: def fz_open_buffer(buf):
           r"""
           Class-aware wrapper for `::fz_open_buffer()`.
               Open a buffer as a stream.
       
               buf: The buffer to open. Ownership of the buffer is NOT passed
               in (this function takes its own reference).
       
               Returns pointer to newly created stream. May throw exceptions on
               failure to allocate.
           """
>>>>>>     return _mupdf.fz_open_buffer(buf)
       
    1: def fz_open_cfb_archive(filename):
           r"""
           Class-aware wrapper for `::fz_open_cfb_archive()`.
               Open a cfb file as an archive.
       
               An exception is thrown if the file is not recognised as a cfb.
       
               filename: a path to an archive file as it would be given to
               open(2).
           """
>>>>>>     return _mupdf.fz_open_cfb_archive(filename)
       
    1: def fz_open_cfb_archive_with_stream(file):
           r"""
           Class-aware wrapper for `::fz_open_cfb_archive_with_stream()`.
               Open a cfb file as an archive.
       
               Open an archive using a seekable stream object rather than
               opening a file or directory on disk.
       
               An exception is thrown if the file is not recognised as a chm.
           """
>>>>>>     return _mupdf.fz_open_cfb_archive_with_stream(file)
       
    1: def fz_open_compressed_buffer(arg_0):
           r"""
           Class-aware wrapper for `::fz_open_compressed_buffer()`.
               Open a stream to read the decompressed version of a buffer.
           """
>>>>>>     return _mupdf.fz_open_compressed_buffer(arg_0)
       
    1: def fz_open_concat(max, pad):
           r"""
           Class-aware wrapper for `::fz_open_concat()`.
               Concat filter concatenates several streams into one.
           """
>>>>>>     return _mupdf.fz_open_concat(max, pad)
       
    1: def fz_open_dctd(chain, color_transform, invert_cmyk, l2factor, jpegtables):
           r"""
           Class-aware wrapper for `::fz_open_dctd()`.
               dctd filter performs DCT (JPEG) decoding of data read
               from the chained filter.
       
               color_transform implements the PDF color_transform option
                       use -1 for default behavior
                       use 0 to disable YUV-RGB / YCCK-CMYK transforms
                       use 1 to enable YUV-RGB / YCCK-CMYK transforms
       
               invert_cmyk implements the necessary inversion for Photoshop CMYK images
                       use 0 if embedded in PDF
                       use 1 if not embedded in PDF
       
               For subsampling on decode, set l2factor to the log2 of the
               reduction required (therefore 0 = full size decode).
       
               jpegtables is an optional stream from which the JPEG tables
               can be read. Use NULL if not required.
           """
>>>>>>     return _mupdf.fz_open_dctd(chain, color_transform, invert_cmyk, l2factor, jpegtables)
       
    1: def fz_open_directory(path):
           r"""
           Class-aware wrapper for `::fz_open_directory()`.
               Open a directory as if it was an archive.
       
               A special case where a directory is opened as if it was an
               archive.
       
               Note that for directories it is not possible to retrieve the
               number of entries or list the entries. It is however possible
               to check if the archive has a particular entry.
       
               path: a path to a directory as it would be given to opendir(3).
           """
>>>>>>     return _mupdf.fz_open_directory(path)
       
    1: def fz_open_document(filename):
           r"""
           Class-aware wrapper for `::fz_open_document()`.
               Open a document file and read its basic structure so pages and
               objects can be located. MuPDF will try to repair broken
               documents (without actually changing the file contents).
       
               The returned fz_document is used when calling most other
               document related functions.
       
               filename: a path to a file as it would be given to open(2).
           """
>>>>>>     return _mupdf.fz_open_document(filename)
       
    1: def fz_open_document_with_buffer(magic, buffer):
           r"""
           Class-aware wrapper for `::fz_open_document_with_buffer()`.
               Open a document using a buffer rather than opening a file on disk.
           """
>>>>>>     return _mupdf.fz_open_document_with_buffer(magic, buffer)
       
    1: def fz_open_document_with_stream(magic, stream):
           r"""
           Class-aware wrapper for `::fz_open_document_with_stream()`.
               Open a document using the specified stream object rather than
               opening a file on disk.
       
               magic: a string used to detect document type; either a file name
               or mime-type.
       
               stream: a stream representing the contents of the document file.
       
               NOTE: The caller retains ownership of 'stream' - the document will take its
               own reference if required.
           """
>>>>>>     return _mupdf.fz_open_document_with_stream(magic, stream)
       
    1: def fz_open_document_with_stream_and_dir(magic, stream, dir):
           r"""
           Class-aware wrapper for `::fz_open_document_with_stream_and_dir()`.
               Open a document using the specified stream object rather than
               opening a file on disk.
       
               magic: a string used to detect document type; either a file name
               or mime-type.
       
               stream: a stream representing the contents of the document file.
       
               dir: a 'directory context' for those filetypes that need it.
       
               NOTE: The caller retains ownership of 'stream' and 'dir' - the document will
               take its own references if required.
           """
>>>>>>     return _mupdf.fz_open_document_with_stream_and_dir(magic, stream, dir)
       
    1: def fz_open_endstream_filter(chain, len, offset):
           r"""
           Class-aware wrapper for `::fz_open_endstream_filter()`.
               The endstream filter reads a PDF substream, and starts to look
               for an 'endstream' token after the specified length.
           """
>>>>>>     return _mupdf.fz_open_endstream_filter(chain, len, offset)
       
    1: def fz_open_faxd(chain, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1):
           r"""
           Class-aware wrapper for `::fz_open_faxd()`.
               faxd filter performs FAX decoding of data read from
               the chained filter.
       
               k: see fax specification (fax default is 0).
       
               end_of_line: whether we expect end of line markers (fax default
               is 0).
       
               encoded_byte_align: whether we align to bytes after each line
               (fax default is 0).
       
               columns: how many columns in the image (fax default is 1728).
       
               rows: 0 for unspecified or the number of rows of data to expect.
       
               end_of_block: whether we expect end of block markers (fax
               default is 1).
       
               black_is_1: determines the polarity of the image (fax default is
               0).
           """
>>>>>>     return _mupdf.fz_open_faxd(chain, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1)
       
    1: def fz_open_file(filename):
           r"""
           Class-aware wrapper for `::fz_open_file()`.
               Open the named file and wrap it in a stream.
       
               filename: Path to a file. On non-Windows machines the filename
               should be exactly as it would be passed to fopen(2). On Windows
               machines, the path should be UTF-8 encoded so that non-ASCII
               characters can be represented. Other platforms do the encoding
               as standard anyway (and in most cases, particularly for MacOS
               and Linux, the encoding they use is UTF-8 anyway).
           """
>>>>>>     return _mupdf.fz_open_file(filename)
       
    1: def fz_open_file_autodelete(filename):
           r"""
           Class-aware wrapper for `::fz_open_file_autodelete()`.
               Do the same as fz_open_file, but delete the file upon close.
           """
>>>>>>     return _mupdf.fz_open_file_autodelete(filename)
       
    1: def fz_open_file_ptr_no_close(file):
           r"""
           Class-aware wrapper for `::fz_open_file_ptr_no_close()`.
               Create a stream from a FILE * that will not be closed
               when the stream is dropped.
           """
>>>>>>     return _mupdf.fz_open_file_ptr_no_close(file)
       
    1: def fz_open_flated(chain, window_bits):
           r"""
           Class-aware wrapper for `::fz_open_flated()`.
               flated filter performs LZ77 decoding (inflating) of data read
               from the chained filter.
       
               window_bits: How large a decompression window to use. Typically
               15. A negative number, -n, means to use n bits, but to expect
               raw data with no header.
           """
>>>>>>     return _mupdf.fz_open_flated(chain, window_bits)
       
    1: def fz_open_image_decomp_stream(arg_0, arg_1, l2factor):
           r"""
           Class-aware wrapper for `::fz_open_image_decomp_stream()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_open_image_decomp_stream(::fz_stream *arg_0, ::fz_compression_params *arg_1)` => `(fz_stream *, int l2factor)`
       
               Open a stream to read the decompressed version of another stream
               with optional log2 subsampling.
           """
>>>>>>     return _mupdf.fz_open_image_decomp_stream(arg_0, arg_1, l2factor)
       
    1: def fz_open_image_decomp_stream_from_buffer(arg_0, l2factor):
           r"""
           Class-aware wrapper for `::fz_open_image_decomp_stream_from_buffer()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_open_image_decomp_stream_from_buffer(::fz_compressed_buffer *arg_0)` => `(fz_stream *, int l2factor)`
       
               Open a stream to read the decompressed version of a buffer,
               with optional log2 subsampling.
       
               l2factor = NULL for no subsampling, or a pointer to an integer
               containing the maximum log2 subsample factor acceptable (0 =
               none, 1 = halve dimensions, 2 = quarter dimensions etc). If
               non-NULL, then *l2factor will be updated on exit with the actual
               log2 subsample factor achieved.
           """
>>>>>>     return _mupdf.fz_open_image_decomp_stream_from_buffer(arg_0, l2factor)
       
    1: def fz_open_jbig2d(chain, globals, embedded):
           r"""
           Class-aware wrapper for `::fz_open_jbig2d()`.
               Open a filter that performs jbig2 decompression on the chained
               stream, using the optional globals record.
           """
>>>>>>     return _mupdf.fz_open_jbig2d(chain, globals, embedded)
       
    1: def fz_open_leecher(chain, buf):
           r"""
           Class-aware wrapper for `::fz_open_leecher()`.
               Attach a filter to a stream that will store any
               characters read from the stream into the supplied buffer.
       
               chain: The underlying stream to leech from.
       
               buf: The buffer into which the read data should be appended.
               The buffer will be resized as required.
       
               Returns pointer to newly created stream. May throw exceptions on
               failure to allocate.
           """
>>>>>>     return _mupdf.fz_open_leecher(chain, buf)
       
    1: def fz_open_libarchive_archive(filename):
           r"""
           Class-aware wrapper for `::fz_open_libarchive_archive()`.
               Open an archive using libarchive.
       
               An exception is thrown if the file is not supported by libarchive.
       
               filename: a path to an archive file as it would be given to
               open(2).
           """
>>>>>>     return _mupdf.fz_open_libarchive_archive(filename)
       
    1: def fz_open_libarchive_archive_with_stream(file):
           r"""
           Class-aware wrapper for `::fz_open_libarchive_archive_with_stream()`.
               Open an archive using libarchive.
       
               Open an archive using a seekable stream object rather than
               opening a file or directory on disk.
       
               An exception is thrown if the stream is not supported by libarchive.
           """
>>>>>>     return _mupdf.fz_open_libarchive_archive_with_stream(file)
       
    1: def fz_open_libarchived(chain):
           r"""
           Class-aware wrapper for `::fz_open_libarchived()`.
               libarchived filter performs generic compressed decoding of data
               in any format understood by libarchive from the chained filter.
       
               This will throw an exception if libarchive is not built in, or
               if the compression format is not recognised.
           """
>>>>>>     return _mupdf.fz_open_libarchived(chain)
       
    1: def fz_open_lzwd(chain, early_change, min_bits, reverse_bits, old_tiff):
           r"""
           Class-aware wrapper for `::fz_open_lzwd()`.
               lzwd filter performs LZW decoding of data read from the chained
               filter.
       
               early_change: (Default 1) specifies whether to change codes 1
               bit early.
       
               min_bits: (Default 9) specifies the minimum number of bits to
               use.
       
               reverse_bits: (Default 0) allows for compatibility with gif and
               old style tiffs (1).
       
               old_tiff: (Default 0) allows for different handling of the clear
               code, as found in old style tiffs.
           """
>>>>>>     return _mupdf.fz_open_lzwd(chain, early_change, min_bits, reverse_bits, old_tiff)
       
    1: def fz_open_memory(data, len):
           r"""
           Class-aware wrapper for `::fz_open_memory()`.
               Open a block of memory as a stream.
       
               data: Pointer to start of data block. Ownership of the data
               block is NOT passed in.
       
               len: Number of bytes in data block.
       
               Returns pointer to newly created stream. May throw exceptions on
               failure to allocate.
           """
>>>>>>     return _mupdf.fz_open_memory(data, len)
       
    1: def fz_open_null_filter(chain, len, offset):
           r"""
           Class-aware wrapper for `::fz_open_null_filter()`.
               The null filter reads a specified amount of data from the
               substream.
           """
>>>>>>     return _mupdf.fz_open_null_filter(chain, len, offset)
       
    1: def fz_open_predict(chain, predictor, columns, colors, bpc):
           r"""
           Class-aware wrapper for `::fz_open_predict()`.
               predict filter performs pixel prediction on data read from
               the chained filter.
       
               predictor: 1 = copy, 2 = tiff, other = inline PNG predictor
       
               columns: width of image in pixels
       
               colors: number of components.
       
               bpc: bits per component (typically 8)
           """
>>>>>>     return _mupdf.fz_open_predict(chain, predictor, columns, colors, bpc)
       
    1: def fz_open_range_filter(chain, ranges, nranges):
           r"""
           Class-aware wrapper for `::fz_open_range_filter()`.
               The range filter copies data from specified ranges of the
               chained stream.
           """
>>>>>>     return _mupdf.fz_open_range_filter(chain, ranges, nranges)
       
    1: def fz_open_reflowed_document(underdoc, opts):
           r"""Class-aware wrapper for `::fz_open_reflowed_document()`."""
>>>>>>     return _mupdf.fz_open_reflowed_document(underdoc, opts)
       
    1: def fz_open_rld(chain):
           r"""
           Class-aware wrapper for `::fz_open_rld()`.
               rld filter performs Run Length Decoding of data read
               from the chained filter.
           """
>>>>>>     return _mupdf.fz_open_rld(chain)
       
    1: def fz_open_sgilog16(chain, w):
           r"""
           Class-aware wrapper for `::fz_open_sgilog16()`.
               SGI Log 16bit (greyscale) decode from the chained filter.
               Decodes lines of w pixels to 8bpp greyscale.
           """
>>>>>>     return _mupdf.fz_open_sgilog16(chain, w)
       
    1: def fz_open_sgilog24(chain, w):
           r"""
           Class-aware wrapper for `::fz_open_sgilog24()`.
               SGI Log 24bit (LUV) decode from the chained filter.
               Decodes lines of w pixels to 8bpc rgb.
           """
>>>>>>     return _mupdf.fz_open_sgilog24(chain, w)
       
    1: def fz_open_sgilog32(chain, w):
           r"""
           Class-aware wrapper for `::fz_open_sgilog32()`.
               SGI Log 32bit (LUV) decode from the chained filter.
               Decodes lines of w pixels to 8bpc rgb.
           """
>>>>>>     return _mupdf.fz_open_sgilog32(chain, w)
       
    1: def fz_open_tar_archive(filename):
           r"""
           Class-aware wrapper for `::fz_open_tar_archive()`.
               Open a tar archive file.
       
               An exception is thrown if the file is not a tar archive as
               indicated by the presence of a tar signature.
       
               filename: a path to a tar archive file as it would be given to
               open(2).
           """
>>>>>>     return _mupdf.fz_open_tar_archive(filename)
       
    1: def fz_open_tar_archive_with_stream(file):
           r"""
           Class-aware wrapper for `::fz_open_tar_archive_with_stream()`.
               Open a tar archive stream.
       
               Open an archive using a seekable stream object rather than
               opening a file or directory on disk.
       
               An exception is thrown if the stream is not a tar archive as
               indicated by the presence of a tar signature.
       
           """
>>>>>>     return _mupdf.fz_open_tar_archive_with_stream(file)
       
    1: def fz_open_thunder(chain, w):
           r"""
           Class-aware wrapper for `::fz_open_thunder()`.
               4bit greyscale Thunderscan decoding from the chained filter.
               Decodes lines of w pixels to 8bpp greyscale.
           """
>>>>>>     return _mupdf.fz_open_thunder(chain, w)
       
    1: def fz_open_zip_archive(path):
           r"""
           Class-aware wrapper for `::fz_open_zip_archive()`.
               Open a zip archive file.
       
               An exception is thrown if the file is not a zip archive as
               indicated by the presence of a zip signature.
       
               filename: a path to a zip archive file as it would be given to
               open(2).
           """
>>>>>>     return _mupdf.fz_open_zip_archive(path)
       
    1: def fz_open_zip_archive_with_stream(file):
           r"""
           Class-aware wrapper for `::fz_open_zip_archive_with_stream()`.
               Open a zip archive stream.
       
               Open an archive using a seekable stream object rather than
               opening a file or directory on disk.
       
               An exception is thrown if the stream is not a zip archive as
               indicated by the presence of a zip signature.
       
           """
>>>>>>     return _mupdf.fz_open_zip_archive_with_stream(file)
       
    1: def fz_opt_from_list(opt, optlist):
           r"""
           Class-aware wrapper for `::fz_opt_from_list()`.
               Return the index of a (case-insensitive) option within an optlist.
       
               For instance for optlist = "Foo|Bar|Baz", and  opt = "bar",
               this would return 1.
       
               If the optlist ends with "|*" then that is a catch all case and
               matches all options allowing the caller to process it itself.
               fz_optarg will be set to point to the option, and the return
               value will be the index of the '*' option within that list.
       
               If an optlist entry ends with ':' (e.g. "Foo:") then that option
               may have suboptions appended to it (for example "JPG:80") and
               fz_optarg will be set to point at "80". Otherwise fz_optarg will
               be set to NULL.
       
               In the event of no-match found, prints an error and returns -1.
           """
>>>>>>     return _mupdf.fz_opt_from_list(opt, optlist)
       
    1: def fz_option_eq(a, b):
           r"""
           Class-aware wrapper for `::fz_option_eq()`.
               Check to see if an option, a, from a string matches a reference
               option, b.
       
               (i.e. a could be 'foo' or 'foo,bar...' etc, but b can only be
               'foo'.)
           """
>>>>>>     return _mupdf.fz_option_eq(a, b)
       
    1: def fz_optpath(opt):
           r"""
           Class-aware wrapper for `::fz_optpath()`.
               Convert "-" to "/dev/stdout" for use with command lines.
               Also converts "nul" and "con" on Windows.
           """
>>>>>>     return _mupdf.fz_optpath(opt)
       
    1: def fz_outline_glyph(font, gid, ctm):
           r"""
           Class-aware wrapper for `::fz_outline_glyph()`.
               Look a glyph up from a font, and return the outline of the
               glyph using the given transform.
       
               The caller owns the returned path, and so is responsible for
               ensuring that it eventually gets dropped.
           """
>>>>>>     return _mupdf.fz_outline_glyph(font, gid, ctm)
       
    1: def fz_outline_iterator_delete(iter):
           r"""
           Class-aware wrapper for `::fz_outline_iterator_delete()`.
               Delete the current item.
       
               This implicitly moves us to the 'next' item, and the return code is as for fz_outline_iterator_next.
           """
>>>>>>     return _mupdf.fz_outline_iterator_delete(iter)
       
    1: def fz_outline_iterator_down(iter):
           r"""Class-aware wrapper for `::fz_outline_iterator_down()`."""
>>>>>>     return _mupdf.fz_outline_iterator_down(iter)
       
    1: def fz_outline_iterator_item(iter):
           r"""
           Class-aware wrapper for `::fz_outline_iterator_item()`.
               Call to get the current outline item.
       
               Can return NULL. The item is only valid until the next call.
           """
>>>>>>     return _mupdf.fz_outline_iterator_item(iter)
       
    1: def fz_outline_iterator_next(iter):
           r"""
           Class-aware wrapper for `::fz_outline_iterator_next()`.
               Calls to move the iterator position.
       
               A negative return value means we could not move as requested. Otherwise:
               0 = the final position has a valid item.
               1 = not a valid item, but we can insert an item here.
           """
>>>>>>     return _mupdf.fz_outline_iterator_next(iter)
       
    1: def fz_outline_iterator_prev(iter):
           r"""Class-aware wrapper for `::fz_outline_iterator_prev()`."""
>>>>>>     return _mupdf.fz_outline_iterator_prev(iter)
       
    1: def fz_outline_iterator_up(iter):
           r"""Class-aware wrapper for `::fz_outline_iterator_up()`."""
>>>>>>     return _mupdf.fz_outline_iterator_up(iter)
       
    1: def fz_output_accelerator(doc, accel):
           r"""
           Class-aware wrapper for `::fz_output_accelerator()`.
               Output accelerator data for the document to a given output
               stream.
           """
>>>>>>     return _mupdf.fz_output_accelerator(doc, accel)
       
    1: def fz_output_supports_stream(out):
           r"""
           Class-aware wrapper for `::fz_output_supports_stream()`.
               Query whether a given fz_output supports fz_stream_from_output.
           """
>>>>>>     return _mupdf.fz_output_supports_stream(out)
       
    1: def fz_output_xml(out, item, level):
           r"""
           Class-aware wrapper for `::fz_output_xml()`.
               Pretty-print an XML tree to given output.
           """
>>>>>>     return _mupdf.fz_output_xml(out, item, level)
       
    1: def fz_overlaps_rect(a, b):
           r"""
           Class-aware wrapper for `::fz_overlaps_rect()`.
               Test rectangle overlap.
       
               Returns true if the area of the overlap is
               non zero.
           """
>>>>>>     return _mupdf.fz_overlaps_rect(a, b)
       
    1: def fz_pack_path(pack, path):
           r"""
           Class-aware wrapper for `::fz_pack_path()`.
               Pack a path into the given block.
               To minimise the size of paths, this function allows them to be
               packed into a buffer with other information. Paths can be used
               interchangeably regardless of how they are packed.
       
               pack: Pointer to a block of data to pack the path into. Should
               be aligned by the caller to the same alignment as required for
               a fz_path pointer.
       
               path: The path to pack.
       
               Returns the number of bytes within the block used. Callers can
               access the packed path data by casting the value of pack on
               entry to be a fz_path *.
       
               Throws exceptions on failure to allocate.
       
               Implementation details: Paths can be 'unpacked', 'flat', or
               'open'. Standard paths, as created are 'unpacked'. Paths
               will be packed as 'flat', unless they are too large
               (where large indicates that they exceed some private
               implementation defined limits, currently including having
               more than 256 coordinates or commands).
       
               Large paths are 'open' packed as a header into the given block,
               plus pointers to other data blocks.
       
               Users should not have to care about whether paths are 'open'
               or 'flat' packed. Simply pack a path (if required), and then
               forget about the details.
           """
>>>>>>     return _mupdf.fz_pack_path(pack, path)
       
    1: def fz_packed_path_size(path):
           r"""
           Class-aware wrapper for `::fz_packed_path_size()`.
               Return the number of bytes required to pack a path.
           """
>>>>>>     return _mupdf.fz_packed_path_size(path)
       
    1: def fz_page_label(page, buf, size):
           r"""
           Class-aware wrapper for `::fz_page_label()`.
               Get page label for a given page.
           """
>>>>>>     return _mupdf.fz_page_label(page, buf, size)
       
    1: def fz_page_number_from_location(doc, loc):
           r"""
           Class-aware wrapper for `::fz_page_number_from_location()`.
               Converts from chapter+page to page number. This may cause many
               chapters to be laid out in order to calculate the number of
               pages within those chapters.
           """
>>>>>>     return _mupdf.fz_page_number_from_location(doc, loc)
       
    1: def fz_page_presentation(page, transition, duration):
           r"""
           Class-aware wrapper for `::fz_page_presentation()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_page_presentation(::fz_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`
       
               Get the presentation details for a given page.
       
               transition: A pointer to a transition struct to fill out.
       
               duration: A pointer to a place to set the page duration in
               seconds. Will be set to 0 if no transition is specified for the
               page.
       
               Returns: a pointer to the transition structure, or NULL if there
               is no transition specified for the page.
           """
>>>>>>     return _mupdf.fz_page_presentation(page, transition, duration)
       
    1: def fz_page_separations(page):
           r"""
           Class-aware wrapper for `::fz_page_separations()`.
               Get the separations details for a page.
               This will be NULL, unless the format specifically supports
               separations (such as PDF files). May be NULL even
               so, if there are no separations on a page.
       
               Returns a reference that must be dropped.
           """
>>>>>>     return _mupdf.fz_page_separations(page)
       
    1: def fz_page_uses_overprint(page):
           r"""
           Class-aware wrapper for `::fz_page_uses_overprint()`.
               Query if a given page requires overprint.
           """
>>>>>>     return _mupdf.fz_page_uses_overprint(page)
       
    1: def fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop, cache):
           r"""
           Class-aware wrapper for `::fz_paint_shade()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_paint_shade(::fz_shade *shade, ::fz_colorspace *override_cs, ::fz_matrix ctm, ::fz_pixmap *dest, ::fz_color_params color_params, ::fz_irect bbox, const ::fz_overprint *eop, ::fz_shade_color_cache **cache)` =>
       
               Render a shade to a given pixmap.
       
               shade: The shade to paint.
       
               override_cs: NULL, or colorspace to override the shades
               inbuilt colorspace.
       
               ctm: The transform to apply.
       
               dest: The pixmap to render into.
       
               color_params: The color rendering settings
       
               bbox: Pointer to a bounding box to limit the rendering
               of the shade.
       
               eop: NULL, or pointer to overprint bitmap.
       
               cache: *cache is used to cache color information. If *cache is NULL it
               is set to point to a new fz_shade_color_cache. If cache is NULL it is
               ignored.
           """
>>>>>>     return _mupdf.fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop, cache)
       
    1: def fz_paragraph_break(page):
           r"""
           Class-aware wrapper for `::fz_paragraph_break()`.
               Attempt to break paragraphs at plausible places.
           """
>>>>>>     return _mupdf.fz_paragraph_break(page)
       
    1: def fz_parse_page_range(s, a, b, n):
           r"""
           Class-aware wrapper for `::fz_parse_page_range()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_parse_page_range(const char *s, int n)` => `(const char *, int a, int b)`
           """
>>>>>>     return _mupdf.fz_parse_page_range(s, a, b, n)
       
    1: def fz_parse_pdfocr_options(opts, args):
           r"""
           Class-aware wrapper for `::fz_parse_pdfocr_options()`.
               Parse PDFOCR options.
       
               Currently defined options and values are as follows:
       
                       compression=none: No compression
                       compression=flate: Flate compression
                       strip-height=n: Strip height (default 16)
                       ocr-language=<lang>: OCR Language (default eng)
                       ocr-datadir=<datadir>: OCR data path (default rely on TESSDATA_PREFIX)
           """
>>>>>>     return _mupdf.fz_parse_pdfocr_options(opts, args)
       
    1: def fz_parse_stext_options(opts, string):
           r"""
           Class-aware wrapper for `::fz_parse_stext_options()`.
               Parse stext device options from a comma separated key-value
               string.
           """
>>>>>>     return _mupdf.fz_parse_stext_options(opts, string)
       
    1: def fz_parse_xml(buf, preserve_white):
           r"""
           Class-aware wrapper for `::fz_parse_xml()`.
               Parse the contents of buffer into a tree of xml nodes.
       
               preserve_white: whether to keep or delete all-whitespace nodes.
           """
>>>>>>     return _mupdf.fz_parse_xml(buf, preserve_white)
       
    1: def fz_parse_xml_archive_entry(dir, filename, preserve_white):
           r"""
           Class-aware wrapper for `::fz_parse_xml_archive_entry()`.
               Parse the contents of an archive entry into a tree of xml nodes.
       
               preserve_white: whether to keep or delete all-whitespace nodes.
           """
>>>>>>     return _mupdf.fz_parse_xml_archive_entry(dir, filename, preserve_white)
       
    1: def fz_parse_xml_from_html5(buf):
           r"""
           Class-aware wrapper for `::fz_parse_xml_from_html5()`.
               Parse the contents of a buffer into a tree of XML nodes,
               using the HTML5 parsing algorithm.
           """
>>>>>>     return _mupdf.fz_parse_xml_from_html5(buf)
       
    1: def fz_parse_xml_stream(stream, preserve_white):
           r"""
           Class-aware wrapper for `::fz_parse_xml_stream()`.
               Parse the contents of buffer into a tree of xml nodes.
       
               preserve_white: whether to keep or delete all-whitespace nodes.
           """
>>>>>>     return _mupdf.fz_parse_xml_stream(stream, preserve_white)
       
    1: def fz_path_is_rect(path, ctm):
           r"""
           Class-aware wrapper for `::fz_path_is_rect()`.
               Check whether a given path, under the given transform
               is an axis-aligned rectangle.
       
               We accept zero width or height rectangles, so
               "move 100, 100; line 200, 100" would count as
               a rectangle too.
           """
>>>>>>     return _mupdf.fz_path_is_rect(path, ctm)
       
    1: def fz_path_is_rect_with_bounds(path, ctm, bounds):
           r"""
           Class-aware wrapper for `::fz_path_is_rect_with_bounds()`.
               Check whether a given path, under the given transform
               is an axis-aligned rectangle.
       
               We accept zero width or height rectangles, so
               "move 100, 100; line 200, 100" would count as
               a rectangle too.
       
               bounds = NULL, or place to return the rectangle
               bounds if the path is a rectangle.
           """
>>>>>>     return _mupdf.fz_path_is_rect_with_bounds(path, ctm, bounds)
       
    1: def fz_pcl_preset(opts, preset):
           r"""
           Class-aware wrapper for `::fz_pcl_preset()`.
               Initialize PCL option struct for a given preset.
       
               Currently defined presets include:
       
                       generic Generic PCL printer
                       ljet4   HP DeskJet
                       dj500   HP DeskJet 500
                       fs600   Kyocera FS-600
                       lj      HP LaserJet, HP LaserJet Plus
                       lj2     HP LaserJet IIp, HP LaserJet IId
                       lj3     HP LaserJet III
                       lj3d    HP LaserJet IIId
                       lj4     HP LaserJet 4
                       lj4pl   HP LaserJet 4 PL
                       lj4d    HP LaserJet 4d
                       lp2563b HP 2563B line printer
                       oce9050 Oce 9050 Line printer
           """
>>>>>>     return _mupdf.fz_pcl_preset(opts, preset)
       
    1: def fz_pdfocr_band_writer_set_progress(writer, progress_fn, progress_arg):
           r"""
           Class-aware wrapper for `::fz_pdfocr_band_writer_set_progress()`.
               Set the progress callback for a pdfocr bandwriter.
           """
>>>>>>     return _mupdf.fz_pdfocr_band_writer_set_progress(writer, progress_fn, progress_arg)
       
    1: def fz_pdfocr_writer_set_progress(writer, progress, arg_2):
           r"""Class-aware wrapper for `::fz_pdfocr_writer_set_progress()`."""
>>>>>>     return _mupdf.fz_pdfocr_writer_set_progress(writer, progress, arg_2)
       
    1: def fz_peek_byte(stm):
           r"""
           Class-aware wrapper for `::fz_peek_byte()`.
               Peek at the next byte in a stream.
       
               stm: The stream to peek at.
       
               Returns -1 for EOF, or the next byte that will be read.
           """
>>>>>>     return _mupdf.fz_peek_byte(stm)
       
    1: def fz_pixmap_alpha(pix):
           r"""
           Class-aware wrapper for `::fz_pixmap_alpha()`.
               Return the number of alpha planes in a pixmap.
       
               Returns the number of alphas. Does not throw exceptions.
           """
>>>>>>     return _mupdf.fz_pixmap_alpha(pix)
       
    1: def fz_pixmap_bbox(pix):
           r"""
           Class-aware wrapper for `::fz_pixmap_bbox()`.
               Return the bounding box for a pixmap.
           """
>>>>>>     return _mupdf.fz_pixmap_bbox(pix)
       
    1: def fz_pixmap_colorants(pix):
           r"""
           Class-aware wrapper for `::fz_pixmap_colorants()`.
               Return the number of colorants in a pixmap.
       
               Returns the number of colorants (components, less any spots and
               alpha).
           """
>>>>>>     return _mupdf.fz_pixmap_colorants(pix)
       
    1: def fz_pixmap_colorspace(pix):
           r"""
           Class-aware wrapper for `::fz_pixmap_colorspace()`.
               Return the colorspace of a pixmap
       
               Returns colorspace.
           """
>>>>>>     return _mupdf.fz_pixmap_colorspace(pix)
       
    1: def fz_pixmap_components(pix):
           r"""
           Class-aware wrapper for `::fz_pixmap_components()`.
               Return the number of components in a pixmap.
       
               Returns the number of components (including spots and alpha).
           """
>>>>>>     return _mupdf.fz_pixmap_components(pix)
       
    1: def fz_pixmap_height(pix):
           r"""
           Class-aware wrapper for `::fz_pixmap_height()`.
               Return the height of the pixmap in pixels.
           """
>>>>>>     return _mupdf.fz_pixmap_height(pix)
       
    1: def fz_pixmap_image_tile(cimg):
           r"""
           Class-aware wrapper for `::fz_pixmap_image_tile()`.
               Retrieve the underlying fz_pixmap for an image.
       
               Returns a pointer to the underlying fz_pixmap for an image,
               or NULL if this image is not based upon an fz_pixmap.
       
               No reference is returned. Lifespan is limited to that of
               the image itself. If required, use fz_keep_pixmap to take
               a reference to keep it longer.
           """
>>>>>>     return _mupdf.fz_pixmap_image_tile(cimg)
       
    1: def fz_pixmap_samples(pix):
           r"""
           Class-aware wrapper for `::fz_pixmap_samples()`.
               Returns a pointer to the pixel data of a pixmap.
       
               Returns the pointer.
           """
>>>>>>     return _mupdf.fz_pixmap_samples(pix)
       
    1: def fz_pixmap_samples_int(pixmap):
           r"""Class-aware wrapper for `::fz_pixmap_samples_int()`."""
>>>>>>     return _mupdf.fz_pixmap_samples_int(pixmap)
       
    1: def fz_pixmap_size(pix):
           r"""
           Class-aware wrapper for `::fz_pixmap_size()`.
               Return sizeof fz_pixmap plus size of data, in bytes.
           """
>>>>>>     return _mupdf.fz_pixmap_size(pix)
       
    1: def fz_pixmap_spots(pix):
           r"""
           Class-aware wrapper for `::fz_pixmap_spots()`.
               Return the number of spots in a pixmap.
       
               Returns the number of spots (components, less colorants and
               alpha). Does not throw exceptions.
           """
>>>>>>     return _mupdf.fz_pixmap_spots(pix)
       
    1: def fz_pixmap_stride(pix):
           r"""
           Class-aware wrapper for `::fz_pixmap_stride()`.
               Return the number of bytes in a row in the pixmap.
           """
>>>>>>     return _mupdf.fz_pixmap_stride(pix)
       
    1: def fz_pixmap_width(pix):
           r"""
           Class-aware wrapper for `::fz_pixmap_width()`.
               Return the width of the pixmap in pixels.
           """
>>>>>>     return _mupdf.fz_pixmap_width(pix)
       
    1: def fz_pixmap_x(pix):
           r"""
           Class-aware wrapper for `::fz_pixmap_x()`.
               Return the x value of the pixmap in pixels.
           """
>>>>>>     return _mupdf.fz_pixmap_x(pix)
       
    1: def fz_pixmap_y(pix):
           r"""
           Class-aware wrapper for `::fz_pixmap_y()`.
               Return the y value of the pixmap in pixels.
           """
>>>>>>     return _mupdf.fz_pixmap_y(pix)
       
    1: def fz_place_story(story, where, filled):
           r"""Class-aware wrapper for `::fz_place_story()`."""
>>>>>>     return _mupdf.fz_place_story(story, where, filled)
       
    1: def fz_place_story_flags(story, where, filled, flags):
           r"""Class-aware wrapper for `::fz_place_story_flags()`."""
>>>>>>     return _mupdf.fz_place_story_flags(story, where, filled, flags)
       
    1: def fz_pool_alloc(pool, size):
           r"""
           Class-aware wrapper for `::fz_pool_alloc()`.
               Allocate a block of size bytes from the pool.
           """
>>>>>>     return _mupdf.fz_pool_alloc(pool, size)
       
    1: def fz_pool_array_append(arr, idx):
           r"""
           Class-aware wrapper for `::fz_pool_array_append()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_pool_array_append(::fz_pool_array *arr)` => `(void *, size_t idx)`
       
               Append an element to the end of the array.
       
               Returns a pointer to the new element (initially all 0's), and
               (optionally) the index of that element.
           """
>>>>>>     return _mupdf.fz_pool_array_append(arr, idx)
       
    1: def fz_pool_array_len(arr):
           r"""
           Class-aware wrapper for `::fz_pool_array_len()`.
               Get the length of the array.
           """
>>>>>>     return _mupdf.fz_pool_array_len(arr)
       
    1: def fz_pool_array_lookup(arr, idx):
           r"""
           Class-aware wrapper for `::fz_pool_array_lookup()`.
               Lookup an element in the array.
           """
>>>>>>     return _mupdf.fz_pool_array_lookup(arr, idx)
       
    1: def fz_pool_size(pool):
           r"""
           Class-aware wrapper for `::fz_pool_size()`.
               The current size of the pool.
       
               The number of bytes of storage currently allocated to the pool.
               This is the total of the storage used for the blocks making
               up the pool, rather then total of the allocated blocks so far,
               so it will increase in 'lumps'.
               from the pool, then the pool size may still be X
           """
>>>>>>     return _mupdf.fz_pool_size(pool)
       
    1: def fz_pool_strdup(pool, s):
           r"""
           Class-aware wrapper for `::fz_pool_strdup()`.
               strdup equivalent allocating from the pool.
           """
>>>>>>     return _mupdf.fz_pool_strdup(pool, s)
       
    1: def fz_pop_clip(dev):
           r"""Class-aware wrapper for `::fz_pop_clip()`."""
>>>>>>     return _mupdf.fz_pop_clip(dev)
       
    1: def fz_post_scale(m, sx, sy):
           r"""
           Class-aware wrapper for `::fz_post_scale()`.
               Scale a matrix by postmultiplication.
       
               m: Pointer to the matrix to scale
       
               sx, sy: Scaling factors along the X- and Y-axes. A scaling
               factor of 1.0 will not cause any scaling along the relevant
               axis.
       
               Returns m (updated).
           """
>>>>>>     return _mupdf.fz_post_scale(m, sx, sy)
       
    1: def fz_pre_rotate(m, degrees):
           r"""
           Class-aware wrapper for `::fz_pre_rotate()`.
               Rotate a transformation by premultiplying.
       
               The premultiplied matrix is of the form
               [ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].
       
               m: Pointer to matrix to premultiply.
       
               degrees: Degrees of counter clockwise rotation. Values less
               than zero and greater than 360 are handled as expected.
       
               Returns m (updated).
           """
>>>>>>     return _mupdf.fz_pre_rotate(m, degrees)
       
    1: def fz_pre_scale(m, sx, sy):
           r"""
           Class-aware wrapper for `::fz_pre_scale()`.
               Scale a matrix by premultiplication.
       
               m: Pointer to the matrix to scale
       
               sx, sy: Scaling factors along the X- and Y-axes. A scaling
               factor of 1.0 will not cause any scaling along the relevant
               axis.
       
               Returns m (updated).
           """
>>>>>>     return _mupdf.fz_pre_scale(m, sx, sy)
       
    1: def fz_pre_shear(m, sx, sy):
           r"""
           Class-aware wrapper for `::fz_pre_shear()`.
               Premultiply a matrix with a shearing matrix.
       
               The shearing matrix is of the form [ 1 sy sx 1 0 0 ].
       
               m: pointer to matrix to premultiply
       
               sx, sy: Shearing factors. A shearing factor of 0.0 will not
               cause any shearing along the relevant axis.
       
               Returns m (updated).
           """
>>>>>>     return _mupdf.fz_pre_shear(m, sx, sy)
       
    1: def fz_pre_translate(m, tx, ty):
           r"""
           Class-aware wrapper for `::fz_pre_translate()`.
               Translate a matrix by premultiplication.
       
               m: The matrix to translate
       
               tx, ty: Translation distances along the X- and Y-axes. A
               translation of 0 will not cause any translation along the
               relevant axis.
       
               Returns m.
           """
>>>>>>     return _mupdf.fz_pre_translate(m, tx, ty)
       
    1: def fz_prepare_t3_glyph(font, gid):
           r"""
           Class-aware wrapper for `::fz_prepare_t3_glyph()`.
               Force a type3 font to cache the displaylist for a given glyph
               id.
       
               This caching can involve reading the underlying file, so must
               happen ahead of time, so we aren't suddenly forced to read the
               file while playing a displaylist back.
           """
>>>>>>     return _mupdf.fz_prepare_t3_glyph(font, gid)
       
    1: def fz_previous_page(doc, loc):
           r"""
           Class-aware wrapper for `::fz_previous_page()`.
               Function to get the location of the previous page (allowing for
               the end of chapters etc). If already at the start of the
               document, returns the current page.
           """
>>>>>>     return _mupdf.fz_previous_page(doc, loc)
       
    1: def fz_print_stext_header_as_html(out):
           r"""Class-aware wrapper for `::fz_print_stext_header_as_html()`."""
>>>>>>     return _mupdf.fz_print_stext_header_as_html(out)
       
    1: def fz_print_stext_header_as_xhtml(out):
           r"""Class-aware wrapper for `::fz_print_stext_header_as_xhtml()`."""
>>>>>>     return _mupdf.fz_print_stext_header_as_xhtml(out)
       
    1: def fz_print_stext_page_as_html(out, page, id):
           r"""
           Class-aware wrapper for `::fz_print_stext_page_as_html()`.
               Output structured text to a file in HTML (visual) format.
           """
>>>>>>     return _mupdf.fz_print_stext_page_as_html(out, page, id)
       
    1: def fz_print_stext_page_as_json(out, page, scale):
           r"""
           Class-aware wrapper for `::fz_print_stext_page_as_json()`.
               Output structured text to a file in JSON format.
           """
>>>>>>     return _mupdf.fz_print_stext_page_as_json(out, page, scale)
       
    1: def fz_print_stext_page_as_text(out, page):
           r"""
           Class-aware wrapper for `::fz_print_stext_page_as_text()`.
               Output structured text to a file in plain-text UTF-8 format.
           """
>>>>>>     return _mupdf.fz_print_stext_page_as_text(out, page)
       
    1: def fz_print_stext_page_as_xhtml(out, page, id):
           r"""
           Class-aware wrapper for `::fz_print_stext_page_as_xhtml()`.
               Output structured text to a file in XHTML (semantic) format.
           """
>>>>>>     return _mupdf.fz_print_stext_page_as_xhtml(out, page, id)
       
    1: def fz_print_stext_page_as_xml(out, page, id):
           r"""
           Class-aware wrapper for `::fz_print_stext_page_as_xml()`.
               Output structured text to a file in XML format.
           """
>>>>>>     return _mupdf.fz_print_stext_page_as_xml(out, page, id)
       
    1: def fz_print_stext_trailer_as_html(out):
           r"""Class-aware wrapper for `::fz_print_stext_trailer_as_html()`."""
>>>>>>     return _mupdf.fz_print_stext_trailer_as_html(out)
       
    1: def fz_print_stext_trailer_as_xhtml(out):
           r"""Class-aware wrapper for `::fz_print_stext_trailer_as_xhtml()`."""
>>>>>>     return _mupdf.fz_print_stext_trailer_as_xhtml(out)
       
    1: def fz_process_opened_pages(doc, process_openend_page, state):
           r"""
           Class-aware wrapper for `::fz_process_opened_pages()`.
               Iterates over all opened pages of the document, calling the
               provided callback for each page for processing. If the callback
               returns non-NULL then the iteration stops and that value is returned
               to the called of fz_process_opened_pages().
       
               The state pointer provided to fz_process_opened_pages() is
               passed on to the callback but is owned by the caller.
       
               Returns the first non-NULL value returned by the callback,
               or NULL if the callback returned NULL for all opened pages.
           """
>>>>>>     return _mupdf.fz_process_opened_pages(doc, process_openend_page, state)
       
    1: def fz_process_shade(shade, ctm, scissor, prepare, process, process_arg):
           r"""
           Class-aware wrapper for `::fz_process_shade()`.
               Process a shade, using supplied callback functions. This
               decomposes the shading to a mesh (even ones that are not
               natively meshes, such as linear or radial shadings), and
               processes triangles from those meshes.
       
               shade: The shade to process.
       
               ctm: The transform to use
       
               prepare: Callback function to 'prepare' each vertex.
               This function is passed an array of floats, and populates
               a fz_vertex structure.
       
               process: This function is passed 3 pointers to vertex
               structures, and actually performs the processing (typically
               filling the area between the vertices).
       
               process_arg: An opaque argument passed through from caller
               to callback functions.
           """
>>>>>>     return _mupdf.fz_process_shade(shade, ctm, scissor, prepare, process, process_arg)
       
    1: def fz_ptr_heap_insert(heap, v, HEAP_CMP):
           r"""Class-aware wrapper for `::fz_ptr_heap_insert()`."""
>>>>>>     return _mupdf.fz_ptr_heap_insert(heap, v, HEAP_CMP)
       
    1: def fz_ptr_heap_sort(heap, HEAP_CMP):
           r"""Class-aware wrapper for `::fz_ptr_heap_sort()`."""
>>>>>>     return _mupdf.fz_ptr_heap_sort(heap, HEAP_CMP)
       
    1: def fz_ptr_heap_uniq(heap, HEAP_CMP):
           r"""Class-aware wrapper for `::fz_ptr_heap_uniq()`."""
>>>>>>     return _mupdf.fz_ptr_heap_uniq(heap, HEAP_CMP)
       
    1: def fz_purge_glyph_cache():
           r"""
           Class-aware wrapper for `::fz_purge_glyph_cache()`.
               Purge all the glyphs from the cache.
           """
>>>>>>     return _mupdf.fz_purge_glyph_cache()
       
    1: def fz_quad_from_rect(r):
           r"""
           Class-aware wrapper for `::fz_quad_from_rect()`.
               Convert a rect to a quad (losslessly).
           """
>>>>>>     return _mupdf.fz_quad_from_rect(r)
       
    1: def fz_quadto(path, x0, y0, x1, y1):
           r"""
           Class-aware wrapper for `::fz_quadto()`.
               Append a 'quadto' command to an open path. (For a
               quadratic bezier).
       
               path: The path to modify.
       
               x0, y0: The control coordinates for the quadratic curve.
       
               x1, y1: The end coordinates for the quadratic curve.
       
               Throws exceptions on failure to allocate, or attempting to
               modify a packed path.
           """
>>>>>>     return _mupdf.fz_quadto(path, x0, y0, x1, y1)
       
    1: def fz_range_limit_xml_char(c):
           r"""Class-aware wrapper for `::fz_range_limit_xml_char()`."""
>>>>>>     return _mupdf.fz_range_limit_xml_char(c)
       
    1: def fz_read(stm, data, len):
           r"""
           Class-aware wrapper for `::fz_read()`.
               Read from a stream into a given data block.
       
               stm: The stream to read from.
       
               data: The data block to read into.
       
               len: The length of the data block (in bytes).
       
               Returns the number of bytes read. May throw exceptions.
           """
>>>>>>     return _mupdf.fz_read(stm, data, len)
       
    1: def fz_read_all(stm, initial):
           r"""
           Class-aware wrapper for `::fz_read_all()`.
               Read all of a stream into a buffer.
       
               stm: The stream to read from
       
               initial: Suggested initial size for the buffer.
       
               Returns a buffer created from reading from the stream. May throw
               exceptions on failure to allocate.
           """
>>>>>>     return _mupdf.fz_read_all(stm, initial)
       
    1: def fz_read_archive_entry(arch, name):
           r"""
           Class-aware wrapper for `::fz_read_archive_entry()`.
               Reads all bytes in an archive entry
               into a buffer.
       
               name: Entry name to look for, this must be an exact match to
               the entry name in the archive.
       
               Throws an exception if a matching entry cannot be found.
           """
>>>>>>     return _mupdf.fz_read_archive_entry(arch, name)
       
    1: def fz_read_best(stm, initial, truncated, worst_case):
           r"""
           Class-aware wrapper for `::fz_read_best()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_read_best(::fz_stream *stm, size_t initial, size_t worst_case)` => `(fz_buffer *, int truncated)`
       
               Attempt to read a stream into a buffer. If truncated
               is NULL behaves as fz_read_all, sets a truncated flag in case of
               error.
       
               stm: The stream to read from.
       
               initial: Suggested initial size for the buffer.
       
               truncated: Flag to store success/failure indication in.
       
               worst_case: 0 for unknown, otherwise an upper bound for the
               size of the stream.
       
               Returns a buffer created from reading from the stream.
           """
>>>>>>     return _mupdf.fz_read_best(stm, initial, truncated, worst_case)
       
    1: def fz_read_bits(stm, n):
           r"""
           Class-aware wrapper for `::fz_read_bits()`.
               Read the next n bits from a stream (assumed to
               be packed most significant bit first).
       
               stm: The stream to read from.
       
               n: The number of bits to read, between 1 and 8*sizeof(int)
               inclusive.
       
               Returns -1 for EOF, or the required number of bits.
           """
>>>>>>     return _mupdf.fz_read_bits(stm, n)
       
    1: def fz_read_byte(stm):
           r"""
           Class-aware wrapper for `::fz_read_byte()`.
               Read the next byte from a stream.
       
               stm: The stream t read from.
       
               Returns -1 for end of stream, or the next byte. May
               throw exceptions.
           """
>>>>>>     return _mupdf.fz_read_byte(stm)
       
    1: def fz_read_file(filename):
           r"""
           Class-aware wrapper for `::fz_read_file()`.
               Read all the contents of a file into a buffer.
           """
>>>>>>     return _mupdf.fz_read_file(filename)
       
    1: def fz_read_float(stm):
           r"""Class-aware wrapper for `::fz_read_float()`."""
>>>>>>     return _mupdf.fz_read_float(stm)
       
    1: def fz_read_float_le(stm):
           r"""Class-aware wrapper for `::fz_read_float_le()`."""
>>>>>>     return _mupdf.fz_read_float_le(stm)
       
    1: def fz_read_int16(stm):
           r"""Class-aware wrapper for `::fz_read_int16()`."""
>>>>>>     return _mupdf.fz_read_int16(stm)
       
    1: def fz_read_int16_le(stm):
           r"""Class-aware wrapper for `::fz_read_int16_le()`."""
>>>>>>     return _mupdf.fz_read_int16_le(stm)
       
    1: def fz_read_int32(stm):
           r"""Class-aware wrapper for `::fz_read_int32()`."""
>>>>>>     return _mupdf.fz_read_int32(stm)
       
    1: def fz_read_int32_le(stm):
           r"""Class-aware wrapper for `::fz_read_int32_le()`."""
>>>>>>     return _mupdf.fz_read_int32_le(stm)
       
    1: def fz_read_int64(stm):
           r"""Class-aware wrapper for `::fz_read_int64()`."""
>>>>>>     return _mupdf.fz_read_int64(stm)
       
    1: def fz_read_int64_le(stm):
           r"""Class-aware wrapper for `::fz_read_int64_le()`."""
>>>>>>     return _mupdf.fz_read_int64_le(stm)
       
    1: def fz_read_line(stm, buf, max):
           r"""
           Class-aware wrapper for `::fz_read_line()`.
               Read a line from stream into the buffer until either a
               terminating newline or EOF, which it replaces with a null byte
               ('').
       
               Returns buf on success, and NULL when end of file occurs while
               no characters have been read.
           """
>>>>>>     return _mupdf.fz_read_line(stm, buf, max)
       
    1: def fz_read_rbits(stm, n):
           r"""
           Class-aware wrapper for `::fz_read_rbits()`.
               Read the next n bits from a stream (assumed to
               be packed least significant bit first).
       
               stm: The stream to read from.
       
               n: The number of bits to read, between 1 and 8*sizeof(int)
               inclusive.
       
               Returns (unsigned int)-1 for EOF, or the required number of bits.
           """
>>>>>>     return _mupdf.fz_read_rbits(stm, n)
       
    1: def fz_read_rune(_in):
           r"""
           Class-aware wrapper for `::fz_read_rune()`.
               Read a utf-8 rune from a stream.
       
               In the event of encountering badly formatted utf-8 codes
               (such as a leading code with an unexpected number of following
               codes) no error/exception is given, but undefined values may be
               returned.
           """
>>>>>>     return _mupdf.fz_read_rune(_in)
       
    1: def fz_read_string(stm, buffer, len):
           r"""
           Class-aware wrapper for `::fz_read_string()`.
               Read a null terminated string from the stream into
               a buffer of a given length. The buffer will be null terminated.
               Throws on failure (including the failure to fit the entire
               string including the terminator into the buffer).
           """
>>>>>>     return _mupdf.fz_read_string(stm, buffer, len)
       
    1: def fz_read_uint16(stm):
           r"""
           Class-aware wrapper for `::fz_read_uint16()`.
               fz_read_[u]int(16|24|32|64)(_le)?
       
               Read a 16/32/64 bit signed/unsigned integer from stream,
               in big or little-endian byte orders.
       
               Throws an exception if EOF is encountered.
           """
>>>>>>     return _mupdf.fz_read_uint16(stm)
       
    1: def fz_read_uint16_le(stm):
           r"""Class-aware wrapper for `::fz_read_uint16_le()`."""
>>>>>>     return _mupdf.fz_read_uint16_le(stm)
       
    1: def fz_read_uint24(stm):
           r"""Class-aware wrapper for `::fz_read_uint24()`."""
>>>>>>     return _mupdf.fz_read_uint24(stm)
       
    1: def fz_read_uint24_le(stm):
           r"""Class-aware wrapper for `::fz_read_uint24_le()`."""
>>>>>>     return _mupdf.fz_read_uint24_le(stm)
       
    1: def fz_read_uint32(stm):
           r"""Class-aware wrapper for `::fz_read_uint32()`."""
>>>>>>     return _mupdf.fz_read_uint32(stm)
       
    1: def fz_read_uint32_le(stm):
           r"""Class-aware wrapper for `::fz_read_uint32_le()`."""
>>>>>>     return _mupdf.fz_read_uint32_le(stm)
       
    1: def fz_read_uint64(stm):
           r"""Class-aware wrapper for `::fz_read_uint64()`."""
>>>>>>     return _mupdf.fz_read_uint64(stm)
       
    1: def fz_read_uint64_le(stm):
           r"""Class-aware wrapper for `::fz_read_uint64_le()`."""
>>>>>>     return _mupdf.fz_read_uint64_le(stm)
       
    1: def fz_read_utf16_be(stm):
           r"""Class-aware wrapper for `::fz_read_utf16_be()`."""
>>>>>>     return _mupdf.fz_read_utf16_be(stm)
       
    1: def fz_read_utf16_le(stm):
           r"""
           Class-aware wrapper for `::fz_read_utf16_le()`.
               Read a utf-16 rune from a stream. (little endian and
               big endian respectively).
       
               In the event of encountering badly formatted utf-16 codes
               (mismatched surrogates) no error/exception is given, but
               undefined values may be returned.
           """
>>>>>>     return _mupdf.fz_read_utf16_le(stm)
       
    1: def fz_realloc(p, size):
           r"""
           Class-aware wrapper for `::fz_realloc()`.
               Reallocates a block of memory to given size. Existing contents
               up to min(old_size,new_size) are maintained. The rest of the
               block is uninitialised.
       
               fz_realloc(ctx, NULL, size) behaves like fz_malloc(ctx, size).
       
               fz_realloc(ctx, p, 0); behaves like fz_free(ctx, p).
       
               Throws exception in the event of failure to allocate.
           """
>>>>>>     return _mupdf.fz_realloc(p, size)
       
    1: def fz_realloc_no_throw(p, size):
           r"""
           Class-aware wrapper for `::fz_realloc_no_throw()`.
               fz_realloc equivalent that returns NULL rather than throwing
               exceptions.
           """
>>>>>>     return _mupdf.fz_realloc_no_throw(p, size)
       
    1: def fz_realpath(path, resolved_path):
           r"""
           Class-aware wrapper for `::fz_realpath()`.
               Resolve a path to an absolute file name.
               The resolved path buffer must be of at least PATH_MAX size.
           """
>>>>>>     return _mupdf.fz_realpath(path, resolved_path)
       
    1: def fz_recognize_image_format(p):
           r"""
           Class-aware wrapper for `::fz_recognize_image_format()`.
               Recognise image format strings in the first 8 bytes from image
               data.
           """
>>>>>>     return _mupdf.fz_recognize_image_format(p)
       
    1: def fz_rect_from_irect(bbox):
           r"""
           Class-aware wrapper for `::fz_rect_from_irect()`.
               Convert a bbox into a rect.
       
               For our purposes, a rect can represent all the values we meet in
               a bbox, so nothing can go wrong.
       
               rect: A place to store the generated rectangle.
       
               bbox: The bbox to convert.
       
               Returns rect (updated).
           """
>>>>>>     return _mupdf.fz_rect_from_irect(bbox)
       
    1: def fz_rect_from_quad(q):
           r"""
           Class-aware wrapper for `::fz_rect_from_quad()`.
               Convert a quad to the smallest rect that covers it.
           """
>>>>>>     return _mupdf.fz_rect_from_quad(q)
       
    1: def fz_rectto(path, x0, y0, x1, y1):
           r"""
           Class-aware wrapper for `::fz_rectto()`.
               Append a 'rectto' command to an open path.
       
               The rectangle is equivalent to:
                       moveto x0 y0
                       lineto x1 y0
                       lineto x1 y1
                       lineto x0 y1
                       closepath
       
               path: The path to modify.
       
               x0, y0: First corner of the rectangle.
       
               x1, y1: Second corner of the rectangle.
       
               Throws exceptions on failure to allocate, or attempting to
               modify a packed path.
           """
>>>>>>     return _mupdf.fz_rectto(path, x0, y0, x1, y1)
       
    1: def fz_register_activity_logger(activity, opaque):
           r"""Class-aware wrapper for `::fz_register_activity_logger()`."""
>>>>>>     return _mupdf.fz_register_activity_logger(activity, opaque)
       
    1: def fz_register_archive_handler(handler):
           r"""Class-aware wrapper for `::fz_register_archive_handler()`."""
>>>>>>     return _mupdf.fz_register_archive_handler(handler)
       
    1: def fz_register_document_handler(handler):
           r"""
           Class-aware wrapper for `::fz_register_document_handler()`.
               Register a handler for a document type.
       
               handler: The handler to register. This must live on for the duration of the
               use of this handler. It will be passed back to the handler for calls so
               the caller can use it to retrieve state.
           """
>>>>>>     return _mupdf.fz_register_document_handler(handler)
       
    1: def fz_register_document_handlers():
           r"""
           Class-aware wrapper for `::fz_register_document_handlers()`.
               Register handlers for all the standard document types supported in
               this build.
           """
>>>>>>     return _mupdf.fz_register_document_handlers()
       
    1: def fz_remove_item(drop, key, type):
           r"""
           Class-aware wrapper for `::fz_remove_item()`.
               Remove an item from the store.
       
               If an item indexed by the given key exists in the store, remove
               it.
       
               drop: The function used to free the value (to ensure we get a
               value of the correct type).
       
               key: The key used to find the item to remove.
       
               type: Functions used to manipulate the key.
           """
>>>>>>     return _mupdf.fz_remove_item(drop, key, type)
       
    1: def fz_render_flags(dev, set, clear):
           r"""Class-aware wrapper for `::fz_render_flags()`."""
>>>>>>     return _mupdf.fz_render_flags(dev, set, clear)
       
    1: def fz_render_glyph_pixmap(font, gid, ctm, scissor, aa):
           r"""
           Class-aware wrapper for `::fz_render_glyph_pixmap()`.
               Create a pixmap containing a rendered glyph.
       
               Lookup gid from font, clip it with scissor, and rendering it
               with aa bits of antialiasing into a new pixmap.
       
               The caller takes ownership of the pixmap and so must free it.
       
               Note: This function is no longer used for normal rendering
               operations, and is kept around just because we use it in the
               app. It should be considered "at risk" of removal from the API.
           """
>>>>>>     return _mupdf.fz_render_glyph_pixmap(font, gid, ctm, scissor, aa)
       
    1: def fz_render_t3_glyph_direct(dev, font, gid, trm, gstate, def_cs, fill_gstate, stroke_gstate):
           r"""
           Class-aware wrapper for `::fz_render_t3_glyph_direct()`.
               Nasty PDF interpreter specific hernia, required to allow the
               interpreter to replay glyphs from a type3 font directly into
               the target device.
       
               This is only used in exceptional circumstances (such as type3
               glyphs that inherit current graphics state, or nested type3
               glyphs).
           """
>>>>>>     return _mupdf.fz_render_t3_glyph_direct(dev, font, gid, trm, gstate, def_cs, fill_gstate, stroke_gstate)
       
    1: def fz_rendering_intent_name(ri):
           r"""
           Class-aware wrapper for `::fz_rendering_intent_name()`.
               Map from enumerated rendering intent to string.
       
               The returned string is static and therefore must not be freed.
           """
>>>>>>     return _mupdf.fz_rendering_intent_name(ri)
       
    1: def fz_report_error():
           r"""Class-aware wrapper for `::fz_report_error()`."""
>>>>>>     return _mupdf.fz_report_error()
       
    1: def fz_reset_output(arg_0):
           r"""
           Class-aware wrapper for `::fz_reset_output()`.
               Reset a closed output stream. Returns state to
               (broadly) that which it was in when opened. Not
               all outputs can be reset, so this may throw an
               exception.
           """
>>>>>>     return _mupdf.fz_reset_output(arg_0)
       
    1: def fz_reset_story(story):
           r"""Class-aware wrapper for `::fz_reset_story()`."""
>>>>>>     return _mupdf.fz_reset_story(story)
       
    1: def fz_resize_buffer(buf, capacity):
           r"""
           Class-aware wrapper for `::fz_resize_buffer()`.
               Ensure that a buffer has a given capacity,
               truncating data if required.
       
               capacity: The desired capacity for the buffer. If the current
               size of the buffer contents is smaller than capacity, it is
               truncated.
           """
>>>>>>     return _mupdf.fz_resize_buffer(buf, capacity)
       
    1: def fz_resolve_link(doc, uri, xp, yp):
           r"""
           Class-aware wrapper for `::fz_resolve_link()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_resolve_link(::fz_document *doc, const char *uri)` => `(fz_location, float xp, float yp)`
       
               Resolve an internal link to a page number.
       
               xp, yp: Pointer to store coordinate of destination on the page.
       
               Returns (-1,-1) if the URI cannot be resolved.
           """
>>>>>>     return _mupdf.fz_resolve_link(doc, uri, xp, yp)
       
    1: def fz_rethrow():
           r"""Class-aware wrapper for `::fz_rethrow()`."""
>>>>>>     return _mupdf.fz_rethrow()
       
    1: def fz_rethrow_if(errcode):
           r"""
           Class-aware wrapper for `::fz_rethrow_if()`.
               Within an fz_catch() block, rethrow the current exception
               if the errcode of the current exception matches.
       
               This assumes no intervening use of fz_try/fz_catch.
           """
>>>>>>     return _mupdf.fz_rethrow_if(errcode)
       
    1: def fz_rethrow_unless(errcode):
           r"""Class-aware wrapper for `::fz_rethrow_unless()`."""
>>>>>>     return _mupdf.fz_rethrow_unless(errcode)
       
    1: def fz_rotate(degrees):
           r"""
           Class-aware wrapper for `::fz_rotate()`.
               Create a rotation matrix.
       
               The returned matrix is of the form
               [ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].
       
               m: Pointer to place to store matrix
       
               degrees: Degrees of counter clockwise rotation. Values less
               than zero and greater than 360 are handled as expected.
       
               Returns m.
           """
>>>>>>     return _mupdf.fz_rotate(degrees)
       
    1: def fz_round_rect(rect):
           r"""
           Class-aware wrapper for `::fz_round_rect()`.
               Round rectangle coordinates.
       
               Coordinates in a bounding box are integers, so rounding of the
               rects coordinates takes place. The top left corner is rounded
               upwards and left while the bottom right corner is rounded
               downwards and to the right.
       
               This differs from fz_irect_from_rect, in that fz_irect_from_rect
               slavishly follows the numbers (i.e any slight over/under
               calculations can cause whole extra pixels to be added).
               fz_round_rect allows for a small amount of rounding error when
               calculating the bbox.
           """
>>>>>>     return _mupdf.fz_round_rect(rect)
       
    1: def fz_run_display_list(list, dev, ctm, scissor, cookie):
           r"""
           Class-aware wrapper for `::fz_run_display_list()`.
               (Re)-run a display list through a device.
       
               list: A display list, created by fz_new_display_list and
               populated with objects from a page by running fz_run_page on a
               device obtained from fz_new_list_device.
       
               ctm: Transform to apply to display list contents. May include
               for example scaling and rotation, see fz_scale, fz_rotate and
               fz_concat. Set to fz_identity if no transformation is desired.
       
               scissor: Only the part of the contents of the display list
               visible within this area will be considered when the list is
               run through the device. This does not imply for tile objects
               contained in the display list.
       
               cookie: Communication mechanism between caller and library
               running the page. Intended for multi-threaded applications,
               while single-threaded applications set cookie to NULL. The
               caller may abort an ongoing page run. Cookie also communicates
               progress information back to the caller. The fields inside
               cookie are continually updated while the page is being run.
           """
>>>>>>     return _mupdf.fz_run_display_list(list, dev, ctm, scissor, cookie)
       
    1: def fz_run_document_structure(doc, dev, cookie):
           r"""
           Class-aware wrapper for `::fz_run_document_structure()`.
               Run the document structure through a device.
       
               doc: Document in question.
       
               dev: Device obtained from fz_new_*_device.
       
               cookie: Communication mechanism between caller and library.
               Intended for multi-threaded applications, while
               single-threaded applications set cookie to NULL. The
               caller may abort an ongoing rendering of a page. Cookie also
               communicates progress information back to the caller. The
               fields inside cookie are continually updated while the page is
               rendering.
           """
>>>>>>     return _mupdf.fz_run_document_structure(doc, dev, cookie)
       
    1: def fz_run_page(page, dev, transform, cookie):
           r"""
           Class-aware wrapper for `::fz_run_page()`.
               Run a page through a device.
       
               page: Page obtained from fz_load_page.
       
               dev: Device obtained from fz_new_*_device.
       
               transform: Transform to apply to page. May include for example
               scaling and rotation, see fz_scale, fz_rotate and fz_concat.
               Set to fz_identity if no transformation is desired.
       
               cookie: Communication mechanism between caller and library
               rendering the page. Intended for multi-threaded applications,
               while single-threaded applications set cookie to NULL. The
               caller may abort an ongoing rendering of a page. Cookie also
               communicates progress information back to the caller. The
               fields inside cookie are continually updated while the page is
               rendering.
           """
>>>>>>     return _mupdf.fz_run_page(page, dev, transform, cookie)
       
    1: def fz_run_page_annots(page, dev, transform, cookie):
           r"""
           Class-aware wrapper for `::fz_run_page_annots()`.
               Run the annotations on a page through a device.
           """
>>>>>>     return _mupdf.fz_run_page_annots(page, dev, transform, cookie)
       
    1: def fz_run_page_contents(page, dev, transform, cookie):
           r"""
           Class-aware wrapper for `::fz_run_page_contents()`.
               Run a page through a device. Just the main
               page content, without the annotations, if any.
       
               page: Page obtained from fz_load_page.
       
               dev: Device obtained from fz_new_*_device.
       
               transform: Transform to apply to page. May include for example
               scaling and rotation, see fz_scale, fz_rotate and fz_concat.
               Set to fz_identity if no transformation is desired.
       
               cookie: Communication mechanism between caller and library
               rendering the page. Intended for multi-threaded applications,
               while single-threaded applications set cookie to NULL. The
               caller may abort an ongoing rendering of a page. Cookie also
               communicates progress information back to the caller. The
               fields inside cookie are continually updated while the page is
               rendering.
           """
>>>>>>     return _mupdf.fz_run_page_contents(page, dev, transform, cookie)
       
    1: def fz_run_page_widgets(page, dev, transform, cookie):
           r"""
           Class-aware wrapper for `::fz_run_page_widgets()`.
               Run the widgets on a page through a device.
           """
>>>>>>     return _mupdf.fz_run_page_widgets(page, dev, transform, cookie)
       
    1: def fz_run_t3_glyph(font, gid, trm, dev):
           r"""
           Class-aware wrapper for `::fz_run_t3_glyph()`.
               Run a glyph from a Type3 font to
               a given device.
       
               font: The font to find the glyph in.
       
               gid: The glyph to run.
       
               trm: The transform to apply.
       
               dev: The device to render onto.
           """
>>>>>>     return _mupdf.fz_run_t3_glyph(font, gid, trm, dev)
       
    1: def fz_runeidx(str, p):
           r"""
           Class-aware wrapper for `::fz_runeidx()`.
               Compute the index of a rune in a string.
       
               str: Pointer to beginning of a string.
       
               p: Pointer to a char in str.
       
               Returns the index of the rune pointed to by p in str.
           """
>>>>>>     return _mupdf.fz_runeidx(str, p)
       
    1: def fz_runelen(rune):
           r"""
           Class-aware wrapper for `::fz_runelen()`.
               Count how many chars are required to represent a rune.
       
               rune: The rune to encode.
       
               Returns the number of bytes required to represent this run in
               UTF8.
           """
>>>>>>     return _mupdf.fz_runelen(rune)
       
    1: def fz_runeptr(str, idx):
           r"""
           Class-aware wrapper for `::fz_runeptr()`.
               Obtain a pointer to the char representing the rune
               at a given index.
       
               str: Pointer to beginning of a string.
       
               idx: Index of a rune to return a char pointer to.
       
               Returns a pointer to the char where the desired rune starts,
               or NULL if the string ends before the index is reached.
           """
>>>>>>     return _mupdf.fz_runeptr(str, idx)
       
    1: def fz_runetochar(str, rune):
           r"""
           Class-aware wrapper for `::fz_runetochar()`.
               UTF8 encode a rune to a sequence of chars.
       
               str: Pointer to a place to put the UTF8 encoded character.
       
               rune: Pointer to a 'rune'.
       
               Returns the number of bytes the rune took to output.
           """
>>>>>>     return _mupdf.fz_runetochar(str, rune)
       
    1: def fz_samples_get(pixmap, offset):
           r"""
           Class-aware wrapper for `::fz_samples_get()`.
           Provides simple (but slow) access to pixmap data from Python and C#.
           """
>>>>>>     return _mupdf.fz_samples_get(pixmap, offset)
       
    1: def fz_samples_set(pixmap, offset, value):
           r"""
           Class-aware wrapper for `::fz_samples_set()`.
           Provides simple (but slow) write access to pixmap data from Python and
           C#.
           """
>>>>>>     return _mupdf.fz_samples_set(pixmap, offset, value)
       
    1: def fz_save_accelerator(doc, accel):
           r"""
           Class-aware wrapper for `::fz_save_accelerator()`.
               Save accelerator data for the document to a given file.
           """
>>>>>>     return _mupdf.fz_save_accelerator(doc, accel)
       
    1: def fz_save_bitmap_as_pbm(bitmap, filename):
           r"""
           Class-aware wrapper for `::fz_save_bitmap_as_pbm()`.
               Save a bitmap as a pbm.
           """
>>>>>>     return _mupdf.fz_save_bitmap_as_pbm(bitmap, filename)
       
    1: def fz_save_bitmap_as_pcl(bitmap, filename, append, pcl):
           r"""
           Class-aware wrapper for `::fz_save_bitmap_as_pcl()`.
               Save a bitmap as mono PCL.
           """
>>>>>>     return _mupdf.fz_save_bitmap_as_pcl(bitmap, filename, append, pcl)
       
    1: def fz_save_bitmap_as_pkm(bitmap, filename):
           r"""
           Class-aware wrapper for `::fz_save_bitmap_as_pkm()`.
               Save a CMYK bitmap as a pkm.
           """
>>>>>>     return _mupdf.fz_save_bitmap_as_pkm(bitmap, filename)
       
    1: def fz_save_bitmap_as_pwg(bitmap, filename, append, pwg):
           r"""
           Class-aware wrapper for `::fz_save_bitmap_as_pwg()`.
               Save a bitmap as a PWG.
           """
>>>>>>     return _mupdf.fz_save_bitmap_as_pwg(bitmap, filename, append, pwg)
       
    1: def fz_save_buffer(buf, filename):
           r"""
           Class-aware wrapper for `::fz_save_buffer()`.
               Save the contents of a buffer to a file.
           """
>>>>>>     return _mupdf.fz_save_buffer(buf, filename)
       
    1: def fz_save_pixmap_as_jpeg(pixmap, filename, quality):
           r"""
           Class-aware wrapper for `::fz_save_pixmap_as_jpeg()`.
               Save a pixmap as a JPEG.
           """
>>>>>>     return _mupdf.fz_save_pixmap_as_jpeg(pixmap, filename, quality)
       
    1: def fz_save_pixmap_as_jpx(pixmap, filename, q):
           r"""
           Class-aware wrapper for `::fz_save_pixmap_as_jpx()`.
               Save pixmap data as JP2K with no subsampling.
       
               quality = 100 = lossless
               otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
           """
>>>>>>     return _mupdf.fz_save_pixmap_as_jpx(pixmap, filename, q)
       
    1: def fz_save_pixmap_as_pam(pixmap, filename):
           r"""
           Class-aware wrapper for `::fz_save_pixmap_as_pam()`.
               Save a pixmap as a pnm (greyscale, rgb or cmyk, with or without
               alpha).
           """
>>>>>>     return _mupdf.fz_save_pixmap_as_pam(pixmap, filename)
       
    1: def fz_save_pixmap_as_pbm(pixmap, filename):
           r"""
           Class-aware wrapper for `::fz_save_pixmap_as_pbm()`.
               Save a pixmap as a pbm. (Performing halftoning).
           """
>>>>>>     return _mupdf.fz_save_pixmap_as_pbm(pixmap, filename)
       
    1: def fz_save_pixmap_as_pcl(pixmap, filename, append, pcl):
           r"""
           Class-aware wrapper for `::fz_save_pixmap_as_pcl()`.
               Save an (RGB) pixmap as color PCL.
           """
>>>>>>     return _mupdf.fz_save_pixmap_as_pcl(pixmap, filename, append, pcl)
       
    1: def fz_save_pixmap_as_pclm(pixmap, filename, append, options):
           r"""
           Class-aware wrapper for `::fz_save_pixmap_as_pclm()`.
               Save a (Greyscale or RGB) pixmap as pclm.
           """
>>>>>>     return _mupdf.fz_save_pixmap_as_pclm(pixmap, filename, append, options)
       
    1: def fz_save_pixmap_as_pdfocr(pixmap, filename, append, options):
           r"""
           Class-aware wrapper for `::fz_save_pixmap_as_pdfocr()`.
               Save a (Greyscale or RGB) pixmap as pdfocr.
           """
>>>>>>     return _mupdf.fz_save_pixmap_as_pdfocr(pixmap, filename, append, options)
       
    1: def fz_save_pixmap_as_pkm(pixmap, filename):
           r"""
           Class-aware wrapper for `::fz_save_pixmap_as_pkm()`.
               Save a CMYK pixmap as a pkm. (Performing halftoning).
           """
>>>>>>     return _mupdf.fz_save_pixmap_as_pkm(pixmap, filename)
       
    1: def fz_save_pixmap_as_png(pixmap, filename):
           r"""
           Class-aware wrapper for `::fz_save_pixmap_as_png()`.
               Save a (Greyscale or RGB) pixmap as a png.
           """
>>>>>>     return _mupdf.fz_save_pixmap_as_png(pixmap, filename)
       
    1: def fz_save_pixmap_as_pnm(pixmap, filename):
           r"""
           Class-aware wrapper for `::fz_save_pixmap_as_pnm()`.
               Save a pixmap as a pnm (greyscale or rgb, no alpha).
           """
>>>>>>     return _mupdf.fz_save_pixmap_as_pnm(pixmap, filename)
       
    1: def fz_save_pixmap_as_ps(pixmap, filename, append):
           r"""
           Class-aware wrapper for `::fz_save_pixmap_as_ps()`.
               Save a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
           """
>>>>>>     return _mupdf.fz_save_pixmap_as_ps(pixmap, filename, append)
       
    1: def fz_save_pixmap_as_psd(pixmap, filename):
           r"""
           Class-aware wrapper for `::fz_save_pixmap_as_psd()`.
               Save a pixmap as a PSD file.
           """
>>>>>>     return _mupdf.fz_save_pixmap_as_psd(pixmap, filename)
       
    1: def fz_save_pixmap_as_pwg(pixmap, filename, append, pwg):
           r"""
           Class-aware wrapper for `::fz_save_pixmap_as_pwg()`.
               Save a pixmap as a PWG.
           """
>>>>>>     return _mupdf.fz_save_pixmap_as_pwg(pixmap, filename, append, pwg)
       
    1: def fz_save_xml(root, path, indented):
           r"""
           Class-aware wrapper for `::fz_save_xml()`.
               As for fz_write_xml, but direct to a file.
           """
>>>>>>     return _mupdf.fz_save_xml(root, path, indented)
       
    1: def fz_scale(sx, sy):
           r"""
           Class-aware wrapper for `::fz_scale()`.
               Create a scaling matrix.
       
               The returned matrix is of the form [ sx 0 0 sy 0 0 ].
       
               m: Pointer to the matrix to populate
       
               sx, sy: Scaling factors along the X- and Y-axes. A scaling
               factor of 1.0 will not cause any scaling along the relevant
               axis.
       
               Returns m.
           """
>>>>>>     return _mupdf.fz_scale(sx, sy)
       
    1: def fz_scale_pixmap(src, x, y, w, h, clip):
           r"""Class-aware wrapper for `::fz_scale_pixmap()`."""
>>>>>>     return _mupdf.fz_scale_pixmap(src, x, y, w, h, clip)
       
    1: def fz_search_chapter_page_number(doc, chapter, page, needle, hit_mark, hit_bbox, hit_max):
           r"""
           Class-aware wrapper for `::fz_search_chapter_page_number()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_search_chapter_page_number(::fz_document *doc, int chapter, int page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
           """
>>>>>>     return _mupdf.fz_search_chapter_page_number(doc, chapter, page, needle, hit_mark, hit_bbox, hit_max)
       
    1: def fz_search_chapter_page_number_cb(doc, chapter, page, needle, cb, opaque):
           r"""Class-aware wrapper for `::fz_search_chapter_page_number_cb()`."""
>>>>>>     return _mupdf.fz_search_chapter_page_number_cb(doc, chapter, page, needle, cb, opaque)
       
    1: def fz_search_display_list(list, needle, hit_mark, hit_bbox, hit_max):
           r"""
           Class-aware wrapper for `::fz_search_display_list()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_search_display_list(::fz_display_list *list, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
           """
>>>>>>     return _mupdf.fz_search_display_list(list, needle, hit_mark, hit_bbox, hit_max)
       
    1: def fz_search_display_list_cb(list, needle, cb, opaque):
           r"""Class-aware wrapper for `::fz_search_display_list_cb()`."""
>>>>>>     return _mupdf.fz_search_display_list_cb(list, needle, cb, opaque)
       
    1: def fz_search_page(page, needle, hit_mark, hit_bbox, hit_max):
           r"""
           Class-aware wrapper for `::fz_search_page()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_search_page(::fz_page *page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
       
               Search for the 'needle' text on the page.
               Record the hits in the hit_bbox array and return the number of
               hits. Will stop looking once it has filled hit_max rectangles.
           """
>>>>>>     return _mupdf.fz_search_page(page, needle, hit_mark, hit_bbox, hit_max)
       
    1: def fz_search_page2(doc, number, needle, hit_max):
           r"""
           Class-aware wrapper for `::fz_search_page2()`.
           C++ alternative to fz_search_page() that returns information in a std::vector.
           """
>>>>>>     return _mupdf.fz_search_page2(doc, number, needle, hit_max)
       
    1: def fz_search_page_cb(page, needle, cb, opaque):
           r"""
           Class-aware wrapper for `::fz_search_page_cb()`.
               Search for the 'needle' text on the page.
           """
>>>>>>     return _mupdf.fz_search_page_cb(page, needle, cb, opaque)
       
    1: def fz_search_page_number(doc, number, needle, hit_mark, hit_bbox, hit_max):
           r"""
           Class-aware wrapper for `::fz_search_page_number()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_search_page_number(::fz_document *doc, int number, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
           """
>>>>>>     return _mupdf.fz_search_page_number(doc, number, needle, hit_mark, hit_bbox, hit_max)
       
    1: def fz_search_page_number_cb(doc, number, needle, cb, opaque):
           r"""Class-aware wrapper for `::fz_search_page_number_cb()`."""
>>>>>>     return _mupdf.fz_search_page_number_cb(doc, number, needle, cb, opaque)
       
    1: def fz_search_stext_page(text, needle, hit_mark, hit_bbox, hit_max):
           r"""
           Class-aware wrapper for `::fz_search_stext_page()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_search_stext_page(::fz_stext_page *text, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
       
               Search for occurrence of 'needle' in text page.
       
               Return the number of quads and store hit quads in the passed in
               array.
       
               NOTE: This is an experimental interface and subject to change
               without notice.
           """
>>>>>>     return _mupdf.fz_search_stext_page(text, needle, hit_mark, hit_bbox, hit_max)
       
    1: def fz_search_stext_page_cb(text, needle, cb, opaque):
           r"""
           Class-aware wrapper for `::fz_search_stext_page_cb()`.
               Search for occurrence of 'needle' in text page.
       
               Call callback once for each hit. This callback will receive
               (potentially) multiple quads for each hit.
       
               Returns the number of hits - note that this is potentially
               different from (i.e. is not greater than) the number of quads
               as returned by the non callback API.
       
               NOTE: This is an experimental interface and subject to change
               without notice.
           """
>>>>>>     return _mupdf.fz_search_stext_page_cb(text, needle, cb, opaque)
       
    1: def fz_seek(stm, offset, whence):
           r"""
           Class-aware wrapper for `::fz_seek()`.
               Seek within a stream.
       
               stm: The stream to seek within.
       
               offset: The offset to seek to.
       
               whence: From where the offset is measured (see fseek).
               SEEK_SET - start of stream.
               SEEK_CUR - current position.
               SEEK_END - end of stream.
       
           """
>>>>>>     return _mupdf.fz_seek(stm, offset, whence)
       
    1: def fz_seek_output(out, off, whence):
           r"""
           Class-aware wrapper for `::fz_seek_output()`.
               Seek to the specified file position.
               See fseek for arguments.
       
               Throw an error on unseekable outputs.
           """
>>>>>>     return _mupdf.fz_seek_output(out, off, whence)
       
    1: def fz_segment_stext_page(page):
           r"""
           Class-aware wrapper for `::fz_segment_stext_page()`.
               Perform segmentation analysis on an (unstructured) page to look for
               recursive subdivisions.
       
               Essentially this code attempts to split the page horizontally and/or
               vertically repeatedly into smaller and smaller "segments" (divisions).
       
               This minimises the reordering of the content, but some reordering
               may be unavoidable.
       
               Returns 0 if no changes were made to the document.
       
               This is experimental code, and may change (or be removed) in future
               versions!
           """
>>>>>>     return _mupdf.fz_segment_stext_page(page)
       
    1: def fz_segment_stext_rect(page, rect):
           r"""
           Class-aware wrapper for `::fz_segment_stext_rect()`.
               Perform segmentation analysis on a rectangle of a given
               stext page.
       
               Like fz_segment_stext_page, this attempts to split the given page
               region horizontally and/or vertically repeatedly into smaller and
               smaller "segments".
       
               This works for pages with structure too, but splitting with
               rectangles that cut across structure blocks may not behave as
               expected.
       
               This minimises the reordering of the content (as viewed from the
               perspective of a depth first traversal), but some reordering may
               be unavoidable.
       
               This function accepts smaller gaps for segmentation than the full
               page segmentation does.
       
               Returns 0 if no changes were made to the document.
       
               This is experimental code, and may change (or be removed) in future
               versions!
           """
>>>>>>     return _mupdf.fz_segment_stext_rect(page, rect)
       
    1: def fz_separation_current_behavior(sep, separation):
           r"""
           Class-aware wrapper for `::fz_separation_current_behavior()`.
               Test for the current behavior of a separation.
           """
>>>>>>     return _mupdf.fz_separation_current_behavior(sep, separation)
       
    1: def fz_separation_equivalent(seps, idx, dst_cs, dst_color, prf, color_params):
           r"""
           Class-aware wrapper for `::fz_separation_equivalent()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_separation_equivalent(const ::fz_separations *seps, int idx, ::fz_colorspace *dst_cs, ::fz_colorspace *prf, ::fz_color_params color_params)` => float dst_color
       
               Get the equivalent separation color in a given colorspace.
           """
>>>>>>     return _mupdf.fz_separation_equivalent(seps, idx, dst_cs, dst_color, prf, color_params)
       
    1: def fz_separation_name(sep, separation):
           r"""Class-aware wrapper for `::fz_separation_name()`."""
>>>>>>     return _mupdf.fz_separation_name(sep, separation)
       
    1: def fz_set_aa_level(bits):
           r"""
           Class-aware wrapper for `::fz_set_aa_level()`.
               Set the number of bits of antialiasing we should
               use (for both text and graphics).
       
               bits: The number of bits of antialiasing to use (values are
               clamped to within the 0 to 8 range).
           """
>>>>>>     return _mupdf.fz_set_aa_level(bits)
       
    1: def fz_set_compressed_image_buffer(cimg, buf):
           r"""Class-aware wrapper for `::fz_set_compressed_image_buffer()`."""
>>>>>>     return _mupdf.fz_set_compressed_image_buffer(cimg, buf)
       
    1: def fz_set_default_cmyk(default_cs, cs):
           r"""Class-aware wrapper for `::fz_set_default_cmyk()`."""
>>>>>>     return _mupdf.fz_set_default_cmyk(default_cs, cs)
       
    1: def fz_set_default_colorspaces(dev, default_cs):
           r"""Class-aware wrapper for `::fz_set_default_colorspaces()`."""
>>>>>>     return _mupdf.fz_set_default_colorspaces(dev, default_cs)
       
    1: def fz_set_default_gray(default_cs, cs):
           r"""
           Class-aware wrapper for `::fz_set_default_gray()`.
               Set new defaults within the default colorspace structure.
       
               New references are taken to the new default, and references to
               the old defaults dropped.
       
               Never throws exceptions.
           """
>>>>>>     return _mupdf.fz_set_default_gray(default_cs, cs)
       
    1: def fz_set_default_output_intent(default_cs, cs):
           r"""Class-aware wrapper for `::fz_set_default_output_intent()`."""
>>>>>>     return _mupdf.fz_set_default_output_intent(default_cs, cs)
       
    1: def fz_set_default_rgb(default_cs, cs):
           r"""Class-aware wrapper for `::fz_set_default_rgb()`."""
>>>>>>     return _mupdf.fz_set_default_rgb(default_cs, cs)
       
    1: def fz_set_error_callback(error_cb, user):
           r"""
           Class-aware wrapper for `::fz_set_error_callback()`.
               Set the error callback. This will be called as part of the
               exception handling.
       
               The callback must not throw exceptions!
           """
>>>>>>     return _mupdf.fz_set_error_callback(error_cb, user)
       
    1: def fz_set_font_bbox(font, xmin, ymin, xmax, ymax):
           r"""
           Class-aware wrapper for `::fz_set_font_bbox()`.
               Set the font bbox.
       
               font: The font to set the bbox for.
       
               xmin, ymin, xmax, ymax: The bounding box.
           """
>>>>>>     return _mupdf.fz_set_font_bbox(font, xmin, ymin, xmax, ymax)
       
    1: def fz_set_font_embedding(font, embed):
           r"""
           Class-aware wrapper for `::fz_set_font_embedding()`.
               Control whether a given font should be embedded or not when writing.
           """
>>>>>>     return _mupdf.fz_set_font_embedding(font, embed)
       
    1: def fz_set_graphics_aa_level(bits):
           r"""
           Class-aware wrapper for `::fz_set_graphics_aa_level()`.
               Set the number of bits of antialiasing we
               should use for graphics.
       
               bits: The number of bits of antialiasing to use (values are
               clamped to within the 0 to 8 range).
           """
>>>>>>     return _mupdf.fz_set_graphics_aa_level(bits)
       
    1: def fz_set_graphics_min_line_width(min_line_width):
           r"""
           Class-aware wrapper for `::fz_set_graphics_min_line_width()`.
               Set the minimum line width to be
               used for stroked lines.
       
               min_line_width: The minimum line width to use (in pixels).
           """
>>>>>>     return _mupdf.fz_set_graphics_min_line_width(min_line_width)
       
    1: def fz_set_link_rect(link, rect):
           r"""Class-aware wrapper for `::fz_set_link_rect()`."""
>>>>>>     return _mupdf.fz_set_link_rect(link, rect)
       
    1: def fz_set_link_uri(link, uri):
           r"""Class-aware wrapper for `::fz_set_link_uri()`."""
>>>>>>     return _mupdf.fz_set_link_uri(link, uri)
       
    1: def fz_set_metadata(doc, key, value):
           r"""Class-aware wrapper for `::fz_set_metadata()`."""
>>>>>>     return _mupdf.fz_set_metadata(doc, key, value)
       
    1: def fz_set_pixmap_image_tile(cimg, pix):
           r"""Class-aware wrapper for `::fz_set_pixmap_image_tile()`."""
>>>>>>     return _mupdf.fz_set_pixmap_image_tile(cimg, pix)
       
    1: def fz_set_pixmap_resolution(pix, xres, yres):
           r"""
           Class-aware wrapper for `::fz_set_pixmap_resolution()`.
               Set the pixels per inch resolution of the pixmap.
           """
>>>>>>     return _mupdf.fz_set_pixmap_resolution(pix, xres, yres)
       
    1: def fz_set_separation_behavior(sep, separation, behavior):
           r"""
           Class-aware wrapper for `::fz_set_separation_behavior()`.
               Control the rendering of a given separation.
           """
>>>>>>     return _mupdf.fz_set_separation_behavior(sep, separation, behavior)
       
    1: def fz_set_stddbg(out):
           r"""
           Class-aware wrapper for `::fz_set_stddbg()`.
               Set the output stream to be used for fz_stddbg. Set to NULL to
               reset to default (stderr).
           """
>>>>>>     return _mupdf.fz_set_stddbg(out)
       
    1: def fz_set_text_aa_level(bits):
           r"""
           Class-aware wrapper for `::fz_set_text_aa_level()`.
               Set the number of bits of antialiasing we
               should use for text.
       
               bits: The number of bits of antialiasing to use (values are
               clamped to within the 0 to 8 range).
           """
>>>>>>     return _mupdf.fz_set_text_aa_level(bits)
       
    1: def fz_set_use_document_css(use):
           r"""
           Class-aware wrapper for `::fz_set_use_document_css()`.
               Toggle whether to respect document styles in HTML and EPUB.
           """
>>>>>>     return _mupdf.fz_set_use_document_css(use)
       
    1: def fz_set_user_context(user):
           r"""
           Class-aware wrapper for `::fz_set_user_context()`.
               Set the user field in the context.
       
               NULL initially, this field can be set to any opaque value
               required by the user. It is copied on clones.
           """
>>>>>>     return _mupdf.fz_set_user_context(user)
       
    1: def fz_set_user_css(text):
           r"""
           Class-aware wrapper for `::fz_set_user_css()`.
               Set the user stylesheet source text for use with HTML and EPUB.
           """
>>>>>>     return _mupdf.fz_set_user_css(text)
       
    1: def fz_set_warning_callback(warning_cb, user):
           r"""
           Class-aware wrapper for `::fz_set_warning_callback()`.
               Set the warning callback. This will be called as part of the
               exception handling.
       
               The callback must not throw exceptions!
           """
>>>>>>     return _mupdf.fz_set_warning_callback(warning_cb, user)
       
    1: def fz_sha256_final(state, digest):
           r"""
           Class-aware wrapper for `::fz_sha256_final()`.
               MD5 finalization. Ends an MD5 message-digest operation, writing
               the message digest and zeroizing the context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_sha256_final(state, digest)
       
    1: def fz_sha256_init(state):
           r"""
           Class-aware wrapper for `::fz_sha256_init()`.
               SHA256 initialization. Begins an SHA256 operation, initialising
               the supplied context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_sha256_init(state)
       
    1: def fz_sha256_update(state, input, inlen):
           r"""
           Class-aware wrapper for `::fz_sha256_update()`.
               SHA256 block update operation. Continues an SHA256 message-
               digest operation, processing another message block, and updating
               the context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_sha256_update(state, input, inlen)
       
    1: def fz_sha384_final(state, digest):
           r"""
           Class-aware wrapper for `::fz_sha384_final()`.
               SHA384 finalization. Ends an SHA384 message-digest operation,
               writing the message digest and zeroizing the context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_sha384_final(state, digest)
       
    1: def fz_sha384_init(state):
           r"""
           Class-aware wrapper for `::fz_sha384_init()`.
               SHA384 initialization. Begins an SHA384 operation, initialising
               the supplied context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_sha384_init(state)
       
    1: def fz_sha384_update(state, input, inlen):
           r"""
           Class-aware wrapper for `::fz_sha384_update()`.
               SHA384 block update operation. Continues an SHA384 message-
               digest operation, processing another message block, and updating
               the context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_sha384_update(state, input, inlen)
       
    1: def fz_sha512_final(state, digest):
           r"""
           Class-aware wrapper for `::fz_sha512_final()`.
               SHA512 finalization. Ends an SHA512 message-digest operation,
               writing the message digest and zeroizing the context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_sha512_final(state, digest)
       
    1: def fz_sha512_init(state):
           r"""
           Class-aware wrapper for `::fz_sha512_init()`.
               SHA512 initialization. Begins an SHA512 operation, initialising
               the supplied context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_sha512_init(state)
       
    1: def fz_sha512_update(state, input, inlen):
           r"""
           Class-aware wrapper for `::fz_sha512_update()`.
               SHA512 block update operation. Continues an SHA512 message-
               digest operation, processing another message block, and updating
               the context.
       
               Never throws an exception.
           """
>>>>>>     return _mupdf.fz_sha512_update(state, input, inlen)
       
    1: def fz_shear(sx, sy):
           r"""
           Class-aware wrapper for `::fz_shear()`.
               Create a shearing matrix.
       
               The returned matrix is of the form [ 1 sy sx 1 0 0 ].
       
               m: pointer to place to store returned matrix
       
               sx, sy: Shearing factors. A shearing factor of 0.0 will not
               cause any shearing along the relevant axis.
       
               Returns m.
           """
>>>>>>     return _mupdf.fz_shear(sx, sy)
       
    1: def fz_show_glyph(text, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language):
           r"""
           Class-aware wrapper for `::fz_show_glyph()`.
               Add a glyph/unicode value to a text object.
       
               text: Text object to add to.
       
               font: The font the glyph should be added in.
       
               trm: The transform to use for the glyph.
       
               glyph: The glyph id to add.
       
               unicode: The unicode character for the glyph.
       
               cid: The CJK CID value or raw character code.
       
               wmode: 1 for vertical mode, 0 for horizontal.
       
               bidi_level: The bidirectional level for this glyph.
       
               markup_dir: The direction of the text as specified in the
               markup.
       
               language: The language in use (if known, 0 otherwise)
               (e.g. FZ_LANG_zh_Hans).
       
               Throws exception on failure to allocate.
           """
>>>>>>     return _mupdf.fz_show_glyph(text, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language)
       
    1: def fz_show_glyph_aux(text, font, trm, adv, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang):
           r"""Class-aware wrapper for `::fz_show_glyph_aux()`."""
>>>>>>     return _mupdf.fz_show_glyph_aux(text, font, trm, adv, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang)
       
    1: def fz_show_string(text, font, trm, s, wmode, bidi_level, markup_dir, language):
           r"""
           Class-aware wrapper for `::fz_show_string()`.
               Add a UTF8 string to a text object.
       
               text: Text object to add to.
       
               font: The font the string should be added in.
       
               trm: The transform to use.
       
               s: The utf-8 string to add.
       
               wmode: 1 for vertical mode, 0 for horizontal.
       
               bidi_level: The bidirectional level for this glyph.
       
               markup_dir: The direction of the text as specified in the markup.
       
               language: The language in use (if known, 0 otherwise)
                       (e.g. FZ_LANG_zh_Hans).
       
               Returns the transform updated with the advance width of the
               string.
           """
>>>>>>     return _mupdf.fz_show_string(text, font, trm, s, wmode, bidi_level, markup_dir, language)
       
    1: def fz_shrink_store(percent):
           r"""
           Class-aware wrapper for `::fz_shrink_store()`.
               Evict items from the store until the total size of
               the objects in the store is reduced to a given percentage of its
               current size.
       
               percent: %age of current size to reduce the store to.
       
               Returns non zero if we managed to free enough memory, zero
               otherwise.
           """
>>>>>>     return _mupdf.fz_shrink_store(percent)
       
    1: def fz_skip(stm, len):
           r"""
           Class-aware wrapper for `::fz_skip()`.
               Read from a stream discarding data.
       
               stm: The stream to read from.
       
               len: The number of bytes to read.
       
               Returns the number of bytes read. May throw exceptions.
           """
>>>>>>     return _mupdf.fz_skip(stm, len)
       
    1: def fz_skip_space(stm):
           r"""
           Class-aware wrapper for `::fz_skip_space()`.
               Skip over whitespace (bytes <= 32) in a stream.
           """
>>>>>>     return _mupdf.fz_skip_space(stm)
       
    1: def fz_skip_string(stm, str):
           r"""
           Class-aware wrapper for `::fz_skip_string()`.
               Skip over a given string in a stream. Return 0 if successfully
               skipped, non-zero otherwise. As many characters will be skipped
               over as matched in the string.
           """
>>>>>>     return _mupdf.fz_skip_string(stm, str)
       
    1: def fz_slice_buffer(buf, start, end):
           r"""
           Class-aware wrapper for `::fz_slice_buffer()`.
               Create a new buffer with a (subset of) the data from the buffer.
       
               start: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.
       
               end: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.
       
           """
>>>>>>     return _mupdf.fz_slice_buffer(buf, start, end)
       
    1: def fz_snap_selection(page, ap, bp, mode):
           r"""Class-aware wrapper for `::fz_snap_selection()`."""
>>>>>>     return _mupdf.fz_snap_selection(page, ap, bp, mode)
       
    1: def fz_start_throw_on_repair():
           r"""Class-aware wrapper for `::fz_start_throw_on_repair()`."""
>>>>>>     return _mupdf.fz_start_throw_on_repair()
       
    1: def fz_stat_ctime(path):
           r"""Class-aware wrapper for `::fz_stat_ctime()`."""
>>>>>>     return _mupdf.fz_stat_ctime(path)
       
    1: def fz_stat_mtime(path):
           r"""Class-aware wrapper for `::fz_stat_mtime()`."""
>>>>>>     return _mupdf.fz_stat_mtime(path)
       
    1: def fz_stext_page_block_iterator_eod(pos):
           r"""Class-aware wrapper for `::fz_stext_page_block_iterator_eod()`."""
>>>>>>     return _mupdf.fz_stext_page_block_iterator_eod(pos)
       
    1: def fz_stext_page_block_iterator_eod_dfs(pos):
           r"""Class-aware wrapper for `::fz_stext_page_block_iterator_eod_dfs()`."""
>>>>>>     return _mupdf.fz_stext_page_block_iterator_eod_dfs(pos)
       
    1: def fz_stext_remove_page_fill(page):
           r"""Class-aware wrapper for `::fz_stext_remove_page_fill()`."""
>>>>>>     return _mupdf.fz_stext_remove_page_fill(page)
       
    1: def fz_store_item(key, val, itemsize, type):
           r"""
           Class-aware wrapper for `::fz_store_item()`.
               Add an item to the store.
       
               Add an item into the store, returning NULL for success. If an
               item with the same key is found in the store, then our item will
               not be inserted, and the function will return a pointer to that
               value instead. This function takes its own reference to val, as
               required (i.e. the caller maintains ownership of its own
               reference).
       
               key: The key used to index the item.
       
               val: The value to store.
       
               itemsize: The size in bytes of the value (as counted towards the
               store size).
       
               type: Functions used to manipulate the key.
           """
>>>>>>     return _mupdf.fz_store_item(key, val, itemsize, type)
       
    1: def fz_store_scavenge(size, phase):
           r"""
           Class-aware wrapper for `::fz_store_scavenge()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_store_scavenge(size_t size)` => `(int, int phase)`
       
               Internal function used as part of the scavenging
               allocator; when we fail to allocate memory, before returning a
               failure to the caller, we try to scavenge space within the store
               by evicting at least 'size' bytes. The allocator then retries.
       
               size: The number of bytes we are trying to have free.
       
               phase: What phase of the scavenge we are in. Updated on exit.
       
               Returns non zero if we managed to free any memory.
           """
>>>>>>     return _mupdf.fz_store_scavenge(size, phase)
       
    1: def fz_store_scavenge_external(size, phase):
           r"""
           Class-aware wrapper for `::fz_store_scavenge_external()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_store_scavenge_external(size_t size)` => `(int, int phase)`
       
               External function for callers to use
               to scavenge while trying allocations.
       
               size: The number of bytes we are trying to have free.
       
               phase: What phase of the scavenge we are in. Updated on exit.
       
               Returns non zero if we managed to free any memory.
           """
>>>>>>     return _mupdf.fz_store_scavenge_external(size, phase)
       
    1: def fz_story_document(story):
           r"""Class-aware wrapper for `::fz_story_document()`."""
>>>>>>     return _mupdf.fz_story_document(story)
       
    1: def fz_story_positions(story, cb, arg):
           r"""Class-aware wrapper for `::fz_story_positions()`."""
>>>>>>     return _mupdf.fz_story_positions(story, cb, arg)
       
    1: def fz_story_warnings(story):
           r"""Class-aware wrapper for `::fz_story_warnings()`."""
>>>>>>     return _mupdf.fz_story_warnings(story)
       
    1: def fz_strcasecmp(a, b):
           r"""
           Class-aware wrapper for `::fz_strcasecmp()`.
               Case insensitive (UTF8) string comparison.
           """
>>>>>>     return _mupdf.fz_strcasecmp(a, b)
       
    1: def fz_strdup(s):
           r"""
           Class-aware wrapper for `::fz_strdup()`.
               Portable strdup implementation, using fz allocators.
           """
>>>>>>     return _mupdf.fz_strdup(s)
       
    1: def fz_stream_filename(stm):
           r"""
           Class-aware wrapper for `::fz_stream_filename()`.
               Return the filename (UTF-8 encoded) from which a stream was opened.
       
               Returns NULL if the filename is not available (or the stream was
               opened from a source other than a file).
           """
>>>>>>     return _mupdf.fz_stream_filename(stm)
       
    1: def fz_stream_from_output(arg_0):
           r"""
           Class-aware wrapper for `::fz_stream_from_output()`.
               Obtain the fz_output in the form of a fz_stream.
       
               This allows data to be read back from some forms of fz_output
               object. When finished reading, the fz_stream should be released
               by calling fz_drop_stream. Until the fz_stream is dropped, no
               further operations should be performed on the fz_output object.
           """
>>>>>>     return _mupdf.fz_stream_from_output(arg_0)
       
    1: def fz_string_from_barcode_type(type):
           r"""
           Class-aware wrapper for `::fz_string_from_barcode_type()`.
               Return barcode string matching one of the above barcode types.
               All lowercase, e.g. "none", "aztec" etc.
           """
>>>>>>     return _mupdf.fz_string_from_barcode_type(type)
       
    1: def fz_string_from_box_type(box):
           r"""Class-aware wrapper for `::fz_string_from_box_type()`."""
>>>>>>     return _mupdf.fz_string_from_box_type(box)
       
    1: def fz_string_from_buffer(buf):
           r"""
           Class-aware wrapper for `::fz_string_from_buffer()`.
               Ensure that a buffer's data ends in a
               0 byte, and return a pointer to it.
           """
>>>>>>     return _mupdf.fz_string_from_buffer(buf)
       
    1: def fz_string_from_linecap(cap):
           r"""Class-aware wrapper for `::fz_string_from_linecap()`."""
>>>>>>     return _mupdf.fz_string_from_linecap(cap)
       
    1: def fz_string_from_linejoin(join):
           r"""Class-aware wrapper for `::fz_string_from_linejoin()`."""
>>>>>>     return _mupdf.fz_string_from_linejoin(join)
       
    1: def fz_string_from_text_language(str, lang):
           r"""
           Class-aware wrapper for `::fz_string_from_text_language()`.
               Recover ISO 639 (639-{1,2,3,5}) language specification
               strings losslessly from a 15 bit fz_text_language code.
       
               No validation is carried out. See note above.
           """
>>>>>>     return _mupdf.fz_string_from_text_language(str, lang)
       
    1: def fz_string_from_text_language2(lang):
           r"""
           Class-aware wrapper for `::fz_string_from_text_language2()`.
           C++ alternative to fz_string_from_text_language() that returns information in a std::string.
           """
>>>>>>     return _mupdf.fz_string_from_text_language2(lang)
       
    1: def fz_strlcat(dst, src, n):
           r"""
           Class-aware wrapper for `::fz_strlcat()`.
               Concatenate 2 strings, with a maximum length.
       
               dst: pointer to first string in a buffer of n bytes.
       
               src: pointer to string to concatenate.
       
               n: Size (in bytes) of buffer that dst is in.
       
               Returns the real length that a concatenated dst + src would have
               been (not including terminator).
           """
>>>>>>     return _mupdf.fz_strlcat(dst, src, n)
       
    1: def fz_strlcpy(dst, src, n):
           r"""
           Class-aware wrapper for `::fz_strlcpy()`.
               Copy at most n-1 chars of a string into a destination
               buffer with null termination, returning the real length of the
               initial string (excluding terminator).
       
               dst: Destination buffer, at least n bytes long.
       
               src: C string (non-NULL).
       
               n: Size of dst buffer in bytes.
       
               Returns the length (excluding terminator) of src.
           """
>>>>>>     return _mupdf.fz_strlcpy(dst, src, n)
       
    1: def fz_strncasecmp(a, b, n):
           r"""
           Class-aware wrapper for `::fz_strncasecmp()`.
               Case insensitive (UTF8) string comparison.
       
               n = maximum number of bytes to read from either a or b.
           """
>>>>>>     return _mupdf.fz_strncasecmp(a, b, n)
       
    1: def fz_strnlen(s, maxlen):
           r"""
           Class-aware wrapper for `::fz_strnlen()`.
               Return strlen(s), if that is less than maxlen, or maxlen if
               there is no null byte ('') among the first maxlen bytes.
           """
>>>>>>     return _mupdf.fz_strnlen(s, maxlen)
       
    1: def fz_stroke_path(dev, path, stroke, ctm, colorspace, color, alpha, color_params):
           r"""Class-aware wrapper for `::fz_stroke_path()`."""
>>>>>>     return _mupdf.fz_stroke_path(dev, path, stroke, ctm, colorspace, color, alpha, color_params)
       
    1: def fz_stroke_state_eq(a, b):
           r"""Class-aware wrapper for `::fz_stroke_state_eq()`."""
>>>>>>     return _mupdf.fz_stroke_state_eq(a, b)
       
    1: def fz_stroke_text(dev, text, stroke, ctm, colorspace, color, alpha, color_params):
           r"""Class-aware wrapper for `::fz_stroke_text()`."""
>>>>>>     return _mupdf.fz_stroke_text(dev, text, stroke, ctm, colorspace, color, alpha, color_params)
       
    1: def fz_strsep(stringp, delim):
           r"""
           Class-aware wrapper for `::fz_strsep()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_strsep(const char *delim)` => `(char *, char *stringp)`
       
               Given a pointer to a C string (or a pointer to NULL) break
               it at the first occurrence of a delimiter char (from a given
               set).
       
               stringp: Pointer to a C string pointer (or NULL). Updated on
               exit to point to the first char of the string after the
               delimiter that was found. The string pointed to by stringp will
               be corrupted by this call (as the found delimiter will be
               overwritten by 0).
       
               delim: A C string of acceptable delimiter characters.
       
               Returns a pointer to a C string containing the chars of stringp
               up to the first delimiter char (or the end of the string), or
               NULL.
           """
>>>>>>     return _mupdf.fz_strsep(stringp, delim)
       
    1: def fz_strstr(haystack, needle):
           r"""
           Class-aware wrapper for `::fz_strstr()`.
               Safe strstr function.
       
               haystack: Where to look (may be NULL).
       
               needled: What to look for.
       
               Returns NULL if unmatched, or pointer to start of match.
           """
>>>>>>     return _mupdf.fz_strstr(haystack, needle)
       
    1: def fz_strstrcase(haystack, needle):
           r"""
           Class-aware wrapper for `::fz_strstrcase()`.
               Safe case-insensitive strstr function. (Accepts UTF-8).
       
               haystack: Where to look (may be NULL).
       
               needled: What to look for.
       
               Returns NULL if unmatched, or pointer to start of match.
           """
>>>>>>     return _mupdf.fz_strstrcase(haystack, needle)
       
    1: def fz_strtof(s, es):
           r"""
           Class-aware wrapper for `::fz_strtof()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_strtof(const char *s)` => `(float, char *es)`
       
               Locale-independent decimal to binary conversion. On overflow
               return (-)INFINITY and set errno to ERANGE. On underflow return
               0 and set errno to ERANGE. Special inputs (case insensitive):
               "NAN", "INF" or "INFINITY".
           """
>>>>>>     return _mupdf.fz_strtof(s, es)
       
    1: def fz_structure_from_string(str):
           r"""Class-aware wrapper for `::fz_structure_from_string()`."""
>>>>>>     return _mupdf.fz_structure_from_string(str)
       
    1: def fz_structure_to_string(type):
           r"""Class-aware wrapper for `::fz_structure_to_string()`."""
>>>>>>     return _mupdf.fz_structure_to_string(type)
       
    1: def fz_strverscmp(s1, s2):
           r"""
           Class-aware wrapper for `::fz_strverscmp()`.
               portable strverscmp(3) function
           """
>>>>>>     return _mupdf.fz_strverscmp(s1, s2)
       
    1: def fz_subpixel_adjust(ctm, subpix_ctm, qe, qf):
           r"""
           Class-aware wrapper for `::fz_subpixel_adjust()`.
               Perform subpixel quantisation and adjustment on a glyph matrix.
       
               ctm: On entry, the desired 'ideal' transformation for a glyph.
               On exit, adjusted to a (very similar) transformation quantised
               for subpixel caching.
       
               subpix_ctm: Initialised by the routine to the transform that
               should be used to render the glyph.
       
               qe, qf: which subpixel position we quantised to.
       
               Returns: the size of the glyph.
       
               Note: This is currently only exposed for use in our app. It
               should be considered "at risk" of removal from the API.
           """
>>>>>>     return _mupdf.fz_subpixel_adjust(ctm, subpix_ctm, qe, qf)
       
    1: def fz_subsample_pixmap(tile, factor):
           r"""Class-aware wrapper for `::fz_subsample_pixmap()`."""
>>>>>>     return _mupdf.fz_subsample_pixmap(tile, factor)
       
    1: def fz_subset_cff_for_gids(orig, gids, num_gids, symbolic, cidfont):
           r"""
           Class-aware wrapper for `::fz_subset_cff_for_gids()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_subset_cff_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
           """
>>>>>>     return _mupdf.fz_subset_cff_for_gids(orig, gids, num_gids, symbolic, cidfont)
       
    1: def fz_subset_ttf_for_gids(orig, gids, num_gids, symbolic, cidfont):
           r"""
           Class-aware wrapper for `::fz_subset_ttf_for_gids()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_subset_ttf_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
           """
>>>>>>     return _mupdf.fz_subset_ttf_for_gids(orig, gids, num_gids, symbolic, cidfont)
       
    1: def fz_sync_bits(stm):
           r"""
           Class-aware wrapper for `::fz_sync_bits()`.
               Called after reading bits to tell the stream
               that we are about to return to reading bytewise. Resyncs
               the stream to whole byte boundaries.
           """
>>>>>>     return _mupdf.fz_sync_bits(stm)
       
    1: def fz_table_hunt(page):
           r"""
           Class-aware wrapper for `::fz_table_hunt()`.
               Hunt for possible tables on a page, and update the stext with
               information.
           """
>>>>>>     return _mupdf.fz_table_hunt(page)
       
    1: def fz_table_hunt_within_bounds(page, bounds):
           r"""
           Class-aware wrapper for `::fz_table_hunt_within_bounds()`.
               Hunt for possible tables within a specific rect on a page, and
               update the stext with information.
           """
>>>>>>     return _mupdf.fz_table_hunt_within_bounds(page, bounds)
       
    1: def fz_tell(stm):
           r"""
           Class-aware wrapper for `::fz_tell()`.
               return the current reading position within a stream
           """
>>>>>>     return _mupdf.fz_tell(stm)
       
    1: def fz_tell_output(out):
           r"""
           Class-aware wrapper for `::fz_tell_output()`.
               Return the current file position.
       
               Throw an error on untellable outputs.
           """
>>>>>>     return _mupdf.fz_tell_output(out)
       
    1: def fz_terminate_buffer(buf):
           r"""
           Class-aware wrapper for `::fz_terminate_buffer()`.
               Zero-terminate buffer in order to use as a C string.
       
               This byte is invisible and does not affect the length of the
               buffer as returned by fz_buffer_storage. The zero byte is
               written *after* the data, and subsequent writes will overwrite
               the terminating byte.
       
               Subsequent changes to the size of the buffer (such as by
               fz_buffer_trim, fz_buffer_grow, fz_resize_buffer, etc) may
               invalidate this.
           """
>>>>>>     return _mupdf.fz_terminate_buffer(buf)
       
    1: def fz_text_aa_level():
           r"""
           Class-aware wrapper for `::fz_text_aa_level()`.
               Get the number of bits of antialiasing we are
               using for text. Between 0 and 8.
           """
>>>>>>     return _mupdf.fz_text_aa_level()
       
    1: def fz_text_language_from_string(str):
           r"""
           Class-aware wrapper for `::fz_text_language_from_string()`.
               Convert ISO 639 (639-{1,2,3,5}) language specification
               strings losslessly to a 15 bit fz_text_language code.
       
               No validation is carried out. Obviously invalid (out
               of spec) codes will be mapped to FZ_LANG_UNSET, but
               well-formed (but undefined) codes will be blithely
               accepted.
           """
>>>>>>     return _mupdf.fz_text_language_from_string(str)
       
    1: def fz_tint_pixmap(pix, black, white):
           r"""
           Class-aware wrapper for `::fz_tint_pixmap()`.
               Tint all the pixels in an RGB, BGR, or Gray pixmap.
       
               black: Map black to this hexadecimal RGB color.
       
               white: Map white to this hexadecimal RGB color.
           """
>>>>>>     return _mupdf.fz_tint_pixmap(pix, black, white)
       
    1: def fz_tolower(c):
           r"""
           Class-aware wrapper for `::fz_tolower()`.
               Unicode aware tolower and toupper functions.
           """
>>>>>>     return _mupdf.fz_tolower(c)
       
    1: def fz_toupper(c):
           r"""Class-aware wrapper for `::fz_toupper()`."""
>>>>>>     return _mupdf.fz_toupper(c)
       
    1: def fz_transform_page(mediabox, resolution, rotate):
           r"""
           Class-aware wrapper for `::fz_transform_page()`.
               Create transform matrix to draw page
               at a given resolution and rotation. Adjusts the scaling
               factors so that the page covers whole number of
               pixels and adjust the page origin to be at 0,0.
           """
>>>>>>     return _mupdf.fz_transform_page(mediabox, resolution, rotate)
       
    1: def fz_transform_path(path, transform):
           r"""
           Class-aware wrapper for `::fz_transform_path()`.
               Transform a path by a given
               matrix.
       
               path: The path to modify (must not be a packed path).
       
               transform: The transform to apply.
       
               Throws exceptions if the path is packed, or on failure
               to allocate.
           """
>>>>>>     return _mupdf.fz_transform_path(path, transform)
       
    1: def fz_transform_point(point, m):
           r"""
           Class-aware wrapper for `::fz_transform_point()`.
               Apply a transformation to a point.
       
               transform: Transformation matrix to apply. See fz_concat,
               fz_scale, fz_rotate and fz_translate for how to create a
               matrix.
       
               point: Pointer to point to update.
       
               Returns transform (unchanged).
           """
>>>>>>     return _mupdf.fz_transform_point(point, m)
       
    1: def fz_transform_point_xy(x, y, m):
           r"""Class-aware wrapper for `::fz_transform_point_xy()`."""
>>>>>>     return _mupdf.fz_transform_point_xy(x, y, m)
       
    1: def fz_transform_quad(q, m):
           r"""
           Class-aware wrapper for `::fz_transform_quad()`.
               Transform a quad by a matrix.
           """
>>>>>>     return _mupdf.fz_transform_quad(q, m)
       
    1: def fz_transform_rect(rect, m):
           r"""
           Class-aware wrapper for `::fz_transform_rect()`.
               Apply a transform to a rectangle.
       
               After the four corner points of the axis-aligned rectangle
               have been transformed it may not longer be axis-aligned. So a
               new axis-aligned rectangle is created covering at least the
               area of the transformed rectangle.
       
               transform: Transformation matrix to apply. See fz_concat,
               fz_scale and fz_rotate for how to create a matrix.
       
               rect: Rectangle to be transformed. The two special cases
               fz_empty_rect and fz_infinite_rect, may be used but are
               returned unchanged as expected.
           """
>>>>>>     return _mupdf.fz_transform_rect(rect, m)
       
    1: def fz_transform_vector(vector, m):
           r"""
           Class-aware wrapper for `::fz_transform_vector()`.
               Apply a transformation to a vector.
       
               transform: Transformation matrix to apply. See fz_concat,
               fz_scale and fz_rotate for how to create a matrix. Any
               translation will be ignored.
       
               vector: Pointer to vector to update.
           """
>>>>>>     return _mupdf.fz_transform_vector(vector, m)
       
    1: def fz_translate(tx, ty):
           r"""
           Class-aware wrapper for `::fz_translate()`.
               Create a translation matrix.
       
               The returned matrix is of the form [ 1 0 0 1 tx ty ].
       
               m: A place to store the created matrix.
       
               tx, ty: Translation distances along the X- and Y-axes. A
               translation of 0 will not cause any translation along the
               relevant axis.
       
               Returns m.
           """
>>>>>>     return _mupdf.fz_translate(tx, ty)
       
    1: def fz_translate_irect(a, xoff, yoff):
           r"""Class-aware wrapper for `::fz_translate_irect()`."""
>>>>>>     return _mupdf.fz_translate_irect(a, xoff, yoff)
       
    1: def fz_translate_rect(a, xoff, yoff):
           r"""
           Class-aware wrapper for `::fz_translate_rect()`.
               Translate bounding box.
       
               Translate a bbox by a given x and y offset. Allows for overflow.
           """
>>>>>>     return _mupdf.fz_translate_rect(a, xoff, yoff)
       
    1: def fz_tree_archive_add_buffer(arch_, name, buf):
           r"""
           Class-aware wrapper for `::fz_tree_archive_add_buffer()`.
               Add a named buffer to an existing tree archive.
       
               The tree will take a new reference to the buffer. Ownership
               is not transferred.
           """
>>>>>>     return _mupdf.fz_tree_archive_add_buffer(arch_, name, buf)
       
    1: def fz_tree_archive_add_data(arch_, name, data, size):
           r"""
           Class-aware wrapper for `::fz_tree_archive_add_data()`.
               Add a named block of data to an existing tree archive.
       
               The data will be copied into a buffer, and so the caller
               may free it as soon as this returns.
           """
>>>>>>     return _mupdf.fz_tree_archive_add_data(arch_, name, data, size)
       
    1: def fz_tree_lookup(node, key):
           r"""
           Class-aware wrapper for `::fz_tree_lookup()`.
               Look for the value of a node in the tree with the given key.
       
               Simple pointer equivalence is used for key.
       
               Returns NULL for no match.
           """
>>>>>>     return _mupdf.fz_tree_lookup(node, key)
       
    1: def fz_trim_buffer(buf):
           r"""
           Class-aware wrapper for `::fz_trim_buffer()`.
               Trim wasted capacity from a buffer by resizing internal memory.
           """
>>>>>>     return _mupdf.fz_trim_buffer(buf)
       
    1: def fz_trim_path(path):
           r"""
           Class-aware wrapper for `::fz_trim_path()`.
               Minimise the internal storage used by a path.
       
               As paths are constructed, the internal buffers
               grow. To avoid repeated reallocations they
               grow with some spare space. Once a path has
               been fully constructed, this call allows the
               excess space to be trimmed.
           """
>>>>>>     return _mupdf.fz_trim_path(path)
       
    1: def fz_truncate_output(arg_0):
           r"""
           Class-aware wrapper for `::fz_truncate_output()`.
               Truncate the output at the current position.
       
               This allows output streams which have seeked back from the end
               of their storage to be truncated at the current point.
           """
>>>>>>     return _mupdf.fz_truncate_output(arg_0)
       
    1: def fz_try_invert_matrix(inv, src):
           r"""
           Class-aware wrapper for `::fz_try_invert_matrix()`.
               Attempt to create an inverse matrix.
       
               inv: Place to store inverse matrix.
       
               src: Matrix to invert. A degenerate matrix, where the
               determinant is equal to zero, can not be inverted.
       
               Returns 1 if matrix is degenerate (singular), or 0 otherwise.
           """
>>>>>>     return _mupdf.fz_try_invert_matrix(inv, src)
       
    1: def fz_try_open_archive_entry(arch, name):
           r"""
           Class-aware wrapper for `::fz_try_open_archive_entry()`.
               Opens an archive entry as a stream.
       
               Returns NULL if a matching entry cannot be found, otherwise
               behaves exactly as fz_open_archive_entry.
           """
>>>>>>     return _mupdf.fz_try_open_archive_entry(arch, name)
       
    1: def fz_try_open_archive_with_stream(file):
           r"""
           Class-aware wrapper for `::fz_try_open_archive_with_stream()`.
               Open zip or tar archive stream.
       
               Does the same as fz_open_archive_with_stream, but will not throw
               an error in the event of failing to recognise the format. Will
               still throw errors in other cases though!
           """
>>>>>>     return _mupdf.fz_try_open_archive_with_stream(file)
       
    1: def fz_try_open_file(name):
           r"""
           Class-aware wrapper for `::fz_try_open_file()`.
               Open the named file and wrap it in a stream.
       
               Does the same as fz_open_file, but in the event the file
               does not open, it will return NULL rather than throw an
               exception.
           """
>>>>>>     return _mupdf.fz_try_open_file(name)
       
    1: def fz_try_parse_xml_archive_entry(dir, filename, preserve_white):
           r"""
           Class-aware wrapper for `::fz_try_parse_xml_archive_entry()`.
               Try and parse the contents of an archive entry into a tree of xml nodes.
       
               preserve_white: whether to keep or delete all-whitespace nodes.
       
               Will return NULL if the archive entry can't be found. Otherwise behaves
               the same as fz_parse_xml_archive_entry. May throw exceptions.
           """
>>>>>>     return _mupdf.fz_try_parse_xml_archive_entry(dir, filename, preserve_white)
       
    1: def fz_try_read_archive_entry(arch, name):
           r"""
           Class-aware wrapper for `::fz_try_read_archive_entry()`.
               Reads all bytes in an archive entry
               into a buffer.
       
               name: Entry name to look for, this must be an exact match to
               the entry name in the archive.
       
               Returns NULL if a matching entry cannot be found. Otherwise behaves
               the same as fz_read_archive_entry. Exceptions may be thrown.
           """
>>>>>>     return _mupdf.fz_try_read_archive_entry(arch, name)
       
    1: def fz_try_read_file(filename):
           r"""
           Class-aware wrapper for `::fz_try_read_file()`.
               Read all the contents of a file into a buffer.
       
               Returns NULL if the file does not exist, otherwise
               behaves exactly as fz_read_file.
           """
>>>>>>     return _mupdf.fz_try_read_file(filename)
       
    1: def fz_tune_image_decode(image_decode, arg):
           r"""
           Class-aware wrapper for `::fz_tune_image_decode()`.
               Set the tuning function to use for
               image decode.
       
               image_decode: Function to use.
       
               arg: Opaque argument to be passed to tuning function.
           """
>>>>>>     return _mupdf.fz_tune_image_decode(image_decode, arg)
       
    1: def fz_tune_image_scale(image_scale, arg):
           r"""
           Class-aware wrapper for `::fz_tune_image_scale()`.
               Set the tuning function to use for
               image scaling.
       
               image_scale: Function to use.
       
               arg: Opaque argument to be passed to tuning function.
           """
>>>>>>     return _mupdf.fz_tune_image_scale(image_scale, arg)
       
    1: def fz_unicode_from_glyph_name(name):
           r"""Class-aware wrapper for `::fz_unicode_from_glyph_name()`."""
>>>>>>     return _mupdf.fz_unicode_from_glyph_name(name)
       
    1: def fz_unicode_from_glyph_name_strict(name):
           r"""Class-aware wrapper for `::fz_unicode_from_glyph_name_strict()`."""
>>>>>>     return _mupdf.fz_unicode_from_glyph_name_strict(name)
       
    1: def fz_union_rect(a, b):
           r"""
           Class-aware wrapper for `::fz_union_rect()`.
               Compute union of two rectangles.
       
               Given two rectangles, update the first to be the smallest
               axis-aligned rectangle that encompasses both given rectangles.
               If either rectangle is infinite then the union is also infinite.
               If either rectangle is empty then the union is simply the
               non-empty rectangle. Should both rectangles be empty, then the
               union is also empty.
           """
>>>>>>     return _mupdf.fz_union_rect(a, b)
       
    1: def fz_unlock(lock):
           r"""
           Class-aware wrapper for `::fz_unlock()`.
               Unlock one of the user supplied mutexes.
           """
>>>>>>     return _mupdf.fz_unlock(lock)
       
    1: def fz_unpack_stream(src, depth, w, h, n, indexed, pad, skip):
           r"""Class-aware wrapper for `::fz_unpack_stream()`."""
>>>>>>     return _mupdf.fz_unpack_stream(src, depth, w, h, n, indexed, pad, skip)
       
    1: def fz_unread_byte(stm):
           r"""
           Class-aware wrapper for `::fz_unread_byte()`.
               Unread the single last byte successfully
               read from a stream. Do not call this without having
               successfully read a byte.
       
               stm: The stream to operate upon.
           """
>>>>>>     return _mupdf.fz_unread_byte(stm)
       
    1: def fz_unshare_stroke_state(shared):
           r"""
           Class-aware wrapper for `::fz_unshare_stroke_state()`.
               Given a reference to a (possibly) shared stroke_state structure,
               return a reference to an equivalent stroke_state structure
               that is guaranteed to be unshared (i.e. one that can
               safely be modified).
       
               shared: The reference to a (possibly) shared structure
               to unshare. Ownership of this reference is passed in
               to this function, even in the case of exceptions being
               thrown.
       
               Exceptions may be thrown in the event of failure to
               allocate if required.
           """
>>>>>>     return _mupdf.fz_unshare_stroke_state(shared)
       
    1: def fz_unshare_stroke_state_with_dash_len(shared, len):
           r"""
           Class-aware wrapper for `::fz_unshare_stroke_state_with_dash_len()`.
               Given a reference to a (possibly) shared stroke_state structure,
               return a reference to a stroke_state structure (with room for a
               given amount of dash data) that is guaranteed to be unshared
               (i.e. one that can safely be modified).
       
               shared: The reference to a (possibly) shared structure
               to unshare. Ownership of this reference is passed in
               to this function, even in the case of exceptions being
               thrown.
       
               Exceptions may be thrown in the event of failure to
               allocate if required.
           """
>>>>>>     return _mupdf.fz_unshare_stroke_state_with_dash_len(shared, len)
       
    1: def fz_urldecode(url):
           r"""
           Class-aware wrapper for `::fz_urldecode()`.
               Like fz_decode_uri_component but in-place.
           """
>>>>>>     return _mupdf.fz_urldecode(url)
       
    1: def fz_use_document_css():
           r"""
           Class-aware wrapper for `::fz_use_document_css()`.
               Return whether to respect document styles in HTML and EPUB.
           """
>>>>>>     return _mupdf.fz_use_document_css()
       
    1: def fz_user_context():
           r"""
           Class-aware wrapper for `::fz_user_context()`.
               Read the user field from the context.
           """
>>>>>>     return _mupdf.fz_user_context()
       
    1: def fz_user_css():
           r"""
           Class-aware wrapper for `::fz_user_css()`.
               Get the user stylesheet source text.
           """
>>>>>>     return _mupdf.fz_user_css()
       
    1: def fz_utflen(s):
           r"""
           Class-aware wrapper for `::fz_utflen()`.
               Count how many runes the UTF-8 encoded string
               consists of.
       
               s: The UTF-8 encoded, NUL-terminated text string.
       
               Returns the number of runes in the string.
           """
>>>>>>     return _mupdf.fz_utflen(s)
       
    1: def fz_var_imp(arg_0):
           r"""Class-aware wrapper for `::fz_var_imp()`."""
>>>>>>     return _mupdf.fz_var_imp(arg_0)
       
    1: def fz_walk_path(path, walker, arg):
           r"""
           Class-aware wrapper for `::fz_walk_path()`.
               Walk the segments of a path, calling the
               appropriate callback function from a given set for each
               segment of the path.
       
               path: The path to walk.
       
               walker: The set of callback functions to use. The first
               4 callback pointers in the set must be non-NULL. The
               subsequent ones can either be supplied, or can be left
               as NULL, in which case the top 4 functions will be
               called as appropriate to simulate them.
       
               arg: An opaque argument passed in to each callback.
       
               Exceptions will only be thrown if the underlying callback
               functions throw them.
           """
>>>>>>     return _mupdf.fz_walk_path(path, walker, arg)
       
    1: def fz_warn(*args):
           r"""Class-aware wrapper for `::fz_warn()`."""
>>>>>>     return _mupdf.fz_warn(*args)
       
    1: def fz_warning_callback(user):
           r"""
           Class-aware wrapper for `::fz_warning_callback()`.
       
           This function has out-params. Python/C# wrappers look like:
               `fz_warning_callback()` => `(fz_warning_cb *, void *user)`
       
               Retrieve the currently set warning callback, or NULL if none
               has been set. Optionally, if user is non-NULL, the user pointer
               given when the warning callback was set is also passed back to
               the caller.
           """
>>>>>>     return _mupdf.fz_warning_callback(user)
       
    1: def fz_warp_pixmap(src, points, width, height):
           r"""Class-aware wrapper for `::fz_warp_pixmap()`."""
>>>>>>     return _mupdf.fz_warp_pixmap(src, points, width, height)
       
    1: def fz_windows_1250_from_unicode(u):
           r"""Class-aware wrapper for `::fz_windows_1250_from_unicode()`."""
>>>>>>     return _mupdf.fz_windows_1250_from_unicode(u)
       
    1: def fz_windows_1251_from_unicode(u):
           r"""Class-aware wrapper for `::fz_windows_1251_from_unicode()`."""
>>>>>>     return _mupdf.fz_windows_1251_from_unicode(u)
       
    1: def fz_windows_1252_from_unicode(u):
           r"""Class-aware wrapper for `::fz_windows_1252_from_unicode()`."""
>>>>>>     return _mupdf.fz_windows_1252_from_unicode(u)
       
    1: def fz_write_band(writer, stride, band_height, samples):
           r"""
           Class-aware wrapper for `::fz_write_band()`.
               Cause a band writer to write the next band
               of data for an image.
       
               stride: The byte offset from the first byte of the data
               for a pixel to the first byte of the data for the same pixel
               on the row below.
       
               band_height: The number of lines in this band.
       
               samples: Pointer to first byte of the data.
           """
>>>>>>     return _mupdf.fz_write_band(writer, stride, band_height, samples)
       
    1: def fz_write_base64(out, data, size, newline):
           r"""
           Class-aware wrapper for `::fz_write_base64()`.
               Write a base64 encoded data block, optionally with periodic
               newlines.
           """
>>>>>>     return _mupdf.fz_write_base64(out, data, size, newline)
       
    1: def fz_write_base64_buffer(out, data, newline):
           r"""
           Class-aware wrapper for `::fz_write_base64_buffer()`.
               Write a base64 encoded fz_buffer, optionally with periodic
               newlines.
           """
>>>>>>     return _mupdf.fz_write_base64_buffer(out, data, newline)
       
    1: def fz_write_bitmap_as_pbm(out, bitmap):
           r"""
           Class-aware wrapper for `::fz_write_bitmap_as_pbm()`.
               Write a bitmap as a pbm.
           """
>>>>>>     return _mupdf.fz_write_bitmap_as_pbm(out, bitmap)
       
    1: def fz_write_bitmap_as_pcl(out, bitmap, pcl):
           r"""
           Class-aware wrapper for `::fz_write_bitmap_as_pcl()`.
               Write a bitmap as mono PCL.
           """
>>>>>>     return _mupdf.fz_write_bitmap_as_pcl(out, bitmap, pcl)
       
    1: def fz_write_bitmap_as_pkm(out, bitmap):
           r"""
           Class-aware wrapper for `::fz_write_bitmap_as_pkm()`.
               Write a CMYK bitmap as a pkm.
           """
>>>>>>     return _mupdf.fz_write_bitmap_as_pkm(out, bitmap)
       
    1: def fz_write_bitmap_as_pwg(out, bitmap, pwg):
           r"""
           Class-aware wrapper for `::fz_write_bitmap_as_pwg()`.
               Write a bitmap as a PWG.
           """
>>>>>>     return _mupdf.fz_write_bitmap_as_pwg(out, bitmap, pwg)
       
    1: def fz_write_bitmap_as_pwg_page(out, bitmap, pwg):
           r"""
           Class-aware wrapper for `::fz_write_bitmap_as_pwg_page()`.
               Write a bitmap as a PWG page.
       
               Caller should provide a file header by calling
               fz_write_pwg_file_header, but can then write several pages to
               the same file.
           """
>>>>>>     return _mupdf.fz_write_bitmap_as_pwg_page(out, bitmap, pwg)
       
    1: def fz_write_bits(out, data, num_bits):
           r"""
           Class-aware wrapper for `::fz_write_bits()`.
               Write num_bits of data to the end of the output stream, assumed to be packed
               most significant bits first.
           """
>>>>>>     return _mupdf.fz_write_bits(out, data, num_bits)
       
    1: def fz_write_bits_sync(out):
           r"""
           Class-aware wrapper for `::fz_write_bits_sync()`.
               Sync to byte boundary after writing bits.
           """
>>>>>>     return _mupdf.fz_write_bits_sync(out)
       
    1: def fz_write_buffer(out, data):
           r"""Class-aware wrapper for `::fz_write_buffer()`."""
>>>>>>     return _mupdf.fz_write_buffer(out, data)
       
    1: def fz_write_byte(out, x):
           r"""Class-aware wrapper for `::fz_write_byte()`."""
>>>>>>     return _mupdf.fz_write_byte(out, x)
       
    1: def fz_write_char(out, x):
           r"""Class-aware wrapper for `::fz_write_char()`."""
>>>>>>     return _mupdf.fz_write_char(out, x)
       
    1: def fz_write_data(out, data, size):
           r"""
           Class-aware wrapper for `::fz_write_data()`.
               Write data to output.
       
               data: Pointer to data to write.
               size: Size of data to write in bytes.
           """
>>>>>>     return _mupdf.fz_write_data(out, data, size)
       
    1: def fz_write_document(wri, doc):
           r"""
           Class-aware wrapper for `::fz_write_document()`.
               Convenience function to feed all the pages of a document to
               fz_begin_page/fz_run_page/fz_end_page.
           """
>>>>>>     return _mupdf.fz_write_document(wri, doc)
       
    1: def fz_write_float_be(out, f):
           r"""Class-aware wrapper for `::fz_write_float_be()`."""
>>>>>>     return _mupdf.fz_write_float_be(out, f)
       
    1: def fz_write_float_le(out, f):
           r"""Class-aware wrapper for `::fz_write_float_le()`."""
>>>>>>     return _mupdf.fz_write_float_le(out, f)
       
    1: def fz_write_header(writer, w, h, n, alpha, xres, yres, pagenum, cs, seps):
           r"""
           Class-aware wrapper for `::fz_write_header()`.
               Cause a band writer to write the header for
               a banded image with the given properties/dimensions etc. This
               also configures the bandwriter for the format of the data to be
               passed in future calls.
       
               w, h: Width and Height of the entire page.
       
               n: Number of components (including spots and alphas).
       
               alpha: Number of alpha components.
       
               xres, yres: X and Y resolutions in dpi.
       
               cs: Colorspace (NULL for bitmaps)
       
               seps: Separation details (or NULL).
           """
>>>>>>     return _mupdf.fz_write_header(writer, w, h, n, alpha, xres, yres, pagenum, cs, seps)
       
    1: def fz_write_image_as_data_uri(out, image):
           r"""
           Class-aware wrapper for `::fz_write_image_as_data_uri()`.
               Write image as a data URI (for HTML and SVG output).
           """
>>>>>>     return _mupdf.fz_write_image_as_data_uri(out, image)
       
    1: def fz_write_int16_be(out, x):
           r"""Class-aware wrapper for `::fz_write_int16_be()`."""
>>>>>>     return _mupdf.fz_write_int16_be(out, x)
       
    1: def fz_write_int16_le(out, x):
           r"""Class-aware wrapper for `::fz_write_int16_le()`."""
>>>>>>     return _mupdf.fz_write_int16_le(out, x)
       
    1: def fz_write_int32_be(out, x):
           r"""
           Class-aware wrapper for `::fz_write_int32_be()`.
               Write different sized data to an output stream.
           """
>>>>>>     return _mupdf.fz_write_int32_be(out, x)
       
    1: def fz_write_int32_le(out, x):
           r"""Class-aware wrapper for `::fz_write_int32_le()`."""
>>>>>>     return _mupdf.fz_write_int32_le(out, x)
       
    1: def fz_write_json(out, value):
           r"""Class-aware wrapper for `::fz_write_json()`."""
>>>>>>     return _mupdf.fz_write_json(out, value)
       
    1: def fz_write_pixmap_as_data_uri(out, pixmap):
           r"""Class-aware wrapper for `::fz_write_pixmap_as_data_uri()`."""
>>>>>>     return _mupdf.fz_write_pixmap_as_data_uri(out, pixmap)
       
    1: def fz_write_pixmap_as_jpeg(out, pix, quality, invert_cmyk):
           r"""
           Class-aware wrapper for `::fz_write_pixmap_as_jpeg()`.
               Write a pixmap as a JPEG.
           """
>>>>>>     return _mupdf.fz_write_pixmap_as_jpeg(out, pix, quality, invert_cmyk)
       
    1: def fz_write_pixmap_as_jpx(out, pix, quality):
           r"""
           Class-aware wrapper for `::fz_write_pixmap_as_jpx()`.
               Pixmap data as JP2K with no subsampling.
       
               quality = 100 = lossless
               otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
           """
>>>>>>     return _mupdf.fz_write_pixmap_as_jpx(out, pix, quality)
       
    1: def fz_write_pixmap_as_pam(out, pixmap):
           r"""
           Class-aware wrapper for `::fz_write_pixmap_as_pam()`.
               Write a pixmap as a pnm (greyscale, rgb or cmyk, with or without
               alpha).
           """
>>>>>>     return _mupdf.fz_write_pixmap_as_pam(out, pixmap)
       
    1: def fz_write_pixmap_as_pcl(out, pixmap, pcl):
           r"""
           Class-aware wrapper for `::fz_write_pixmap_as_pcl()`.
               Write an (RGB) pixmap as color PCL.
           """
>>>>>>     return _mupdf.fz_write_pixmap_as_pcl(out, pixmap, pcl)
       
    1: def fz_write_pixmap_as_pclm(out, pixmap, options):
           r"""
           Class-aware wrapper for `::fz_write_pixmap_as_pclm()`.
               Write a (Greyscale or RGB) pixmap as pclm.
           """
>>>>>>     return _mupdf.fz_write_pixmap_as_pclm(out, pixmap, options)
       
    1: def fz_write_pixmap_as_pdfocr(out, pixmap, options):
           r"""
           Class-aware wrapper for `::fz_write_pixmap_as_pdfocr()`.
               Write a (Greyscale or RGB) pixmap as pdfocr.
           """
>>>>>>     return _mupdf.fz_write_pixmap_as_pdfocr(out, pixmap, options)
       
    1: def fz_write_pixmap_as_png(out, pixmap):
           r"""
           Class-aware wrapper for `::fz_write_pixmap_as_png()`.
               Write a (Greyscale or RGB) pixmap as a png.
           """
>>>>>>     return _mupdf.fz_write_pixmap_as_png(out, pixmap)
       
    1: def fz_write_pixmap_as_pnm(out, pixmap):
           r"""
           Class-aware wrapper for `::fz_write_pixmap_as_pnm()`.
               Write a pixmap as a pnm (greyscale or rgb, no alpha).
           """
>>>>>>     return _mupdf.fz_write_pixmap_as_pnm(out, pixmap)
       
    1: def fz_write_pixmap_as_ps(out, pixmap):
           r"""
           Class-aware wrapper for `::fz_write_pixmap_as_ps()`.
               Write a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
           """
>>>>>>     return _mupdf.fz_write_pixmap_as_ps(out, pixmap)
       
    1: def fz_write_pixmap_as_psd(out, pixmap):
           r"""
           Class-aware wrapper for `::fz_write_pixmap_as_psd()`.
               Write a pixmap as a PSD file.
           """
>>>>>>     return _mupdf.fz_write_pixmap_as_psd(out, pixmap)
       
    1: def fz_write_pixmap_as_pwg(out, pixmap, pwg):
           r"""
           Class-aware wrapper for `::fz_write_pixmap_as_pwg()`.
               Write a pixmap as a PWG.
           """
>>>>>>     return _mupdf.fz_write_pixmap_as_pwg(out, pixmap, pwg)
       
    1: def fz_write_pixmap_as_pwg_page(out, pixmap, pwg):
           r"""
           Class-aware wrapper for `::fz_write_pixmap_as_pwg_page()`.
               Write a pixmap as a PWG page.
       
               Caller should provide a file header by calling
               fz_write_pwg_file_header, but can then write several pages to
               the same file.
           """
>>>>>>     return _mupdf.fz_write_pixmap_as_pwg_page(out, pixmap, pwg)
       
    1: def fz_write_ps_file_header(out):
           r"""
           Class-aware wrapper for `::fz_write_ps_file_header()`.
               Write the file level header for ps band writer output.
           """
>>>>>>     return _mupdf.fz_write_ps_file_header(out)
       
    1: def fz_write_ps_file_trailer(out, pages):
           r"""
           Class-aware wrapper for `::fz_write_ps_file_trailer()`.
               Write the file level trailer for ps band writer output.
           """
>>>>>>     return _mupdf.fz_write_ps_file_trailer(out, pages)
       
    1: def fz_write_pwg_file_header(out):
           r"""
           Class-aware wrapper for `::fz_write_pwg_file_header()`.
               Output the file header to a pwg stream, ready for pages to follow it.
           """
>>>>>>     return _mupdf.fz_write_pwg_file_header(out)
       
    1: def fz_write_rune(out, rune):
           r"""
           Class-aware wrapper for `::fz_write_rune()`.
               Write a UTF-8 encoded unicode character.
           """
>>>>>>     return _mupdf.fz_write_rune(out, rune)
       
    1: def fz_write_stabilized_story(writer, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir):
           r"""Class-aware wrapper for `::fz_write_stabilized_story()`."""
>>>>>>     return _mupdf.fz_write_stabilized_story(writer, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir)
       
    1: def fz_write_story(writer, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref):
           r"""Class-aware wrapper for `::fz_write_story()`."""
>>>>>>     return _mupdf.fz_write_story(writer, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref)
       
    1: def fz_write_stream(out, _in):
           r"""
           Class-aware wrapper for `::fz_write_stream()`.
               Copy the stream contents to the output.
           """
>>>>>>     return _mupdf.fz_write_stream(out, _in)
       
    1: def fz_write_string(out, s):
           r"""
           Class-aware wrapper for `::fz_write_string()`.
               Write a string. Does not write zero terminator.
           """
>>>>>>     return _mupdf.fz_write_string(out, s)
       
    1: def fz_write_uint16_be(out, x):
           r"""Class-aware wrapper for `::fz_write_uint16_be()`."""
>>>>>>     return _mupdf.fz_write_uint16_be(out, x)
       
    1: def fz_write_uint16_le(out, x):
           r"""Class-aware wrapper for `::fz_write_uint16_le()`."""
>>>>>>     return _mupdf.fz_write_uint16_le(out, x)
       
    1: def fz_write_uint32_be(out, x):
           r"""Class-aware wrapper for `::fz_write_uint32_be()`."""
>>>>>>     return _mupdf.fz_write_uint32_be(out, x)
       
    1: def fz_write_uint32_le(out, x):
           r"""Class-aware wrapper for `::fz_write_uint32_le()`."""
>>>>>>     return _mupdf.fz_write_uint32_le(out, x)
       
    1: def fz_write_xml(root, out, indented):
           r"""
           Class-aware wrapper for `::fz_write_xml()`.
               Write our xml structure out to an xml stream.
       
               Properly formatted XML is only allowed to have a single top-level node
               under which everything must sit. Our structures allow for multiple
               top level nodes. If required, we will output an extra 'ROOT' node
               at the top so that the xml is well-formed.
       
               If 'indented' is non-zero then additional whitespace will be added to
               make the XML easier to read in a text editor. It will NOT be properly
               compliant.
           """
>>>>>>     return _mupdf.fz_write_xml(root, out, indented)
       
    1: def fz_write_zip_entry(zip, name, buf, compress):
           r"""
           Class-aware wrapper for `::fz_write_zip_entry()`.
               Given a buffer of data, (optionally) compress it, and add it to
               the zip file with the given name.
           """
>>>>>>     return _mupdf.fz_write_zip_entry(zip, name, buf, compress)
       
    1: def fz_xml_add_att(pool, node, key, val):
           r"""
           Class-aware wrapper for `::fz_xml_add_att()`.
               Add an attribute to an XML node.
           """
>>>>>>     return _mupdf.fz_xml_add_att(pool, node, key, val)
       
    1: def fz_xml_att(item, att):
           r"""
           Class-aware wrapper for `::fz_xml_att()`.
               Return the value of an attribute of an XML node.
               NULL if the attribute doesn't exist.
           """
>>>>>>     return _mupdf.fz_xml_att(item, att)
       
    1: def fz_xml_att_alt(item, one, two):
           r"""
           Class-aware wrapper for `::fz_xml_att_alt()`.
               Return the value of an attribute of an XML node.
               If the first attribute doesn't exist, try the second.
               NULL if neither attribute exists.
           """
>>>>>>     return _mupdf.fz_xml_att_alt(item, one, two)
       
    1: def fz_xml_att_eq(item, name, match):
           r"""
           Class-aware wrapper for `::fz_xml_att_eq()`.
               Check for a matching attribute on an XML node.
       
               If the node has the requested attribute (name), and the value
               matches (match) then return 1. Otherwise, 0.
           """
>>>>>>     return _mupdf.fz_xml_att_eq(item, name, match)
       
    1: def fz_xml_down(item):
           r"""
           Class-aware wrapper for `::fz_xml_down()`.
               Return first child of XML node.
           """
>>>>>>     return _mupdf.fz_xml_down(item)
       
    1: def fz_xml_find(item, tag):
           r"""
           Class-aware wrapper for `::fz_xml_find()`.
               Search the siblings of XML nodes starting with item looking for
               the first with the given tag.
       
               Return NULL if none found.
           """
>>>>>>     return _mupdf.fz_xml_find(item, tag)
       
    1: def fz_xml_find_dfs(item, tag, att, match):
           r"""
           Class-aware wrapper for `::fz_xml_find_dfs()`.
               Perform a depth first search from item, returning the first
               child that matches the given tag (or any tag if tag is NULL),
               with the given attribute (if att is non NULL), that matches
               match (if match is non NULL).
           """
>>>>>>     return _mupdf.fz_xml_find_dfs(item, tag, att, match)
       
    1: def fz_xml_find_dfs_top(item, tag, att, match, top):
           r"""
           Class-aware wrapper for `::fz_xml_find_dfs_top()`.
               Perform a depth first search from item, returning the first
               child that matches the given tag (or any tag if tag is NULL),
               with the given attribute (if att is non NULL), that matches
               match (if match is non NULL). The search stops if it ever
               reaches the top of the tree, or the declared 'top' item.
           """
>>>>>>     return _mupdf.fz_xml_find_dfs_top(item, tag, att, match, top)
       
    1: def fz_xml_find_down(item, tag):
           r"""
           Class-aware wrapper for `::fz_xml_find_down()`.
               Search the siblings of XML nodes starting with the first child
               of item looking for the first with the given tag.
       
               Return NULL if none found.
           """
>>>>>>     return _mupdf.fz_xml_find_down(item, tag)
       
    1: def fz_xml_find_down_match(item, tag, att, match):
           r"""
           Class-aware wrapper for `::fz_xml_find_down_match()`.
               Search the siblings of XML nodes starting with the first child
               of item looking for the first with the given tag (or any tag if
               tag is NULL), and with a matching attribute.
       
               Return NULL if none found.
           """
>>>>>>     return _mupdf.fz_xml_find_down_match(item, tag, att, match)
       
    1: def fz_xml_find_match(item, tag, att, match):
           r"""
           Class-aware wrapper for `::fz_xml_find_match()`.
               Search the siblings of XML nodes starting with item looking for
               the first with the given tag (or any tag if tag is NULL), and
               with a matching attribute.
       
               Return NULL if none found.
           """
>>>>>>     return _mupdf.fz_xml_find_match(item, tag, att, match)
       
    1: def fz_xml_find_next(item, tag):
           r"""
           Class-aware wrapper for `::fz_xml_find_next()`.
               Search the siblings of XML nodes starting with the first sibling
               of item looking for the first with the given tag.
       
               Return NULL if none found.
           """
>>>>>>     return _mupdf.fz_xml_find_next(item, tag)
       
    1: def fz_xml_find_next_dfs(item, tag, att, match):
           r"""
           Class-aware wrapper for `::fz_xml_find_next_dfs()`.
               Perform a depth first search onwards from item, returning the first
               child that matches the given tag (or any tag if tag is NULL),
               with the given attribute (if att is non NULL), that matches
               match (if match is non NULL).
           """
>>>>>>     return _mupdf.fz_xml_find_next_dfs(item, tag, att, match)
       
    1: def fz_xml_find_next_dfs_top(item, tag, att, match, top):
           r"""
           Class-aware wrapper for `::fz_xml_find_next_dfs_top()`.
               Perform a depth first search onwards from item, returning the first
               child that matches the given tag (or any tag if tag is NULL),
               with the given attribute (if att is non NULL), that matches
               match (if match is non NULL). The search stops if it ever reaches
               the top of the tree, or the declared 'top' item.
           """
>>>>>>     return _mupdf.fz_xml_find_next_dfs_top(item, tag, att, match, top)
       
    1: def fz_xml_find_next_match(item, tag, att, match):
           r"""
           Class-aware wrapper for `::fz_xml_find_next_match()`.
               Search the siblings of XML nodes starting with the first sibling
               of item looking for the first with the given tag (or any tag if tag
               is NULL), and with a matching attribute.
       
               Return NULL if none found.
           """
>>>>>>     return _mupdf.fz_xml_find_next_match(item, tag, att, match)
       
    1: def fz_xml_is_tag(item, name):
           r"""
           Class-aware wrapper for `::fz_xml_is_tag()`.
               Return true if the tag name matches.
           """
>>>>>>     return _mupdf.fz_xml_is_tag(item, name)
       
    1: def fz_xml_next(item):
           r"""
           Class-aware wrapper for `::fz_xml_next()`.
               Return next sibling of XML node.
           """
>>>>>>     return _mupdf.fz_xml_next(item)
       
    1: def fz_xml_prev(item):
           r"""
           Class-aware wrapper for `::fz_xml_prev()`.
               Return previous sibling of XML node.
           """
>>>>>>     return _mupdf.fz_xml_prev(item)
       
    1: def fz_xml_root(xml):
           r"""
           Class-aware wrapper for `::fz_xml_root()`.
               Return the topmost XML node of a document.
           """
>>>>>>     return _mupdf.fz_xml_root(xml)
       
    1: def fz_xml_tag(item):
           r"""
           Class-aware wrapper for `::fz_xml_tag()`.
               Return tag of XML node. Return NULL for text nodes.
           """
>>>>>>     return _mupdf.fz_xml_tag(item)
       
    1: def fz_xml_text(item):
           r"""
           Class-aware wrapper for `::fz_xml_text()`.
               Return the text content of an XML node.
               Return NULL if the node is a tag.
           """
>>>>>>     return _mupdf.fz_xml_text(item)
       
    1: def fz_xml_up(item):
           r"""
           Class-aware wrapper for `::fz_xml_up()`.
               Return parent of XML node.
           """
>>>>>>     return _mupdf.fz_xml_up(item)
       
    1: def pdf_abandon_operation(doc):
           r"""Class-aware wrapper for `::pdf_abandon_operation()`."""
>>>>>>     return _mupdf.pdf_abandon_operation(doc)
       
    1: def pdf_access_exec_menu_item_event(evt):
           r"""Class-aware wrapper for `::pdf_access_exec_menu_item_event()`."""
>>>>>>     return _mupdf.pdf_access_exec_menu_item_event(evt)
       
    1: def pdf_add_annot_border_dash_item(annot, length):
           r"""Class-aware wrapper for `::pdf_add_annot_border_dash_item()`."""
>>>>>>     return _mupdf.pdf_add_annot_border_dash_item(annot, length)
       
    1: def pdf_add_annot_ink_list(annot, n, stroke):
           r"""Class-aware wrapper for `::pdf_add_annot_ink_list()`."""
>>>>>>     return _mupdf.pdf_add_annot_ink_list(annot, n, stroke)
       
    1: def pdf_add_annot_ink_list_stroke(annot):
           r"""Class-aware wrapper for `::pdf_add_annot_ink_list_stroke()`."""
>>>>>>     return _mupdf.pdf_add_annot_ink_list_stroke(annot)
       
    1: def pdf_add_annot_ink_list_stroke_vertex(annot, p):
           r"""Class-aware wrapper for `::pdf_add_annot_ink_list_stroke_vertex()`."""
>>>>>>     return _mupdf.pdf_add_annot_ink_list_stroke_vertex(annot, p)
       
    1: def pdf_add_annot_quad_point(annot, quad):
           r"""Class-aware wrapper for `::pdf_add_annot_quad_point()`."""
>>>>>>     return _mupdf.pdf_add_annot_quad_point(annot, quad)
       
    1: def pdf_add_annot_vertex(annot, p):
           r"""Class-aware wrapper for `::pdf_add_annot_vertex()`."""
>>>>>>     return _mupdf.pdf_add_annot_vertex(annot, p)
       
    1: def pdf_add_cid_font(doc, font):
           r"""Class-aware wrapper for `::pdf_add_cid_font()`."""
>>>>>>     return _mupdf.pdf_add_cid_font(doc, font)
       
    1: def pdf_add_cjk_font(doc, font, script, wmode, serif):
           r"""Class-aware wrapper for `::pdf_add_cjk_font()`."""
>>>>>>     return _mupdf.pdf_add_cjk_font(doc, font, script, wmode, serif)
       
    1: def pdf_add_codespace(cmap, low, high, n):
           r"""Class-aware wrapper for `::pdf_add_codespace()`."""
>>>>>>     return _mupdf.pdf_add_codespace(cmap, low, high, n)
       
    1: def pdf_add_colorspace(doc, cs):
           r"""Class-aware wrapper for `::pdf_add_colorspace()`."""
>>>>>>     return _mupdf.pdf_add_colorspace(doc, cs)
       
    1: def pdf_add_embedded_file(doc, filename, mimetype, contents, created, modified, add_checksum):
           r"""Class-aware wrapper for `::pdf_add_embedded_file()`."""
>>>>>>     return _mupdf.pdf_add_embedded_file(doc, filename, mimetype, contents, created, modified, add_checksum)
       
    1: def pdf_add_hmtx(font, lo, hi, w):
           r"""Class-aware wrapper for `::pdf_add_hmtx()`."""
>>>>>>     return _mupdf.pdf_add_hmtx(font, lo, hi, w)
       
    1: def pdf_add_image(doc, image):
           r"""Class-aware wrapper for `::pdf_add_image()`."""
>>>>>>     return _mupdf.pdf_add_image(doc, image)
       
    1: def pdf_add_journal_fragment(doc, parent, copy, copy_stream, newobj):
           r"""Class-aware wrapper for `::pdf_add_journal_fragment()`."""
>>>>>>     return _mupdf.pdf_add_journal_fragment(doc, parent, copy, copy_stream, newobj)
       
    1: def pdf_add_new_array(doc, initial):
           r"""Class-aware wrapper for `::pdf_add_new_array()`."""
>>>>>>     return _mupdf.pdf_add_new_array(doc, initial)
       
    1: def pdf_add_new_dict(doc, initial):
           r"""Class-aware wrapper for `::pdf_add_new_dict()`."""
>>>>>>     return _mupdf.pdf_add_new_dict(doc, initial)
       
    1: def pdf_add_object(doc, obj):
           r"""Class-aware wrapper for `::pdf_add_object()`."""
>>>>>>     return _mupdf.pdf_add_object(doc, obj)
       
    1: def pdf_add_page(doc, mediabox, rotate, resources, contents):
           r"""Class-aware wrapper for `::pdf_add_page()`."""
>>>>>>     return _mupdf.pdf_add_page(doc, mediabox, rotate, resources, contents)
       
    1: def pdf_add_simple_font(doc, font, encoding):
           r"""Class-aware wrapper for `::pdf_add_simple_font()`."""
>>>>>>     return _mupdf.pdf_add_simple_font(doc, font, encoding)
       
    1: def pdf_add_stream(doc, buf, obj, compressed):
           r"""Class-aware wrapper for `::pdf_add_stream()`."""
>>>>>>     return _mupdf.pdf_add_stream(doc, buf, obj, compressed)
       
    1: def pdf_add_substitute_font(doc, font):
           r"""Class-aware wrapper for `::pdf_add_substitute_font()`."""
>>>>>>     return _mupdf.pdf_add_substitute_font(doc, font)
       
    1: def pdf_add_vmtx(font, lo, hi, x, y, w):
           r"""Class-aware wrapper for `::pdf_add_vmtx()`."""
>>>>>>     return _mupdf.pdf_add_vmtx(font, lo, hi, x, y, w)
       
    1: def pdf_annot_MK_BC(annot, n, color):
           r"""
           Class-aware wrapper for `::pdf_annot_MK_BC()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_annot_MK_BC(::pdf_annot *annot, float color[4])` => int n
           """
>>>>>>     return _mupdf.pdf_annot_MK_BC(annot, n, color)
       
    1: def pdf_annot_MK_BC_rgb(annot, rgb):
           r"""Class-aware wrapper for `::pdf_annot_MK_BC_rgb()`."""
>>>>>>     return _mupdf.pdf_annot_MK_BC_rgb(annot, rgb)
       
    1: def pdf_annot_MK_BG(annot, n, color):
           r"""
           Class-aware wrapper for `::pdf_annot_MK_BG()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_annot_MK_BG(::pdf_annot *annot, float color[4])` => int n
           """
>>>>>>     return _mupdf.pdf_annot_MK_BG(annot, n, color)
       
    1: def pdf_annot_MK_BG_rgb(annot, rgb):
           r"""Class-aware wrapper for `::pdf_annot_MK_BG_rgb()`."""
>>>>>>     return _mupdf.pdf_annot_MK_BG_rgb(annot, rgb)
       
    1: def pdf_annot_active(annot):
           r"""Class-aware wrapper for `::pdf_annot_active()`."""
>>>>>>     return _mupdf.pdf_annot_active(annot)
       
    1: def pdf_annot_ap(annot):
           r"""Class-aware wrapper for `::pdf_annot_ap()`."""
>>>>>>     return _mupdf.pdf_annot_ap(annot)
       
    1: def pdf_annot_author(annot):
           r"""Class-aware wrapper for `::pdf_annot_author()`."""
>>>>>>     return _mupdf.pdf_annot_author(annot)
       
    1: def pdf_annot_border(annot):
           r"""Class-aware wrapper for `::pdf_annot_border()`."""
>>>>>>     return _mupdf.pdf_annot_border(annot)
       
    1: def pdf_annot_border_dash_count(annot):
           r"""Class-aware wrapper for `::pdf_annot_border_dash_count()`."""
>>>>>>     return _mupdf.pdf_annot_border_dash_count(annot)
       
    1: def pdf_annot_border_dash_item(annot, i):
           r"""Class-aware wrapper for `::pdf_annot_border_dash_item()`."""
>>>>>>     return _mupdf.pdf_annot_border_dash_item(annot, i)
       
    1: def pdf_annot_border_effect(annot):
           r"""Class-aware wrapper for `::pdf_annot_border_effect()`."""
>>>>>>     return _mupdf.pdf_annot_border_effect(annot)
       
    1: def pdf_annot_border_effect_intensity(annot):
           r"""Class-aware wrapper for `::pdf_annot_border_effect_intensity()`."""
>>>>>>     return _mupdf.pdf_annot_border_effect_intensity(annot)
       
    1: def pdf_annot_border_style(annot):
           r"""Class-aware wrapper for `::pdf_annot_border_style()`."""
>>>>>>     return _mupdf.pdf_annot_border_style(annot)
       
    1: def pdf_annot_border_width(annot):
           r"""Class-aware wrapper for `::pdf_annot_border_width()`."""
>>>>>>     return _mupdf.pdf_annot_border_width(annot)
       
    1: def pdf_annot_callout_line(annot, callout, n):
           r"""
           Class-aware wrapper for `::pdf_annot_callout_line()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_annot_callout_line(::pdf_annot *annot, ::fz_point callout[3])` => int n
           """
>>>>>>     return _mupdf.pdf_annot_callout_line(annot, callout, n)
       
    1: def pdf_annot_callout_point(annot):
           r"""Class-aware wrapper for `::pdf_annot_callout_point()`."""
>>>>>>     return _mupdf.pdf_annot_callout_point(annot)
       
    1: def pdf_annot_callout_style(annot):
           r"""Class-aware wrapper for `::pdf_annot_callout_style()`."""
>>>>>>     return _mupdf.pdf_annot_callout_style(annot)
       
    1: def pdf_annot_color(annot, n, color):
           r"""
           Class-aware wrapper for `::pdf_annot_color()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_annot_color(::pdf_annot *annot, float color[4])` => int n
           """
>>>>>>     return _mupdf.pdf_annot_color(annot, n, color)
       
    1: def pdf_annot_contents(annot):
           r"""Class-aware wrapper for `::pdf_annot_contents()`."""
>>>>>>     return _mupdf.pdf_annot_contents(annot)
       
    1: def pdf_annot_creation_date(annot):
           r"""Class-aware wrapper for `::pdf_annot_creation_date()`."""
>>>>>>     return _mupdf.pdf_annot_creation_date(annot)
       
    1: def pdf_annot_default_appearance(annot, font, size, n, color):
           r"""
           Class-aware wrapper for `::pdf_annot_default_appearance()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_annot_default_appearance(::pdf_annot *annot, float color[4])` => `(const char *font, float size, int n)`
           """
>>>>>>     return _mupdf.pdf_annot_default_appearance(annot, font, size, n, color)
       
    1: def pdf_annot_default_appearance_unmapped(annot, font_name, font_name_len, size, n, color):
           r"""
           Class-aware wrapper for `::pdf_annot_default_appearance_unmapped()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_annot_default_appearance_unmapped(::pdf_annot *annot, char *font_name, int font_name_len, float color[4])` => `(float size, int n)`
           """
>>>>>>     return _mupdf.pdf_annot_default_appearance_unmapped(annot, font_name, font_name_len, size, n, color)
       
    1: def pdf_annot_ensure_local_xref(annot):
           r"""Class-aware wrapper for `::pdf_annot_ensure_local_xref()`."""
>>>>>>     return _mupdf.pdf_annot_ensure_local_xref(annot)
       
    1: def pdf_annot_event_blur(annot):
           r"""Class-aware wrapper for `::pdf_annot_event_blur()`."""
>>>>>>     return _mupdf.pdf_annot_event_blur(annot)
       
    1: def pdf_annot_event_down(annot):
           r"""Class-aware wrapper for `::pdf_annot_event_down()`."""
>>>>>>     return _mupdf.pdf_annot_event_down(annot)
       
    1: def pdf_annot_event_enter(annot):
           r"""Class-aware wrapper for `::pdf_annot_event_enter()`."""
>>>>>>     return _mupdf.pdf_annot_event_enter(annot)
       
    1: def pdf_annot_event_exit(annot):
           r"""Class-aware wrapper for `::pdf_annot_event_exit()`."""
>>>>>>     return _mupdf.pdf_annot_event_exit(annot)
       
    1: def pdf_annot_event_focus(annot):
           r"""Class-aware wrapper for `::pdf_annot_event_focus()`."""
>>>>>>     return _mupdf.pdf_annot_event_focus(annot)
       
    1: def pdf_annot_event_page_close(annot):
           r"""Class-aware wrapper for `::pdf_annot_event_page_close()`."""
>>>>>>     return _mupdf.pdf_annot_event_page_close(annot)
       
    1: def pdf_annot_event_page_invisible(annot):
           r"""Class-aware wrapper for `::pdf_annot_event_page_invisible()`."""
>>>>>>     return _mupdf.pdf_annot_event_page_invisible(annot)
       
    1: def pdf_annot_event_page_open(annot):
           r"""Class-aware wrapper for `::pdf_annot_event_page_open()`."""
>>>>>>     return _mupdf.pdf_annot_event_page_open(annot)
       
    1: def pdf_annot_event_page_visible(annot):
           r"""Class-aware wrapper for `::pdf_annot_event_page_visible()`."""
>>>>>>     return _mupdf.pdf_annot_event_page_visible(annot)
       
    1: def pdf_annot_event_up(annot):
           r"""Class-aware wrapper for `::pdf_annot_event_up()`."""
>>>>>>     return _mupdf.pdf_annot_event_up(annot)
       
    1: def pdf_annot_field_event_keystroke(doc, annot, evt):
           r"""Class-aware wrapper for `::pdf_annot_field_event_keystroke()`."""
>>>>>>     return _mupdf.pdf_annot_field_event_keystroke(doc, annot, evt)
       
    1: def pdf_annot_field_flags(annot):
           r"""Class-aware wrapper for `::pdf_annot_field_flags()`."""
>>>>>>     return _mupdf.pdf_annot_field_flags(annot)
       
    1: def pdf_annot_field_label(widget):
           r"""Class-aware wrapper for `::pdf_annot_field_label()`."""
>>>>>>     return _mupdf.pdf_annot_field_label(widget)
       
    1: def pdf_annot_field_value(annot):
           r"""Class-aware wrapper for `::pdf_annot_field_value()`."""
>>>>>>     return _mupdf.pdf_annot_field_value(annot)
       
    1: def pdf_annot_filespec(annot):
           r"""Class-aware wrapper for `::pdf_annot_filespec()`."""
>>>>>>     return _mupdf.pdf_annot_filespec(annot)
       
    1: def pdf_annot_flags(annot):
           r"""Class-aware wrapper for `::pdf_annot_flags()`."""
>>>>>>     return _mupdf.pdf_annot_flags(annot)
       
    1: def pdf_annot_has_author(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_author()`."""
>>>>>>     return _mupdf.pdf_annot_has_author(annot)
       
    1: def pdf_annot_has_border(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_border()`."""
>>>>>>     return _mupdf.pdf_annot_has_border(annot)
       
    1: def pdf_annot_has_border_effect(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_border_effect()`."""
>>>>>>     return _mupdf.pdf_annot_has_border_effect(annot)
       
    1: def pdf_annot_has_callout(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_callout()`."""
>>>>>>     return _mupdf.pdf_annot_has_callout(annot)
       
    1: def pdf_annot_has_default_appearance(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_default_appearance()`."""
>>>>>>     return _mupdf.pdf_annot_has_default_appearance(annot)
       
    1: def pdf_annot_has_filespec(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_filespec()`."""
>>>>>>     return _mupdf.pdf_annot_has_filespec(annot)
       
    1: def pdf_annot_has_icon_name(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_icon_name()`."""
>>>>>>     return _mupdf.pdf_annot_has_icon_name(annot)
       
    1: def pdf_annot_has_ink_list(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_ink_list()`."""
>>>>>>     return _mupdf.pdf_annot_has_ink_list(annot)
       
    1: def pdf_annot_has_intent(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_intent()`."""
>>>>>>     return _mupdf.pdf_annot_has_intent(annot)
       
    1: def pdf_annot_has_interior_color(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_interior_color()`."""
>>>>>>     return _mupdf.pdf_annot_has_interior_color(annot)
       
    1: def pdf_annot_has_line(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_line()`."""
>>>>>>     return _mupdf.pdf_annot_has_line(annot)
       
    1: def pdf_annot_has_line_ending_styles(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_line_ending_styles()`."""
>>>>>>     return _mupdf.pdf_annot_has_line_ending_styles(annot)
       
    1: def pdf_annot_has_open(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_open()`."""
>>>>>>     return _mupdf.pdf_annot_has_open(annot)
       
    1: def pdf_annot_has_popup(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_popup()`."""
>>>>>>     return _mupdf.pdf_annot_has_popup(annot)
       
    1: def pdf_annot_has_quad_points(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_quad_points()`."""
>>>>>>     return _mupdf.pdf_annot_has_quad_points(annot)
       
    1: def pdf_annot_has_quadding(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_quadding()`."""
>>>>>>     return _mupdf.pdf_annot_has_quadding(annot)
       
    1: def pdf_annot_has_rect(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_rect()`."""
>>>>>>     return _mupdf.pdf_annot_has_rect(annot)
       
    1: def pdf_annot_has_rich_contents(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_rich_contents()`."""
>>>>>>     return _mupdf.pdf_annot_has_rich_contents(annot)
       
    1: def pdf_annot_has_rich_defaults(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_rich_defaults()`."""
>>>>>>     return _mupdf.pdf_annot_has_rich_defaults(annot)
       
    1: def pdf_annot_has_vertices(annot):
           r"""Class-aware wrapper for `::pdf_annot_has_vertices()`."""
>>>>>>     return _mupdf.pdf_annot_has_vertices(annot)
       
    1: def pdf_annot_hidden_for_editing(annot):
           r"""Class-aware wrapper for `::pdf_annot_hidden_for_editing()`."""
>>>>>>     return _mupdf.pdf_annot_hidden_for_editing(annot)
       
    1: def pdf_annot_hot(annot):
           r"""Class-aware wrapper for `::pdf_annot_hot()`."""
>>>>>>     return _mupdf.pdf_annot_hot(annot)
       
    1: def pdf_annot_icon_name(annot):
           r"""Class-aware wrapper for `::pdf_annot_icon_name()`."""
>>>>>>     return _mupdf.pdf_annot_icon_name(annot)
       
    1: def pdf_annot_ink_list_count(annot):
           r"""Class-aware wrapper for `::pdf_annot_ink_list_count()`."""
>>>>>>     return _mupdf.pdf_annot_ink_list_count(annot)
       
    1: def pdf_annot_ink_list_stroke_count(annot, i):
           r"""Class-aware wrapper for `::pdf_annot_ink_list_stroke_count()`."""
>>>>>>     return _mupdf.pdf_annot_ink_list_stroke_count(annot, i)
       
    1: def pdf_annot_ink_list_stroke_vertex(annot, i, k):
           r"""Class-aware wrapper for `::pdf_annot_ink_list_stroke_vertex()`."""
>>>>>>     return _mupdf.pdf_annot_ink_list_stroke_vertex(annot, i, k)
       
    1: def pdf_annot_intent(annot):
           r"""Class-aware wrapper for `::pdf_annot_intent()`."""
>>>>>>     return _mupdf.pdf_annot_intent(annot)
       
    1: def pdf_annot_interior_color(annot, n, color):
           r"""
           Class-aware wrapper for `::pdf_annot_interior_color()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_annot_interior_color(::pdf_annot *annot, float color[4])` => int n
           """
>>>>>>     return _mupdf.pdf_annot_interior_color(annot, n, color)
       
    1: def pdf_annot_is_open(annot):
           r"""Class-aware wrapper for `::pdf_annot_is_open()`."""
>>>>>>     return _mupdf.pdf_annot_is_open(annot)
       
    1: def pdf_annot_is_standard_stamp(annot):
           r"""Class-aware wrapper for `::pdf_annot_is_standard_stamp()`."""
>>>>>>     return _mupdf.pdf_annot_is_standard_stamp(annot)
       
    1: def pdf_annot_language(annot):
           r"""Class-aware wrapper for `::pdf_annot_language()`."""
>>>>>>     return _mupdf.pdf_annot_language(annot)
       
    1: def pdf_annot_line(annot, a, b):
           r"""Class-aware wrapper for `::pdf_annot_line()`."""
>>>>>>     return _mupdf.pdf_annot_line(annot, a, b)
       
    1: def pdf_annot_line_caption(annot):
           r"""Class-aware wrapper for `::pdf_annot_line_caption()`."""
>>>>>>     return _mupdf.pdf_annot_line_caption(annot)
       
    1: def pdf_annot_line_caption_offset(annot):
           r"""Class-aware wrapper for `::pdf_annot_line_caption_offset()`."""
>>>>>>     return _mupdf.pdf_annot_line_caption_offset(annot)
       
    1: def pdf_annot_line_end_style(annot):
           r"""Class-aware wrapper for `::pdf_annot_line_end_style()`."""
>>>>>>     return _mupdf.pdf_annot_line_end_style(annot)
       
    1: def pdf_annot_line_ending_styles(annot, start_style, end_style):
           r"""
           Class-aware wrapper for `::pdf_annot_line_ending_styles()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_annot_line_ending_styles(::pdf_annot *annot)` => `(enum pdf_line_ending start_style, enum pdf_line_ending end_style)`
           """
>>>>>>     return _mupdf.pdf_annot_line_ending_styles(annot, start_style, end_style)
       
    1: def pdf_annot_line_leader(annot):
           r"""Class-aware wrapper for `::pdf_annot_line_leader()`."""
>>>>>>     return _mupdf.pdf_annot_line_leader(annot)
       
    1: def pdf_annot_line_leader_extension(annot):
           r"""Class-aware wrapper for `::pdf_annot_line_leader_extension()`."""
>>>>>>     return _mupdf.pdf_annot_line_leader_extension(annot)
       
    1: def pdf_annot_line_leader_offset(annot):
           r"""Class-aware wrapper for `::pdf_annot_line_leader_offset()`."""
>>>>>>     return _mupdf.pdf_annot_line_leader_offset(annot)
       
    1: def pdf_annot_line_start_style(annot):
           r"""Class-aware wrapper for `::pdf_annot_line_start_style()`."""
>>>>>>     return _mupdf.pdf_annot_line_start_style(annot)
       
    1: def pdf_annot_modification_date(annot):
           r"""Class-aware wrapper for `::pdf_annot_modification_date()`."""
>>>>>>     return _mupdf.pdf_annot_modification_date(annot)
       
    1: def pdf_annot_needs_resynthesis(annot):
           r"""Class-aware wrapper for `::pdf_annot_needs_resynthesis()`."""
>>>>>>     return _mupdf.pdf_annot_needs_resynthesis(annot)
       
    1: def pdf_annot_obj(annot):
           r"""Class-aware wrapper for `::pdf_annot_obj()`."""
>>>>>>     return _mupdf.pdf_annot_obj(annot)
       
    1: def pdf_annot_opacity(annot):
           r"""Class-aware wrapper for `::pdf_annot_opacity()`."""
>>>>>>     return _mupdf.pdf_annot_opacity(annot)
       
    1: def pdf_annot_page(annot):
           r"""Class-aware wrapper for `::pdf_annot_page()`."""
>>>>>>     return _mupdf.pdf_annot_page(annot)
       
    1: def pdf_annot_pop_and_discard_local_xref(annot):
           r"""Class-aware wrapper for `::pdf_annot_pop_and_discard_local_xref()`."""
>>>>>>     return _mupdf.pdf_annot_pop_and_discard_local_xref(annot)
       
    1: def pdf_annot_pop_local_xref(annot):
           r"""Class-aware wrapper for `::pdf_annot_pop_local_xref()`."""
>>>>>>     return _mupdf.pdf_annot_pop_local_xref(annot)
       
    1: def pdf_annot_popup(annot):
           r"""Class-aware wrapper for `::pdf_annot_popup()`."""
>>>>>>     return _mupdf.pdf_annot_popup(annot)
       
    1: def pdf_annot_push_local_xref(annot):
           r"""Class-aware wrapper for `::pdf_annot_push_local_xref()`."""
>>>>>>     return _mupdf.pdf_annot_push_local_xref(annot)
       
    1: def pdf_annot_quad_point(annot, i):
           r"""Class-aware wrapper for `::pdf_annot_quad_point()`."""
>>>>>>     return _mupdf.pdf_annot_quad_point(annot, i)
       
    1: def pdf_annot_quad_point_count(annot):
           r"""Class-aware wrapper for `::pdf_annot_quad_point_count()`."""
>>>>>>     return _mupdf.pdf_annot_quad_point_count(annot)
       
    1: def pdf_annot_quadding(annot):
           r"""Class-aware wrapper for `::pdf_annot_quadding()`."""
>>>>>>     return _mupdf.pdf_annot_quadding(annot)
       
    1: def pdf_annot_rect(annot):
           r"""Class-aware wrapper for `::pdf_annot_rect()`."""
>>>>>>     return _mupdf.pdf_annot_rect(annot)
       
    1: def pdf_annot_request_resynthesis(annot):
           r"""Class-aware wrapper for `::pdf_annot_request_resynthesis()`."""
>>>>>>     return _mupdf.pdf_annot_request_resynthesis(annot)
       
    1: def pdf_annot_request_synthesis(annot):
           r"""Class-aware wrapper for `::pdf_annot_request_synthesis()`."""
>>>>>>     return _mupdf.pdf_annot_request_synthesis(annot)
       
    1: def pdf_annot_rich_contents(annot):
           r"""Class-aware wrapper for `::pdf_annot_rich_contents()`."""
>>>>>>     return _mupdf.pdf_annot_rich_contents(annot)
       
    1: def pdf_annot_rich_defaults(annot):
           r"""Class-aware wrapper for `::pdf_annot_rich_defaults()`."""
>>>>>>     return _mupdf.pdf_annot_rich_defaults(annot)
       
    1: def pdf_annot_stamp_image_obj(annot):
           r"""Class-aware wrapper for `::pdf_annot_stamp_image_obj()`."""
>>>>>>     return _mupdf.pdf_annot_stamp_image_obj(annot)
       
    1: def pdf_annot_transform(annot):
           r"""Class-aware wrapper for `::pdf_annot_transform()`."""
>>>>>>     return _mupdf.pdf_annot_transform(annot)
       
    1: def pdf_annot_type(annot):
           r"""Class-aware wrapper for `::pdf_annot_type()`."""
>>>>>>     return _mupdf.pdf_annot_type(annot)
       
    1: def pdf_annot_type_from_string(subtype):
           r"""Class-aware wrapper for `::pdf_annot_type_from_string()`."""
>>>>>>     return _mupdf.pdf_annot_type_from_string(subtype)
       
    1: def pdf_annot_vertex(annot, i):
           r"""Class-aware wrapper for `::pdf_annot_vertex()`."""
>>>>>>     return _mupdf.pdf_annot_vertex(annot, i)
       
    1: def pdf_annot_vertex_count(annot):
           r"""Class-aware wrapper for `::pdf_annot_vertex_count()`."""
>>>>>>     return _mupdf.pdf_annot_vertex_count(annot)
       
    1: def pdf_append_explicit_dest_to_uri(url, dest):
           r"""Class-aware wrapper for `::pdf_append_explicit_dest_to_uri()`."""
>>>>>>     return _mupdf.pdf_append_explicit_dest_to_uri(url, dest)
       
    1: def pdf_append_named_dest_to_uri(url, name):
           r"""Class-aware wrapper for `::pdf_append_named_dest_to_uri()`."""
>>>>>>     return _mupdf.pdf_append_named_dest_to_uri(url, name)
       
    1: def pdf_append_token(buf, tok, lex):
           r"""Class-aware wrapper for `::pdf_append_token()`."""
>>>>>>     return _mupdf.pdf_append_token(buf, tok, lex)
       
    1: def pdf_apply_redaction(annot, opts):
           r"""Class-aware wrapper for `::pdf_apply_redaction()`."""
>>>>>>     return _mupdf.pdf_apply_redaction(annot, opts)
       
    1: def pdf_array_contains(array, obj):
           r"""Class-aware wrapper for `::pdf_array_contains()`."""
>>>>>>     return _mupdf.pdf_array_contains(array, obj)
       
    1: def pdf_array_delete(array, index):
           r"""Class-aware wrapper for `::pdf_array_delete()`."""
>>>>>>     return _mupdf.pdf_array_delete(array, index)
       
    1: def pdf_array_find(array, obj):
           r"""Class-aware wrapper for `::pdf_array_find()`."""
>>>>>>     return _mupdf.pdf_array_find(array, obj)
       
    1: def pdf_array_get(array, i):
           r"""Class-aware wrapper for `::pdf_array_get()`."""
>>>>>>     return _mupdf.pdf_array_get(array, i)
       
    1: def pdf_array_get_bool(array, index):
           r"""Class-aware wrapper for `::pdf_array_get_bool()`."""
>>>>>>     return _mupdf.pdf_array_get_bool(array, index)
       
    1: def pdf_array_get_int(array, index):
           r"""Class-aware wrapper for `::pdf_array_get_int()`."""
>>>>>>     return _mupdf.pdf_array_get_int(array, index)
       
    1: def pdf_array_get_matrix(array, index):
           r"""Class-aware wrapper for `::pdf_array_get_matrix()`."""
>>>>>>     return _mupdf.pdf_array_get_matrix(array, index)
       
    1: def pdf_array_get_name(array, index):
           r"""Class-aware wrapper for `::pdf_array_get_name()`."""
>>>>>>     return _mupdf.pdf_array_get_name(array, index)
       
    1: def pdf_array_get_real(array, index):
           r"""Class-aware wrapper for `::pdf_array_get_real()`."""
>>>>>>     return _mupdf.pdf_array_get_real(array, index)
       
    1: def pdf_array_get_rect(array, index):
           r"""Class-aware wrapper for `::pdf_array_get_rect()`."""
>>>>>>     return _mupdf.pdf_array_get_rect(array, index)
       
    1: def pdf_array_get_string(array, index, sizep):
           r"""
           Class-aware wrapper for `::pdf_array_get_string()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_array_get_string(::pdf_obj *array, int index)` => `(const char *, size_t sizep)`
           """
>>>>>>     return _mupdf.pdf_array_get_string(array, index, sizep)
       
    1: def pdf_array_get_text_string(array, index):
           r"""Class-aware wrapper for `::pdf_array_get_text_string()`."""
>>>>>>     return _mupdf.pdf_array_get_text_string(array, index)
       
    1: def pdf_array_insert(array, obj, index):
           r"""Class-aware wrapper for `::pdf_array_insert()`."""
>>>>>>     return _mupdf.pdf_array_insert(array, obj, index)
       
    1: def pdf_array_len(array):
           r"""Class-aware wrapper for `::pdf_array_len()`."""
>>>>>>     return _mupdf.pdf_array_len(array)
       
    1: def pdf_array_push(array, obj):
           r"""Class-aware wrapper for `::pdf_array_push()`."""
>>>>>>     return _mupdf.pdf_array_push(array, obj)
       
    1: def pdf_array_push_array(array, initial):
           r"""Class-aware wrapper for `::pdf_array_push_array()`."""
>>>>>>     return _mupdf.pdf_array_push_array(array, initial)
       
    1: def pdf_array_push_bool(array, x):
           r"""Class-aware wrapper for `::pdf_array_push_bool()`."""
>>>>>>     return _mupdf.pdf_array_push_bool(array, x)
       
    1: def pdf_array_push_dict(array, initial):
           r"""Class-aware wrapper for `::pdf_array_push_dict()`."""
>>>>>>     return _mupdf.pdf_array_push_dict(array, initial)
       
    1: def pdf_array_push_int(array, x):
           r"""Class-aware wrapper for `::pdf_array_push_int()`."""
>>>>>>     return _mupdf.pdf_array_push_int(array, x)
       
    1: def pdf_array_push_name(array, x):
           r"""Class-aware wrapper for `::pdf_array_push_name()`."""
>>>>>>     return _mupdf.pdf_array_push_name(array, x)
       
    1: def pdf_array_push_real(array, x):
           r"""Class-aware wrapper for `::pdf_array_push_real()`."""
>>>>>>     return _mupdf.pdf_array_push_real(array, x)
       
    1: def pdf_array_push_string(array, x, n):
           r"""Class-aware wrapper for `::pdf_array_push_string()`."""
>>>>>>     return _mupdf.pdf_array_push_string(array, x, n)
       
    1: def pdf_array_push_text_string(array, x):
           r"""Class-aware wrapper for `::pdf_array_push_text_string()`."""
>>>>>>     return _mupdf.pdf_array_push_text_string(array, x)
       
    1: def pdf_array_put(array, i, obj):
           r"""Class-aware wrapper for `::pdf_array_put()`."""
>>>>>>     return _mupdf.pdf_array_put(array, i, obj)
       
    1: def pdf_array_put_array(array, i, initial):
           r"""Class-aware wrapper for `::pdf_array_put_array()`."""
>>>>>>     return _mupdf.pdf_array_put_array(array, i, initial)
       
    1: def pdf_array_put_bool(array, i, x):
           r"""Class-aware wrapper for `::pdf_array_put_bool()`."""
>>>>>>     return _mupdf.pdf_array_put_bool(array, i, x)
       
    1: def pdf_array_put_dict(array, i, initial):
           r"""Class-aware wrapper for `::pdf_array_put_dict()`."""
>>>>>>     return _mupdf.pdf_array_put_dict(array, i, initial)
       
    1: def pdf_array_put_int(array, i, x):
           r"""Class-aware wrapper for `::pdf_array_put_int()`."""
>>>>>>     return _mupdf.pdf_array_put_int(array, i, x)
       
    1: def pdf_array_put_name(array, i, x):
           r"""Class-aware wrapper for `::pdf_array_put_name()`."""
>>>>>>     return _mupdf.pdf_array_put_name(array, i, x)
       
    1: def pdf_array_put_real(array, i, x):
           r"""Class-aware wrapper for `::pdf_array_put_real()`."""
>>>>>>     return _mupdf.pdf_array_put_real(array, i, x)
       
    1: def pdf_array_put_string(array, i, x, n):
           r"""Class-aware wrapper for `::pdf_array_put_string()`."""
>>>>>>     return _mupdf.pdf_array_put_string(array, i, x, n)
       
    1: def pdf_array_put_text_string(array, i, x):
           r"""Class-aware wrapper for `::pdf_array_put_text_string()`."""
>>>>>>     return _mupdf.pdf_array_put_text_string(array, i, x)
       
    1: def pdf_authenticate_password(doc, pw):
           r"""Class-aware wrapper for `::pdf_authenticate_password()`."""
>>>>>>     return _mupdf.pdf_authenticate_password(doc, pw)
       
    1: def pdf_bake_document(doc, bake_annots, bake_widgets):
           r"""Class-aware wrapper for `::pdf_bake_document()`."""
>>>>>>     return _mupdf.pdf_bake_document(doc, bake_annots, bake_widgets)
       
    1: def pdf_begin_implicit_operation(doc):
           r"""Class-aware wrapper for `::pdf_begin_implicit_operation()`."""
>>>>>>     return _mupdf.pdf_begin_implicit_operation(doc)
       
    1: def pdf_begin_operation(doc, operation):
           r"""Class-aware wrapper for `::pdf_begin_operation()`."""
>>>>>>     return _mupdf.pdf_begin_operation(doc, operation)
       
    1: def pdf_bound_annot(annot):
           r"""Class-aware wrapper for `::pdf_bound_annot()`."""
>>>>>>     return _mupdf.pdf_bound_annot(annot)
       
    1: def pdf_bound_page(page, box):
           r"""Class-aware wrapper for `::pdf_bound_page()`."""
>>>>>>     return _mupdf.pdf_bound_page(page, box)
       
    1: def pdf_bound_widget(widget):
           r"""Class-aware wrapper for `::pdf_bound_widget()`."""
>>>>>>     return _mupdf.pdf_bound_widget(widget)
       
    1: def pdf_button_field_on_state(field):
           r"""Class-aware wrapper for `::pdf_button_field_on_state()`."""
>>>>>>     return _mupdf.pdf_button_field_on_state(field)
       
    1: def pdf_calculate_form(doc):
           r"""Class-aware wrapper for `::pdf_calculate_form()`."""
>>>>>>     return _mupdf.pdf_calculate_form(doc)
       
    1: def pdf_can_be_saved_incrementally(doc):
           r"""Class-aware wrapper for `::pdf_can_be_saved_incrementally()`."""
>>>>>>     return _mupdf.pdf_can_be_saved_incrementally(doc)
       
    1: def pdf_can_redo(doc):
           r"""Class-aware wrapper for `::pdf_can_redo()`."""
>>>>>>     return _mupdf.pdf_can_redo(doc)
       
    1: def pdf_can_undo(doc):
           r"""Class-aware wrapper for `::pdf_can_undo()`."""
>>>>>>     return _mupdf.pdf_can_undo(doc)
       
    1: def pdf_check_certificate(verifier, doc, signature):
           r"""Class-aware wrapper for `::pdf_check_certificate()`."""
>>>>>>     return _mupdf.pdf_check_certificate(verifier, doc, signature)
       
    1: def pdf_check_digest(verifier, doc, signature):
           r"""Class-aware wrapper for `::pdf_check_digest()`."""
>>>>>>     return _mupdf.pdf_check_digest(verifier, doc, signature)
       
    1: def pdf_check_widget_certificate(verifier, widget):
           r"""Class-aware wrapper for `::pdf_check_widget_certificate()`."""
>>>>>>     return _mupdf.pdf_check_widget_certificate(verifier, widget)
       
    1: def pdf_check_widget_digest(verifier, widget):
           r"""Class-aware wrapper for `::pdf_check_widget_digest()`."""
>>>>>>     return _mupdf.pdf_check_widget_digest(verifier, widget)
       
    1: def pdf_choice_field_option(field, exportval, i):
           r"""Class-aware wrapper for `::pdf_choice_field_option()`."""
>>>>>>     return _mupdf.pdf_choice_field_option(field, exportval, i)
       
    1: def pdf_choice_field_option_count(field):
           r"""Class-aware wrapper for `::pdf_choice_field_option_count()`."""
>>>>>>     return _mupdf.pdf_choice_field_option_count(field)
       
    1: def pdf_choice_widget_is_multiselect(tw):
           r"""Class-aware wrapper for `::pdf_choice_widget_is_multiselect()`."""
>>>>>>     return _mupdf.pdf_choice_widget_is_multiselect(tw)
       
    1: def pdf_choice_widget_options(tw, exportval, opts):
           r"""Class-aware wrapper for `::pdf_choice_widget_options()`."""
>>>>>>     return _mupdf.pdf_choice_widget_options(tw, exportval, opts)
       
    1: def pdf_choice_widget_options2(tw, exportval):
           r"""
           Class-aware wrapper for `::pdf_choice_widget_options2()`.   Swig-friendly wrapper for pdf_choice_widget_options(), returns the
           options directly in a vector.
           """
>>>>>>     return _mupdf.pdf_choice_widget_options2(tw, exportval)
       
    1: def pdf_choice_widget_set_value(tw, n, opts):
           r"""Class-aware wrapper for `::pdf_choice_widget_set_value()`."""
>>>>>>     return _mupdf.pdf_choice_widget_set_value(tw, n, opts)
       
    1: def pdf_choice_widget_value(tw, opts):
           r"""Class-aware wrapper for `::pdf_choice_widget_value()`."""
>>>>>>     return _mupdf.pdf_choice_widget_value(tw, opts)
       
    1: def pdf_clean_file(infile, outfile, password, opts, retainlen):
           r"""Class-aware wrapper for `::pdf_clean_file()`."""
>>>>>>     return _mupdf.pdf_clean_file(infile, outfile, password, opts, retainlen)
       
    1: def pdf_clean_font_name(fontname):
           r"""Class-aware wrapper for `::pdf_clean_font_name()`."""
>>>>>>     return _mupdf.pdf_clean_font_name(fontname)
       
    1: def pdf_clean_obj(obj):
           r"""Class-aware wrapper for `::pdf_clean_obj()`."""
>>>>>>     return _mupdf.pdf_clean_obj(obj)
       
    1: def pdf_clear_annot_border_dash(annot):
           r"""Class-aware wrapper for `::pdf_clear_annot_border_dash()`."""
>>>>>>     return _mupdf.pdf_clear_annot_border_dash(annot)
       
    1: def pdf_clear_annot_ink_list(annot):
           r"""Class-aware wrapper for `::pdf_clear_annot_ink_list()`."""
>>>>>>     return _mupdf.pdf_clear_annot_ink_list(annot)
       
    1: def pdf_clear_annot_quad_points(annot):
           r"""Class-aware wrapper for `::pdf_clear_annot_quad_points()`."""
>>>>>>     return _mupdf.pdf_clear_annot_quad_points(annot)
       
    1: def pdf_clear_annot_vertices(annot):
           r"""Class-aware wrapper for `::pdf_clear_annot_vertices()`."""
>>>>>>     return _mupdf.pdf_clear_annot_vertices(annot)
       
    1: def pdf_clear_signature(widget):
           r"""Class-aware wrapper for `::pdf_clear_signature()`."""
>>>>>>     return _mupdf.pdf_clear_signature(widget)
       
    1: def pdf_clear_xref(doc):
           r"""Class-aware wrapper for `::pdf_clear_xref()`."""
>>>>>>     return _mupdf.pdf_clear_xref(doc)
       
    1: def pdf_clear_xref_to_mark(doc):
           r"""Class-aware wrapper for `::pdf_clear_xref_to_mark()`."""
>>>>>>     return _mupdf.pdf_clear_xref_to_mark(doc)
       
    1: def pdf_clip_page(page, clip):
           r"""Class-aware wrapper for `::pdf_clip_page()`."""
>>>>>>     return _mupdf.pdf_clip_page(page, clip)
       
    1: def pdf_close_processor(proc):
           r"""Class-aware wrapper for `::pdf_close_processor()`."""
>>>>>>     return _mupdf.pdf_close_processor(proc)
       
    1: def pdf_cmap_size(cmap):
           r"""Class-aware wrapper for `::pdf_cmap_size()`."""
>>>>>>     return _mupdf.pdf_cmap_size(cmap)
       
    1: def pdf_cmap_wmode(cmap):
           r"""Class-aware wrapper for `::pdf_cmap_wmode()`."""
>>>>>>     return _mupdf.pdf_cmap_wmode(cmap)
       
    1: def pdf_copy_array(array):
           r"""Class-aware wrapper for `::pdf_copy_array()`."""
>>>>>>     return _mupdf.pdf_copy_array(array)
       
    1: def pdf_copy_dict(dict):
           r"""Class-aware wrapper for `::pdf_copy_dict()`."""
>>>>>>     return _mupdf.pdf_copy_dict(dict)
       
    1: def pdf_count_document_associated_files(doc):
           r"""Class-aware wrapper for `::pdf_count_document_associated_files()`."""
>>>>>>     return _mupdf.pdf_count_document_associated_files(doc)
       
    1: def pdf_count_layer_config_ui(doc):
           r"""Class-aware wrapper for `::pdf_count_layer_config_ui()`."""
>>>>>>     return _mupdf.pdf_count_layer_config_ui(doc)
       
    1: def pdf_count_layer_configs(doc):
           r"""Class-aware wrapper for `::pdf_count_layer_configs()`."""
>>>>>>     return _mupdf.pdf_count_layer_configs(doc)
       
    1: def pdf_count_layers(doc):
           r"""Class-aware wrapper for `::pdf_count_layers()`."""
>>>>>>     return _mupdf.pdf_count_layers(doc)
       
    1: def pdf_count_objects(doc):
           r"""Class-aware wrapper for `::pdf_count_objects()`."""
>>>>>>     return _mupdf.pdf_count_objects(doc)
       
    1: def pdf_count_page_associated_files(page):
           r"""Class-aware wrapper for `::pdf_count_page_associated_files()`."""
>>>>>>     return _mupdf.pdf_count_page_associated_files(page)
       
    1: def pdf_count_pages(doc):
           r"""Class-aware wrapper for `::pdf_count_pages()`."""
>>>>>>     return _mupdf.pdf_count_pages(doc)
       
    1: def pdf_count_pages_imp(doc, chapter):
           r"""Class-aware wrapper for `::pdf_count_pages_imp()`."""
>>>>>>     return _mupdf.pdf_count_pages_imp(doc, chapter)
       
    1: def pdf_count_q_balance(doc, res, stm, prepend, append):
           r"""
           Class-aware wrapper for `::pdf_count_q_balance()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_count_q_balance(::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm)` => `(int prepend, int append)`
           """
>>>>>>     return _mupdf.pdf_count_q_balance(doc, res, stm, prepend, append)
       
    1: def pdf_count_signatures(doc):
           r"""Class-aware wrapper for `::pdf_count_signatures()`."""
>>>>>>     return _mupdf.pdf_count_signatures(doc)
       
    1: def pdf_count_unsaved_versions(doc):
           r"""Class-aware wrapper for `::pdf_count_unsaved_versions()`."""
>>>>>>     return _mupdf.pdf_count_unsaved_versions(doc)
       
    1: def pdf_count_versions(doc):
           r"""Class-aware wrapper for `::pdf_count_versions()`."""
>>>>>>     return _mupdf.pdf_count_versions(doc)
       
    1: def pdf_create_annot(page, type):
           r"""Class-aware wrapper for `::pdf_create_annot()`."""
>>>>>>     return _mupdf.pdf_create_annot(page, type)
       
    1: def pdf_create_annot_raw(page, type):
           r"""Class-aware wrapper for `::pdf_create_annot_raw()`."""
>>>>>>     return _mupdf.pdf_create_annot_raw(page, type)
       
    1: def pdf_create_document():
           r"""Class-aware wrapper for `::pdf_create_document()`."""
>>>>>>     return _mupdf.pdf_create_document()
       
    1: def pdf_create_field_name(doc, prefix, buf, len):
           r"""Class-aware wrapper for `::pdf_create_field_name()`."""
>>>>>>     return _mupdf.pdf_create_field_name(doc, prefix, buf, len)
       
    1: def pdf_create_link(page, bbox, uri):
           r"""Class-aware wrapper for `::pdf_create_link()`."""
>>>>>>     return _mupdf.pdf_create_link(page, bbox, uri)
       
    1: def pdf_create_object(doc):
           r"""Class-aware wrapper for `::pdf_create_object()`."""
>>>>>>     return _mupdf.pdf_create_object(doc)
       
    1: def pdf_create_signature_widget(page, name):
           r"""Class-aware wrapper for `::pdf_create_signature_widget()`."""
>>>>>>     return _mupdf.pdf_create_signature_widget(page, name)
       
    1: def pdf_crypt_encrypt_metadata(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_encrypt_metadata()`."""
>>>>>>     return _mupdf.pdf_crypt_encrypt_metadata(crypt)
       
    1: def pdf_crypt_key(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_key()`."""
>>>>>>     return _mupdf.pdf_crypt_key(crypt)
       
    1: def pdf_crypt_length(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_length()`."""
>>>>>>     return _mupdf.pdf_crypt_length(crypt)
       
    1: def pdf_crypt_method(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_method()`."""
>>>>>>     return _mupdf.pdf_crypt_method(crypt)
       
    1: def pdf_crypt_obj(crypt, obj, num, gen):
           r"""Class-aware wrapper for `::pdf_crypt_obj()`."""
>>>>>>     return _mupdf.pdf_crypt_obj(crypt, obj, num, gen)
       
    1: def pdf_crypt_owner_encryption(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_owner_encryption()`."""
>>>>>>     return _mupdf.pdf_crypt_owner_encryption(crypt)
       
    1: def pdf_crypt_owner_password(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_owner_password()`."""
>>>>>>     return _mupdf.pdf_crypt_owner_password(crypt)
       
    1: def pdf_crypt_permissions(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_permissions()`."""
>>>>>>     return _mupdf.pdf_crypt_permissions(crypt)
       
    1: def pdf_crypt_permissions_encryption(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_permissions_encryption()`."""
>>>>>>     return _mupdf.pdf_crypt_permissions_encryption(crypt)
       
    1: def pdf_crypt_revision(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_revision()`."""
>>>>>>     return _mupdf.pdf_crypt_revision(crypt)
       
    1: def pdf_crypt_stream_method(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_stream_method()`."""
>>>>>>     return _mupdf.pdf_crypt_stream_method(crypt)
       
    1: def pdf_crypt_string_method(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_string_method()`."""
>>>>>>     return _mupdf.pdf_crypt_string_method(crypt)
       
    1: def pdf_crypt_user_encryption(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_user_encryption()`."""
>>>>>>     return _mupdf.pdf_crypt_user_encryption(crypt)
       
    1: def pdf_crypt_user_password(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_user_password()`."""
>>>>>>     return _mupdf.pdf_crypt_user_password(crypt)
       
    1: def pdf_crypt_version(crypt):
           r"""Class-aware wrapper for `::pdf_crypt_version()`."""
>>>>>>     return _mupdf.pdf_crypt_version(crypt)
       
    1: def pdf_cycle(here, prev, obj):
           r"""Class-aware wrapper for `::pdf_cycle()`."""
>>>>>>     return _mupdf.pdf_cycle(here, prev, obj)
       
    1: def pdf_debug_doc_changes(doc):
           r"""Class-aware wrapper for `::pdf_debug_doc_changes()`."""
>>>>>>     return _mupdf.pdf_debug_doc_changes(doc)
       
    1: def pdf_debug_obj(obj):
           r"""Class-aware wrapper for `::pdf_debug_obj()`."""
>>>>>>     return _mupdf.pdf_debug_obj(obj)
       
    1: def pdf_debug_ref(obj):
           r"""Class-aware wrapper for `::pdf_debug_ref()`."""
>>>>>>     return _mupdf.pdf_debug_ref(obj)
       
    1: def pdf_decode_cmap(cmap, s, e, cpt):
           r"""
           Class-aware wrapper for `::pdf_decode_cmap()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_decode_cmap(::pdf_cmap *cmap, unsigned char *s, unsigned char *e)` => `(int, unsigned int cpt)`
           """
>>>>>>     return _mupdf.pdf_decode_cmap(cmap, s, e, cpt)
       
    1: def pdf_deep_copy_obj(obj):
           r"""Class-aware wrapper for `::pdf_deep_copy_obj()`."""
>>>>>>     return _mupdf.pdf_deep_copy_obj(obj)
       
    1: def pdf_delete_annot(page, annot):
           r"""Class-aware wrapper for `::pdf_delete_annot()`."""
>>>>>>     return _mupdf.pdf_delete_annot(page, annot)
       
    1: def pdf_delete_link(page, link):
           r"""Class-aware wrapper for `::pdf_delete_link()`."""
>>>>>>     return _mupdf.pdf_delete_link(page, link)
       
    1: def pdf_delete_object(doc, num):
           r"""Class-aware wrapper for `::pdf_delete_object()`."""
>>>>>>     return _mupdf.pdf_delete_object(doc, num)
       
    1: def pdf_delete_page(doc, number):
           r"""Class-aware wrapper for `::pdf_delete_page()`."""
>>>>>>     return _mupdf.pdf_delete_page(doc, number)
       
    1: def pdf_delete_page_labels(doc, index):
           r"""Class-aware wrapper for `::pdf_delete_page_labels()`."""
>>>>>>     return _mupdf.pdf_delete_page_labels(doc, index)
       
    1: def pdf_delete_page_range(doc, start, end):
           r"""Class-aware wrapper for `::pdf_delete_page_range()`."""
>>>>>>     return _mupdf.pdf_delete_page_range(doc, start, end)
       
    1: def pdf_deselect_layer_config_ui(doc, ui):
           r"""Class-aware wrapper for `::pdf_deselect_layer_config_ui()`."""
>>>>>>     return _mupdf.pdf_deselect_layer_config_ui(doc, ui)
       
    1: def pdf_deserialise_journal(doc, stm):
           r"""Class-aware wrapper for `::pdf_deserialise_journal()`."""
>>>>>>     return _mupdf.pdf_deserialise_journal(doc, stm)
       
    1: def pdf_dict_del(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_del()`."""
>>>>>>     return _mupdf.pdf_dict_del(dict, key)
       
    1: def pdf_dict_dels(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_dels()`."""
>>>>>>     return _mupdf.pdf_dict_dels(dict, key)
       
    1: def pdf_dict_get(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get()`."""
>>>>>>     return _mupdf.pdf_dict_get(dict, key)
       
    1: def pdf_dict_get_bool(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_bool()`."""
>>>>>>     return _mupdf.pdf_dict_get_bool(dict, key)
       
    1: def pdf_dict_get_bool_default(dict, key, _def):
           r"""Class-aware wrapper for `::pdf_dict_get_bool_default()`."""
>>>>>>     return _mupdf.pdf_dict_get_bool_default(dict, key, _def)
       
    1: def pdf_dict_get_date(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_date()`."""
>>>>>>     return _mupdf.pdf_dict_get_date(dict, key)
       
    1: def pdf_dict_get_inheritable(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_inheritable()`."""
>>>>>>     return _mupdf.pdf_dict_get_inheritable(dict, key)
       
    1: def pdf_dict_get_inheritable_bool(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_inheritable_bool()`."""
>>>>>>     return _mupdf.pdf_dict_get_inheritable_bool(dict, key)
       
    1: def pdf_dict_get_inheritable_date(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_inheritable_date()`."""
>>>>>>     return _mupdf.pdf_dict_get_inheritable_date(dict, key)
       
    1: def pdf_dict_get_inheritable_int(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_inheritable_int()`."""
>>>>>>     return _mupdf.pdf_dict_get_inheritable_int(dict, key)
       
    1: def pdf_dict_get_inheritable_int64(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_inheritable_int64()`."""
>>>>>>     return _mupdf.pdf_dict_get_inheritable_int64(dict, key)
       
    1: def pdf_dict_get_inheritable_matrix(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_inheritable_matrix()`."""
>>>>>>     return _mupdf.pdf_dict_get_inheritable_matrix(dict, key)
       
    1: def pdf_dict_get_inheritable_name(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_inheritable_name()`."""
>>>>>>     return _mupdf.pdf_dict_get_inheritable_name(dict, key)
       
    1: def pdf_dict_get_inheritable_real(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_inheritable_real()`."""
>>>>>>     return _mupdf.pdf_dict_get_inheritable_real(dict, key)
       
    1: def pdf_dict_get_inheritable_rect(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_inheritable_rect()`."""
>>>>>>     return _mupdf.pdf_dict_get_inheritable_rect(dict, key)
       
    1: def pdf_dict_get_inheritable_string(dict, key, sizep):
           r"""
           Class-aware wrapper for `::pdf_dict_get_inheritable_string()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_dict_get_inheritable_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
           """
>>>>>>     return _mupdf.pdf_dict_get_inheritable_string(dict, key, sizep)
       
    1: def pdf_dict_get_inheritable_text_string(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_inheritable_text_string()`."""
>>>>>>     return _mupdf.pdf_dict_get_inheritable_text_string(dict, key)
       
    1: def pdf_dict_get_int(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_int()`."""
>>>>>>     return _mupdf.pdf_dict_get_int(dict, key)
       
    1: def pdf_dict_get_int64(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_int64()`."""
>>>>>>     return _mupdf.pdf_dict_get_int64(dict, key)
       
    1: def pdf_dict_get_int_default(dict, key, _def):
           r"""Class-aware wrapper for `::pdf_dict_get_int_default()`."""
>>>>>>     return _mupdf.pdf_dict_get_int_default(dict, key, _def)
       
    1: def pdf_dict_get_key(dict, idx):
           r"""Class-aware wrapper for `::pdf_dict_get_key()`."""
>>>>>>     return _mupdf.pdf_dict_get_key(dict, idx)
       
    1: def pdf_dict_get_matrix(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_matrix()`."""
>>>>>>     return _mupdf.pdf_dict_get_matrix(dict, key)
       
    1: def pdf_dict_get_name(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_name()`."""
>>>>>>     return _mupdf.pdf_dict_get_name(dict, key)
       
    1: def pdf_dict_get_point(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_point()`."""
>>>>>>     return _mupdf.pdf_dict_get_point(dict, key)
       
    1: def pdf_dict_get_real(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_real()`."""
>>>>>>     return _mupdf.pdf_dict_get_real(dict, key)
       
    1: def pdf_dict_get_real_default(dict, key, _def):
           r"""Class-aware wrapper for `::pdf_dict_get_real_default()`."""
>>>>>>     return _mupdf.pdf_dict_get_real_default(dict, key, _def)
       
    1: def pdf_dict_get_rect(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_rect()`."""
>>>>>>     return _mupdf.pdf_dict_get_rect(dict, key)
       
    1: def pdf_dict_get_string(dict, key, sizep):
           r"""
           Class-aware wrapper for `::pdf_dict_get_string()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_dict_get_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
           """
>>>>>>     return _mupdf.pdf_dict_get_string(dict, key, sizep)
       
    1: def pdf_dict_get_text_string(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_text_string()`."""
>>>>>>     return _mupdf.pdf_dict_get_text_string(dict, key)
       
    1: def pdf_dict_get_text_string_opt(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_get_text_string_opt()`."""
>>>>>>     return _mupdf.pdf_dict_get_text_string_opt(dict, key)
       
    1: def pdf_dict_get_val(dict, idx):
           r"""Class-aware wrapper for `::pdf_dict_get_val()`."""
>>>>>>     return _mupdf.pdf_dict_get_val(dict, idx)
       
    1: def pdf_dict_geta(dict, key, abbrev):
           r"""Class-aware wrapper for `::pdf_dict_geta()`."""
>>>>>>     return _mupdf.pdf_dict_geta(dict, key, abbrev)
       
    1: def pdf_dict_getp(dict, path):
           r"""Class-aware wrapper for `::pdf_dict_getp()`."""
>>>>>>     return _mupdf.pdf_dict_getp(dict, path)
       
    1: def pdf_dict_getp_inheritable(dict, path):
           r"""Class-aware wrapper for `::pdf_dict_getp_inheritable()`."""
>>>>>>     return _mupdf.pdf_dict_getp_inheritable(dict, path)
       
    1: def pdf_dict_gets(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_gets()`."""
>>>>>>     return _mupdf.pdf_dict_gets(dict, key)
       
    1: def pdf_dict_gets_inheritable(dict, key):
           r"""Class-aware wrapper for `::pdf_dict_gets_inheritable()`."""
>>>>>>     return _mupdf.pdf_dict_gets_inheritable(dict, key)
       
    1: def pdf_dict_getsa(dict, key, abbrev):
           r"""Class-aware wrapper for `::pdf_dict_getsa()`."""
>>>>>>     return _mupdf.pdf_dict_getsa(dict, key, abbrev)
       
    1: def pdf_dict_len(dict):
           r"""Class-aware wrapper for `::pdf_dict_len()`."""
>>>>>>     return _mupdf.pdf_dict_len(dict)
       
    1: def pdf_dict_put(dict, key, val):
           r"""Class-aware wrapper for `::pdf_dict_put()`."""
>>>>>>     return _mupdf.pdf_dict_put(dict, key, val)
       
    1: def pdf_dict_put_array(dict, key, initial):
           r"""Class-aware wrapper for `::pdf_dict_put_array()`."""
>>>>>>     return _mupdf.pdf_dict_put_array(dict, key, initial)
       
    1: def pdf_dict_put_bool(dict, key, x):
           r"""Class-aware wrapper for `::pdf_dict_put_bool()`."""
>>>>>>     return _mupdf.pdf_dict_put_bool(dict, key, x)
       
    1: def pdf_dict_put_date(dict, key, time):
           r"""Class-aware wrapper for `::pdf_dict_put_date()`."""
>>>>>>     return _mupdf.pdf_dict_put_date(dict, key, time)
       
    1: def pdf_dict_put_dict(dict, key, initial):
           r"""Class-aware wrapper for `::pdf_dict_put_dict()`."""
>>>>>>     return _mupdf.pdf_dict_put_dict(dict, key, initial)
       
    1: def pdf_dict_put_indirect(dict, key, num):
           r"""Class-aware wrapper for `::pdf_dict_put_indirect()`."""
>>>>>>     return _mupdf.pdf_dict_put_indirect(dict, key, num)
       
    1: def pdf_dict_put_int(dict, key, x):
           r"""Class-aware wrapper for `::pdf_dict_put_int()`."""
>>>>>>     return _mupdf.pdf_dict_put_int(dict, key, x)
       
    1: def pdf_dict_put_matrix(dict, key, x):
           r"""Class-aware wrapper for `::pdf_dict_put_matrix()`."""
>>>>>>     return _mupdf.pdf_dict_put_matrix(dict, key, x)
       
    1: def pdf_dict_put_name(dict, key, x):
           r"""Class-aware wrapper for `::pdf_dict_put_name()`."""
>>>>>>     return _mupdf.pdf_dict_put_name(dict, key, x)
       
    1: def pdf_dict_put_point(dict, key, x):
           r"""Class-aware wrapper for `::pdf_dict_put_point()`."""
>>>>>>     return _mupdf.pdf_dict_put_point(dict, key, x)
       
    1: def pdf_dict_put_real(dict, key, x):
           r"""Class-aware wrapper for `::pdf_dict_put_real()`."""
>>>>>>     return _mupdf.pdf_dict_put_real(dict, key, x)
       
    1: def pdf_dict_put_rect(dict, key, x):
           r"""Class-aware wrapper for `::pdf_dict_put_rect()`."""
>>>>>>     return _mupdf.pdf_dict_put_rect(dict, key, x)
       
    1: def pdf_dict_put_string(dict, key, x, n):
           r"""Class-aware wrapper for `::pdf_dict_put_string()`."""
>>>>>>     return _mupdf.pdf_dict_put_string(dict, key, x, n)
       
    1: def pdf_dict_put_text_string(dict, key, x):
           r"""Class-aware wrapper for `::pdf_dict_put_text_string()`."""
>>>>>>     return _mupdf.pdf_dict_put_text_string(dict, key, x)
       
    1: def pdf_dict_put_val_null(obj, idx):
           r"""Class-aware wrapper for `::pdf_dict_put_val_null()`."""
>>>>>>     return _mupdf.pdf_dict_put_val_null(obj, idx)
       
    1: def pdf_dict_putp(dict, path, val):
           r"""Class-aware wrapper for `::pdf_dict_putp()`."""
>>>>>>     return _mupdf.pdf_dict_putp(dict, path, val)
       
    1: def pdf_dict_puts(dict, key, val):
           r"""Class-aware wrapper for `::pdf_dict_puts()`."""
>>>>>>     return _mupdf.pdf_dict_puts(dict, key, val)
       
    1: def pdf_dict_puts_dict(dict, key, initial):
           r"""Class-aware wrapper for `::pdf_dict_puts_dict()`."""
>>>>>>     return _mupdf.pdf_dict_puts_dict(dict, key, initial)
       
    1: def pdf_dirty_annot(annot):
           r"""Class-aware wrapper for `::pdf_dirty_annot()`."""
>>>>>>     return _mupdf.pdf_dirty_annot(annot)
       
    1: def pdf_dirty_obj(obj):
           r"""Class-aware wrapper for `::pdf_dirty_obj()`."""
>>>>>>     return _mupdf.pdf_dirty_obj(obj)
       
    1: def pdf_disable_js(doc):
           r"""Class-aware wrapper for `::pdf_disable_js()`."""
>>>>>>     return _mupdf.pdf_disable_js(doc)
       
    1: def pdf_discard_journal(journal):
           r"""Class-aware wrapper for `::pdf_discard_journal()`."""
>>>>>>     return _mupdf.pdf_discard_journal(journal)
       
    1: def pdf_doc_was_linearized(doc):
           r"""Class-aware wrapper for `::pdf_doc_was_linearized()`."""
>>>>>>     return _mupdf.pdf_doc_was_linearized(doc)
       
    1: def pdf_document_associated_file(doc, idx):
           r"""Class-aware wrapper for `::pdf_document_associated_file()`."""
>>>>>>     return _mupdf.pdf_document_associated_file(doc, idx)
       
    1: def pdf_document_event_did_print(doc):
           r"""Class-aware wrapper for `::pdf_document_event_did_print()`."""
>>>>>>     return _mupdf.pdf_document_event_did_print(doc)
       
    1: def pdf_document_event_did_save(doc):
           r"""Class-aware wrapper for `::pdf_document_event_did_save()`."""
>>>>>>     return _mupdf.pdf_document_event_did_save(doc)
       
    1: def pdf_document_event_will_close(doc):
           r"""Class-aware wrapper for `::pdf_document_event_will_close()`."""
>>>>>>     return _mupdf.pdf_document_event_will_close(doc)
       
    1: def pdf_document_event_will_print(doc):
           r"""Class-aware wrapper for `::pdf_document_event_will_print()`."""
>>>>>>     return _mupdf.pdf_document_event_will_print(doc)
       
    1: def pdf_document_event_will_save(doc):
           r"""Class-aware wrapper for `::pdf_document_event_will_save()`."""
>>>>>>     return _mupdf.pdf_document_event_will_save(doc)
       
    1: def pdf_document_from_fz_document(ptr):
           r"""Class-aware wrapper for `::pdf_document_from_fz_document()`."""
>>>>>>     return _mupdf.pdf_document_from_fz_document(ptr)
       
    1: def pdf_document_language(doc):
           r"""Class-aware wrapper for `::pdf_document_language()`."""
>>>>>>     return _mupdf.pdf_document_language(doc)
       
    1: def pdf_document_output_intent(doc):
           r"""Class-aware wrapper for `::pdf_document_output_intent()`."""
>>>>>>     return _mupdf.pdf_document_output_intent(doc)
       
    1: def pdf_document_permissions(doc):
           r"""Class-aware wrapper for `::pdf_document_permissions()`."""
>>>>>>     return _mupdf.pdf_document_permissions(doc)
       
    1: def pdf_edit_text_field_value(widget, value, change, selStart, selEnd, newvalue):
           r"""
           Class-aware wrapper for `::pdf_edit_text_field_value()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_edit_text_field_value(::pdf_annot *widget, const char *value, const char *change)` => `(int, int selStart, int selEnd, char *newvalue)`
           """
>>>>>>     return _mupdf.pdf_edit_text_field_value(widget, value, change, selStart, selEnd, newvalue)
       
    1: def pdf_empty_store(doc):
           r"""Class-aware wrapper for `::pdf_empty_store()`."""
>>>>>>     return _mupdf.pdf_empty_store(doc)
       
    1: def pdf_enable_journal(doc):
           r"""Class-aware wrapper for `::pdf_enable_journal()`."""
>>>>>>     return _mupdf.pdf_enable_journal(doc)
       
    1: def pdf_enable_js(doc):
           r"""Class-aware wrapper for `::pdf_enable_js()`."""
>>>>>>     return _mupdf.pdf_enable_js(doc)
       
    1: def pdf_enable_layer(doc, layer, enabled):
           r"""Class-aware wrapper for `::pdf_enable_layer()`."""
>>>>>>     return _mupdf.pdf_enable_layer(doc, layer, enabled)
       
    1: def pdf_encrypt_data(crypt, num, gen, fmt_str_out, arg, s, n):
           r"""Class-aware wrapper for `::pdf_encrypt_data()`."""
>>>>>>     return _mupdf.pdf_encrypt_data(crypt, num, gen, fmt_str_out, arg, s, n)
       
    1: def pdf_encrypted_len(crypt, num, gen, len):
           r"""Class-aware wrapper for `::pdf_encrypted_len()`."""
>>>>>>     return _mupdf.pdf_encrypted_len(crypt, num, gen, len)
       
    1: def pdf_end_hmtx(font):
           r"""Class-aware wrapper for `::pdf_end_hmtx()`."""
>>>>>>     return _mupdf.pdf_end_hmtx(font)
       
    1: def pdf_end_operation(doc):
           r"""Class-aware wrapper for `::pdf_end_operation()`."""
>>>>>>     return _mupdf.pdf_end_operation(doc)
       
    1: def pdf_end_vmtx(font):
           r"""Class-aware wrapper for `::pdf_end_vmtx()`."""
>>>>>>     return _mupdf.pdf_end_vmtx(font)
       
    1: def pdf_ensure_solid_xref(doc, num):
           r"""Class-aware wrapper for `::pdf_ensure_solid_xref()`."""
>>>>>>     return _mupdf.pdf_ensure_solid_xref(doc, num)
       
    1: def pdf_eval_function(func, _in, inlen, out, outlen):
           r"""
           Class-aware wrapper for `::pdf_eval_function()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_eval_function(::pdf_function *func, const float *in, int inlen, int outlen)` => float out
           """
>>>>>>     return _mupdf.pdf_eval_function(func, _in, inlen, out, outlen)
       
    1: def pdf_event_issue_alert(doc, evt):
           r"""Class-aware wrapper for `::pdf_event_issue_alert()`."""
>>>>>>     return _mupdf.pdf_event_issue_alert(doc, evt)
       
    1: def pdf_event_issue_exec_menu_item(doc, item):
           r"""Class-aware wrapper for `::pdf_event_issue_exec_menu_item()`."""
>>>>>>     return _mupdf.pdf_event_issue_exec_menu_item(doc, item)
       
    1: def pdf_event_issue_launch_url(doc, url, new_frame):
           r"""Class-aware wrapper for `::pdf_event_issue_launch_url()`."""
>>>>>>     return _mupdf.pdf_event_issue_launch_url(doc, url, new_frame)
       
    1: def pdf_event_issue_mail_doc(doc, evt):
           r"""Class-aware wrapper for `::pdf_event_issue_mail_doc()`."""
>>>>>>     return _mupdf.pdf_event_issue_mail_doc(doc, evt)
       
    1: def pdf_event_issue_print(doc):
           r"""Class-aware wrapper for `::pdf_event_issue_print()`."""
>>>>>>     return _mupdf.pdf_event_issue_print(doc)
       
    1: def pdf_field_border_style(field):
           r"""Class-aware wrapper for `::pdf_field_border_style()`."""
>>>>>>     return _mupdf.pdf_field_border_style(field)
       
    1: def pdf_field_display(field):
           r"""Class-aware wrapper for `::pdf_field_display()`."""
>>>>>>     return _mupdf.pdf_field_display(field)
       
    1: def pdf_field_event_calculate(doc, field):
           r"""Class-aware wrapper for `::pdf_field_event_calculate()`."""
>>>>>>     return _mupdf.pdf_field_event_calculate(doc, field)
       
    1: def pdf_field_event_format(doc, field):
           r"""Class-aware wrapper for `::pdf_field_event_format()`."""
>>>>>>     return _mupdf.pdf_field_event_format(doc, field)
       
    1: def pdf_field_event_keystroke(doc, field, evt):
           r"""Class-aware wrapper for `::pdf_field_event_keystroke()`."""
>>>>>>     return _mupdf.pdf_field_event_keystroke(doc, field, evt)
       
    1: def pdf_field_event_validate(doc, field, value, newvalue):
           r"""
           Class-aware wrapper for `::pdf_field_event_validate()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_field_event_validate(::pdf_document *doc, ::pdf_obj *field, const char *value)` => `(int, char *newvalue)`
           """
>>>>>>     return _mupdf.pdf_field_event_validate(doc, field, value, newvalue)
       
    1: def pdf_field_flags(field):
           r"""Class-aware wrapper for `::pdf_field_flags()`."""
>>>>>>     return _mupdf.pdf_field_flags(field)
       
    1: def pdf_field_label(field):
           r"""Class-aware wrapper for `::pdf_field_label()`."""
>>>>>>     return _mupdf.pdf_field_label(field)
       
    1: def pdf_field_reset(doc, field):
           r"""Class-aware wrapper for `::pdf_field_reset()`."""
>>>>>>     return _mupdf.pdf_field_reset(doc, field)
       
    1: def pdf_field_set_border_style(field, text):
           r"""Class-aware wrapper for `::pdf_field_set_border_style()`."""
>>>>>>     return _mupdf.pdf_field_set_border_style(field, text)
       
    1: def pdf_field_set_button_caption(field, text):
           r"""Class-aware wrapper for `::pdf_field_set_button_caption()`."""
>>>>>>     return _mupdf.pdf_field_set_button_caption(field, text)
       
    1: def pdf_field_set_display(field, d):
           r"""Class-aware wrapper for `::pdf_field_set_display()`."""
>>>>>>     return _mupdf.pdf_field_set_display(field, d)
       
    1: def pdf_field_set_fill_color(field, col):
           r"""Class-aware wrapper for `::pdf_field_set_fill_color()`."""
>>>>>>     return _mupdf.pdf_field_set_fill_color(field, col)
       
    1: def pdf_field_set_text_color(field, col):
           r"""Class-aware wrapper for `::pdf_field_set_text_color()`."""
>>>>>>     return _mupdf.pdf_field_set_text_color(field, col)
       
    1: def pdf_field_type(field):
           r"""Class-aware wrapper for `::pdf_field_type()`."""
>>>>>>     return _mupdf.pdf_field_type(field)
       
    1: def pdf_field_type_string(field):
           r"""Class-aware wrapper for `::pdf_field_type_string()`."""
>>>>>>     return _mupdf.pdf_field_type_string(field)
       
    1: def pdf_field_value(field):
           r"""Class-aware wrapper for `::pdf_field_value()`."""
>>>>>>     return _mupdf.pdf_field_value(field)
       
    1: def pdf_filter_annot_contents(doc, annot, options):
           r"""Class-aware wrapper for `::pdf_filter_annot_contents()`."""
>>>>>>     return _mupdf.pdf_filter_annot_contents(doc, annot, options)
       
    1: def pdf_filter_page_contents(doc, page, options):
           r"""Class-aware wrapper for `::pdf_filter_page_contents()`."""
>>>>>>     return _mupdf.pdf_filter_page_contents(doc, page, options)
       
    1: def pdf_filter_xobject_instance(old_xobj, page_res, ctm, options, cycle_up):
           r"""Class-aware wrapper for `::pdf_filter_xobject_instance()`."""
>>>>>>     return _mupdf.pdf_filter_xobject_instance(old_xobj, page_res, ctm, options, cycle_up)
       
    1: def pdf_find_colorspace_resource(doc, item, key):
           r"""Class-aware wrapper for `::pdf_find_colorspace_resource()`."""
>>>>>>     return _mupdf.pdf_find_colorspace_resource(doc, item, key)
       
    1: def pdf_find_font_resource(doc, type, encoding, item, key):
           r"""Class-aware wrapper for `::pdf_find_font_resource()`."""
>>>>>>     return _mupdf.pdf_find_font_resource(doc, type, encoding, item, key)
       
    1: def pdf_find_item(drop, key):
           r"""Class-aware wrapper for `::pdf_find_item()`."""
>>>>>>     return _mupdf.pdf_find_item(drop, key)
       
    1: def pdf_find_version_for_obj(doc, obj):
           r"""Class-aware wrapper for `::pdf_find_version_for_obj()`."""
>>>>>>     return _mupdf.pdf_find_version_for_obj(doc, obj)
       
    1: def pdf_first_annot(page):
           r"""Class-aware wrapper for `::pdf_first_annot()`."""
>>>>>>     return _mupdf.pdf_first_annot(page)
       
    1: def pdf_first_widget(page):
           r"""Class-aware wrapper for `::pdf_first_widget()`."""
>>>>>>     return _mupdf.pdf_first_widget(page)
       
    1: def pdf_flatten_inheritable_page_items(page):
           r"""Class-aware wrapper for `::pdf_flatten_inheritable_page_items()`."""
>>>>>>     return _mupdf.pdf_flatten_inheritable_page_items(page)
       
    1: def pdf_font_cid_to_gid(fontdesc, cid):
           r"""Class-aware wrapper for `::pdf_font_cid_to_gid()`."""
>>>>>>     return _mupdf.pdf_font_cid_to_gid(fontdesc, cid)
       
    1: def pdf_font_writing_supported(font):
           r"""Class-aware wrapper for `::pdf_font_writing_supported()`."""
>>>>>>     return _mupdf.pdf_font_writing_supported(font)
       
    1: def pdf_forget_xref(doc):
           r"""Class-aware wrapper for `::pdf_forget_xref()`."""
>>>>>>     return _mupdf.pdf_forget_xref(doc)
       
    1: def pdf_format_date(time, s, n):
           r"""Class-aware wrapper for `::pdf_format_date()`."""
>>>>>>     return _mupdf.pdf_format_date(time, s, n)
       
    1: def pdf_format_write_options(buffer, buffer_len, opts):
           r"""Class-aware wrapper for `::pdf_format_write_options()`."""
>>>>>>     return _mupdf.pdf_format_write_options(buffer, buffer_len, opts)
       
    1: def pdf_function_size(func):
           r"""Class-aware wrapper for `::pdf_function_size()`."""
>>>>>>     return _mupdf.pdf_function_size(func)
       
    1: def pdf_get_bound_document(obj):
           r"""Class-aware wrapper for `::pdf_get_bound_document()`."""
>>>>>>     return _mupdf.pdf_get_bound_document(obj)
       
    1: def pdf_get_doc_event_callback_data(doc):
           r"""Class-aware wrapper for `::pdf_get_doc_event_callback_data()`."""
>>>>>>     return _mupdf.pdf_get_doc_event_callback_data(doc)
       
    1: def pdf_get_filespec_params(fs, out):
           r"""Class-aware wrapper for `::pdf_get_filespec_params()`."""
>>>>>>     return _mupdf.pdf_get_filespec_params(fs, out)
       
    1: def pdf_get_indirect_document(obj):
           r"""Class-aware wrapper for `::pdf_get_indirect_document()`."""
>>>>>>     return _mupdf.pdf_get_indirect_document(obj)
       
    1: def pdf_get_widget_editing_state(widget):
           r"""Class-aware wrapper for `::pdf_get_widget_editing_state()`."""
>>>>>>     return _mupdf.pdf_get_widget_editing_state(widget)
       
    1: def pdf_graft_mapped_object(map, obj):
           r"""Class-aware wrapper for `::pdf_graft_mapped_object()`."""
>>>>>>     return _mupdf.pdf_graft_mapped_object(map, obj)
       
    1: def pdf_graft_mapped_page(map, page_to, src, page_from):
           r"""Class-aware wrapper for `::pdf_graft_mapped_page()`."""
>>>>>>     return _mupdf.pdf_graft_mapped_page(map, page_to, src, page_from)
       
    1: def pdf_graft_object(dst, obj):
           r"""Class-aware wrapper for `::pdf_graft_object()`."""
>>>>>>     return _mupdf.pdf_graft_object(dst, obj)
       
    1: def pdf_graft_page(dst, page_to, src, page_from):
           r"""Class-aware wrapper for `::pdf_graft_page()`."""
>>>>>>     return _mupdf.pdf_graft_page(dst, page_to, src, page_from)
       
    1: def pdf_has_permission(doc, p):
           r"""Class-aware wrapper for `::pdf_has_permission()`."""
>>>>>>     return _mupdf.pdf_has_permission(doc, p)
       
    1: def pdf_has_unsaved_changes(doc):
           r"""Class-aware wrapper for `::pdf_has_unsaved_changes()`."""
>>>>>>     return _mupdf.pdf_has_unsaved_changes(doc)
       
    1: def pdf_has_unsaved_sigs(doc):
           r"""Class-aware wrapper for `::pdf_has_unsaved_sigs()`."""
>>>>>>     return _mupdf.pdf_has_unsaved_sigs(doc)
       
    1: def pdf_incremental_change_since_signing_widget(widget):
           r"""Class-aware wrapper for `::pdf_incremental_change_since_signing_widget()`."""
>>>>>>     return _mupdf.pdf_incremental_change_since_signing_widget(widget)
       
    1: def pdf_insert_colorspace_resource(doc, key, obj):
           r"""Class-aware wrapper for `::pdf_insert_colorspace_resource()`."""
>>>>>>     return _mupdf.pdf_insert_colorspace_resource(doc, key, obj)
       
    1: def pdf_insert_font_resource(doc, key, obj):
           r"""Class-aware wrapper for `::pdf_insert_font_resource()`."""
>>>>>>     return _mupdf.pdf_insert_font_resource(doc, key, obj)
       
    1: def pdf_insert_page(doc, at, page):
           r"""Class-aware wrapper for `::pdf_insert_page()`."""
>>>>>>     return _mupdf.pdf_insert_page(doc, at, page)
       
    1: def pdf_intent_from_name(obj):
           r"""Class-aware wrapper for `::pdf_intent_from_name()`."""
>>>>>>     return _mupdf.pdf_intent_from_name(obj)
       
    1: def pdf_intent_from_string(str):
           r"""Class-aware wrapper for `::pdf_intent_from_string()`."""
>>>>>>     return _mupdf.pdf_intent_from_string(str)
       
    1: def pdf_invalidate_xfa(doc):
           r"""Class-aware wrapper for `::pdf_invalidate_xfa()`."""
>>>>>>     return _mupdf.pdf_invalidate_xfa(doc)
       
    1: def pdf_is_array(obj):
           r"""Class-aware wrapper for `::pdf_is_array()`."""
>>>>>>     return _mupdf.pdf_is_array(obj)
       
    1: def pdf_is_bool(obj):
           r"""Class-aware wrapper for `::pdf_is_bool()`."""
>>>>>>     return _mupdf.pdf_is_bool(obj)
       
    1: def pdf_is_dict(obj):
           r"""Class-aware wrapper for `::pdf_is_dict()`."""
>>>>>>     return _mupdf.pdf_is_dict(obj)
       
    1: def pdf_is_embedded_file(fs):
           r"""Class-aware wrapper for `::pdf_is_embedded_file()`."""
>>>>>>     return _mupdf.pdf_is_embedded_file(fs)
       
    1: def pdf_is_field_locked(locked, name):
           r"""Class-aware wrapper for `::pdf_is_field_locked()`."""
>>>>>>     return _mupdf.pdf_is_field_locked(locked, name)
       
    1: def pdf_is_filespec(fs):
           r"""Class-aware wrapper for `::pdf_is_filespec()`."""
>>>>>>     return _mupdf.pdf_is_filespec(fs)
       
    1: def pdf_is_image_stream(obj):
           r"""Class-aware wrapper for `::pdf_is_image_stream()`."""
>>>>>>     return _mupdf.pdf_is_image_stream(obj)
       
    1: def pdf_is_indirect(obj):
           r"""Class-aware wrapper for `::pdf_is_indirect()`."""
>>>>>>     return _mupdf.pdf_is_indirect(obj)
       
    1: def pdf_is_int(obj):
           r"""Class-aware wrapper for `::pdf_is_int()`."""
>>>>>>     return _mupdf.pdf_is_int(obj)
       
    1: def pdf_is_jpx_image(dict):
           r"""Class-aware wrapper for `::pdf_is_jpx_image()`."""
>>>>>>     return _mupdf.pdf_is_jpx_image(dict)
       
    1: def pdf_is_local_object(doc, obj):
           r"""Class-aware wrapper for `::pdf_is_local_object()`."""
>>>>>>     return _mupdf.pdf_is_local_object(doc, obj)
       
    1: def pdf_is_name(obj):
           r"""Class-aware wrapper for `::pdf_is_name()`."""
>>>>>>     return _mupdf.pdf_is_name(obj)
       
    1: def pdf_is_null(obj):
           r"""Class-aware wrapper for `::pdf_is_null()`."""
>>>>>>     return _mupdf.pdf_is_null(obj)
       
    1: def pdf_is_number(obj):
           r"""Class-aware wrapper for `::pdf_is_number()`."""
>>>>>>     return _mupdf.pdf_is_number(obj)
       
    1: def pdf_is_ocg_hidden(doc, rdb, usage, ocg):
           r"""Class-aware wrapper for `::pdf_is_ocg_hidden()`."""
>>>>>>     return _mupdf.pdf_is_ocg_hidden(doc, rdb, usage, ocg)
       
    1: def pdf_is_real(obj):
           r"""Class-aware wrapper for `::pdf_is_real()`."""
>>>>>>     return _mupdf.pdf_is_real(obj)
       
    1: def pdf_is_stream(obj):
           r"""Class-aware wrapper for `::pdf_is_stream()`."""
>>>>>>     return _mupdf.pdf_is_stream(obj)
       
    1: def pdf_is_string(obj):
           r"""Class-aware wrapper for `::pdf_is_string()`."""
>>>>>>     return _mupdf.pdf_is_string(obj)
       
    1: def pdf_is_tint_colorspace(cs):
           r"""Class-aware wrapper for `::pdf_is_tint_colorspace()`."""
>>>>>>     return _mupdf.pdf_is_tint_colorspace(cs)
       
    1: def pdf_js_event_init(js, target, value, willCommit):
           r"""Class-aware wrapper for `::pdf_js_event_init()`."""
>>>>>>     return _mupdf.pdf_js_event_init(js, target, value, willCommit)
       
    1: def pdf_js_event_init_keystroke(js, target, evt):
           r"""Class-aware wrapper for `::pdf_js_event_init_keystroke()`."""
>>>>>>     return _mupdf.pdf_js_event_init_keystroke(js, target, evt)
       
    1: def pdf_js_event_result(js):
           r"""Class-aware wrapper for `::pdf_js_event_result()`."""
>>>>>>     return _mupdf.pdf_js_event_result(js)
       
    1: def pdf_js_event_result_keystroke(js, evt):
           r"""Class-aware wrapper for `::pdf_js_event_result_keystroke()`."""
>>>>>>     return _mupdf.pdf_js_event_result_keystroke(js, evt)
       
    1: def pdf_js_event_result_validate(js, newvalue):
           r"""
           Class-aware wrapper for `::pdf_js_event_result_validate()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_js_event_result_validate(::pdf_js *js)` => `(int, char *newvalue)`
           """
>>>>>>     return _mupdf.pdf_js_event_result_validate(js, newvalue)
       
    1: def pdf_js_event_value(js):
           r"""Class-aware wrapper for `::pdf_js_event_value()`."""
>>>>>>     return _mupdf.pdf_js_event_value(js)
       
    1: def pdf_js_execute(js, name, code, result):
           r"""
           Class-aware wrapper for `::pdf_js_execute()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_js_execute(::pdf_js *js, const char *name, const char *code)` => char *result
           """
>>>>>>     return _mupdf.pdf_js_execute(js, name, code, result)
       
    1: def pdf_js_set_console(doc, console, user):
           r"""Class-aware wrapper for `::pdf_js_set_console()`."""
>>>>>>     return _mupdf.pdf_js_set_console(doc, console, user)
       
    1: def pdf_js_supported(doc):
           r"""Class-aware wrapper for `::pdf_js_supported()`."""
>>>>>>     return _mupdf.pdf_js_supported(doc)
       
    1: def pdf_label_object(g, num, callback, arg):
           r"""Class-aware wrapper for `::pdf_label_object()`."""
>>>>>>     return _mupdf.pdf_label_object(g, num, callback, arg)
       
    1: def pdf_layer_config_info(doc, config_num, info):
           r"""Class-aware wrapper for `::pdf_layer_config_info()`."""
>>>>>>     return _mupdf.pdf_layer_config_info(doc, config_num, info)
       
    1: def pdf_layer_config_ui_info(doc, ui, info):
           r"""Class-aware wrapper for `::pdf_layer_config_ui_info()`."""
>>>>>>     return _mupdf.pdf_layer_config_ui_info(doc, ui, info)
       
    1: def pdf_layer_is_enabled(doc, layer):
           r"""Class-aware wrapper for `::pdf_layer_is_enabled()`."""
>>>>>>     return _mupdf.pdf_layer_is_enabled(doc, layer)
       
    1: def pdf_layer_name(doc, layer):
           r"""Class-aware wrapper for `::pdf_layer_name()`."""
>>>>>>     return _mupdf.pdf_layer_name(doc, layer)
       
    1: def pdf_layout_fit_text(font, lang, str, bounds):
           r"""Class-aware wrapper for `::pdf_layout_fit_text()`."""
>>>>>>     return _mupdf.pdf_layout_fit_text(font, lang, str, bounds)
       
    1: def pdf_lex(f, lexbuf):
           r"""Class-aware wrapper for `::pdf_lex()`."""
>>>>>>     return _mupdf.pdf_lex(f, lexbuf)
       
    1: def pdf_lex_no_string(f, lexbuf):
           r"""Class-aware wrapper for `::pdf_lex_no_string()`."""
>>>>>>     return _mupdf.pdf_lex_no_string(f, lexbuf)
       
    1: def pdf_lexbuf_fin(lexbuf):
           r"""Class-aware wrapper for `::pdf_lexbuf_fin()`."""
>>>>>>     return _mupdf.pdf_lexbuf_fin(lexbuf)
       
    1: def pdf_lexbuf_grow(lexbuf):
           r"""Class-aware wrapper for `::pdf_lexbuf_grow()`."""
>>>>>>     return _mupdf.pdf_lexbuf_grow(lexbuf)
       
    1: def pdf_lexbuf_init(lexbuf, size):
           r"""Class-aware wrapper for `::pdf_lexbuf_init()`."""
>>>>>>     return _mupdf.pdf_lexbuf_init(lexbuf, size)
       
    1: def pdf_line_ending_from_name(end):
           r"""Class-aware wrapper for `::pdf_line_ending_from_name()`."""
>>>>>>     return _mupdf.pdf_line_ending_from_name(end)
       
    1: def pdf_line_ending_from_string(end):
           r"""Class-aware wrapper for `::pdf_line_ending_from_string()`."""
>>>>>>     return _mupdf.pdf_line_ending_from_string(end)
       
    1: def pdf_load_builtin_cmap(name):
           r"""Class-aware wrapper for `::pdf_load_builtin_cmap()`."""
>>>>>>     return _mupdf.pdf_load_builtin_cmap(name)
       
    1: def pdf_load_cmap(file):
           r"""Class-aware wrapper for `::pdf_load_cmap()`."""
>>>>>>     return _mupdf.pdf_load_cmap(file)
       
    1: def pdf_load_colorspace(obj):
           r"""Class-aware wrapper for `::pdf_load_colorspace()`."""
>>>>>>     return _mupdf.pdf_load_colorspace(obj)
       
    1: def pdf_load_compressed_inline_image(doc, dict, length, cstm, indexed, image):
           r"""Class-aware wrapper for `::pdf_load_compressed_inline_image()`."""
>>>>>>     return _mupdf.pdf_load_compressed_inline_image(doc, dict, length, cstm, indexed, image)
       
    1: def pdf_load_compressed_stream(doc, num, worst_case):
           r"""Class-aware wrapper for `::pdf_load_compressed_stream()`."""
>>>>>>     return _mupdf.pdf_load_compressed_stream(doc, num, worst_case)
       
    1: def pdf_load_default_colorspaces(doc, page):
           r"""Class-aware wrapper for `::pdf_load_default_colorspaces()`."""
>>>>>>     return _mupdf.pdf_load_default_colorspaces(doc, page)
       
    1: def pdf_load_embedded_cmap(doc, ref):
           r"""Class-aware wrapper for `::pdf_load_embedded_cmap()`."""
>>>>>>     return _mupdf.pdf_load_embedded_cmap(doc, ref)
       
    1: def pdf_load_embedded_file_contents(fs):
           r"""Class-aware wrapper for `::pdf_load_embedded_file_contents()`."""
>>>>>>     return _mupdf.pdf_load_embedded_file_contents(fs)
       
    1: def pdf_load_encoding(estrings, encoding):
           r"""
           Class-aware wrapper for `::pdf_load_encoding()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_load_encoding(const char *encoding)` => const char *estrings
           """
>>>>>>     return _mupdf.pdf_load_encoding(estrings, encoding)
       
    1: def pdf_load_field_name(field):
           r"""Class-aware wrapper for `::pdf_load_field_name()`."""
>>>>>>     return _mupdf.pdf_load_field_name(field)
       
    1: def pdf_load_field_name2(field):
           r"""Alternative to `pdf_load_field_name()` that returns a std::string."""
>>>>>>     return _mupdf.pdf_load_field_name2(field)
       
    1: def pdf_load_function(ref, _in, out):
           r"""Class-aware wrapper for `::pdf_load_function()`."""
>>>>>>     return _mupdf.pdf_load_function(ref, _in, out)
       
    1: def pdf_load_image(doc, obj):
           r"""Class-aware wrapper for `::pdf_load_image()`."""
>>>>>>     return _mupdf.pdf_load_image(doc, obj)
       
    1: def pdf_load_inline_image(doc, rdb, dict, file):
           r"""Class-aware wrapper for `::pdf_load_inline_image()`."""
>>>>>>     return _mupdf.pdf_load_inline_image(doc, rdb, dict, file)
       
    1: def pdf_load_journal(doc, filename):
           r"""Class-aware wrapper for `::pdf_load_journal()`."""
>>>>>>     return _mupdf.pdf_load_journal(doc, filename)
       
    1: def pdf_load_link_annots(arg_0, arg_1, annots, pagenum, page_ctm):
           r"""Class-aware wrapper for `::pdf_load_link_annots()`."""
>>>>>>     return _mupdf.pdf_load_link_annots(arg_0, arg_1, annots, pagenum, page_ctm)
       
    1: def pdf_load_links(page):
           r"""Class-aware wrapper for `::pdf_load_links()`."""
>>>>>>     return _mupdf.pdf_load_links(page)
       
    1: def pdf_load_name_tree(doc, which):
           r"""Class-aware wrapper for `::pdf_load_name_tree()`."""
>>>>>>     return _mupdf.pdf_load_name_tree(doc, which)
       
    1: def pdf_load_object(doc, num):
           r"""
           Class-aware wrapper for `::pdf_load_object()`.
               Load a given object.
       
               This can cause xref reorganisations (solidifications etc) due to
               repairs, so all held pdf_xref_entries should be considered
               invalid after this call (other than the returned one).
           """
>>>>>>     return _mupdf.pdf_load_object(doc, num)
       
    1: def pdf_load_outline(doc):
           r"""Class-aware wrapper for `::pdf_load_outline()`."""
>>>>>>     return _mupdf.pdf_load_outline(doc)
       
    1: def pdf_load_page(doc, number):
           r"""Class-aware wrapper for `::pdf_load_page()`."""
>>>>>>     return _mupdf.pdf_load_page(doc, number)
       
    1: def pdf_load_page_imp(doc, chapter, number):
           r"""Class-aware wrapper for `::pdf_load_page_imp()`."""
>>>>>>     return _mupdf.pdf_load_page_imp(doc, chapter, number)
       
    1: def pdf_load_page_tree(doc):
           r"""Class-aware wrapper for `::pdf_load_page_tree()`."""
>>>>>>     return _mupdf.pdf_load_page_tree(doc)
       
    1: def pdf_load_pattern(doc, obj):
           r"""Class-aware wrapper for `::pdf_load_pattern()`."""
>>>>>>     return _mupdf.pdf_load_pattern(doc, obj)
       
    1: def pdf_load_raw_stream(ref):
           r"""Class-aware wrapper for `::pdf_load_raw_stream()`."""
>>>>>>     return _mupdf.pdf_load_raw_stream(ref)
       
    1: def pdf_load_raw_stream_number(doc, num):
           r"""Class-aware wrapper for `::pdf_load_raw_stream_number()`."""
>>>>>>     return _mupdf.pdf_load_raw_stream_number(doc, num)
       
    1: def pdf_load_shading(doc, obj):
           r"""Class-aware wrapper for `::pdf_load_shading()`."""
>>>>>>     return _mupdf.pdf_load_shading(doc, obj)
       
    1: def pdf_load_stream(ref):
           r"""Class-aware wrapper for `::pdf_load_stream()`."""
>>>>>>     return _mupdf.pdf_load_stream(ref)
       
    1: def pdf_load_stream_number(doc, num):
           r"""Class-aware wrapper for `::pdf_load_stream_number()`."""
>>>>>>     return _mupdf.pdf_load_stream_number(doc, num)
       
    1: def pdf_load_stream_or_string_as_utf8(src):
           r"""Class-aware wrapper for `::pdf_load_stream_or_string_as_utf8()`."""
>>>>>>     return _mupdf.pdf_load_stream_or_string_as_utf8(src)
       
    1: def pdf_load_system_cmap(name):
           r"""Class-aware wrapper for `::pdf_load_system_cmap()`."""
>>>>>>     return _mupdf.pdf_load_system_cmap(name)
       
    1: def pdf_load_to_unicode(doc, font, strings, collection, cmapstm):
           r"""
           Class-aware wrapper for `::pdf_load_to_unicode()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_load_to_unicode(::pdf_document *doc, ::pdf_font_desc *font, char *collection, ::pdf_obj *cmapstm)` => const char *strings
           """
>>>>>>     return _mupdf.pdf_load_to_unicode(doc, font, strings, collection, cmapstm)
       
    1: def pdf_load_type3_glyphs(doc, fontdesc):
           r"""Class-aware wrapper for `::pdf_load_type3_glyphs()`."""
>>>>>>     return _mupdf.pdf_load_type3_glyphs(doc, fontdesc)
       
    1: def pdf_load_unencrypted_object(doc, num):
           r"""Class-aware wrapper for `::pdf_load_unencrypted_object()`."""
>>>>>>     return _mupdf.pdf_load_unencrypted_object(doc, num)
       
    1: def pdf_lookup_cmap(cmap, cpt):
           r"""Class-aware wrapper for `::pdf_lookup_cmap()`."""
>>>>>>     return _mupdf.pdf_lookup_cmap(cmap, cpt)
       
    1: def pdf_lookup_cmap_full(cmap, cpt, out):
           r"""
           Class-aware wrapper for `::pdf_lookup_cmap_full()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_lookup_cmap_full(::pdf_cmap *cmap, unsigned int cpt)` => `(int, int out)`
           """
>>>>>>     return _mupdf.pdf_lookup_cmap_full(cmap, cpt, out)
       
    1: def pdf_lookup_dest(doc, needle):
           r"""Class-aware wrapper for `::pdf_lookup_dest()`."""
>>>>>>     return _mupdf.pdf_lookup_dest(doc, needle)
       
    1: def pdf_lookup_field(form, name):
           r"""Class-aware wrapper for `::pdf_lookup_field()`."""
>>>>>>     return _mupdf.pdf_lookup_field(form, name)
       
    1: def pdf_lookup_metadata(doc, key, ptr, size):
           r"""Class-aware wrapper for `::pdf_lookup_metadata()`."""
>>>>>>     return _mupdf.pdf_lookup_metadata(doc, key, ptr, size)
       
    1: def pdf_lookup_metadata2(doc, key):
           r"""
           Class-aware wrapper for `::pdf_lookup_metadata2()`.
           C++ alternative to `pdf_lookup_metadata()` that returns a `std::string`
           or calls `fz_throw()` if not found.
           """
>>>>>>     return _mupdf.pdf_lookup_metadata2(doc, key)
       
    1: def pdf_lookup_name(doc, which, needle):
           r"""Class-aware wrapper for `::pdf_lookup_name()`."""
>>>>>>     return _mupdf.pdf_lookup_name(doc, which, needle)
       
    1: def pdf_lookup_number(root, needle):
           r"""Class-aware wrapper for `::pdf_lookup_number()`."""
>>>>>>     return _mupdf.pdf_lookup_number(root, needle)
       
    1: def pdf_lookup_page_loc(doc, needle, parentp, indexp):
           r"""
           Class-aware wrapper for `::pdf_lookup_page_loc()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_lookup_page_loc(::pdf_document *doc, int needle, ::pdf_obj **parentp)` => `(pdf_obj *, int indexp)`
           """
>>>>>>     return _mupdf.pdf_lookup_page_loc(doc, needle, parentp, indexp)
       
    1: def pdf_lookup_page_number(doc, pageobj):
           r"""Class-aware wrapper for `::pdf_lookup_page_number()`."""
>>>>>>     return _mupdf.pdf_lookup_page_number(doc, pageobj)
       
    1: def pdf_lookup_page_obj(doc, needle):
           r"""Class-aware wrapper for `::pdf_lookup_page_obj()`."""
>>>>>>     return _mupdf.pdf_lookup_page_obj(doc, needle)
       
    1: def pdf_lookup_resource(stack, type, name):
           r"""Class-aware wrapper for `::pdf_lookup_resource()`."""
>>>>>>     return _mupdf.pdf_lookup_resource(stack, type, name)
       
    1: def pdf_lookup_substitute_font(mono, serif, bold, italic, len):
           r"""
           Class-aware wrapper for `::pdf_lookup_substitute_font()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_lookup_substitute_font(int mono, int serif, int bold, int italic)` => `(const unsigned char *, int len)`
           """
>>>>>>     return _mupdf.pdf_lookup_substitute_font(mono, serif, bold, italic, len)
       
    1: def pdf_map_one_to_many(cmap, one, many, len):
           r"""
           Class-aware wrapper for `::pdf_map_one_to_many()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_map_one_to_many(::pdf_cmap *cmap, unsigned int one, size_t len)` => int many
           """
>>>>>>     return _mupdf.pdf_map_one_to_many(cmap, one, many, len)
       
    1: def pdf_map_range_to_range(cmap, srclo, srchi, dstlo):
           r"""Class-aware wrapper for `::pdf_map_range_to_range()`."""
>>>>>>     return _mupdf.pdf_map_range_to_range(cmap, srclo, srchi, dstlo)
       
    1: def pdf_mark_bits_reset(marks):
           r"""Class-aware wrapper for `::pdf_mark_bits_reset()`."""
>>>>>>     return _mupdf.pdf_mark_bits_reset(marks)
       
    1: def pdf_mark_bits_set(marks, obj):
           r"""Class-aware wrapper for `::pdf_mark_bits_set()`."""
>>>>>>     return _mupdf.pdf_mark_bits_set(marks, obj)
       
    1: def pdf_mark_list_check(list, obj):
           r"""Class-aware wrapper for `::pdf_mark_list_check()`."""
>>>>>>     return _mupdf.pdf_mark_list_check(list, obj)
       
    1: def pdf_mark_list_free(list):
           r"""Class-aware wrapper for `::pdf_mark_list_free()`."""
>>>>>>     return _mupdf.pdf_mark_list_free(list)
       
    1: def pdf_mark_list_init(list):
           r"""Class-aware wrapper for `::pdf_mark_list_init()`."""
>>>>>>     return _mupdf.pdf_mark_list_init(list)
       
    1: def pdf_mark_list_pop(list):
           r"""Class-aware wrapper for `::pdf_mark_list_pop()`."""
>>>>>>     return _mupdf.pdf_mark_list_pop(list)
       
    1: def pdf_mark_list_push(list, obj):
           r"""Class-aware wrapper for `::pdf_mark_list_push()`."""
>>>>>>     return _mupdf.pdf_mark_list_push(list, obj)
       
    1: def pdf_mark_obj(obj):
           r"""Class-aware wrapper for `::pdf_mark_obj()`."""
>>>>>>     return _mupdf.pdf_mark_obj(obj)
       
    1: def pdf_mark_xref(doc):
           r"""Class-aware wrapper for `::pdf_mark_xref()`."""
>>>>>>     return _mupdf.pdf_mark_xref(doc)
       
    1: def pdf_metadata(doc):
           r"""Class-aware wrapper for `::pdf_metadata()`."""
>>>>>>     return _mupdf.pdf_metadata(doc)
       
    1: def pdf_minimize_document(doc):
           r"""Class-aware wrapper for `::pdf_minimize_document()`."""
>>>>>>     return _mupdf.pdf_minimize_document(doc)
       
    1: def pdf_name_eq(a, b):
           r"""Class-aware wrapper for `::pdf_name_eq()`."""
>>>>>>     return _mupdf.pdf_name_eq(a, b)
       
    1: def pdf_name_from_intent(intent):
           r"""Class-aware wrapper for `::pdf_name_from_intent()`."""
>>>>>>     return _mupdf.pdf_name_from_intent(intent)
       
    1: def pdf_name_from_line_ending(end):
           r"""Class-aware wrapper for `::pdf_name_from_line_ending()`."""
>>>>>>     return _mupdf.pdf_name_from_line_ending(end)
       
    1: def pdf_needs_password(doc):
           r"""Class-aware wrapper for `::pdf_needs_password()`."""
>>>>>>     return _mupdf.pdf_needs_password(doc)
       
    1: def pdf_new_action_from_link(doc, uri):
           r"""Class-aware wrapper for `::pdf_new_action_from_link()`."""
>>>>>>     return _mupdf.pdf_new_action_from_link(doc, uri)
       
    1: def pdf_new_array(doc, initialcap):
           r"""Class-aware wrapper for `::pdf_new_array()`."""
>>>>>>     return _mupdf.pdf_new_array(doc, initialcap)
       
    1: def pdf_new_buffer_processor(buffer, ahxencode, newlines):
           r"""Class-aware wrapper for `::pdf_new_buffer_processor()`."""
>>>>>>     return _mupdf.pdf_new_buffer_processor(buffer, ahxencode, newlines)
       
    1: def pdf_new_cmap():
           r"""Class-aware wrapper for `::pdf_new_cmap()`."""
>>>>>>     return _mupdf.pdf_new_cmap()
       
    1: def pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts):
           r"""Class-aware wrapper for `::pdf_new_color_filter()`."""
>>>>>>     return _mupdf.pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts)
       
    1: def pdf_new_date(doc, time):
           r"""Class-aware wrapper for `::pdf_new_date()`."""
>>>>>>     return _mupdf.pdf_new_date(doc, time)
       
    1: def pdf_new_dest_from_link(doc, uri, is_remote):
           r"""Class-aware wrapper for `::pdf_new_dest_from_link()`."""
>>>>>>     return _mupdf.pdf_new_dest_from_link(doc, uri, is_remote)
       
    1: def pdf_new_dict(doc, initialcap):
           r"""Class-aware wrapper for `::pdf_new_dict()`."""
>>>>>>     return _mupdf.pdf_new_dict(doc, initialcap)
       
    1: def pdf_new_display_list_from_annot(annot):
           r"""Class-aware wrapper for `::pdf_new_display_list_from_annot()`."""
>>>>>>     return _mupdf.pdf_new_display_list_from_annot(annot)
       
    1: def pdf_new_graft_map(dst):
           r"""Class-aware wrapper for `::pdf_new_graft_map()`."""
>>>>>>     return _mupdf.pdf_new_graft_map(dst)
       
    1: def pdf_new_identity_cmap(wmode, bytes):
           r"""Class-aware wrapper for `::pdf_new_identity_cmap()`."""
>>>>>>     return _mupdf.pdf_new_identity_cmap(wmode, bytes)
       
    1: def pdf_new_indirect(doc, num, gen):
           r"""Class-aware wrapper for `::pdf_new_indirect()`."""
>>>>>>     return _mupdf.pdf_new_indirect(doc, num, gen)
       
    1: def pdf_new_int(i):
           r"""Class-aware wrapper for `::pdf_new_int()`."""
>>>>>>     return _mupdf.pdf_new_int(i)
       
    1: def pdf_new_link(page, rect, uri, obj):
           r"""Class-aware wrapper for `::pdf_new_link()`."""
>>>>>>     return _mupdf.pdf_new_link(page, rect, uri, obj)
       
    1: def pdf_new_matrix(doc, mtx):
           r"""Class-aware wrapper for `::pdf_new_matrix()`."""
>>>>>>     return _mupdf.pdf_new_matrix(doc, mtx)
       
    1: def pdf_new_name(str):
           r"""Class-aware wrapper for `::pdf_new_name()`."""
>>>>>>     return _mupdf.pdf_new_name(str)
       
    1: def pdf_new_output_processor(out, ahxencode, newlines):
           r"""Class-aware wrapper for `::pdf_new_output_processor()`."""
>>>>>>     return _mupdf.pdf_new_output_processor(out, ahxencode, newlines)
       
    1: def pdf_new_pdf_device(doc, topctm, resources, contents):
           r"""Class-aware wrapper for `::pdf_new_pdf_device()`."""
>>>>>>     return _mupdf.pdf_new_pdf_device(doc, topctm, resources, contents)
       
    1: def pdf_new_pixmap_from_annot(annot, ctm, cs, seps, alpha):
           r"""Class-aware wrapper for `::pdf_new_pixmap_from_annot()`."""
>>>>>>     return _mupdf.pdf_new_pixmap_from_annot(annot, ctm, cs, seps, alpha)
       
    1: def pdf_new_pixmap_from_page_contents_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
           r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_separations_and_usage()`."""
>>>>>>     return _mupdf.pdf_new_pixmap_from_page_contents_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)
       
    1: def pdf_new_pixmap_from_page_contents_with_usage(page, ctm, cs, alpha, usage, box):
           r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_usage()`."""
>>>>>>     return _mupdf.pdf_new_pixmap_from_page_contents_with_usage(page, ctm, cs, alpha, usage, box)
       
    1: def pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
           r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`."""
>>>>>>     return _mupdf.pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)
       
    1: def pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box):
           r"""Class-aware wrapper for `::pdf_new_pixmap_from_page_with_usage()`."""
>>>>>>     return _mupdf.pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box)
       
    1: def pdf_new_point(doc, point):
           r"""Class-aware wrapper for `::pdf_new_point()`."""
>>>>>>     return _mupdf.pdf_new_point(doc, point)
       
    1: def pdf_new_processor(size):
           r"""Class-aware wrapper for `::pdf_new_processor()`."""
>>>>>>     return _mupdf.pdf_new_processor(size)
       
    1: def pdf_new_real(f):
           r"""Class-aware wrapper for `::pdf_new_real()`."""
>>>>>>     return _mupdf.pdf_new_real(f)
       
    1: def pdf_new_rect(doc, rect):
           r"""Class-aware wrapper for `::pdf_new_rect()`."""
>>>>>>     return _mupdf.pdf_new_rect(doc, rect)
       
    1: def pdf_new_run_processor(doc, dev, ctm, struct_parent, usage, gstate, default_cs, cookie, fill_gstate, stroke_gstate):
           r"""Class-aware wrapper for `::pdf_new_run_processor()`."""
>>>>>>     return _mupdf.pdf_new_run_processor(doc, dev, ctm, struct_parent, usage, gstate, default_cs, cookie, fill_gstate, stroke_gstate)
       
    1: def pdf_new_sanitize_filter(doc, chain, struct_parents, transform, options, sopts):
           r"""Class-aware wrapper for `::pdf_new_sanitize_filter()`."""
>>>>>>     return _mupdf.pdf_new_sanitize_filter(doc, chain, struct_parents, transform, options, sopts)
       
    1: def pdf_new_string(str, len):
           r"""Class-aware wrapper for `::pdf_new_string()`."""
>>>>>>     return _mupdf.pdf_new_string(str, len)
       
    1: def pdf_new_text_string(s):
           r"""Class-aware wrapper for `::pdf_new_text_string()`."""
>>>>>>     return _mupdf.pdf_new_text_string(s)
       
    1: def pdf_new_uri_from_explicit_dest(dest):
           r"""Class-aware wrapper for `::pdf_new_uri_from_explicit_dest()`."""
>>>>>>     return _mupdf.pdf_new_uri_from_explicit_dest(dest)
       
    1: def pdf_new_uri_from_path_and_explicit_dest(path, dest):
           r"""Class-aware wrapper for `::pdf_new_uri_from_path_and_explicit_dest()`."""
>>>>>>     return _mupdf.pdf_new_uri_from_path_and_explicit_dest(path, dest)
       
    1: def pdf_new_uri_from_path_and_named_dest(path, name):
           r"""Class-aware wrapper for `::pdf_new_uri_from_path_and_named_dest()`."""
>>>>>>     return _mupdf.pdf_new_uri_from_path_and_named_dest(path, name)
       
    1: def pdf_new_utf8_from_pdf_stream_obj(src):
           r"""Class-aware wrapper for `::pdf_new_utf8_from_pdf_stream_obj()`."""
>>>>>>     return _mupdf.pdf_new_utf8_from_pdf_stream_obj(src)
       
    1: def pdf_new_utf8_from_pdf_string(srcptr, srclen):
           r"""Class-aware wrapper for `::pdf_new_utf8_from_pdf_string()`."""
>>>>>>     return _mupdf.pdf_new_utf8_from_pdf_string(srcptr, srclen)
       
    1: def pdf_new_utf8_from_pdf_string_obj(src):
           r"""Class-aware wrapper for `::pdf_new_utf8_from_pdf_string_obj()`."""
>>>>>>     return _mupdf.pdf_new_utf8_from_pdf_string_obj(src)
       
    1: def pdf_new_xobject(doc, bbox, matrix, res, buffer):
           r"""Class-aware wrapper for `::pdf_new_xobject()`."""
>>>>>>     return _mupdf.pdf_new_xobject(doc, bbox, matrix, res, buffer)
       
    1: def pdf_next_annot(annot):
           r"""Class-aware wrapper for `::pdf_next_annot()`."""
>>>>>>     return _mupdf.pdf_next_annot(annot)
       
    1: def pdf_next_widget(previous):
           r"""Class-aware wrapper for `::pdf_next_widget()`."""
>>>>>>     return _mupdf.pdf_next_widget(previous)
       
    1: def pdf_nuke_annots(page):
           r"""Class-aware wrapper for `::pdf_nuke_annots()`."""
>>>>>>     return _mupdf.pdf_nuke_annots(page)
       
    1: def pdf_nuke_links(page):
           r"""Class-aware wrapper for `::pdf_nuke_links()`."""
>>>>>>     return _mupdf.pdf_nuke_links(page)
       
    1: def pdf_nuke_page(page):
           r"""Class-aware wrapper for `::pdf_nuke_page()`."""
>>>>>>     return _mupdf.pdf_nuke_page(page)
       
    1: def pdf_obj_is_dirty(obj):
           r"""Class-aware wrapper for `::pdf_obj_is_dirty()`."""
>>>>>>     return _mupdf.pdf_obj_is_dirty(obj)
       
    1: def pdf_obj_is_incremental(obj):
           r"""Class-aware wrapper for `::pdf_obj_is_incremental()`."""
>>>>>>     return _mupdf.pdf_obj_is_incremental(obj)
       
    1: def pdf_obj_marked(obj):
           r"""Class-aware wrapper for `::pdf_obj_marked()`."""
>>>>>>     return _mupdf.pdf_obj_marked(obj)
       
    1: def pdf_obj_memo(obj, bit, memo):
           r"""
           Class-aware wrapper for `::pdf_obj_memo()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_obj_memo(::pdf_obj *obj, int bit)` => `(int, int memo)`
           """
>>>>>>     return _mupdf.pdf_obj_memo(obj, bit, memo)
       
    1: def pdf_obj_num_is_stream(doc, num):
           r"""Class-aware wrapper for `::pdf_obj_num_is_stream()`."""
>>>>>>     return _mupdf.pdf_obj_num_is_stream(doc, num)
       
    1: def pdf_obj_parent_num(obj):
           r"""Class-aware wrapper for `::pdf_obj_parent_num()`."""
>>>>>>     return _mupdf.pdf_obj_parent_num(obj)
       
    1: def pdf_obj_refs(ref):
           r"""Class-aware wrapper for `::pdf_obj_refs()`."""
>>>>>>     return _mupdf.pdf_obj_refs(ref)
       
    1: def pdf_objcmp(a, b):
           r"""Class-aware wrapper for `::pdf_objcmp()`."""
>>>>>>     return _mupdf.pdf_objcmp(a, b)
       
    1: def pdf_objcmp_deep(a, b):
           r"""Class-aware wrapper for `::pdf_objcmp_deep()`."""
>>>>>>     return _mupdf.pdf_objcmp_deep(a, b)
       
    1: def pdf_objcmp_resolve(a, b):
           r"""Class-aware wrapper for `::pdf_objcmp_resolve()`."""
>>>>>>     return _mupdf.pdf_objcmp_resolve(a, b)
       
    1: def pdf_object_exists(doc, num):
           r"""Class-aware wrapper for `::pdf_object_exists()`."""
>>>>>>     return _mupdf.pdf_object_exists(doc, num)
       
    1: def pdf_open_contents_stream(doc, obj):
           r"""Class-aware wrapper for `::pdf_open_contents_stream()`."""
>>>>>>     return _mupdf.pdf_open_contents_stream(doc, obj)
       
    1: def pdf_open_crypt(chain, crypt, num, gen):
           r"""Class-aware wrapper for `::pdf_open_crypt()`."""
>>>>>>     return _mupdf.pdf_open_crypt(chain, crypt, num, gen)
       
    1: def pdf_open_crypt_with_filter(chain, crypt, name, num, gen):
           r"""Class-aware wrapper for `::pdf_open_crypt_with_filter()`."""
>>>>>>     return _mupdf.pdf_open_crypt_with_filter(chain, crypt, name, num, gen)
       
    1: def pdf_open_document(filename):
           r"""Class-aware wrapper for `::pdf_open_document()`."""
>>>>>>     return _mupdf.pdf_open_document(filename)
       
    1: def pdf_open_document_with_stream(file):
           r"""Class-aware wrapper for `::pdf_open_document_with_stream()`."""
>>>>>>     return _mupdf.pdf_open_document_with_stream(file)
       
    1: def pdf_open_inline_stream(doc, stmobj, length, chain, params):
           r"""Class-aware wrapper for `::pdf_open_inline_stream()`."""
>>>>>>     return _mupdf.pdf_open_inline_stream(doc, stmobj, length, chain, params)
       
    1: def pdf_open_raw_stream(ref):
           r"""Class-aware wrapper for `::pdf_open_raw_stream()`."""
>>>>>>     return _mupdf.pdf_open_raw_stream(ref)
       
    1: def pdf_open_raw_stream_number(doc, num):
           r"""Class-aware wrapper for `::pdf_open_raw_stream_number()`."""
>>>>>>     return _mupdf.pdf_open_raw_stream_number(doc, num)
       
    1: def pdf_open_stream(ref):
           r"""Class-aware wrapper for `::pdf_open_stream()`."""
>>>>>>     return _mupdf.pdf_open_stream(ref)
       
    1: def pdf_open_stream_number(doc, num):
           r"""Class-aware wrapper for `::pdf_open_stream_number()`."""
>>>>>>     return _mupdf.pdf_open_stream_number(doc, num)
       
    1: def pdf_open_stream_with_offset(doc, num, dict, stm_ofs):
           r"""Class-aware wrapper for `::pdf_open_stream_with_offset()`."""
>>>>>>     return _mupdf.pdf_open_stream_with_offset(doc, num, dict, stm_ofs)
       
    1: def pdf_page_associated_file(page, idx):
           r"""Class-aware wrapper for `::pdf_page_associated_file()`."""
>>>>>>     return _mupdf.pdf_page_associated_file(page, idx)
       
    1: def pdf_page_contents(page):
           r"""Class-aware wrapper for `::pdf_page_contents()`."""
>>>>>>     return _mupdf.pdf_page_contents(page)
       
    1: def pdf_page_event_close(page):
           r"""Class-aware wrapper for `::pdf_page_event_close()`."""
>>>>>>     return _mupdf.pdf_page_event_close(page)
       
    1: def pdf_page_event_open(page):
           r"""Class-aware wrapper for `::pdf_page_event_open()`."""
>>>>>>     return _mupdf.pdf_page_event_open(page)
       
    1: def pdf_page_from_fz_page(ptr):
           r"""Class-aware wrapper for `::pdf_page_from_fz_page()`."""
>>>>>>     return _mupdf.pdf_page_from_fz_page(ptr)
       
    1: def pdf_page_group(page):
           r"""Class-aware wrapper for `::pdf_page_group()`."""
>>>>>>     return _mupdf.pdf_page_group(page)
       
    1: def pdf_page_has_transparency(page):
           r"""Class-aware wrapper for `::pdf_page_has_transparency()`."""
>>>>>>     return _mupdf.pdf_page_has_transparency(page)
       
    1: def pdf_page_label(doc, page, buf, size):
           r"""Class-aware wrapper for `::pdf_page_label()`."""
>>>>>>     return _mupdf.pdf_page_label(doc, page, buf, size)
       
    1: def pdf_page_label_imp(doc, chapter, page, buf, size):
           r"""Class-aware wrapper for `::pdf_page_label_imp()`."""
>>>>>>     return _mupdf.pdf_page_label_imp(doc, chapter, page, buf, size)
       
    1: def pdf_page_obj_transform(pageobj, outbox, outctm):
           r"""Class-aware wrapper for `::pdf_page_obj_transform()`."""
>>>>>>     return _mupdf.pdf_page_obj_transform(pageobj, outbox, outctm)
       
    1: def pdf_page_obj_transform_box(pageobj, outbox, out, box):
           r"""Class-aware wrapper for `::pdf_page_obj_transform_box()`."""
>>>>>>     return _mupdf.pdf_page_obj_transform_box(pageobj, outbox, out, box)
       
    1: def pdf_page_presentation(page, transition, duration):
           r"""
           Class-aware wrapper for `::pdf_page_presentation()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_page_presentation(::pdf_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`
           """
>>>>>>     return _mupdf.pdf_page_presentation(page, transition, duration)
       
    1: def pdf_page_resources(page):
           r"""Class-aware wrapper for `::pdf_page_resources()`."""
>>>>>>     return _mupdf.pdf_page_resources(page)
       
    1: def pdf_page_separations(page):
           r"""Class-aware wrapper for `::pdf_page_separations()`."""
>>>>>>     return _mupdf.pdf_page_separations(page)
       
    1: def pdf_page_transform(page, mediabox, ctm):
           r"""Class-aware wrapper for `::pdf_page_transform()`."""
>>>>>>     return _mupdf.pdf_page_transform(page, mediabox, ctm)
       
    1: def pdf_page_transform_box(page, mediabox, ctm, box):
           r"""Class-aware wrapper for `::pdf_page_transform_box()`."""
>>>>>>     return _mupdf.pdf_page_transform_box(page, mediabox, ctm, box)
       
    1: def pdf_page_write(doc, mediabox, presources, pcontents):
           r"""
           Class-aware wrapper for `::pdf_page_write()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_page_write(::pdf_document *doc, ::fz_rect mediabox, ::pdf_obj **presources, ::fz_buffer **pcontents)` => `(fz_device *)`
           """
>>>>>>     return _mupdf.pdf_page_write(doc, mediabox, presources, pcontents)
       
    1: def pdf_parse_array(doc, f, buf):
           r"""Class-aware wrapper for `::pdf_parse_array()`."""
>>>>>>     return _mupdf.pdf_parse_array(doc, f, buf)
       
    1: def pdf_parse_date(s):
           r"""Class-aware wrapper for `::pdf_parse_date()`."""
>>>>>>     return _mupdf.pdf_parse_date(s)
       
    1: def pdf_parse_default_appearance(da, font, size, n, color):
           r"""
           Class-aware wrapper for `::pdf_parse_default_appearance()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_parse_default_appearance(const char *da, float color[4])` => `(const char *font, float size, int n)`
           """
>>>>>>     return _mupdf.pdf_parse_default_appearance(da, font, size, n, color)
       
    1: def pdf_parse_default_appearance_unmapped(da, font_name, font_name_len, size, n, color):
           r"""
           Class-aware wrapper for `::pdf_parse_default_appearance_unmapped()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_parse_default_appearance_unmapped(const char *da, char *font_name, int font_name_len, float color[4])` => `(float size, int n)`
           """
>>>>>>     return _mupdf.pdf_parse_default_appearance_unmapped(da, font_name, font_name_len, size, n, color)
       
    1: def pdf_parse_dict(doc, f, buf):
           r"""Class-aware wrapper for `::pdf_parse_dict()`."""
>>>>>>     return _mupdf.pdf_parse_dict(doc, f, buf)
       
    1: def pdf_parse_ind_obj(doc, f, num, gen, stm_ofs, try_repair):
           r"""
           Class-aware wrapper for `::pdf_parse_ind_obj()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_parse_ind_obj(::pdf_document *doc, ::fz_stream *f)` => `(pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair)`
           """
>>>>>>     return _mupdf.pdf_parse_ind_obj(doc, f, num, gen, stm_ofs, try_repair)
       
    1: def pdf_parse_journal_obj(doc, stm, onum, ostm, newobj):
           r"""
           Class-aware wrapper for `::pdf_parse_journal_obj()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_parse_journal_obj(::pdf_document *doc, ::fz_stream *stm, ::fz_buffer **ostm)` => `(pdf_obj *, int onum, int newobj)`
           """
>>>>>>     return _mupdf.pdf_parse_journal_obj(doc, stm, onum, ostm, newobj)
       
    1: def pdf_parse_stm_obj(doc, f, buf):
           r"""Class-aware wrapper for `::pdf_parse_stm_obj()`."""
>>>>>>     return _mupdf.pdf_parse_stm_obj(doc, f, buf)
       
    1: def pdf_parse_write_options(opts, args):
           r"""Class-aware wrapper for `::pdf_parse_write_options()`."""
>>>>>>     return _mupdf.pdf_parse_write_options(opts, args)
       
    1: def pdf_pin_document(obj):
           r"""Class-aware wrapper for `::pdf_pin_document()`."""
>>>>>>     return _mupdf.pdf_pin_document(obj)
       
    1: def pdf_preview_signature_as_display_list(w, h, lang, signer, appearance_flags, graphic, reason, location):
           r"""Class-aware wrapper for `::pdf_preview_signature_as_display_list()`."""
>>>>>>     return _mupdf.pdf_preview_signature_as_display_list(w, h, lang, signer, appearance_flags, graphic, reason, location)
       
    1: def pdf_preview_signature_as_pixmap(w, h, lang, signer, appearance_flags, graphic, reason, location):
           r"""Class-aware wrapper for `::pdf_preview_signature_as_pixmap()`."""
>>>>>>     return _mupdf.pdf_preview_signature_as_pixmap(w, h, lang, signer, appearance_flags, graphic, reason, location)
       
    1: def pdf_print_crypt(out, crypt):
           r"""Class-aware wrapper for `::pdf_print_crypt()`."""
>>>>>>     return _mupdf.pdf_print_crypt(out, crypt)
       
    1: def pdf_print_default_appearance(buf, nbuf, font, size, n, color):
           r"""Class-aware wrapper for `::pdf_print_default_appearance()`."""
>>>>>>     return _mupdf.pdf_print_default_appearance(buf, nbuf, font, size, n, color)
       
    1: def pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen, sep):
           r"""
           Class-aware wrapper for `::pdf_print_encrypted_obj()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_print_encrypted_obj(::fz_output *out, ::pdf_obj *obj, int tight, int ascii, ::pdf_crypt *crypt, int num, int gen)` => int sep
           """
>>>>>>     return _mupdf.pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen, sep)
       
    1: def pdf_print_font(out, fontdesc):
           r"""Class-aware wrapper for `::pdf_print_font()`."""
>>>>>>     return _mupdf.pdf_print_font(out, fontdesc)
       
    1: def pdf_print_obj(out, obj, tight, ascii):
           r"""Class-aware wrapper for `::pdf_print_obj()`."""
>>>>>>     return _mupdf.pdf_print_obj(out, obj, tight, ascii)
       
    1: def pdf_process_annot(proc, annot, cookie):
           r"""Class-aware wrapper for `::pdf_process_annot()`."""
>>>>>>     return _mupdf.pdf_process_annot(proc, annot, cookie)
       
    1: def pdf_process_contents(proc, doc, res, stm, cookie, out_res):
           r"""
           Class-aware wrapper for `::pdf_process_contents()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_process_contents(::pdf_processor *proc, ::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, ::fz_cookie *cookie, ::pdf_obj **out_res)` =>
           """
>>>>>>     return _mupdf.pdf_process_contents(proc, doc, res, stm, cookie, out_res)
       
    1: def pdf_process_glyph(proc, doc, resources, contents):
           r"""Class-aware wrapper for `::pdf_process_glyph()`."""
>>>>>>     return _mupdf.pdf_process_glyph(proc, doc, resources, contents)
       
    1: def pdf_process_raw_contents(proc, doc, stmobj, cookie):
           r"""Class-aware wrapper for `::pdf_process_raw_contents()`."""
>>>>>>     return _mupdf.pdf_process_raw_contents(proc, doc, stmobj, cookie)
       
    1: def pdf_processor_pop_resources(proc):
           r"""Class-aware wrapper for `::pdf_processor_pop_resources()`."""
>>>>>>     return _mupdf.pdf_processor_pop_resources(proc)
       
    1: def pdf_processor_push_resources(proc, res):
           r"""Class-aware wrapper for `::pdf_processor_push_resources()`."""
>>>>>>     return _mupdf.pdf_processor_push_resources(proc, res)
       
    1: def pdf_progressive_advance(doc, pagenum):
           r"""Class-aware wrapper for `::pdf_progressive_advance()`."""
>>>>>>     return _mupdf.pdf_progressive_advance(doc, pagenum)
       
    1: def pdf_purge_local_resources(doc):
           r"""Class-aware wrapper for `::pdf_purge_local_resources()`."""
>>>>>>     return _mupdf.pdf_purge_local_resources(doc)
       
    1: def pdf_purge_locals_from_store(doc):
           r"""Class-aware wrapper for `::pdf_purge_locals_from_store()`."""
>>>>>>     return _mupdf.pdf_purge_locals_from_store(doc)
       
    1: def pdf_purge_object_from_store(doc, num):
           r"""Class-aware wrapper for `::pdf_purge_object_from_store()`."""
>>>>>>     return _mupdf.pdf_purge_object_from_store(doc, num)
       
    1: def pdf_read_journal(doc, stm):
           r"""Class-aware wrapper for `::pdf_read_journal()`."""
>>>>>>     return _mupdf.pdf_read_journal(doc, stm)
       
    1: def pdf_rearrange_pages(doc, count, pages, structure):
           r"""Class-aware wrapper for `::pdf_rearrange_pages()`."""
>>>>>>     return _mupdf.pdf_rearrange_pages(doc, count, pages, structure)
       
    1: def pdf_rearrange_pages2(doc, pages, structure):
           r"""Class-aware wrapper for `::pdf_rearrange_pages2()`.   Swig-friendly wrapper for pdf_rearrange_pages()."""
>>>>>>     return _mupdf.pdf_rearrange_pages2(doc, pages, structure)
       
    1: def pdf_recolor_page(doc, pagenum, opts):
           r"""Class-aware wrapper for `::pdf_recolor_page()`."""
>>>>>>     return _mupdf.pdf_recolor_page(doc, pagenum, opts)
       
    1: def pdf_recolor_shade(shade, reshade, opaque):
           r"""
           Class-aware wrapper for `::pdf_recolor_shade()`.
               Recolor a shade.
           """
>>>>>>     return _mupdf.pdf_recolor_shade(shade, reshade, opaque)
       
    1: def pdf_redact_page(doc, page, opts):
           r"""Class-aware wrapper for `::pdf_redact_page()`."""
>>>>>>     return _mupdf.pdf_redact_page(doc, page, opts)
       
    1: def pdf_redo(doc):
           r"""Class-aware wrapper for `::pdf_redo()`."""
>>>>>>     return _mupdf.pdf_redo(doc)
       
    1: def pdf_remove_item(drop, key):
           r"""Class-aware wrapper for `::pdf_remove_item()`."""
>>>>>>     return _mupdf.pdf_remove_item(drop, key)
       
    1: def pdf_remove_output_intents(doc):
           r"""Class-aware wrapper for `::pdf_remove_output_intents()`."""
>>>>>>     return _mupdf.pdf_remove_output_intents(doc)
       
    1: def pdf_repair_obj(doc, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root):
           r"""
           Class-aware wrapper for `::pdf_repair_obj()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_repair_obj(::pdf_document *doc, ::pdf_lexbuf *buf, ::pdf_obj **encrypt, ::pdf_obj **id, ::pdf_obj **page, ::pdf_obj **root)` => `(int, int64_t stmofsp, int64_t stmlenp, int64_t tmpofs)`
           """
>>>>>>     return _mupdf.pdf_repair_obj(doc, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root)
       
    1: def pdf_repair_xref(doc):
           r"""Class-aware wrapper for `::pdf_repair_xref()`."""
>>>>>>     return _mupdf.pdf_repair_xref(doc)
       
    1: def pdf_replace_xref(doc, entries, n):
           r"""Class-aware wrapper for `::pdf_replace_xref()`."""
>>>>>>     return _mupdf.pdf_replace_xref(doc, entries, n)
       
    1: def pdf_reset_form(doc, fields, exclude):
           r"""Class-aware wrapper for `::pdf_reset_form()`."""
>>>>>>     return _mupdf.pdf_reset_form(doc, fields, exclude)
       
    1: def pdf_reset_processor(proc):
           r"""Class-aware wrapper for `::pdf_reset_processor()`."""
>>>>>>     return _mupdf.pdf_reset_processor(proc)
       
    1: def pdf_resolve_indirect(ref):
           r"""
           Class-aware wrapper for `::pdf_resolve_indirect()`.
               Resolve an indirect object (or chain of objects).
       
               This can cause xref reorganisations (solidifications etc) due to
               repairs, so all held pdf_xref_entries should be considered
               invalid after this call (other than the returned one).
           """
>>>>>>     return _mupdf.pdf_resolve_indirect(ref)
       
    1: def pdf_resolve_indirect_chain(ref):
           r"""Class-aware wrapper for `::pdf_resolve_indirect_chain()`."""
>>>>>>     return _mupdf.pdf_resolve_indirect_chain(ref)
       
    1: def pdf_resolve_link(doc, uri, xp, yp):
           r"""
           Class-aware wrapper for `::pdf_resolve_link()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_resolve_link(::pdf_document *doc, const char *uri)` => `(int, float xp, float yp)`
           """
>>>>>>     return _mupdf.pdf_resolve_link(doc, uri, xp, yp)
       
    1: def pdf_rewrite_images(doc, opts):
           r"""Class-aware wrapper for `::pdf_rewrite_images()`."""
>>>>>>     return _mupdf.pdf_rewrite_images(doc, opts)
       
    1: def pdf_run_annot(annot, dev, ctm, cookie):
           r"""Class-aware wrapper for `::pdf_run_annot()`."""
>>>>>>     return _mupdf.pdf_run_annot(annot, dev, ctm, cookie)
       
    1: def pdf_run_document_structure(doc, dev, cookie):
           r"""Class-aware wrapper for `::pdf_run_document_structure()`."""
>>>>>>     return _mupdf.pdf_run_document_structure(doc, dev, cookie)
       
    1: def pdf_run_glyph(doc, resources, contents, dev, ctm, gstate, default_cs, fill_gstate, stroke_gstate):
           r"""Class-aware wrapper for `::pdf_run_glyph()`."""
>>>>>>     return _mupdf.pdf_run_glyph(doc, resources, contents, dev, ctm, gstate, default_cs, fill_gstate, stroke_gstate)
       
    1: def pdf_run_page(page, dev, ctm, cookie):
           r"""Class-aware wrapper for `::pdf_run_page()`."""
>>>>>>     return _mupdf.pdf_run_page(page, dev, ctm, cookie)
       
    1: def pdf_run_page_annots(page, dev, ctm, cookie):
           r"""Class-aware wrapper for `::pdf_run_page_annots()`."""
>>>>>>     return _mupdf.pdf_run_page_annots(page, dev, ctm, cookie)
       
    1: def pdf_run_page_annots_with_usage(page, dev, ctm, usage, cookie):
           r"""Class-aware wrapper for `::pdf_run_page_annots_with_usage()`."""
>>>>>>     return _mupdf.pdf_run_page_annots_with_usage(page, dev, ctm, usage, cookie)
       
    1: def pdf_run_page_contents(page, dev, ctm, cookie):
           r"""Class-aware wrapper for `::pdf_run_page_contents()`."""
>>>>>>     return _mupdf.pdf_run_page_contents(page, dev, ctm, cookie)
       
    1: def pdf_run_page_contents_with_usage(page, dev, ctm, usage, cookie):
           r"""Class-aware wrapper for `::pdf_run_page_contents_with_usage()`."""
>>>>>>     return _mupdf.pdf_run_page_contents_with_usage(page, dev, ctm, usage, cookie)
       
    1: def pdf_run_page_widgets(page, dev, ctm, cookie):
           r"""Class-aware wrapper for `::pdf_run_page_widgets()`."""
>>>>>>     return _mupdf.pdf_run_page_widgets(page, dev, ctm, cookie)
       
    1: def pdf_run_page_widgets_with_usage(page, dev, ctm, usage, cookie):
           r"""Class-aware wrapper for `::pdf_run_page_widgets_with_usage()`."""
>>>>>>     return _mupdf.pdf_run_page_widgets_with_usage(page, dev, ctm, usage, cookie)
       
    1: def pdf_run_page_with_usage(page, dev, ctm, usage, cookie):
           r"""Class-aware wrapper for `::pdf_run_page_with_usage()`."""
>>>>>>     return _mupdf.pdf_run_page_with_usage(page, dev, ctm, usage, cookie)
       
    1: def pdf_sample_shade_function(samples, n, funcs, func, t0, t1):
           r"""
           Class-aware wrapper for `::pdf_sample_shade_function()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_sample_shade_function(int n, int funcs, ::pdf_function **func, float t0, float t1)` => `(float samples)`
           """
>>>>>>     return _mupdf.pdf_sample_shade_function(samples, n, funcs, func, t0, t1)
       
    1: def pdf_save_document(doc, filename, opts):
           r"""Class-aware wrapper for `::pdf_save_document()`."""
>>>>>>     return _mupdf.pdf_save_document(doc, filename, opts)
       
    1: def pdf_save_journal(doc, filename):
           r"""Class-aware wrapper for `::pdf_save_journal()`."""
>>>>>>     return _mupdf.pdf_save_journal(doc, filename)
       
    1: def pdf_save_snapshot(doc, filename):
           r"""Class-aware wrapper for `::pdf_save_snapshot()`."""
>>>>>>     return _mupdf.pdf_save_snapshot(doc, filename)
       
    1: def pdf_select_layer_config(doc, config_num):
           r"""Class-aware wrapper for `::pdf_select_layer_config()`."""
>>>>>>     return _mupdf.pdf_select_layer_config(doc, config_num)
       
    1: def pdf_select_layer_config_ui(doc, ui):
           r"""Class-aware wrapper for `::pdf_select_layer_config_ui()`."""
>>>>>>     return _mupdf.pdf_select_layer_config_ui(doc, ui)
       
    1: def pdf_serialise_journal(doc, out):
           r"""Class-aware wrapper for `::pdf_serialise_journal()`."""
>>>>>>     return _mupdf.pdf_serialise_journal(doc, out)
       
    1: def pdf_set_annot_active(annot, active):
           r"""Class-aware wrapper for `::pdf_set_annot_active()`."""
>>>>>>     return _mupdf.pdf_set_annot_active(annot, active)
       
    1: def pdf_set_annot_appearance(annot, appearance, state, ctm, bbox, res, contents):
           r"""Class-aware wrapper for `::pdf_set_annot_appearance()`."""
>>>>>>     return _mupdf.pdf_set_annot_appearance(annot, appearance, state, ctm, bbox, res, contents)
       
    1: def pdf_set_annot_appearance_from_display_list(annot, appearance, state, ctm, list):
           r"""Class-aware wrapper for `::pdf_set_annot_appearance_from_display_list()`."""
>>>>>>     return _mupdf.pdf_set_annot_appearance_from_display_list(annot, appearance, state, ctm, list)
       
    1: def pdf_set_annot_author(annot, author):
           r"""Class-aware wrapper for `::pdf_set_annot_author()`."""
>>>>>>     return _mupdf.pdf_set_annot_author(annot, author)
       
    1: def pdf_set_annot_border(annot, width):
           r"""Class-aware wrapper for `::pdf_set_annot_border()`."""
>>>>>>     return _mupdf.pdf_set_annot_border(annot, width)
       
    1: def pdf_set_annot_border_effect(annot, effect):
           r"""Class-aware wrapper for `::pdf_set_annot_border_effect()`."""
>>>>>>     return _mupdf.pdf_set_annot_border_effect(annot, effect)
       
    1: def pdf_set_annot_border_effect_intensity(annot, intensity):
           r"""Class-aware wrapper for `::pdf_set_annot_border_effect_intensity()`."""
>>>>>>     return _mupdf.pdf_set_annot_border_effect_intensity(annot, intensity)
       
    1: def pdf_set_annot_border_style(annot, style):
           r"""Class-aware wrapper for `::pdf_set_annot_border_style()`."""
>>>>>>     return _mupdf.pdf_set_annot_border_style(annot, style)
       
    1: def pdf_set_annot_border_width(annot, width):
           r"""Class-aware wrapper for `::pdf_set_annot_border_width()`."""
>>>>>>     return _mupdf.pdf_set_annot_border_width(annot, width)
       
    1: def pdf_set_annot_callout_line(annot, callout, n):
           r"""Class-aware wrapper for `::pdf_set_annot_callout_line()`."""
>>>>>>     return _mupdf.pdf_set_annot_callout_line(annot, callout, n)
       
    1: def pdf_set_annot_callout_line2(annot, callout):
           r"""Class-aware wrapper for `::pdf_set_annot_callout_line2()`.   SWIG-friendly wrapper for pdf_set_annot_callout_line()."""
>>>>>>     return _mupdf.pdf_set_annot_callout_line2(annot, callout)
       
    1: def pdf_set_annot_callout_point(annot, p):
           r"""Class-aware wrapper for `::pdf_set_annot_callout_point()`."""
>>>>>>     return _mupdf.pdf_set_annot_callout_point(annot, p)
       
    1: def pdf_set_annot_callout_style(annot, style):
           r"""Class-aware wrapper for `::pdf_set_annot_callout_style()`."""
>>>>>>     return _mupdf.pdf_set_annot_callout_style(annot, style)
       
    1: def pdf_set_annot_color(annot, n, color):
           r"""Class-aware wrapper for `::pdf_set_annot_color()`."""
>>>>>>     return _mupdf.pdf_set_annot_color(annot, n, color)
       
    1: def pdf_set_annot_contents(annot, text):
           r"""Class-aware wrapper for `::pdf_set_annot_contents()`."""
>>>>>>     return _mupdf.pdf_set_annot_contents(annot, text)
       
    1: def pdf_set_annot_creation_date(annot, time):
           r"""Class-aware wrapper for `::pdf_set_annot_creation_date()`."""
>>>>>>     return _mupdf.pdf_set_annot_creation_date(annot, time)
       
    1: def pdf_set_annot_default_appearance(annot, font, size, n, color):
           r"""Class-aware wrapper for `::pdf_set_annot_default_appearance()`."""
>>>>>>     return _mupdf.pdf_set_annot_default_appearance(annot, font, size, n, color)
       
    1: def pdf_set_annot_field_value(doc, widget, text, ignore_trigger_events):
           r"""Class-aware wrapper for `::pdf_set_annot_field_value()`."""
>>>>>>     return _mupdf.pdf_set_annot_field_value(doc, widget, text, ignore_trigger_events)
       
    1: def pdf_set_annot_filespec(annot, obj):
           r"""Class-aware wrapper for `::pdf_set_annot_filespec()`."""
>>>>>>     return _mupdf.pdf_set_annot_filespec(annot, obj)
       
    1: def pdf_set_annot_flags(annot, flags):
           r"""Class-aware wrapper for `::pdf_set_annot_flags()`."""
>>>>>>     return _mupdf.pdf_set_annot_flags(annot, flags)
       
    1: def pdf_set_annot_hidden_for_editing(annot, hidden):
           r"""Class-aware wrapper for `::pdf_set_annot_hidden_for_editing()`."""
>>>>>>     return _mupdf.pdf_set_annot_hidden_for_editing(annot, hidden)
       
    1: def pdf_set_annot_hot(annot, hot):
           r"""Class-aware wrapper for `::pdf_set_annot_hot()`."""
>>>>>>     return _mupdf.pdf_set_annot_hot(annot, hot)
       
    1: def pdf_set_annot_icon_name(annot, name):
           r"""Class-aware wrapper for `::pdf_set_annot_icon_name()`."""
>>>>>>     return _mupdf.pdf_set_annot_icon_name(annot, name)
       
    1: def pdf_set_annot_ink_list(annot, n, count, v):
           r"""Class-aware wrapper for `::pdf_set_annot_ink_list()`."""
>>>>>>     return _mupdf.pdf_set_annot_ink_list(annot, n, count, v)
       
    1: def pdf_set_annot_intent(annot, it):
           r"""Class-aware wrapper for `::pdf_set_annot_intent()`."""
>>>>>>     return _mupdf.pdf_set_annot_intent(annot, it)
       
    1: def pdf_set_annot_interior_color(annot, n, color):
           r"""Class-aware wrapper for `::pdf_set_annot_interior_color()`."""
>>>>>>     return _mupdf.pdf_set_annot_interior_color(annot, n, color)
       
    1: def pdf_set_annot_is_open(annot, is_open):
           r"""Class-aware wrapper for `::pdf_set_annot_is_open()`."""
>>>>>>     return _mupdf.pdf_set_annot_is_open(annot, is_open)
       
    1: def pdf_set_annot_language(annot, lang):
           r"""Class-aware wrapper for `::pdf_set_annot_language()`."""
>>>>>>     return _mupdf.pdf_set_annot_language(annot, lang)
       
    1: def pdf_set_annot_line(annot, a, b):
           r"""Class-aware wrapper for `::pdf_set_annot_line()`."""
>>>>>>     return _mupdf.pdf_set_annot_line(annot, a, b)
       
    1: def pdf_set_annot_line_caption(annot, cap):
           r"""Class-aware wrapper for `::pdf_set_annot_line_caption()`."""
>>>>>>     return _mupdf.pdf_set_annot_line_caption(annot, cap)
       
    1: def pdf_set_annot_line_caption_offset(annot, offset):
           r"""Class-aware wrapper for `::pdf_set_annot_line_caption_offset()`."""
>>>>>>     return _mupdf.pdf_set_annot_line_caption_offset(annot, offset)
       
    1: def pdf_set_annot_line_end_style(annot, e):
           r"""Class-aware wrapper for `::pdf_set_annot_line_end_style()`."""
>>>>>>     return _mupdf.pdf_set_annot_line_end_style(annot, e)
       
    1: def pdf_set_annot_line_ending_styles(annot, start_style, end_style):
           r"""Class-aware wrapper for `::pdf_set_annot_line_ending_styles()`."""
>>>>>>     return _mupdf.pdf_set_annot_line_ending_styles(annot, start_style, end_style)
       
    1: def pdf_set_annot_line_leader(annot, ll):
           r"""Class-aware wrapper for `::pdf_set_annot_line_leader()`."""
>>>>>>     return _mupdf.pdf_set_annot_line_leader(annot, ll)
       
    1: def pdf_set_annot_line_leader_extension(annot, lle):
           r"""Class-aware wrapper for `::pdf_set_annot_line_leader_extension()`."""
>>>>>>     return _mupdf.pdf_set_annot_line_leader_extension(annot, lle)
       
    1: def pdf_set_annot_line_leader_offset(annot, llo):
           r"""Class-aware wrapper for `::pdf_set_annot_line_leader_offset()`."""
>>>>>>     return _mupdf.pdf_set_annot_line_leader_offset(annot, llo)
       
    1: def pdf_set_annot_line_start_style(annot, s):
           r"""Class-aware wrapper for `::pdf_set_annot_line_start_style()`."""
>>>>>>     return _mupdf.pdf_set_annot_line_start_style(annot, s)
       
    1: def pdf_set_annot_modification_date(annot, time):
           r"""Class-aware wrapper for `::pdf_set_annot_modification_date()`."""
>>>>>>     return _mupdf.pdf_set_annot_modification_date(annot, time)
       
    1: def pdf_set_annot_opacity(annot, opacity):
           r"""Class-aware wrapper for `::pdf_set_annot_opacity()`."""
>>>>>>     return _mupdf.pdf_set_annot_opacity(annot, opacity)
       
    1: def pdf_set_annot_popup(annot, rect):
           r"""Class-aware wrapper for `::pdf_set_annot_popup()`."""
>>>>>>     return _mupdf.pdf_set_annot_popup(annot, rect)
       
    1: def pdf_set_annot_quad_points(annot, n, qv):
           r"""Class-aware wrapper for `::pdf_set_annot_quad_points()`."""
>>>>>>     return _mupdf.pdf_set_annot_quad_points(annot, n, qv)
       
    1: def pdf_set_annot_quadding(annot, q):
           r"""Class-aware wrapper for `::pdf_set_annot_quadding()`."""
>>>>>>     return _mupdf.pdf_set_annot_quadding(annot, q)
       
    1: def pdf_set_annot_rect(annot, rect):
           r"""Class-aware wrapper for `::pdf_set_annot_rect()`."""
>>>>>>     return _mupdf.pdf_set_annot_rect(annot, rect)
       
    1: def pdf_set_annot_resynthesised(annot):
           r"""Class-aware wrapper for `::pdf_set_annot_resynthesised()`."""
>>>>>>     return _mupdf.pdf_set_annot_resynthesised(annot)
       
    1: def pdf_set_annot_rich_contents(annot, plain, rich):
           r"""Class-aware wrapper for `::pdf_set_annot_rich_contents()`."""
>>>>>>     return _mupdf.pdf_set_annot_rich_contents(annot, plain, rich)
       
    1: def pdf_set_annot_rich_defaults(annot, style):
           r"""Class-aware wrapper for `::pdf_set_annot_rich_defaults()`."""
>>>>>>     return _mupdf.pdf_set_annot_rich_defaults(annot, style)
       
    1: def pdf_set_annot_stamp_image(annot, image):
           r"""Class-aware wrapper for `::pdf_set_annot_stamp_image()`."""
>>>>>>     return _mupdf.pdf_set_annot_stamp_image(annot, image)
       
    1: def pdf_set_annot_stamp_image_obj(annot, ref):
           r"""Class-aware wrapper for `::pdf_set_annot_stamp_image_obj()`."""
>>>>>>     return _mupdf.pdf_set_annot_stamp_image_obj(annot, ref)
       
    1: def pdf_set_annot_vertex(annot, i, p):
           r"""Class-aware wrapper for `::pdf_set_annot_vertex()`."""
>>>>>>     return _mupdf.pdf_set_annot_vertex(annot, i, p)
       
    1: def pdf_set_annot_vertices(annot, n, v):
           r"""Class-aware wrapper for `::pdf_set_annot_vertices()`."""
>>>>>>     return _mupdf.pdf_set_annot_vertices(annot, n, v)
       
    1: def pdf_set_choice_field_value(widget, value):
           r"""Class-aware wrapper for `::pdf_set_choice_field_value()`."""
>>>>>>     return _mupdf.pdf_set_choice_field_value(widget, value)
       
    1: def pdf_set_cmap_wmode(cmap, wmode):
           r"""Class-aware wrapper for `::pdf_set_cmap_wmode()`."""
>>>>>>     return _mupdf.pdf_set_cmap_wmode(cmap, wmode)
       
    1: def pdf_set_default_hmtx(font, w):
           r"""Class-aware wrapper for `::pdf_set_default_hmtx()`."""
>>>>>>     return _mupdf.pdf_set_default_hmtx(font, w)
       
    1: def pdf_set_default_vmtx(font, y, w):
           r"""Class-aware wrapper for `::pdf_set_default_vmtx()`."""
>>>>>>     return _mupdf.pdf_set_default_vmtx(font, y, w)
       
    1: def pdf_set_doc_event_callback(doc, event_cb, free_event_data_cb, data):
           r"""Class-aware wrapper for `::pdf_set_doc_event_callback()`."""
>>>>>>     return _mupdf.pdf_set_doc_event_callback(doc, event_cb, free_event_data_cb, data)
       
    1: def pdf_set_document_language(doc, lang):
           r"""Class-aware wrapper for `::pdf_set_document_language()`."""
>>>>>>     return _mupdf.pdf_set_document_language(doc, lang)
       
    1: def pdf_set_field_value(doc, field, text, ignore_trigger_events):
           r"""Class-aware wrapper for `::pdf_set_field_value()`."""
>>>>>>     return _mupdf.pdf_set_field_value(doc, field, text, ignore_trigger_events)
       
    1: def pdf_set_font_wmode(font, wmode):
           r"""Class-aware wrapper for `::pdf_set_font_wmode()`."""
>>>>>>     return _mupdf.pdf_set_font_wmode(font, wmode)
       
    1: def pdf_set_int(obj, i):
           r"""Class-aware wrapper for `::pdf_set_int()`."""
>>>>>>     return _mupdf.pdf_set_int(obj, i)
       
    1: def pdf_set_layer_config_as_default(doc):
           r"""Class-aware wrapper for `::pdf_set_layer_config_as_default()`."""
>>>>>>     return _mupdf.pdf_set_layer_config_as_default(doc)
       
    1: def pdf_set_obj_memo(obj, bit, memo):
           r"""Class-aware wrapper for `::pdf_set_obj_memo()`."""
>>>>>>     return _mupdf.pdf_set_obj_memo(obj, bit, memo)
       
    1: def pdf_set_obj_parent(obj, num):
           r"""Class-aware wrapper for `::pdf_set_obj_parent()`."""
>>>>>>     return _mupdf.pdf_set_obj_parent(obj, num)
       
    1: def pdf_set_page_box(page, box, rect):
           r"""Class-aware wrapper for `::pdf_set_page_box()`."""
>>>>>>     return _mupdf.pdf_set_page_box(page, box, rect)
       
    1: def pdf_set_page_labels(doc, index, style, prefix, start):
           r"""Class-aware wrapper for `::pdf_set_page_labels()`."""
>>>>>>     return _mupdf.pdf_set_page_labels(doc, index, style, prefix, start)
       
    1: def pdf_set_populating_xref_trailer(doc, trailer):
           r"""Class-aware wrapper for `::pdf_set_populating_xref_trailer()`."""
>>>>>>     return _mupdf.pdf_set_populating_xref_trailer(doc, trailer)
       
    1: def pdf_set_str_len(obj, newlen):
           r"""Class-aware wrapper for `::pdf_set_str_len()`."""
>>>>>>     return _mupdf.pdf_set_str_len(obj, newlen)
       
    1: def pdf_set_text_field_value(widget, value):
           r"""Class-aware wrapper for `::pdf_set_text_field_value()`."""
>>>>>>     return _mupdf.pdf_set_text_field_value(widget, value)
       
    1: def pdf_set_usecmap(cmap, usecmap):
           r"""Class-aware wrapper for `::pdf_set_usecmap()`."""
>>>>>>     return _mupdf.pdf_set_usecmap(cmap, usecmap)
       
    1: def pdf_set_widget_editing_state(widget, editing):
           r"""Class-aware wrapper for `::pdf_set_widget_editing_state()`."""
>>>>>>     return _mupdf.pdf_set_widget_editing_state(widget, editing)
       
    1: def pdf_sign_signature(widget, signer, appearance_flags, graphic, reason, location):
           r"""Class-aware wrapper for `::pdf_sign_signature()`."""
>>>>>>     return _mupdf.pdf_sign_signature(widget, signer, appearance_flags, graphic, reason, location)
       
    1: def pdf_sign_signature_with_appearance(widget, signer, date, disp_list):
           r"""Class-aware wrapper for `::pdf_sign_signature_with_appearance()`."""
>>>>>>     return _mupdf.pdf_sign_signature_with_appearance(widget, signer, date, disp_list)
       
    1: def pdf_signature_appearance_signed(rect, lang, img, left_text, right_text, include_logo):
           r"""Class-aware wrapper for `::pdf_signature_appearance_signed()`."""
>>>>>>     return _mupdf.pdf_signature_appearance_signed(rect, lang, img, left_text, right_text, include_logo)
       
    1: def pdf_signature_appearance_unsigned(rect, lang):
           r"""Class-aware wrapper for `::pdf_signature_appearance_unsigned()`."""
>>>>>>     return _mupdf.pdf_signature_appearance_unsigned(rect, lang)
       
    1: def pdf_signature_byte_range(doc, signature, byte_range):
           r"""Class-aware wrapper for `::pdf_signature_byte_range()`."""
>>>>>>     return _mupdf.pdf_signature_byte_range(doc, signature, byte_range)
       
    1: def pdf_signature_contents(doc, signature, contents):
           r"""
           Class-aware wrapper for `::pdf_signature_contents()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_signature_contents(::pdf_document *doc, ::pdf_obj *signature)` => `(size_t, char *contents)`
           """
>>>>>>     return _mupdf.pdf_signature_contents(doc, signature, contents)
       
    1: def pdf_signature_drop_distinguished_name(name):
           r"""Class-aware wrapper for `::pdf_signature_drop_distinguished_name()`."""
>>>>>>     return _mupdf.pdf_signature_drop_distinguished_name(name)
       
    1: def pdf_signature_error_description(err):
           r"""Class-aware wrapper for `::pdf_signature_error_description()`."""
>>>>>>     return _mupdf.pdf_signature_error_description(err)
       
    1: def pdf_signature_format_distinguished_name(name):
           r"""Class-aware wrapper for `::pdf_signature_format_distinguished_name()`."""
>>>>>>     return _mupdf.pdf_signature_format_distinguished_name(name)
       
    1: def pdf_signature_hash_bytes(doc, signature):
           r"""Class-aware wrapper for `::pdf_signature_hash_bytes()`."""
>>>>>>     return _mupdf.pdf_signature_hash_bytes(doc, signature)
       
    1: def pdf_signature_incremental_change_since_signing(doc, signature):
           r"""Class-aware wrapper for `::pdf_signature_incremental_change_since_signing()`."""
>>>>>>     return _mupdf.pdf_signature_incremental_change_since_signing(doc, signature)
       
    1: def pdf_signature_info(name, dn, reason, location, date, include_labels):
           r"""Class-aware wrapper for `::pdf_signature_info()`."""
>>>>>>     return _mupdf.pdf_signature_info(name, dn, reason, location, date, include_labels)
       
    1: def pdf_signature_is_signed(doc, field):
           r"""Class-aware wrapper for `::pdf_signature_is_signed()`."""
>>>>>>     return _mupdf.pdf_signature_is_signed(doc, field)
       
    1: def pdf_signature_set_value(doc, field, signer, stime):
           r"""Class-aware wrapper for `::pdf_signature_set_value()`."""
>>>>>>     return _mupdf.pdf_signature_set_value(doc, field, signer, stime)
       
    1: def pdf_sort_cmap(cmap):
           r"""Class-aware wrapper for `::pdf_sort_cmap()`."""
>>>>>>     return _mupdf.pdf_sort_cmap(cmap)
       
    1: def pdf_sort_dict(dict):
           r"""Class-aware wrapper for `::pdf_sort_dict()`."""
>>>>>>     return _mupdf.pdf_sort_dict(dict)
       
    1: def pdf_specifics(doc):
           r"""Class-aware wrapper for `::pdf_specifics()`."""
>>>>>>     return _mupdf.pdf_specifics(doc)
       
    1: def pdf_sprint_obj(buf, cap, len, obj, tight, ascii):
           r"""
           Class-aware wrapper for `::pdf_sprint_obj()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_sprint_obj(char *buf, size_t cap, ::pdf_obj *obj, int tight, int ascii)` => `(char *, size_t len)`
           """
>>>>>>     return _mupdf.pdf_sprint_obj(buf, cap, len, obj, tight, ascii)
       
    1: def pdf_store_item(key, val, itemsize):
           r"""Class-aware wrapper for `::pdf_store_item()`."""
>>>>>>     return _mupdf.pdf_store_item(key, val, itemsize)
       
    1: def pdf_string_from_annot_type(type):
           r"""Class-aware wrapper for `::pdf_string_from_annot_type()`."""
>>>>>>     return _mupdf.pdf_string_from_annot_type(type)
       
    1: def pdf_string_from_intent(intent):
           r"""Class-aware wrapper for `::pdf_string_from_intent()`."""
>>>>>>     return _mupdf.pdf_string_from_intent(intent)
       
    1: def pdf_string_from_line_ending(end):
           r"""Class-aware wrapper for `::pdf_string_from_line_ending()`."""
>>>>>>     return _mupdf.pdf_string_from_line_ending(end)
       
    1: def pdf_structure_type(role_map, tag):
           r"""Class-aware wrapper for `::pdf_structure_type()`."""
>>>>>>     return _mupdf.pdf_structure_type(role_map, tag)
       
    1: def pdf_subset_fonts(doc, pages_len, pages):
           r"""Class-aware wrapper for `::pdf_subset_fonts()`."""
>>>>>>     return _mupdf.pdf_subset_fonts(doc, pages_len, pages)
       
    1: def pdf_subset_fonts2(doc, pages):
           r"""Class-aware wrapper for `::pdf_subset_fonts2()`.   Swig-friendly wrapper for pdf_subset_fonts()."""
>>>>>>     return _mupdf.pdf_subset_fonts2(doc, pages)
       
    1: def pdf_sync_annots(page):
           r"""Class-aware wrapper for `::pdf_sync_annots()`."""
>>>>>>     return _mupdf.pdf_sync_annots(page)
       
    1: def pdf_sync_links(page):
           r"""Class-aware wrapper for `::pdf_sync_links()`."""
>>>>>>     return _mupdf.pdf_sync_links(page)
       
    1: def pdf_sync_open_pages(doc):
           r"""Class-aware wrapper for `::pdf_sync_open_pages()`."""
>>>>>>     return _mupdf.pdf_sync_open_pages(doc)
       
    1: def pdf_sync_page(page):
           r"""Class-aware wrapper for `::pdf_sync_page()`."""
>>>>>>     return _mupdf.pdf_sync_page(page)
       
    1: def pdf_text_widget_format(tw):
           r"""Class-aware wrapper for `::pdf_text_widget_format()`."""
>>>>>>     return _mupdf.pdf_text_widget_format(tw)
       
    1: def pdf_text_widget_max_len(tw):
           r"""Class-aware wrapper for `::pdf_text_widget_max_len()`."""
>>>>>>     return _mupdf.pdf_text_widget_max_len(tw)
       
    1: def pdf_to_bool(obj):
           r"""Class-aware wrapper for `::pdf_to_bool()`."""
>>>>>>     return _mupdf.pdf_to_bool(obj)
       
    1: def pdf_to_bool_default(obj, _def):
           r"""Class-aware wrapper for `::pdf_to_bool_default()`."""
>>>>>>     return _mupdf.pdf_to_bool_default(obj, _def)
       
    1: def pdf_to_date(time):
           r"""Class-aware wrapper for `::pdf_to_date()`."""
>>>>>>     return _mupdf.pdf_to_date(time)
       
    1: def pdf_to_gen(obj):
           r"""Class-aware wrapper for `::pdf_to_gen()`."""
>>>>>>     return _mupdf.pdf_to_gen(obj)
       
    1: def pdf_to_int(obj):
           r"""Class-aware wrapper for `::pdf_to_int()`."""
>>>>>>     return _mupdf.pdf_to_int(obj)
       
    1: def pdf_to_int64(obj):
           r"""Class-aware wrapper for `::pdf_to_int64()`."""
>>>>>>     return _mupdf.pdf_to_int64(obj)
       
    1: def pdf_to_int_default(obj, _def):
           r"""Class-aware wrapper for `::pdf_to_int_default()`."""
>>>>>>     return _mupdf.pdf_to_int_default(obj, _def)
       
    1: def pdf_to_matrix(array):
           r"""Class-aware wrapper for `::pdf_to_matrix()`."""
>>>>>>     return _mupdf.pdf_to_matrix(array)
       
    1: def pdf_to_name(obj):
           r"""Class-aware wrapper for `::pdf_to_name()`."""
>>>>>>     return _mupdf.pdf_to_name(obj)
       
    1: def pdf_to_num(obj):
           r"""Class-aware wrapper for `::pdf_to_num()`."""
>>>>>>     return _mupdf.pdf_to_num(obj)
       
    1: def pdf_to_point(array, offset):
           r"""Class-aware wrapper for `::pdf_to_point()`."""
>>>>>>     return _mupdf.pdf_to_point(array, offset)
       
    1: def pdf_to_quad(array, offset):
           r"""Class-aware wrapper for `::pdf_to_quad()`."""
>>>>>>     return _mupdf.pdf_to_quad(array, offset)
       
    1: def pdf_to_real(obj):
           r"""Class-aware wrapper for `::pdf_to_real()`."""
>>>>>>     return _mupdf.pdf_to_real(obj)
       
    1: def pdf_to_real_default(obj, _def):
           r"""Class-aware wrapper for `::pdf_to_real_default()`."""
>>>>>>     return _mupdf.pdf_to_real_default(obj, _def)
       
    1: def pdf_to_rect(array):
           r"""Class-aware wrapper for `::pdf_to_rect()`."""
>>>>>>     return _mupdf.pdf_to_rect(array)
       
    1: def pdf_to_str_buf(obj):
           r"""Class-aware wrapper for `::pdf_to_str_buf()`."""
>>>>>>     return _mupdf.pdf_to_str_buf(obj)
       
    1: def pdf_to_str_len(obj):
           r"""Class-aware wrapper for `::pdf_to_str_len()`."""
>>>>>>     return _mupdf.pdf_to_str_len(obj)
       
    1: def pdf_to_string(obj, sizep):
           r"""
           Class-aware wrapper for `::pdf_to_string()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_to_string(::pdf_obj *obj)` => `(const char *, size_t sizep)`
           """
>>>>>>     return _mupdf.pdf_to_string(obj, sizep)
       
    1: def pdf_to_text_string(obj):
           r"""Class-aware wrapper for `::pdf_to_text_string()`."""
>>>>>>     return _mupdf.pdf_to_text_string(obj)
       
    1: def pdf_toggle_layer_config_ui(doc, ui):
           r"""Class-aware wrapper for `::pdf_toggle_layer_config_ui()`."""
>>>>>>     return _mupdf.pdf_toggle_layer_config_ui(doc, ui)
       
    1: def pdf_toggle_widget(widget):
           r"""Class-aware wrapper for `::pdf_toggle_widget()`."""
>>>>>>     return _mupdf.pdf_toggle_widget(widget)
       
    1: def pdf_tos_get_text(tos):
           r"""Class-aware wrapper for `::pdf_tos_get_text()`."""
>>>>>>     return _mupdf.pdf_tos_get_text(tos)
       
    1: def pdf_tos_make_trm(tos, text, fontdesc, cid, trm, adv):
           r"""
           Class-aware wrapper for `::pdf_tos_make_trm()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_tos_make_trm(::pdf_text_object_state *tos, ::pdf_text_state *text, ::pdf_font_desc *fontdesc, int cid, ::fz_matrix *trm)` => `(int, float adv)`
           """
>>>>>>     return _mupdf.pdf_tos_make_trm(tos, text, fontdesc, cid, trm, adv)
       
    1: def pdf_tos_move_after_char(tos):
           r"""Class-aware wrapper for `::pdf_tos_move_after_char()`."""
>>>>>>     return _mupdf.pdf_tos_move_after_char(tos)
       
    1: def pdf_tos_newline(tos, leading):
           r"""Class-aware wrapper for `::pdf_tos_newline()`."""
>>>>>>     return _mupdf.pdf_tos_newline(tos, leading)
       
    1: def pdf_tos_reset(tos, render):
           r"""Class-aware wrapper for `::pdf_tos_reset()`."""
>>>>>>     return _mupdf.pdf_tos_reset(tos, render)
       
    1: def pdf_tos_restore(tos, save):
           r"""Class-aware wrapper for `::pdf_tos_restore()`."""
>>>>>>     return _mupdf.pdf_tos_restore(tos, save)
       
    1: def pdf_tos_save(tos, save):
           r"""Class-aware wrapper for `::pdf_tos_save()`."""
>>>>>>     return _mupdf.pdf_tos_save(tos, save)
       
    1: def pdf_tos_set_matrix(tos, a, b, c, d, e, f):
           r"""Class-aware wrapper for `::pdf_tos_set_matrix()`."""
>>>>>>     return _mupdf.pdf_tos_set_matrix(tos, a, b, c, d, e, f)
       
    1: def pdf_tos_translate(tos, tx, ty):
           r"""Class-aware wrapper for `::pdf_tos_translate()`."""
>>>>>>     return _mupdf.pdf_tos_translate(tos, tx, ty)
       
    1: def pdf_trailer(doc):
           r"""Class-aware wrapper for `::pdf_trailer()`."""
>>>>>>     return _mupdf.pdf_trailer(doc)
       
    1: def pdf_undo(doc):
           r"""Class-aware wrapper for `::pdf_undo()`."""
>>>>>>     return _mupdf.pdf_undo(doc)
       
    1: def pdf_undoredo_state(doc, steps):
           r"""
           Class-aware wrapper for `::pdf_undoredo_state()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_undoredo_state(::pdf_document *doc)` => `(int, int steps)`
           """
>>>>>>     return _mupdf.pdf_undoredo_state(doc, steps)
       
    1: def pdf_undoredo_step(doc, step):
           r"""Class-aware wrapper for `::pdf_undoredo_step()`."""
>>>>>>     return _mupdf.pdf_undoredo_step(doc, step)
       
    1: def pdf_unmark_obj(obj):
           r"""Class-aware wrapper for `::pdf_unmark_obj()`."""
>>>>>>     return _mupdf.pdf_unmark_obj(obj)
       
    1: def pdf_update_annot(annot):
           r"""Class-aware wrapper for `::pdf_update_annot()`."""
>>>>>>     return _mupdf.pdf_update_annot(annot)
       
    1: def pdf_update_default_colorspaces(old_cs, res):
           r"""Class-aware wrapper for `::pdf_update_default_colorspaces()`."""
>>>>>>     return _mupdf.pdf_update_default_colorspaces(old_cs, res)
       
    1: def pdf_update_object(doc, num, obj):
           r"""Class-aware wrapper for `::pdf_update_object()`."""
>>>>>>     return _mupdf.pdf_update_object(doc, num, obj)
       
    1: def pdf_update_page(page):
           r"""Class-aware wrapper for `::pdf_update_page()`."""
>>>>>>     return _mupdf.pdf_update_page(page)
       
    1: def pdf_update_stream(doc, ref, buf, compressed):
           r"""Class-aware wrapper for `::pdf_update_stream()`."""
>>>>>>     return _mupdf.pdf_update_stream(doc, ref, buf, compressed)
       
    1: def pdf_update_widget(widget):
           r"""Class-aware wrapper for `::pdf_update_widget()`."""
>>>>>>     return _mupdf.pdf_update_widget(widget)
       
    1: def pdf_update_xobject(doc, xobj, bbox, mat, res, buffer):
           r"""Class-aware wrapper for `::pdf_update_xobject()`."""
>>>>>>     return _mupdf.pdf_update_xobject(doc, xobj, bbox, mat, res, buffer)
       
    1: def pdf_validate_change_history(doc):
           r"""Class-aware wrapper for `::pdf_validate_change_history()`."""
>>>>>>     return _mupdf.pdf_validate_change_history(doc)
       
    1: def pdf_validate_changes(doc, version):
           r"""Class-aware wrapper for `::pdf_validate_changes()`."""
>>>>>>     return _mupdf.pdf_validate_changes(doc, version)
       
    1: def pdf_validate_signature(widget):
           r"""Class-aware wrapper for `::pdf_validate_signature()`."""
>>>>>>     return _mupdf.pdf_validate_signature(widget)
       
    1: def pdf_verify_embedded_file_checksum(fs):
           r"""Class-aware wrapper for `::pdf_verify_embedded_file_checksum()`."""
>>>>>>     return _mupdf.pdf_verify_embedded_file_checksum(fs)
       
    1: def pdf_version(doc):
           r"""Class-aware wrapper for `::pdf_version()`."""
>>>>>>     return _mupdf.pdf_version(doc)
       
    1: def pdf_walk_tree(tree, kid_name, arrive, leave, arg, names, values):
           r"""
           Class-aware wrapper for `::pdf_walk_tree()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_walk_tree(::pdf_obj *tree, ::pdf_obj *kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, ::pdf_obj **names, ::pdf_obj **values)` => `()`
           """
>>>>>>     return _mupdf.pdf_walk_tree(tree, kid_name, arrive, leave, arg, names, values)
       
    1: def pdf_was_pure_xfa(doc):
           r"""Class-aware wrapper for `::pdf_was_pure_xfa()`."""
>>>>>>     return _mupdf.pdf_was_pure_xfa(doc)
       
    1: def pdf_was_repaired(doc):
           r"""Class-aware wrapper for `::pdf_was_repaired()`."""
>>>>>>     return _mupdf.pdf_was_repaired(doc)
       
    1: def pdf_widget_is_readonly(widget):
           r"""Class-aware wrapper for `::pdf_widget_is_readonly()`."""
>>>>>>     return _mupdf.pdf_widget_is_readonly(widget)
       
    1: def pdf_widget_is_signed(widget):
           r"""Class-aware wrapper for `::pdf_widget_is_signed()`."""
>>>>>>     return _mupdf.pdf_widget_is_signed(widget)
       
    1: def pdf_widget_type(widget):
           r"""Class-aware wrapper for `::pdf_widget_type()`."""
>>>>>>     return _mupdf.pdf_widget_type(widget)
       
    1: def pdf_write_digest(out, byte_range, field, digest_offset, digest_length, signer):
           r"""Class-aware wrapper for `::pdf_write_digest()`."""
>>>>>>     return _mupdf.pdf_write_digest(out, byte_range, field, digest_offset, digest_length, signer)
       
    1: def pdf_write_document(doc, out, opts):
           r"""Class-aware wrapper for `::pdf_write_document()`."""
>>>>>>     return _mupdf.pdf_write_document(doc, out, opts)
       
    1: def pdf_write_journal(doc, out):
           r"""Class-aware wrapper for `::pdf_write_journal()`."""
>>>>>>     return _mupdf.pdf_write_journal(doc, out)
       
    1: def pdf_write_snapshot(doc, out):
           r"""Class-aware wrapper for `::pdf_write_snapshot()`."""
>>>>>>     return _mupdf.pdf_write_snapshot(doc, out)
       
    1: def pdf_xobject_bbox(xobj):
           r"""Class-aware wrapper for `::pdf_xobject_bbox()`."""
>>>>>>     return _mupdf.pdf_xobject_bbox(xobj)
       
    1: def pdf_xobject_colorspace(xobj):
           r"""Class-aware wrapper for `::pdf_xobject_colorspace()`."""
>>>>>>     return _mupdf.pdf_xobject_colorspace(xobj)
       
    1: def pdf_xobject_isolated(xobj):
           r"""Class-aware wrapper for `::pdf_xobject_isolated()`."""
>>>>>>     return _mupdf.pdf_xobject_isolated(xobj)
       
    1: def pdf_xobject_knockout(xobj):
           r"""Class-aware wrapper for `::pdf_xobject_knockout()`."""
>>>>>>     return _mupdf.pdf_xobject_knockout(xobj)
       
    1: def pdf_xobject_matrix(xobj):
           r"""Class-aware wrapper for `::pdf_xobject_matrix()`."""
>>>>>>     return _mupdf.pdf_xobject_matrix(xobj)
       
    1: def pdf_xobject_resources(xobj):
           r"""Class-aware wrapper for `::pdf_xobject_resources()`."""
>>>>>>     return _mupdf.pdf_xobject_resources(xobj)
       
    1: def pdf_xobject_transparency(xobj):
           r"""Class-aware wrapper for `::pdf_xobject_transparency()`."""
>>>>>>     return _mupdf.pdf_xobject_transparency(xobj)
       
    1: def pdf_xref_ensure_incremental_object(doc, num):
           r"""Class-aware wrapper for `::pdf_xref_ensure_incremental_object()`."""
>>>>>>     return _mupdf.pdf_xref_ensure_incremental_object(doc, num)
       
    1: def pdf_xref_ensure_local_object(doc, num):
           r"""Class-aware wrapper for `::pdf_xref_ensure_local_object()`."""
>>>>>>     return _mupdf.pdf_xref_ensure_local_object(doc, num)
       
    1: def pdf_xref_entry_map(doc, fn, arg):
           r"""Class-aware wrapper for `::pdf_xref_entry_map()`."""
>>>>>>     return _mupdf.pdf_xref_entry_map(doc, fn, arg)
       
    1: def pdf_xref_is_incremental(doc, num):
           r"""Class-aware wrapper for `::pdf_xref_is_incremental()`."""
>>>>>>     return _mupdf.pdf_xref_is_incremental(doc, num)
       
    1: def pdf_xref_len(doc):
           r"""Class-aware wrapper for `::pdf_xref_len()`."""
>>>>>>     return _mupdf.pdf_xref_len(doc)
       
    1: def pdf_xref_obj_is_unsaved_signature(doc, obj):
           r"""Class-aware wrapper for `::pdf_xref_obj_is_unsaved_signature()`."""
>>>>>>     return _mupdf.pdf_xref_obj_is_unsaved_signature(doc, obj)
       
    1: def pdf_xref_remove_unsaved_signature(doc, field):
           r"""Class-aware wrapper for `::pdf_xref_remove_unsaved_signature()`."""
>>>>>>     return _mupdf.pdf_xref_remove_unsaved_signature(doc, field)
       
    1: def pdf_xref_store_unsaved_signature(doc, field, signer):
           r"""Class-aware wrapper for `::pdf_xref_store_unsaved_signature()`."""
>>>>>>     return _mupdf.pdf_xref_store_unsaved_signature(doc, field, signer)
       
    1: def pdf_zugferd_profile(doc, version):
           r"""
           Class-aware wrapper for `::pdf_zugferd_profile()`.
       
           This function has out-params. Python/C# wrappers look like:
               `pdf_zugferd_profile(::pdf_document *doc)` => `(enum pdf_zugferd_profile, float version)`
           """
>>>>>>     return _mupdf.pdf_zugferd_profile(doc, version)
       
    1: def pdf_zugferd_profile_to_string(profile):
           r"""Class-aware wrapper for `::pdf_zugferd_profile_to_string()`."""
>>>>>>     return _mupdf.pdf_zugferd_profile_to_string(profile)
       
    1: def pdf_zugferd_xml(doc):
           r"""Class-aware wrapper for `::pdf_zugferd_xml()`."""
>>>>>>     return _mupdf.pdf_zugferd_xml(doc)
       
    1: def internal_assert_fail(file, line, fn, expression):
           r"""This file was auto-generated by mupdfwrap.py."""
>>>>>>     return _mupdf.internal_assert_fail(file, line, fn, expression)
       
    1: def internal_env_flag(name):
           r"""Internal use only. Looks at environmental variable <name>; returns 0 if unset else int value."""
>>>>>>     return _mupdf.internal_env_flag(name)
       
    1: def internal_env_flag_check_unset(if_, name):
           r"""Internal use only. Looks at environmental variable <name>; returns 0 if unset else int value."""
>>>>>>     return _mupdf.internal_env_flag_check_unset(if_, name)
       
    1: def internal_context_get():
           r"""Internal use only. Returns `fz_context*` for use by current thread."""
>>>>>>     return _mupdf.internal_context_get()
    2: class FzErrorBase(Exception):
    1:     r"""Base class for exceptions."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     m_code = property(_mupdf.FzErrorBase_m_code_get, _mupdf.FzErrorBase_m_code_set)
    1:     m_text = property(_mupdf.FzErrorBase_m_text_get, _mupdf.FzErrorBase_m_text_set)
    1:     m_what = property(_mupdf.FzErrorBase_m_what_get, _mupdf.FzErrorBase_m_what_set)
       
    1:     def what(self):
>>>>>>         return _mupdf.FzErrorBase_what(self)
       
    1:     def __init__(self, code, text):
>>>>>>         _mupdf.FzErrorBase_swiginit(self, _mupdf.new_FzErrorBase(code, text))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorBase
       
       # Register FzErrorBase in _mupdf:
    1: _mupdf.FzErrorBase_swigregister(FzErrorBase)
    2: class FzErrorNone(FzErrorBase):
    1:     r"""For `FZ_ERROR_NONE`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, message):
>>>>>>         _mupdf.FzErrorNone_swiginit(self, _mupdf.new_FzErrorNone(message))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorNone
       
       # Register FzErrorNone in _mupdf:
    1: _mupdf.FzErrorNone_swigregister(FzErrorNone)
    2: class FzErrorGeneric(FzErrorBase):
    1:     r"""For `FZ_ERROR_GENERIC`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, message):
>>>>>>         _mupdf.FzErrorGeneric_swiginit(self, _mupdf.new_FzErrorGeneric(message))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorGeneric
       
       # Register FzErrorGeneric in _mupdf:
    1: _mupdf.FzErrorGeneric_swigregister(FzErrorGeneric)
    2: class FzErrorSystem(FzErrorBase):
    1:     r"""For `FZ_ERROR_SYSTEM`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, message):
>>>>>>         _mupdf.FzErrorSystem_swiginit(self, _mupdf.new_FzErrorSystem(message))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorSystem
       
       # Register FzErrorSystem in _mupdf:
    1: _mupdf.FzErrorSystem_swigregister(FzErrorSystem)
    2: class FzErrorLibrary(FzErrorBase):
    1:     r"""For `FZ_ERROR_LIBRARY`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, message):
>>>>>>         _mupdf.FzErrorLibrary_swiginit(self, _mupdf.new_FzErrorLibrary(message))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorLibrary
       
       # Register FzErrorLibrary in _mupdf:
    1: _mupdf.FzErrorLibrary_swigregister(FzErrorLibrary)
    2: class FzErrorArgument(FzErrorBase):
    1:     r"""For `FZ_ERROR_ARGUMENT`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, message):
>>>>>>         _mupdf.FzErrorArgument_swiginit(self, _mupdf.new_FzErrorArgument(message))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorArgument
       
       # Register FzErrorArgument in _mupdf:
    1: _mupdf.FzErrorArgument_swigregister(FzErrorArgument)
    2: class FzErrorLimit(FzErrorBase):
    1:     r"""For `FZ_ERROR_LIMIT`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, message):
>>>>>>         _mupdf.FzErrorLimit_swiginit(self, _mupdf.new_FzErrorLimit(message))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorLimit
       
       # Register FzErrorLimit in _mupdf:
    1: _mupdf.FzErrorLimit_swigregister(FzErrorLimit)
    2: class FzErrorUnsupported(FzErrorBase):
    1:     r"""For `FZ_ERROR_UNSUPPORTED`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, message):
>>>>>>         _mupdf.FzErrorUnsupported_swiginit(self, _mupdf.new_FzErrorUnsupported(message))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorUnsupported
       
       # Register FzErrorUnsupported in _mupdf:
    1: _mupdf.FzErrorUnsupported_swigregister(FzErrorUnsupported)
    2: class FzErrorFormat(FzErrorBase):
    1:     r"""For `FZ_ERROR_FORMAT`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, message):
>>>>>>         _mupdf.FzErrorFormat_swiginit(self, _mupdf.new_FzErrorFormat(message))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorFormat
       
       # Register FzErrorFormat in _mupdf:
    1: _mupdf.FzErrorFormat_swigregister(FzErrorFormat)
    2: class FzErrorSyntax(FzErrorBase):
    1:     r"""For `FZ_ERROR_SYNTAX`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, message):
>>>>>>         _mupdf.FzErrorSyntax_swiginit(self, _mupdf.new_FzErrorSyntax(message))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorSyntax
       
       # Register FzErrorSyntax in _mupdf:
    1: _mupdf.FzErrorSyntax_swigregister(FzErrorSyntax)
    2: class FzErrorTrylater(FzErrorBase):
    1:     r"""For `FZ_ERROR_TRYLATER`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, message):
>>>>>>         _mupdf.FzErrorTrylater_swiginit(self, _mupdf.new_FzErrorTrylater(message))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorTrylater
       
       # Register FzErrorTrylater in _mupdf:
    1: _mupdf.FzErrorTrylater_swigregister(FzErrorTrylater)
    2: class FzErrorAbort(FzErrorBase):
    1:     r"""For `FZ_ERROR_ABORT`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, message):
>>>>>>         _mupdf.FzErrorAbort_swiginit(self, _mupdf.new_FzErrorAbort(message))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorAbort
       
       # Register FzErrorAbort in _mupdf:
    1: _mupdf.FzErrorAbort_swigregister(FzErrorAbort)
    2: class FzErrorRepaired(FzErrorBase):
    1:     r"""For `FZ_ERROR_REPAIRED`."""
       
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, message):
>>>>>>         _mupdf.FzErrorRepaired_swiginit(self, _mupdf.new_FzErrorRepaired(message))
    1:     __swig_destroy__ = _mupdf.delete_FzErrorRepaired
       
       # Register FzErrorRepaired in _mupdf:
    1: _mupdf.FzErrorRepaired_swigregister(FzErrorRepaired)
       
    1: def internal_throw_exception(ctx):
           r"""Throw exception appropriate for error in `ctx`."""
>>>>>>     return _mupdf.internal_throw_exception(ctx)
       
    1: def to_stdstring(s):
>>>>>>     return _mupdf.to_stdstring(s)
       
    1: def py_repr(x):
>>>>>>     return _mupdf.py_repr(x)
       
    1: def py_str(x):
>>>>>>     return _mupdf.py_str(x)
       
    1: def ll_fz_buffer_to_bytes_internal(buffer, clear):
>>>>>>     return _mupdf.ll_fz_buffer_to_bytes_internal(buffer, clear)
       
    1: def python_memoryview_from_memory(data, size, writable):
>>>>>>     return _mupdf.python_memoryview_from_memory(data, size, writable)
       
    1: def ll_fz_buffer_storage_memoryview(buffer, writable):
>>>>>>     return _mupdf.ll_fz_buffer_storage_memoryview(buffer, writable)
       
    1: def raw_to_python_bytes(*args):
>>>>>>     return _mupdf.raw_to_python_bytes(*args)
       
    1: def python_buffer_data(PYTHON_BUFFER_DATA):
>>>>>>     return _mupdf.python_buffer_data(PYTHON_BUFFER_DATA)
       
    1: def python_mutable_buffer_data(PYTHON_BUFFER_MUTABLE_DATA):
>>>>>>     return _mupdf.python_mutable_buffer_data(PYTHON_BUFFER_MUTABLE_DATA)
       
    1: def obj_enum_to_obj(n):
  601:     return _mupdf.obj_enum_to_obj(n)
       
    1: def ll_pdf_set_annot_color2(annot, n, color0, color1, color2, color3):
>>>>>>     return _mupdf.ll_pdf_set_annot_color2(annot, n, color0, color1, color2, color3)
       
    1: def ll_pdf_set_annot_interior_color2(annot, n, color0, color1, color2, color3):
>>>>>>     return _mupdf.ll_pdf_set_annot_interior_color2(annot, n, color0, color1, color2, color3)
       
    1: def ll_fz_fill_text2(dev, text, ctm, colorspace, color0, color1, color2, color3, alpha, color_params):
>>>>>>     return _mupdf.ll_fz_fill_text2(dev, text, ctm, colorspace, color0, color1, color2, color3, alpha, color_params)
       
    1: def fz_memrnd2(length):
>>>>>>     return _mupdf.fz_memrnd2(length)
       
    1: def ll_fz_pixmap_copy_raw(pm, samples):
>>>>>>     return _mupdf.ll_fz_pixmap_copy_raw(pm, samples)
       
    1: def fz_runetochar2(rune):
>>>>>>     return _mupdf.fz_runetochar2(rune)
       
    1: def ll_fz_make_bookmark2(doc, loc):
>>>>>>     return _mupdf.ll_fz_make_bookmark2(doc, loc)
       
    1: def ll_fz_lookup_bookmark2(doc, mark):
>>>>>>     return _mupdf.ll_fz_lookup_bookmark2(doc, mark)
       
    1: def fz_lookup_bookmark2(doc, mark):
>>>>>>     return _mupdf.fz_lookup_bookmark2(doc, mark)
    2: class fz_convert_color2_v(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     v0 = property(_mupdf.fz_convert_color2_v_v0_get, _mupdf.fz_convert_color2_v_v0_set)
    1:     v1 = property(_mupdf.fz_convert_color2_v_v1_get, _mupdf.fz_convert_color2_v_v1_set)
    1:     v2 = property(_mupdf.fz_convert_color2_v_v2_get, _mupdf.fz_convert_color2_v_v2_set)
    1:     v3 = property(_mupdf.fz_convert_color2_v_v3_get, _mupdf.fz_convert_color2_v_v3_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.fz_convert_color2_v_swiginit(self, _mupdf.new_fz_convert_color2_v())
    1:     __swig_destroy__ = _mupdf.delete_fz_convert_color2_v
       
       # Register fz_convert_color2_v in _mupdf:
    1: _mupdf.fz_convert_color2_v_swigregister(fz_convert_color2_v)
       
    1: def ll_fz_convert_color2(*args):
>>>>>>     return _mupdf.ll_fz_convert_color2(*args)
    2: class DiagnosticCallback(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self, description):
    2:         if self.__class__ == DiagnosticCallback:
>>>>>>             _self = None
               else:
    2:             _self = self
    2:         _mupdf.DiagnosticCallback_swiginit(self, _mupdf.new_DiagnosticCallback(_self, description))
       
    1:     def _print(self, message):
>>>>>>         return _mupdf.DiagnosticCallback__print(self, message)
    1:     __swig_destroy__ = _mupdf.delete_DiagnosticCallback
       
    2:     @staticmethod
    2:     def s_print(self0, message):
>>>>>>         return _mupdf.DiagnosticCallback_s_print(self0, message)
    1:     m_description = property(_mupdf.DiagnosticCallback_m_description_get, _mupdf.DiagnosticCallback_m_description_set)
    1:     def __disown__(self):
>>>>>>         self.this.disown()
>>>>>>         _mupdf.disown_DiagnosticCallback(self)
>>>>>>         return weakref.proxy(self)
       
       # Register DiagnosticCallback in _mupdf:
    1: _mupdf.DiagnosticCallback_swigregister(DiagnosticCallback)
    2: class StoryPositionsCallback(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
       
    1:     def __init__(self):
>>>>>>         if self.__class__ == StoryPositionsCallback:
>>>>>>             _self = None
               else:
>>>>>>             _self = self
>>>>>>         _mupdf.StoryPositionsCallback_swiginit(self, _mupdf.new_StoryPositionsCallback(_self, ))
       
    1:     def call(self, position):
>>>>>>         return _mupdf.StoryPositionsCallback_call(self, position)
       
    2:     @staticmethod
    2:     def s_call(ctx, self0, position):
>>>>>>         return _mupdf.StoryPositionsCallback_s_call(ctx, self0, position)
    1:     __swig_destroy__ = _mupdf.delete_StoryPositionsCallback
    1:     def __disown__(self):
>>>>>>         self.this.disown()
>>>>>>         _mupdf.disown_StoryPositionsCallback(self)
>>>>>>         return weakref.proxy(self)
       
       # Register StoryPositionsCallback in _mupdf:
    1: _mupdf.StoryPositionsCallback_swigregister(StoryPositionsCallback)
       
    1: def ll_fz_story_positions_director(story, cb):
>>>>>>     return _mupdf.ll_fz_story_positions_director(story, cb)
       
    1: def Pixmap_set_alpha_helper(balen, n, data_len, zero_out, data, pix, premultiply, bground, colors, bgcolor):
>>>>>>     return _mupdf.Pixmap_set_alpha_helper(balen, n, data_len, zero_out, data, pix, premultiply, bground, colors, bgcolor)
       
    1: def page_merge_helper(old_annots, graft_map, doc_des, new_annots, n):
>>>>>>     return _mupdf.page_merge_helper(old_annots, graft_map, doc_des, new_annots, n)
    2: class ll_fz_bidi_fragment_text_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     baseDir = property(_mupdf.ll_fz_bidi_fragment_text_outparams_baseDir_get, _mupdf.ll_fz_bidi_fragment_text_outparams_baseDir_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_bidi_fragment_text_outparams_swiginit(self, _mupdf.new_ll_fz_bidi_fragment_text_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_bidi_fragment_text_outparams
       
       # Register ll_fz_bidi_fragment_text_outparams in _mupdf:
    1: _mupdf.ll_fz_bidi_fragment_text_outparams_swigregister(ll_fz_bidi_fragment_text_outparams)
       
    1: def ll_fz_bidi_fragment_text_outparams_fn(text, textlen, callback, arg, flags, outparams):
>>>>>>     return _mupdf.ll_fz_bidi_fragment_text_outparams_fn(text, textlen, callback, arg, flags, outparams)
    2: class ll_fz_bitmap_details_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     w = property(_mupdf.ll_fz_bitmap_details_outparams_w_get, _mupdf.ll_fz_bitmap_details_outparams_w_set)
    1:     h = property(_mupdf.ll_fz_bitmap_details_outparams_h_get, _mupdf.ll_fz_bitmap_details_outparams_h_set)
    1:     n = property(_mupdf.ll_fz_bitmap_details_outparams_n_get, _mupdf.ll_fz_bitmap_details_outparams_n_set)
    1:     stride = property(_mupdf.ll_fz_bitmap_details_outparams_stride_get, _mupdf.ll_fz_bitmap_details_outparams_stride_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_bitmap_details_outparams_swiginit(self, _mupdf.new_ll_fz_bitmap_details_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_bitmap_details_outparams
       
       # Register ll_fz_bitmap_details_outparams in _mupdf:
    1: _mupdf.ll_fz_bitmap_details_outparams_swigregister(ll_fz_bitmap_details_outparams)
       
    1: def ll_fz_bitmap_details_outparams_fn(bitmap, outparams):
>>>>>>     return _mupdf.ll_fz_bitmap_details_outparams_fn(bitmap, outparams)
    2: class ll_fz_buffer_extract_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     data = property(_mupdf.ll_fz_buffer_extract_outparams_data_get, _mupdf.ll_fz_buffer_extract_outparams_data_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_buffer_extract_outparams_swiginit(self, _mupdf.new_ll_fz_buffer_extract_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_buffer_extract_outparams
       
       # Register ll_fz_buffer_extract_outparams in _mupdf:
    1: _mupdf.ll_fz_buffer_extract_outparams_swigregister(ll_fz_buffer_extract_outparams)
       
    1: def ll_fz_buffer_extract_outparams_fn(buf, outparams):
>>>>>>     return _mupdf.ll_fz_buffer_extract_outparams_fn(buf, outparams)
    2: class ll_fz_buffer_storage_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     datap = property(_mupdf.ll_fz_buffer_storage_outparams_datap_get, _mupdf.ll_fz_buffer_storage_outparams_datap_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_buffer_storage_outparams_swiginit(self, _mupdf.new_ll_fz_buffer_storage_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_buffer_storage_outparams
       
       # Register ll_fz_buffer_storage_outparams in _mupdf:
    1: _mupdf.ll_fz_buffer_storage_outparams_swigregister(ll_fz_buffer_storage_outparams)
       
    1: def ll_fz_buffer_storage_outparams_fn(buf, outparams):
>>>>>>     return _mupdf.ll_fz_buffer_storage_outparams_fn(buf, outparams)
    2: class ll_fz_chartorune_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     rune = property(_mupdf.ll_fz_chartorune_outparams_rune_get, _mupdf.ll_fz_chartorune_outparams_rune_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_chartorune_outparams_swiginit(self, _mupdf.new_ll_fz_chartorune_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_chartorune_outparams
       
       # Register ll_fz_chartorune_outparams in _mupdf:
    1: _mupdf.ll_fz_chartorune_outparams_swigregister(ll_fz_chartorune_outparams)
       
    1: def ll_fz_chartorune_outparams_fn(str, outparams):
>>>>>>     return _mupdf.ll_fz_chartorune_outparams_fn(str, outparams)
    2: class ll_fz_chartorunen_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     rune = property(_mupdf.ll_fz_chartorunen_outparams_rune_get, _mupdf.ll_fz_chartorunen_outparams_rune_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_chartorunen_outparams_swiginit(self, _mupdf.new_ll_fz_chartorunen_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_chartorunen_outparams
       
       # Register ll_fz_chartorunen_outparams in _mupdf:
    1: _mupdf.ll_fz_chartorunen_outparams_swigregister(ll_fz_chartorunen_outparams)
       
    1: def ll_fz_chartorunen_outparams_fn(str, n, outparams):
>>>>>>     return _mupdf.ll_fz_chartorunen_outparams_fn(str, n, outparams)
    2: class ll_fz_clamp_color_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     out = property(_mupdf.ll_fz_clamp_color_outparams_out_get, _mupdf.ll_fz_clamp_color_outparams_out_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_clamp_color_outparams_swiginit(self, _mupdf.new_ll_fz_clamp_color_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_clamp_color_outparams
       
       # Register ll_fz_clamp_color_outparams in _mupdf:
    1: _mupdf.ll_fz_clamp_color_outparams_swigregister(ll_fz_clamp_color_outparams)
       
    1: def ll_fz_clamp_color_outparams_fn(cs, _in, outparams):
>>>>>>     return _mupdf.ll_fz_clamp_color_outparams_fn(cs, _in, outparams)
    2: class ll_fz_compress_brotli_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     compressed_length = property(_mupdf.ll_fz_compress_brotli_outparams_compressed_length_get, _mupdf.ll_fz_compress_brotli_outparams_compressed_length_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_compress_brotli_outparams_swiginit(self, _mupdf.new_ll_fz_compress_brotli_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_compress_brotli_outparams
       
       # Register ll_fz_compress_brotli_outparams in _mupdf:
    1: _mupdf.ll_fz_compress_brotli_outparams_swigregister(ll_fz_compress_brotli_outparams)
       
    1: def ll_fz_compress_brotli_outparams_fn(dest, source, source_length, level, outparams):
>>>>>>     return _mupdf.ll_fz_compress_brotli_outparams_fn(dest, source, source_length, level, outparams)
    2: class ll_fz_convert_color_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     dv = property(_mupdf.ll_fz_convert_color_outparams_dv_get, _mupdf.ll_fz_convert_color_outparams_dv_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_convert_color_outparams_swiginit(self, _mupdf.new_ll_fz_convert_color_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_convert_color_outparams
       
       # Register ll_fz_convert_color_outparams in _mupdf:
    1: _mupdf.ll_fz_convert_color_outparams_swigregister(ll_fz_convert_color_outparams)
       
    1: def ll_fz_convert_color_outparams_fn(ss, sv, ds, _is, params, outparams):
>>>>>>     return _mupdf.ll_fz_convert_color_outparams_fn(ss, sv, ds, _is, params, outparams)
    2: class ll_fz_convert_error_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     code = property(_mupdf.ll_fz_convert_error_outparams_code_get, _mupdf.ll_fz_convert_error_outparams_code_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_convert_error_outparams_swiginit(self, _mupdf.new_ll_fz_convert_error_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_convert_error_outparams
       
       # Register ll_fz_convert_error_outparams in _mupdf:
    1: _mupdf.ll_fz_convert_error_outparams_swigregister(ll_fz_convert_error_outparams)
       
    1: def ll_fz_convert_error_outparams_fn(outparams):
>>>>>>     return _mupdf.ll_fz_convert_error_outparams_fn(outparams)
    2: class ll_fz_convert_separation_colors_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     dst_color = property(_mupdf.ll_fz_convert_separation_colors_outparams_dst_color_get, _mupdf.ll_fz_convert_separation_colors_outparams_dst_color_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_convert_separation_colors_outparams_swiginit(self, _mupdf.new_ll_fz_convert_separation_colors_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_convert_separation_colors_outparams
       
       # Register ll_fz_convert_separation_colors_outparams in _mupdf:
    1: _mupdf.ll_fz_convert_separation_colors_outparams_swigregister(ll_fz_convert_separation_colors_outparams)
       
    1: def ll_fz_convert_separation_colors_outparams_fn(src_cs, src_color, dst_seps, dst_cs, color_params, outparams):
>>>>>>     return _mupdf.ll_fz_convert_separation_colors_outparams_fn(src_cs, src_color, dst_seps, dst_cs, color_params, outparams)
    2: class ll_fz_decode_barcode_from_display_list_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     type = property(_mupdf.ll_fz_decode_barcode_from_display_list_outparams_type_get, _mupdf.ll_fz_decode_barcode_from_display_list_outparams_type_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_decode_barcode_from_display_list_outparams_swiginit(self, _mupdf.new_ll_fz_decode_barcode_from_display_list_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_decode_barcode_from_display_list_outparams
       
       # Register ll_fz_decode_barcode_from_display_list_outparams in _mupdf:
    1: _mupdf.ll_fz_decode_barcode_from_display_list_outparams_swigregister(ll_fz_decode_barcode_from_display_list_outparams)
       
    1: def ll_fz_decode_barcode_from_display_list_outparams_fn(list, subarea, rotate, outparams):
>>>>>>     return _mupdf.ll_fz_decode_barcode_from_display_list_outparams_fn(list, subarea, rotate, outparams)
    2: class ll_fz_decode_barcode_from_display_list2_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     type = property(_mupdf.ll_fz_decode_barcode_from_display_list2_outparams_type_get, _mupdf.ll_fz_decode_barcode_from_display_list2_outparams_type_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_decode_barcode_from_display_list2_outparams_swiginit(self, _mupdf.new_ll_fz_decode_barcode_from_display_list2_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_decode_barcode_from_display_list2_outparams
       
       # Register ll_fz_decode_barcode_from_display_list2_outparams in _mupdf:
    1: _mupdf.ll_fz_decode_barcode_from_display_list2_outparams_swigregister(ll_fz_decode_barcode_from_display_list2_outparams)
       
    1: def ll_fz_decode_barcode_from_display_list2_outparams_fn(list, subarea, rotate, outparams):
>>>>>>     return _mupdf.ll_fz_decode_barcode_from_display_list2_outparams_fn(list, subarea, rotate, outparams)
    2: class ll_fz_decode_barcode_from_page_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     type = property(_mupdf.ll_fz_decode_barcode_from_page_outparams_type_get, _mupdf.ll_fz_decode_barcode_from_page_outparams_type_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_decode_barcode_from_page_outparams_swiginit(self, _mupdf.new_ll_fz_decode_barcode_from_page_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_decode_barcode_from_page_outparams
       
       # Register ll_fz_decode_barcode_from_page_outparams in _mupdf:
    1: _mupdf.ll_fz_decode_barcode_from_page_outparams_swigregister(ll_fz_decode_barcode_from_page_outparams)
       
    1: def ll_fz_decode_barcode_from_page_outparams_fn(page, subarea, rotate, outparams):
>>>>>>     return _mupdf.ll_fz_decode_barcode_from_page_outparams_fn(page, subarea, rotate, outparams)
    2: class ll_fz_decode_barcode_from_page2_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     type = property(_mupdf.ll_fz_decode_barcode_from_page2_outparams_type_get, _mupdf.ll_fz_decode_barcode_from_page2_outparams_type_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_decode_barcode_from_page2_outparams_swiginit(self, _mupdf.new_ll_fz_decode_barcode_from_page2_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_decode_barcode_from_page2_outparams
       
       # Register ll_fz_decode_barcode_from_page2_outparams in _mupdf:
    1: _mupdf.ll_fz_decode_barcode_from_page2_outparams_swigregister(ll_fz_decode_barcode_from_page2_outparams)
       
    1: def ll_fz_decode_barcode_from_page2_outparams_fn(page, subarea, rotate, outparams):
>>>>>>     return _mupdf.ll_fz_decode_barcode_from_page2_outparams_fn(page, subarea, rotate, outparams)
    2: class ll_fz_decode_barcode_from_pixmap_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     type = property(_mupdf.ll_fz_decode_barcode_from_pixmap_outparams_type_get, _mupdf.ll_fz_decode_barcode_from_pixmap_outparams_type_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_decode_barcode_from_pixmap_outparams_swiginit(self, _mupdf.new_ll_fz_decode_barcode_from_pixmap_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_decode_barcode_from_pixmap_outparams
       
       # Register ll_fz_decode_barcode_from_pixmap_outparams in _mupdf:
    1: _mupdf.ll_fz_decode_barcode_from_pixmap_outparams_swigregister(ll_fz_decode_barcode_from_pixmap_outparams)
       
    1: def ll_fz_decode_barcode_from_pixmap_outparams_fn(pix, rotate, outparams):
>>>>>>     return _mupdf.ll_fz_decode_barcode_from_pixmap_outparams_fn(pix, rotate, outparams)
    2: class ll_fz_decode_barcode_from_pixmap2_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     type = property(_mupdf.ll_fz_decode_barcode_from_pixmap2_outparams_type_get, _mupdf.ll_fz_decode_barcode_from_pixmap2_outparams_type_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_decode_barcode_from_pixmap2_outparams_swiginit(self, _mupdf.new_ll_fz_decode_barcode_from_pixmap2_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_decode_barcode_from_pixmap2_outparams
       
       # Register ll_fz_decode_barcode_from_pixmap2_outparams in _mupdf:
    1: _mupdf.ll_fz_decode_barcode_from_pixmap2_outparams_swigregister(ll_fz_decode_barcode_from_pixmap2_outparams)
       
    1: def ll_fz_decode_barcode_from_pixmap2_outparams_fn(pix, rotate, outparams):
>>>>>>     return _mupdf.ll_fz_decode_barcode_from_pixmap2_outparams_fn(pix, rotate, outparams)
    2: class ll_fz_decomp_image_from_stream_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     l2extra = property(_mupdf.ll_fz_decomp_image_from_stream_outparams_l2extra_get, _mupdf.ll_fz_decomp_image_from_stream_outparams_l2extra_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_decomp_image_from_stream_outparams_swiginit(self, _mupdf.new_ll_fz_decomp_image_from_stream_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_decomp_image_from_stream_outparams
       
       # Register ll_fz_decomp_image_from_stream_outparams in _mupdf:
    1: _mupdf.ll_fz_decomp_image_from_stream_outparams_swigregister(ll_fz_decomp_image_from_stream_outparams)
       
    1: def ll_fz_decomp_image_from_stream_outparams_fn(stm, image, subarea, indexed, l2factor, outparams):
>>>>>>     return _mupdf.ll_fz_decomp_image_from_stream_outparams_fn(stm, image, subarea, indexed, l2factor, outparams)
    2: class ll_fz_deflate_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     compressed_length = property(_mupdf.ll_fz_deflate_outparams_compressed_length_get, _mupdf.ll_fz_deflate_outparams_compressed_length_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_deflate_outparams_swiginit(self, _mupdf.new_ll_fz_deflate_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_deflate_outparams
       
       # Register ll_fz_deflate_outparams in _mupdf:
    1: _mupdf.ll_fz_deflate_outparams_swigregister(ll_fz_deflate_outparams)
       
    1: def ll_fz_deflate_outparams_fn(dest, source, source_length, level, outparams):
>>>>>>     return _mupdf.ll_fz_deflate_outparams_fn(dest, source, source_length, level, outparams)
    2: class ll_fz_dom_get_attribute_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     att = property(_mupdf.ll_fz_dom_get_attribute_outparams_att_get, _mupdf.ll_fz_dom_get_attribute_outparams_att_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_dom_get_attribute_outparams_swiginit(self, _mupdf.new_ll_fz_dom_get_attribute_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_dom_get_attribute_outparams
       
       # Register ll_fz_dom_get_attribute_outparams in _mupdf:
    1: _mupdf.ll_fz_dom_get_attribute_outparams_swigregister(ll_fz_dom_get_attribute_outparams)
       
    1: def ll_fz_dom_get_attribute_outparams_fn(elt, i, outparams):
>>>>>>     return _mupdf.ll_fz_dom_get_attribute_outparams_fn(elt, i, outparams)
    2: class ll_fz_drop_imp_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.ll_fz_drop_imp_outparams_refs_get, _mupdf.ll_fz_drop_imp_outparams_refs_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_drop_imp_outparams_swiginit(self, _mupdf.new_ll_fz_drop_imp_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_drop_imp_outparams
       
       # Register ll_fz_drop_imp_outparams in _mupdf:
    1: _mupdf.ll_fz_drop_imp_outparams_swigregister(ll_fz_drop_imp_outparams)
       
    1: def ll_fz_drop_imp_outparams_fn(p, outparams):
>>>>>>     return _mupdf.ll_fz_drop_imp_outparams_fn(p, outparams)
    2: class ll_fz_drop_imp16_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.ll_fz_drop_imp16_outparams_refs_get, _mupdf.ll_fz_drop_imp16_outparams_refs_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_drop_imp16_outparams_swiginit(self, _mupdf.new_ll_fz_drop_imp16_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_drop_imp16_outparams
       
       # Register ll_fz_drop_imp16_outparams in _mupdf:
    1: _mupdf.ll_fz_drop_imp16_outparams_swigregister(ll_fz_drop_imp16_outparams)
       
    1: def ll_fz_drop_imp16_outparams_fn(p, outparams):
>>>>>>     return _mupdf.ll_fz_drop_imp16_outparams_fn(p, outparams)
    2: class ll_fz_encode_character_with_fallback_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     out_font = property(_mupdf.ll_fz_encode_character_with_fallback_outparams_out_font_get, _mupdf.ll_fz_encode_character_with_fallback_outparams_out_font_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_encode_character_with_fallback_outparams_swiginit(self, _mupdf.new_ll_fz_encode_character_with_fallback_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_encode_character_with_fallback_outparams
       
       # Register ll_fz_encode_character_with_fallback_outparams in _mupdf:
    1: _mupdf.ll_fz_encode_character_with_fallback_outparams_swigregister(ll_fz_encode_character_with_fallback_outparams)
       
    1: def ll_fz_encode_character_with_fallback_outparams_fn(font, unicode, script, language, outparams):
>>>>>>     return _mupdf.ll_fz_encode_character_with_fallback_outparams_fn(font, unicode, script, language, outparams)
    2: class ll_fz_error_callback_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     user = property(_mupdf.ll_fz_error_callback_outparams_user_get, _mupdf.ll_fz_error_callback_outparams_user_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_error_callback_outparams_swiginit(self, _mupdf.new_ll_fz_error_callback_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_error_callback_outparams
       
       # Register ll_fz_error_callback_outparams in _mupdf:
    1: _mupdf.ll_fz_error_callback_outparams_swigregister(ll_fz_error_callback_outparams)
       
    1: def ll_fz_error_callback_outparams_fn(outparams):
>>>>>>     return _mupdf.ll_fz_error_callback_outparams_fn(outparams)
    2: class ll_fz_eval_function_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     out = property(_mupdf.ll_fz_eval_function_outparams_out_get, _mupdf.ll_fz_eval_function_outparams_out_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_eval_function_outparams_swiginit(self, _mupdf.new_ll_fz_eval_function_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_eval_function_outparams
       
       # Register ll_fz_eval_function_outparams in _mupdf:
    1: _mupdf.ll_fz_eval_function_outparams_swigregister(ll_fz_eval_function_outparams)
       
    1: def ll_fz_eval_function_outparams_fn(func, _in, inlen, outlen, outparams):
>>>>>>     return _mupdf.ll_fz_eval_function_outparams_fn(func, _in, inlen, outlen, outparams)
    2: class ll_fz_fill_pixmap_with_color_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     color = property(_mupdf.ll_fz_fill_pixmap_with_color_outparams_color_get, _mupdf.ll_fz_fill_pixmap_with_color_outparams_color_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_fill_pixmap_with_color_outparams_swiginit(self, _mupdf.new_ll_fz_fill_pixmap_with_color_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_fill_pixmap_with_color_outparams
       
       # Register ll_fz_fill_pixmap_with_color_outparams in _mupdf:
    1: _mupdf.ll_fz_fill_pixmap_with_color_outparams_swigregister(ll_fz_fill_pixmap_with_color_outparams)
       
    1: def ll_fz_fill_pixmap_with_color_outparams_fn(pix, colorspace, color_params, outparams):
>>>>>>     return _mupdf.ll_fz_fill_pixmap_with_color_outparams_fn(pix, colorspace, color_params, outparams)
    2: class ll_fz_get_pixmap_from_image_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     w = property(_mupdf.ll_fz_get_pixmap_from_image_outparams_w_get, _mupdf.ll_fz_get_pixmap_from_image_outparams_w_set)
    1:     h = property(_mupdf.ll_fz_get_pixmap_from_image_outparams_h_get, _mupdf.ll_fz_get_pixmap_from_image_outparams_h_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_get_pixmap_from_image_outparams_swiginit(self, _mupdf.new_ll_fz_get_pixmap_from_image_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_get_pixmap_from_image_outparams
       
       # Register ll_fz_get_pixmap_from_image_outparams in _mupdf:
    1: _mupdf.ll_fz_get_pixmap_from_image_outparams_swigregister(ll_fz_get_pixmap_from_image_outparams)
       
    1: def ll_fz_get_pixmap_from_image_outparams_fn(image, subarea, ctm, outparams):
>>>>>>     return _mupdf.ll_fz_get_pixmap_from_image_outparams_fn(image, subarea, ctm, outparams)
    2: class ll_fz_getopt_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     nargv = property(_mupdf.ll_fz_getopt_outparams_nargv_get, _mupdf.ll_fz_getopt_outparams_nargv_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_getopt_outparams_swiginit(self, _mupdf.new_ll_fz_getopt_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_getopt_outparams
       
       # Register ll_fz_getopt_outparams in _mupdf:
    1: _mupdf.ll_fz_getopt_outparams_swigregister(ll_fz_getopt_outparams)
       
    1: def ll_fz_getopt_outparams_fn(nargc, ostr, outparams):
>>>>>>     return _mupdf.ll_fz_getopt_outparams_fn(nargc, ostr, outparams)
    2: class ll_fz_getopt_long_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     nargv = property(_mupdf.ll_fz_getopt_long_outparams_nargv_get, _mupdf.ll_fz_getopt_long_outparams_nargv_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_getopt_long_outparams_swiginit(self, _mupdf.new_ll_fz_getopt_long_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_getopt_long_outparams
       
       # Register ll_fz_getopt_long_outparams in _mupdf:
    1: _mupdf.ll_fz_getopt_long_outparams_swigregister(ll_fz_getopt_long_outparams)
       
    1: def ll_fz_getopt_long_outparams_fn(nargc, ostr, longopts, outparams):
>>>>>>     return _mupdf.ll_fz_getopt_long_outparams_fn(nargc, ostr, longopts, outparams)
    2: class ll_fz_grisu_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     exp = property(_mupdf.ll_fz_grisu_outparams_exp_get, _mupdf.ll_fz_grisu_outparams_exp_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_grisu_outparams_swiginit(self, _mupdf.new_ll_fz_grisu_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_grisu_outparams
       
       # Register ll_fz_grisu_outparams in _mupdf:
    1: _mupdf.ll_fz_grisu_outparams_swigregister(ll_fz_grisu_outparams)
       
    1: def ll_fz_grisu_outparams_fn(f, s, outparams):
>>>>>>     return _mupdf.ll_fz_grisu_outparams_fn(f, s, outparams)
    2: class ll_fz_has_option_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     val = property(_mupdf.ll_fz_has_option_outparams_val_get, _mupdf.ll_fz_has_option_outparams_val_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_has_option_outparams_swiginit(self, _mupdf.new_ll_fz_has_option_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_has_option_outparams
       
       # Register ll_fz_has_option_outparams in _mupdf:
    1: _mupdf.ll_fz_has_option_outparams_swigregister(ll_fz_has_option_outparams)
       
    1: def ll_fz_has_option_outparams_fn(opts, key, outparams):
>>>>>>     return _mupdf.ll_fz_has_option_outparams_fn(opts, key, outparams)
    2: class ll_fz_image_resolution_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     xres = property(_mupdf.ll_fz_image_resolution_outparams_xres_get, _mupdf.ll_fz_image_resolution_outparams_xres_set)
    1:     yres = property(_mupdf.ll_fz_image_resolution_outparams_yres_get, _mupdf.ll_fz_image_resolution_outparams_yres_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_image_resolution_outparams_swiginit(self, _mupdf.new_ll_fz_image_resolution_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_image_resolution_outparams
       
       # Register ll_fz_image_resolution_outparams in _mupdf:
    1: _mupdf.ll_fz_image_resolution_outparams_swigregister(ll_fz_image_resolution_outparams)
       
    1: def ll_fz_image_resolution_outparams_fn(image, outparams):
>>>>>>     return _mupdf.ll_fz_image_resolution_outparams_fn(image, outparams)
    2: class ll_fz_keep_imp_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.ll_fz_keep_imp_outparams_refs_get, _mupdf.ll_fz_keep_imp_outparams_refs_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_keep_imp_outparams_swiginit(self, _mupdf.new_ll_fz_keep_imp_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_keep_imp_outparams
       
       # Register ll_fz_keep_imp_outparams in _mupdf:
    1: _mupdf.ll_fz_keep_imp_outparams_swigregister(ll_fz_keep_imp_outparams)
       
    1: def ll_fz_keep_imp_outparams_fn(p, outparams):
>>>>>>     return _mupdf.ll_fz_keep_imp_outparams_fn(p, outparams)
    2: class ll_fz_keep_imp16_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.ll_fz_keep_imp16_outparams_refs_get, _mupdf.ll_fz_keep_imp16_outparams_refs_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_keep_imp16_outparams_swiginit(self, _mupdf.new_ll_fz_keep_imp16_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_keep_imp16_outparams
       
       # Register ll_fz_keep_imp16_outparams in _mupdf:
    1: _mupdf.ll_fz_keep_imp16_outparams_swigregister(ll_fz_keep_imp16_outparams)
       
    1: def ll_fz_keep_imp16_outparams_fn(p, outparams):
>>>>>>     return _mupdf.ll_fz_keep_imp16_outparams_fn(p, outparams)
    2: class ll_fz_keep_imp_locked_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     refs = property(_mupdf.ll_fz_keep_imp_locked_outparams_refs_get, _mupdf.ll_fz_keep_imp_locked_outparams_refs_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_keep_imp_locked_outparams_swiginit(self, _mupdf.new_ll_fz_keep_imp_locked_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_keep_imp_locked_outparams
       
       # Register ll_fz_keep_imp_locked_outparams in _mupdf:
    1: _mupdf.ll_fz_keep_imp_locked_outparams_swigregister(ll_fz_keep_imp_locked_outparams)
       
    1: def ll_fz_keep_imp_locked_outparams_fn(p, outparams):
>>>>>>     return _mupdf.ll_fz_keep_imp_locked_outparams_fn(p, outparams)
    2: class ll_fz_lookup_base14_font_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.ll_fz_lookup_base14_font_outparams_len_get, _mupdf.ll_fz_lookup_base14_font_outparams_len_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_lookup_base14_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_base14_font_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_lookup_base14_font_outparams
       
       # Register ll_fz_lookup_base14_font_outparams in _mupdf:
    1: _mupdf.ll_fz_lookup_base14_font_outparams_swigregister(ll_fz_lookup_base14_font_outparams)
       
    1: def ll_fz_lookup_base14_font_outparams_fn(name, outparams):
>>>>>>     return _mupdf.ll_fz_lookup_base14_font_outparams_fn(name, outparams)
    2: class ll_fz_lookup_builtin_font_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.ll_fz_lookup_builtin_font_outparams_len_get, _mupdf.ll_fz_lookup_builtin_font_outparams_len_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_lookup_builtin_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_builtin_font_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_lookup_builtin_font_outparams
       
       # Register ll_fz_lookup_builtin_font_outparams in _mupdf:
    1: _mupdf.ll_fz_lookup_builtin_font_outparams_swigregister(ll_fz_lookup_builtin_font_outparams)
       
    1: def ll_fz_lookup_builtin_font_outparams_fn(name, bold, italic, outparams):
>>>>>>     return _mupdf.ll_fz_lookup_builtin_font_outparams_fn(name, bold, italic, outparams)
    2: class ll_fz_lookup_cjk_font_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.ll_fz_lookup_cjk_font_outparams_len_get, _mupdf.ll_fz_lookup_cjk_font_outparams_len_set)
    1:     index = property(_mupdf.ll_fz_lookup_cjk_font_outparams_index_get, _mupdf.ll_fz_lookup_cjk_font_outparams_index_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_lookup_cjk_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_cjk_font_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_lookup_cjk_font_outparams
       
       # Register ll_fz_lookup_cjk_font_outparams in _mupdf:
    1: _mupdf.ll_fz_lookup_cjk_font_outparams_swigregister(ll_fz_lookup_cjk_font_outparams)
       
    1: def ll_fz_lookup_cjk_font_outparams_fn(ordering, outparams):
>>>>>>     return _mupdf.ll_fz_lookup_cjk_font_outparams_fn(ordering, outparams)
    2: class ll_fz_lookup_cjk_font_by_language_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.ll_fz_lookup_cjk_font_by_language_outparams_len_get, _mupdf.ll_fz_lookup_cjk_font_by_language_outparams_len_set)
    1:     subfont = property(_mupdf.ll_fz_lookup_cjk_font_by_language_outparams_subfont_get, _mupdf.ll_fz_lookup_cjk_font_by_language_outparams_subfont_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_lookup_cjk_font_by_language_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_cjk_font_by_language_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_lookup_cjk_font_by_language_outparams
       
       # Register ll_fz_lookup_cjk_font_by_language_outparams in _mupdf:
    1: _mupdf.ll_fz_lookup_cjk_font_by_language_outparams_swigregister(ll_fz_lookup_cjk_font_by_language_outparams)
       
    1: def ll_fz_lookup_cjk_font_by_language_outparams_fn(lang, outparams):
>>>>>>     return _mupdf.ll_fz_lookup_cjk_font_by_language_outparams_fn(lang, outparams)
    2: class ll_fz_lookup_noto_boxes_font_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.ll_fz_lookup_noto_boxes_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_boxes_font_outparams_len_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_lookup_noto_boxes_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_boxes_font_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_boxes_font_outparams
       
       # Register ll_fz_lookup_noto_boxes_font_outparams in _mupdf:
    1: _mupdf.ll_fz_lookup_noto_boxes_font_outparams_swigregister(ll_fz_lookup_noto_boxes_font_outparams)
       
    1: def ll_fz_lookup_noto_boxes_font_outparams_fn(outparams):
>>>>>>     return _mupdf.ll_fz_lookup_noto_boxes_font_outparams_fn(outparams)
    2: class ll_fz_lookup_noto_emoji_font_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.ll_fz_lookup_noto_emoji_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_emoji_font_outparams_len_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_lookup_noto_emoji_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_emoji_font_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_emoji_font_outparams
       
       # Register ll_fz_lookup_noto_emoji_font_outparams in _mupdf:
    1: _mupdf.ll_fz_lookup_noto_emoji_font_outparams_swigregister(ll_fz_lookup_noto_emoji_font_outparams)
       
    1: def ll_fz_lookup_noto_emoji_font_outparams_fn(outparams):
>>>>>>     return _mupdf.ll_fz_lookup_noto_emoji_font_outparams_fn(outparams)
    2: class ll_fz_lookup_noto_font_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.ll_fz_lookup_noto_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_font_outparams_len_set)
    1:     subfont = property(_mupdf.ll_fz_lookup_noto_font_outparams_subfont_get, _mupdf.ll_fz_lookup_noto_font_outparams_subfont_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_lookup_noto_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_font_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_font_outparams
       
       # Register ll_fz_lookup_noto_font_outparams in _mupdf:
    1: _mupdf.ll_fz_lookup_noto_font_outparams_swigregister(ll_fz_lookup_noto_font_outparams)
       
    1: def ll_fz_lookup_noto_font_outparams_fn(script, lang, outparams):
>>>>>>     return _mupdf.ll_fz_lookup_noto_font_outparams_fn(script, lang, outparams)
    2: class ll_fz_lookup_noto_math_font_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.ll_fz_lookup_noto_math_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_math_font_outparams_len_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_lookup_noto_math_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_math_font_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_math_font_outparams
       
       # Register ll_fz_lookup_noto_math_font_outparams in _mupdf:
    1: _mupdf.ll_fz_lookup_noto_math_font_outparams_swigregister(ll_fz_lookup_noto_math_font_outparams)
       
    1: def ll_fz_lookup_noto_math_font_outparams_fn(outparams):
>>>>>>     return _mupdf.ll_fz_lookup_noto_math_font_outparams_fn(outparams)
    2: class ll_fz_lookup_noto_music_font_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.ll_fz_lookup_noto_music_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_music_font_outparams_len_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_lookup_noto_music_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_music_font_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_music_font_outparams
       
       # Register ll_fz_lookup_noto_music_font_outparams in _mupdf:
    1: _mupdf.ll_fz_lookup_noto_music_font_outparams_swigregister(ll_fz_lookup_noto_music_font_outparams)
       
    1: def ll_fz_lookup_noto_music_font_outparams_fn(outparams):
>>>>>>     return _mupdf.ll_fz_lookup_noto_music_font_outparams_fn(outparams)
    2: class ll_fz_lookup_noto_symbol1_font_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.ll_fz_lookup_noto_symbol1_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_symbol1_font_outparams_len_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_lookup_noto_symbol1_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_symbol1_font_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_symbol1_font_outparams
       
       # Register ll_fz_lookup_noto_symbol1_font_outparams in _mupdf:
    1: _mupdf.ll_fz_lookup_noto_symbol1_font_outparams_swigregister(ll_fz_lookup_noto_symbol1_font_outparams)
       
    1: def ll_fz_lookup_noto_symbol1_font_outparams_fn(outparams):
>>>>>>     return _mupdf.ll_fz_lookup_noto_symbol1_font_outparams_fn(outparams)
    2: class ll_fz_lookup_noto_symbol2_font_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.ll_fz_lookup_noto_symbol2_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_symbol2_font_outparams_len_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_lookup_noto_symbol2_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_symbol2_font_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_symbol2_font_outparams
       
       # Register ll_fz_lookup_noto_symbol2_font_outparams in _mupdf:
    1: _mupdf.ll_fz_lookup_noto_symbol2_font_outparams_swigregister(ll_fz_lookup_noto_symbol2_font_outparams)
       
    1: def ll_fz_lookup_noto_symbol2_font_outparams_fn(outparams):
>>>>>>     return _mupdf.ll_fz_lookup_noto_symbol2_font_outparams_fn(outparams)
    2: class ll_fz_new_brotli_data_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     compressed_length = property(_mupdf.ll_fz_new_brotli_data_outparams_compressed_length_get, _mupdf.ll_fz_new_brotli_data_outparams_compressed_length_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_new_brotli_data_outparams_swiginit(self, _mupdf.new_ll_fz_new_brotli_data_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_new_brotli_data_outparams
       
       # Register ll_fz_new_brotli_data_outparams in _mupdf:
    1: _mupdf.ll_fz_new_brotli_data_outparams_swigregister(ll_fz_new_brotli_data_outparams)
       
    1: def ll_fz_new_brotli_data_outparams_fn(source, source_length, level, outparams):
>>>>>>     return _mupdf.ll_fz_new_brotli_data_outparams_fn(source, source_length, level, outparams)
    2: class ll_fz_new_brotli_data_from_buffer_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     compressed_length = property(_mupdf.ll_fz_new_brotli_data_from_buffer_outparams_compressed_length_get, _mupdf.ll_fz_new_brotli_data_from_buffer_outparams_compressed_length_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_new_brotli_data_from_buffer_outparams_swiginit(self, _mupdf.new_ll_fz_new_brotli_data_from_buffer_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_new_brotli_data_from_buffer_outparams
       
       # Register ll_fz_new_brotli_data_from_buffer_outparams in _mupdf:
    1: _mupdf.ll_fz_new_brotli_data_from_buffer_outparams_swigregister(ll_fz_new_brotli_data_from_buffer_outparams)
       
    1: def ll_fz_new_brotli_data_from_buffer_outparams_fn(buffer, level, outparams):
>>>>>>     return _mupdf.ll_fz_new_brotli_data_from_buffer_outparams_fn(buffer, level, outparams)
    2: class ll_fz_new_deflated_data_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     compressed_length = property(_mupdf.ll_fz_new_deflated_data_outparams_compressed_length_get, _mupdf.ll_fz_new_deflated_data_outparams_compressed_length_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_new_deflated_data_outparams_swiginit(self, _mupdf.new_ll_fz_new_deflated_data_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_new_deflated_data_outparams
       
       # Register ll_fz_new_deflated_data_outparams in _mupdf:
    1: _mupdf.ll_fz_new_deflated_data_outparams_swigregister(ll_fz_new_deflated_data_outparams)
       
    1: def ll_fz_new_deflated_data_outparams_fn(source, source_length, level, outparams):
>>>>>>     return _mupdf.ll_fz_new_deflated_data_outparams_fn(source, source_length, level, outparams)
    2: class ll_fz_new_deflated_data_from_buffer_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     compressed_length = property(_mupdf.ll_fz_new_deflated_data_from_buffer_outparams_compressed_length_get, _mupdf.ll_fz_new_deflated_data_from_buffer_outparams_compressed_length_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_new_deflated_data_from_buffer_outparams_swiginit(self, _mupdf.new_ll_fz_new_deflated_data_from_buffer_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_new_deflated_data_from_buffer_outparams
       
       # Register ll_fz_new_deflated_data_from_buffer_outparams in _mupdf:
    1: _mupdf.ll_fz_new_deflated_data_from_buffer_outparams_swigregister(ll_fz_new_deflated_data_from_buffer_outparams)
       
    1: def ll_fz_new_deflated_data_from_buffer_outparams_fn(buffer, level, outparams):
>>>>>>     return _mupdf.ll_fz_new_deflated_data_from_buffer_outparams_fn(buffer, level, outparams)
    2: class ll_fz_new_display_list_from_svg_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     w = property(_mupdf.ll_fz_new_display_list_from_svg_outparams_w_get, _mupdf.ll_fz_new_display_list_from_svg_outparams_w_set)
    1:     h = property(_mupdf.ll_fz_new_display_list_from_svg_outparams_h_get, _mupdf.ll_fz_new_display_list_from_svg_outparams_h_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_new_display_list_from_svg_outparams_swiginit(self, _mupdf.new_ll_fz_new_display_list_from_svg_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_new_display_list_from_svg_outparams
       
       # Register ll_fz_new_display_list_from_svg_outparams in _mupdf:
    1: _mupdf.ll_fz_new_display_list_from_svg_outparams_swigregister(ll_fz_new_display_list_from_svg_outparams)
       
    1: def ll_fz_new_display_list_from_svg_outparams_fn(buf, base_uri, dir, outparams):
>>>>>>     return _mupdf.ll_fz_new_display_list_from_svg_outparams_fn(buf, base_uri, dir, outparams)
    2: class ll_fz_new_display_list_from_svg_xml_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     w = property(_mupdf.ll_fz_new_display_list_from_svg_xml_outparams_w_get, _mupdf.ll_fz_new_display_list_from_svg_xml_outparams_w_set)
    1:     h = property(_mupdf.ll_fz_new_display_list_from_svg_xml_outparams_h_get, _mupdf.ll_fz_new_display_list_from_svg_xml_outparams_h_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_new_display_list_from_svg_xml_outparams_swiginit(self, _mupdf.new_ll_fz_new_display_list_from_svg_xml_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_new_display_list_from_svg_xml_outparams
       
       # Register ll_fz_new_display_list_from_svg_xml_outparams in _mupdf:
    1: _mupdf.ll_fz_new_display_list_from_svg_xml_outparams_swigregister(ll_fz_new_display_list_from_svg_xml_outparams)
       
    1: def ll_fz_new_display_list_from_svg_xml_outparams_fn(xmldoc, xml, base_uri, dir, outparams):
>>>>>>     return _mupdf.ll_fz_new_display_list_from_svg_xml_outparams_fn(xmldoc, xml, base_uri, dir, outparams)
    2: class ll_fz_new_draw_device_with_options_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     pixmap = property(_mupdf.ll_fz_new_draw_device_with_options_outparams_pixmap_get, _mupdf.ll_fz_new_draw_device_with_options_outparams_pixmap_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_new_draw_device_with_options_outparams_swiginit(self, _mupdf.new_ll_fz_new_draw_device_with_options_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_new_draw_device_with_options_outparams
       
       # Register ll_fz_new_draw_device_with_options_outparams in _mupdf:
    1: _mupdf.ll_fz_new_draw_device_with_options_outparams_swigregister(ll_fz_new_draw_device_with_options_outparams)
       
    1: def ll_fz_new_draw_device_with_options_outparams_fn(options, mediabox, outparams):
>>>>>>     return _mupdf.ll_fz_new_draw_device_with_options_outparams_fn(options, mediabox, outparams)
    2: class ll_fz_new_svg_device_with_id_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     id = property(_mupdf.ll_fz_new_svg_device_with_id_outparams_id_get, _mupdf.ll_fz_new_svg_device_with_id_outparams_id_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_new_svg_device_with_id_outparams_swiginit(self, _mupdf.new_ll_fz_new_svg_device_with_id_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_new_svg_device_with_id_outparams
       
       # Register ll_fz_new_svg_device_with_id_outparams in _mupdf:
    1: _mupdf.ll_fz_new_svg_device_with_id_outparams_swigregister(ll_fz_new_svg_device_with_id_outparams)
       
    1: def ll_fz_new_svg_device_with_id_outparams_fn(out, page_width, page_height, text_format, reuse_images, outparams):
>>>>>>     return _mupdf.ll_fz_new_svg_device_with_id_outparams_fn(out, page_width, page_height, text_format, reuse_images, outparams)
    2: class ll_fz_new_test_device_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     is_color = property(_mupdf.ll_fz_new_test_device_outparams_is_color_get, _mupdf.ll_fz_new_test_device_outparams_is_color_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_new_test_device_outparams_swiginit(self, _mupdf.new_ll_fz_new_test_device_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_new_test_device_outparams
       
       # Register ll_fz_new_test_device_outparams in _mupdf:
    1: _mupdf.ll_fz_new_test_device_outparams_swigregister(ll_fz_new_test_device_outparams)
       
    1: def ll_fz_new_test_device_outparams_fn(threshold, options, passthrough, outparams):
>>>>>>     return _mupdf.ll_fz_new_test_device_outparams_fn(threshold, options, passthrough, outparams)
    2: class ll_fz_open_image_decomp_stream_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     l2factor = property(_mupdf.ll_fz_open_image_decomp_stream_outparams_l2factor_get, _mupdf.ll_fz_open_image_decomp_stream_outparams_l2factor_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_open_image_decomp_stream_outparams_swiginit(self, _mupdf.new_ll_fz_open_image_decomp_stream_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_open_image_decomp_stream_outparams
       
       # Register ll_fz_open_image_decomp_stream_outparams in _mupdf:
    1: _mupdf.ll_fz_open_image_decomp_stream_outparams_swigregister(ll_fz_open_image_decomp_stream_outparams)
       
    1: def ll_fz_open_image_decomp_stream_outparams_fn(arg_0, arg_1, outparams):
>>>>>>     return _mupdf.ll_fz_open_image_decomp_stream_outparams_fn(arg_0, arg_1, outparams)
    2: class ll_fz_open_image_decomp_stream_from_buffer_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     l2factor = property(_mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_l2factor_get, _mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_l2factor_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_swiginit(self, _mupdf.new_ll_fz_open_image_decomp_stream_from_buffer_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_open_image_decomp_stream_from_buffer_outparams
       
       # Register ll_fz_open_image_decomp_stream_from_buffer_outparams in _mupdf:
    1: _mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_swigregister(ll_fz_open_image_decomp_stream_from_buffer_outparams)
       
    1: def ll_fz_open_image_decomp_stream_from_buffer_outparams_fn(arg_0, outparams):
>>>>>>     return _mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_fn(arg_0, outparams)
    2: class ll_fz_page_presentation_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     duration = property(_mupdf.ll_fz_page_presentation_outparams_duration_get, _mupdf.ll_fz_page_presentation_outparams_duration_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_page_presentation_outparams_swiginit(self, _mupdf.new_ll_fz_page_presentation_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_page_presentation_outparams
       
       # Register ll_fz_page_presentation_outparams in _mupdf:
    1: _mupdf.ll_fz_page_presentation_outparams_swigregister(ll_fz_page_presentation_outparams)
       
    1: def ll_fz_page_presentation_outparams_fn(page, transition, outparams):
>>>>>>     return _mupdf.ll_fz_page_presentation_outparams_fn(page, transition, outparams)
    2: class ll_fz_paint_shade_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     cache = property(_mupdf.ll_fz_paint_shade_outparams_cache_get, _mupdf.ll_fz_paint_shade_outparams_cache_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_paint_shade_outparams_swiginit(self, _mupdf.new_ll_fz_paint_shade_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_paint_shade_outparams
       
       # Register ll_fz_paint_shade_outparams in _mupdf:
    1: _mupdf.ll_fz_paint_shade_outparams_swigregister(ll_fz_paint_shade_outparams)
       
    1: def ll_fz_paint_shade_outparams_fn(shade, override_cs, ctm, dest, color_params, bbox, eop, outparams):
>>>>>>     return _mupdf.ll_fz_paint_shade_outparams_fn(shade, override_cs, ctm, dest, color_params, bbox, eop, outparams)
    2: class ll_fz_parse_page_range_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     a = property(_mupdf.ll_fz_parse_page_range_outparams_a_get, _mupdf.ll_fz_parse_page_range_outparams_a_set)
    1:     b = property(_mupdf.ll_fz_parse_page_range_outparams_b_get, _mupdf.ll_fz_parse_page_range_outparams_b_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_parse_page_range_outparams_swiginit(self, _mupdf.new_ll_fz_parse_page_range_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_parse_page_range_outparams
       
       # Register ll_fz_parse_page_range_outparams in _mupdf:
    1: _mupdf.ll_fz_parse_page_range_outparams_swigregister(ll_fz_parse_page_range_outparams)
       
    1: def ll_fz_parse_page_range_outparams_fn(s, n, outparams):
>>>>>>     return _mupdf.ll_fz_parse_page_range_outparams_fn(s, n, outparams)
    2: class ll_fz_pool_array_append_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     idx = property(_mupdf.ll_fz_pool_array_append_outparams_idx_get, _mupdf.ll_fz_pool_array_append_outparams_idx_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_pool_array_append_outparams_swiginit(self, _mupdf.new_ll_fz_pool_array_append_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_pool_array_append_outparams
       
       # Register ll_fz_pool_array_append_outparams in _mupdf:
    1: _mupdf.ll_fz_pool_array_append_outparams_swigregister(ll_fz_pool_array_append_outparams)
       
    1: def ll_fz_pool_array_append_outparams_fn(arr, outparams):
>>>>>>     return _mupdf.ll_fz_pool_array_append_outparams_fn(arr, outparams)
    2: class ll_fz_read_best_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     truncated = property(_mupdf.ll_fz_read_best_outparams_truncated_get, _mupdf.ll_fz_read_best_outparams_truncated_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_read_best_outparams_swiginit(self, _mupdf.new_ll_fz_read_best_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_read_best_outparams
       
       # Register ll_fz_read_best_outparams in _mupdf:
    1: _mupdf.ll_fz_read_best_outparams_swigregister(ll_fz_read_best_outparams)
       
    1: def ll_fz_read_best_outparams_fn(stm, initial, worst_case, outparams):
>>>>>>     return _mupdf.ll_fz_read_best_outparams_fn(stm, initial, worst_case, outparams)
    2: class ll_fz_resolve_link_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     xp = property(_mupdf.ll_fz_resolve_link_outparams_xp_get, _mupdf.ll_fz_resolve_link_outparams_xp_set)
    1:     yp = property(_mupdf.ll_fz_resolve_link_outparams_yp_get, _mupdf.ll_fz_resolve_link_outparams_yp_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_resolve_link_outparams_swiginit(self, _mupdf.new_ll_fz_resolve_link_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_resolve_link_outparams
       
       # Register ll_fz_resolve_link_outparams in _mupdf:
    1: _mupdf.ll_fz_resolve_link_outparams_swigregister(ll_fz_resolve_link_outparams)
       
    1: def ll_fz_resolve_link_outparams_fn(doc, uri, outparams):
>>>>>>     return _mupdf.ll_fz_resolve_link_outparams_fn(doc, uri, outparams)
    2: class ll_fz_search_chapter_page_number_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     hit_mark = property(_mupdf.ll_fz_search_chapter_page_number_outparams_hit_mark_get, _mupdf.ll_fz_search_chapter_page_number_outparams_hit_mark_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_search_chapter_page_number_outparams_swiginit(self, _mupdf.new_ll_fz_search_chapter_page_number_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_search_chapter_page_number_outparams
       
       # Register ll_fz_search_chapter_page_number_outparams in _mupdf:
    1: _mupdf.ll_fz_search_chapter_page_number_outparams_swigregister(ll_fz_search_chapter_page_number_outparams)
       
    1: def ll_fz_search_chapter_page_number_outparams_fn(doc, chapter, page, needle, hit_bbox, hit_max, outparams):
>>>>>>     return _mupdf.ll_fz_search_chapter_page_number_outparams_fn(doc, chapter, page, needle, hit_bbox, hit_max, outparams)
    2: class ll_fz_search_display_list_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     hit_mark = property(_mupdf.ll_fz_search_display_list_outparams_hit_mark_get, _mupdf.ll_fz_search_display_list_outparams_hit_mark_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_search_display_list_outparams_swiginit(self, _mupdf.new_ll_fz_search_display_list_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_search_display_list_outparams
       
       # Register ll_fz_search_display_list_outparams in _mupdf:
    1: _mupdf.ll_fz_search_display_list_outparams_swigregister(ll_fz_search_display_list_outparams)
       
    1: def ll_fz_search_display_list_outparams_fn(list, needle, hit_bbox, hit_max, outparams):
>>>>>>     return _mupdf.ll_fz_search_display_list_outparams_fn(list, needle, hit_bbox, hit_max, outparams)
    2: class ll_fz_search_page_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     hit_mark = property(_mupdf.ll_fz_search_page_outparams_hit_mark_get, _mupdf.ll_fz_search_page_outparams_hit_mark_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_search_page_outparams_swiginit(self, _mupdf.new_ll_fz_search_page_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_search_page_outparams
       
       # Register ll_fz_search_page_outparams in _mupdf:
    1: _mupdf.ll_fz_search_page_outparams_swigregister(ll_fz_search_page_outparams)
       
    1: def ll_fz_search_page_outparams_fn(page, needle, hit_bbox, hit_max, outparams):
>>>>>>     return _mupdf.ll_fz_search_page_outparams_fn(page, needle, hit_bbox, hit_max, outparams)
    2: class ll_fz_search_page_number_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     hit_mark = property(_mupdf.ll_fz_search_page_number_outparams_hit_mark_get, _mupdf.ll_fz_search_page_number_outparams_hit_mark_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_search_page_number_outparams_swiginit(self, _mupdf.new_ll_fz_search_page_number_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_search_page_number_outparams
       
       # Register ll_fz_search_page_number_outparams in _mupdf:
    1: _mupdf.ll_fz_search_page_number_outparams_swigregister(ll_fz_search_page_number_outparams)
       
    1: def ll_fz_search_page_number_outparams_fn(doc, number, needle, hit_bbox, hit_max, outparams):
>>>>>>     return _mupdf.ll_fz_search_page_number_outparams_fn(doc, number, needle, hit_bbox, hit_max, outparams)
    2: class ll_fz_search_stext_page_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     hit_mark = property(_mupdf.ll_fz_search_stext_page_outparams_hit_mark_get, _mupdf.ll_fz_search_stext_page_outparams_hit_mark_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_search_stext_page_outparams_swiginit(self, _mupdf.new_ll_fz_search_stext_page_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_search_stext_page_outparams
       
       # Register ll_fz_search_stext_page_outparams in _mupdf:
    1: _mupdf.ll_fz_search_stext_page_outparams_swigregister(ll_fz_search_stext_page_outparams)
       
    1: def ll_fz_search_stext_page_outparams_fn(text, needle, hit_bbox, hit_max, outparams):
>>>>>>     return _mupdf.ll_fz_search_stext_page_outparams_fn(text, needle, hit_bbox, hit_max, outparams)
    2: class ll_fz_separation_equivalent_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     dst_color = property(_mupdf.ll_fz_separation_equivalent_outparams_dst_color_get, _mupdf.ll_fz_separation_equivalent_outparams_dst_color_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_separation_equivalent_outparams_swiginit(self, _mupdf.new_ll_fz_separation_equivalent_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_separation_equivalent_outparams
       
       # Register ll_fz_separation_equivalent_outparams in _mupdf:
    1: _mupdf.ll_fz_separation_equivalent_outparams_swigregister(ll_fz_separation_equivalent_outparams)
       
    1: def ll_fz_separation_equivalent_outparams_fn(seps, idx, dst_cs, prf, color_params, outparams):
>>>>>>     return _mupdf.ll_fz_separation_equivalent_outparams_fn(seps, idx, dst_cs, prf, color_params, outparams)
    2: class ll_fz_store_scavenge_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     phase = property(_mupdf.ll_fz_store_scavenge_outparams_phase_get, _mupdf.ll_fz_store_scavenge_outparams_phase_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_store_scavenge_outparams_swiginit(self, _mupdf.new_ll_fz_store_scavenge_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_store_scavenge_outparams
       
       # Register ll_fz_store_scavenge_outparams in _mupdf:
    1: _mupdf.ll_fz_store_scavenge_outparams_swigregister(ll_fz_store_scavenge_outparams)
       
    1: def ll_fz_store_scavenge_outparams_fn(size, outparams):
>>>>>>     return _mupdf.ll_fz_store_scavenge_outparams_fn(size, outparams)
    2: class ll_fz_store_scavenge_external_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     phase = property(_mupdf.ll_fz_store_scavenge_external_outparams_phase_get, _mupdf.ll_fz_store_scavenge_external_outparams_phase_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_store_scavenge_external_outparams_swiginit(self, _mupdf.new_ll_fz_store_scavenge_external_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_store_scavenge_external_outparams
       
       # Register ll_fz_store_scavenge_external_outparams in _mupdf:
    1: _mupdf.ll_fz_store_scavenge_external_outparams_swigregister(ll_fz_store_scavenge_external_outparams)
       
    1: def ll_fz_store_scavenge_external_outparams_fn(size, outparams):
>>>>>>     return _mupdf.ll_fz_store_scavenge_external_outparams_fn(size, outparams)
    2: class ll_fz_strsep_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     stringp = property(_mupdf.ll_fz_strsep_outparams_stringp_get, _mupdf.ll_fz_strsep_outparams_stringp_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_strsep_outparams_swiginit(self, _mupdf.new_ll_fz_strsep_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_strsep_outparams
       
       # Register ll_fz_strsep_outparams in _mupdf:
    1: _mupdf.ll_fz_strsep_outparams_swigregister(ll_fz_strsep_outparams)
       
    1: def ll_fz_strsep_outparams_fn(delim, outparams):
>>>>>>     return _mupdf.ll_fz_strsep_outparams_fn(delim, outparams)
    2: class ll_fz_strtof_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     es = property(_mupdf.ll_fz_strtof_outparams_es_get, _mupdf.ll_fz_strtof_outparams_es_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_strtof_outparams_swiginit(self, _mupdf.new_ll_fz_strtof_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_strtof_outparams
       
       # Register ll_fz_strtof_outparams in _mupdf:
    1: _mupdf.ll_fz_strtof_outparams_swigregister(ll_fz_strtof_outparams)
       
    1: def ll_fz_strtof_outparams_fn(s, outparams):
>>>>>>     return _mupdf.ll_fz_strtof_outparams_fn(s, outparams)
    2: class ll_fz_subset_cff_for_gids_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     gids = property(_mupdf.ll_fz_subset_cff_for_gids_outparams_gids_get, _mupdf.ll_fz_subset_cff_for_gids_outparams_gids_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_subset_cff_for_gids_outparams_swiginit(self, _mupdf.new_ll_fz_subset_cff_for_gids_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_subset_cff_for_gids_outparams
       
       # Register ll_fz_subset_cff_for_gids_outparams in _mupdf:
    1: _mupdf.ll_fz_subset_cff_for_gids_outparams_swigregister(ll_fz_subset_cff_for_gids_outparams)
       
    1: def ll_fz_subset_cff_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams):
>>>>>>     return _mupdf.ll_fz_subset_cff_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams)
    2: class ll_fz_subset_ttf_for_gids_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     gids = property(_mupdf.ll_fz_subset_ttf_for_gids_outparams_gids_get, _mupdf.ll_fz_subset_ttf_for_gids_outparams_gids_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_subset_ttf_for_gids_outparams_swiginit(self, _mupdf.new_ll_fz_subset_ttf_for_gids_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_subset_ttf_for_gids_outparams
       
       # Register ll_fz_subset_ttf_for_gids_outparams in _mupdf:
    1: _mupdf.ll_fz_subset_ttf_for_gids_outparams_swigregister(ll_fz_subset_ttf_for_gids_outparams)
       
    1: def ll_fz_subset_ttf_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams):
>>>>>>     return _mupdf.ll_fz_subset_ttf_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams)
    2: class ll_fz_warning_callback_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     user = property(_mupdf.ll_fz_warning_callback_outparams_user_get, _mupdf.ll_fz_warning_callback_outparams_user_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_fz_warning_callback_outparams_swiginit(self, _mupdf.new_ll_fz_warning_callback_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_fz_warning_callback_outparams
       
       # Register ll_fz_warning_callback_outparams in _mupdf:
    1: _mupdf.ll_fz_warning_callback_outparams_swigregister(ll_fz_warning_callback_outparams)
       
    1: def ll_fz_warning_callback_outparams_fn(outparams):
>>>>>>     return _mupdf.ll_fz_warning_callback_outparams_fn(outparams)
    2: class ll_pdf_annot_MK_BC_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     n = property(_mupdf.ll_pdf_annot_MK_BC_outparams_n_get, _mupdf.ll_pdf_annot_MK_BC_outparams_n_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_annot_MK_BC_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_MK_BC_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_annot_MK_BC_outparams
       
       # Register ll_pdf_annot_MK_BC_outparams in _mupdf:
    1: _mupdf.ll_pdf_annot_MK_BC_outparams_swigregister(ll_pdf_annot_MK_BC_outparams)
       
    1: def ll_pdf_annot_MK_BC_outparams_fn(annot, color, outparams):
>>>>>>     return _mupdf.ll_pdf_annot_MK_BC_outparams_fn(annot, color, outparams)
    2: class ll_pdf_annot_MK_BG_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     n = property(_mupdf.ll_pdf_annot_MK_BG_outparams_n_get, _mupdf.ll_pdf_annot_MK_BG_outparams_n_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_annot_MK_BG_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_MK_BG_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_annot_MK_BG_outparams
       
       # Register ll_pdf_annot_MK_BG_outparams in _mupdf:
    1: _mupdf.ll_pdf_annot_MK_BG_outparams_swigregister(ll_pdf_annot_MK_BG_outparams)
       
    1: def ll_pdf_annot_MK_BG_outparams_fn(annot, color, outparams):
>>>>>>     return _mupdf.ll_pdf_annot_MK_BG_outparams_fn(annot, color, outparams)
    2: class ll_pdf_annot_callout_line_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     n = property(_mupdf.ll_pdf_annot_callout_line_outparams_n_get, _mupdf.ll_pdf_annot_callout_line_outparams_n_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_annot_callout_line_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_callout_line_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_annot_callout_line_outparams
       
       # Register ll_pdf_annot_callout_line_outparams in _mupdf:
    1: _mupdf.ll_pdf_annot_callout_line_outparams_swigregister(ll_pdf_annot_callout_line_outparams)
       
    1: def ll_pdf_annot_callout_line_outparams_fn(annot, callout, outparams):
>>>>>>     return _mupdf.ll_pdf_annot_callout_line_outparams_fn(annot, callout, outparams)
    2: class ll_pdf_annot_color_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     n = property(_mupdf.ll_pdf_annot_color_outparams_n_get, _mupdf.ll_pdf_annot_color_outparams_n_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_annot_color_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_color_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_annot_color_outparams
       
       # Register ll_pdf_annot_color_outparams in _mupdf:
    1: _mupdf.ll_pdf_annot_color_outparams_swigregister(ll_pdf_annot_color_outparams)
       
    1: def ll_pdf_annot_color_outparams_fn(annot, color, outparams):
>>>>>>     return _mupdf.ll_pdf_annot_color_outparams_fn(annot, color, outparams)
    2: class ll_pdf_annot_default_appearance_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     font = property(_mupdf.ll_pdf_annot_default_appearance_outparams_font_get, _mupdf.ll_pdf_annot_default_appearance_outparams_font_set)
    1:     size = property(_mupdf.ll_pdf_annot_default_appearance_outparams_size_get, _mupdf.ll_pdf_annot_default_appearance_outparams_size_set)
    1:     n = property(_mupdf.ll_pdf_annot_default_appearance_outparams_n_get, _mupdf.ll_pdf_annot_default_appearance_outparams_n_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_annot_default_appearance_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_default_appearance_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_annot_default_appearance_outparams
       
       # Register ll_pdf_annot_default_appearance_outparams in _mupdf:
    1: _mupdf.ll_pdf_annot_default_appearance_outparams_swigregister(ll_pdf_annot_default_appearance_outparams)
       
    1: def ll_pdf_annot_default_appearance_outparams_fn(annot, color, outparams):
>>>>>>     return _mupdf.ll_pdf_annot_default_appearance_outparams_fn(annot, color, outparams)
    2: class ll_pdf_annot_default_appearance_unmapped_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     size = property(_mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_size_get, _mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_size_set)
    1:     n = property(_mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_n_get, _mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_n_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_default_appearance_unmapped_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_annot_default_appearance_unmapped_outparams
       
       # Register ll_pdf_annot_default_appearance_unmapped_outparams in _mupdf:
    1: _mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_swigregister(ll_pdf_annot_default_appearance_unmapped_outparams)
       
    1: def ll_pdf_annot_default_appearance_unmapped_outparams_fn(annot, font_name, font_name_len, color, outparams):
>>>>>>     return _mupdf.ll_pdf_annot_default_appearance_unmapped_outparams_fn(annot, font_name, font_name_len, color, outparams)
    2: class ll_pdf_annot_interior_color_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     n = property(_mupdf.ll_pdf_annot_interior_color_outparams_n_get, _mupdf.ll_pdf_annot_interior_color_outparams_n_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_annot_interior_color_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_interior_color_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_annot_interior_color_outparams
       
       # Register ll_pdf_annot_interior_color_outparams in _mupdf:
    1: _mupdf.ll_pdf_annot_interior_color_outparams_swigregister(ll_pdf_annot_interior_color_outparams)
       
    1: def ll_pdf_annot_interior_color_outparams_fn(annot, color, outparams):
>>>>>>     return _mupdf.ll_pdf_annot_interior_color_outparams_fn(annot, color, outparams)
    2: class ll_pdf_annot_line_ending_styles_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     start_style = property(_mupdf.ll_pdf_annot_line_ending_styles_outparams_start_style_get, _mupdf.ll_pdf_annot_line_ending_styles_outparams_start_style_set)
    1:     end_style = property(_mupdf.ll_pdf_annot_line_ending_styles_outparams_end_style_get, _mupdf.ll_pdf_annot_line_ending_styles_outparams_end_style_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_annot_line_ending_styles_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_line_ending_styles_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_annot_line_ending_styles_outparams
       
       # Register ll_pdf_annot_line_ending_styles_outparams in _mupdf:
    1: _mupdf.ll_pdf_annot_line_ending_styles_outparams_swigregister(ll_pdf_annot_line_ending_styles_outparams)
       
    1: def ll_pdf_annot_line_ending_styles_outparams_fn(annot, outparams):
>>>>>>     return _mupdf.ll_pdf_annot_line_ending_styles_outparams_fn(annot, outparams)
    2: class ll_pdf_array_get_string_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     sizep = property(_mupdf.ll_pdf_array_get_string_outparams_sizep_get, _mupdf.ll_pdf_array_get_string_outparams_sizep_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_array_get_string_outparams_swiginit(self, _mupdf.new_ll_pdf_array_get_string_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_array_get_string_outparams
       
       # Register ll_pdf_array_get_string_outparams in _mupdf:
    1: _mupdf.ll_pdf_array_get_string_outparams_swigregister(ll_pdf_array_get_string_outparams)
       
    1: def ll_pdf_array_get_string_outparams_fn(array, index, outparams):
>>>>>>     return _mupdf.ll_pdf_array_get_string_outparams_fn(array, index, outparams)
    2: class ll_pdf_count_q_balance_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     prepend = property(_mupdf.ll_pdf_count_q_balance_outparams_prepend_get, _mupdf.ll_pdf_count_q_balance_outparams_prepend_set)
    1:     append = property(_mupdf.ll_pdf_count_q_balance_outparams_append_get, _mupdf.ll_pdf_count_q_balance_outparams_append_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_count_q_balance_outparams_swiginit(self, _mupdf.new_ll_pdf_count_q_balance_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_count_q_balance_outparams
       
       # Register ll_pdf_count_q_balance_outparams in _mupdf:
    1: _mupdf.ll_pdf_count_q_balance_outparams_swigregister(ll_pdf_count_q_balance_outparams)
       
    1: def ll_pdf_count_q_balance_outparams_fn(doc, res, stm, outparams):
>>>>>>     return _mupdf.ll_pdf_count_q_balance_outparams_fn(doc, res, stm, outparams)
    2: class ll_pdf_decode_cmap_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     cpt = property(_mupdf.ll_pdf_decode_cmap_outparams_cpt_get, _mupdf.ll_pdf_decode_cmap_outparams_cpt_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_decode_cmap_outparams_swiginit(self, _mupdf.new_ll_pdf_decode_cmap_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_decode_cmap_outparams
       
       # Register ll_pdf_decode_cmap_outparams in _mupdf:
    1: _mupdf.ll_pdf_decode_cmap_outparams_swigregister(ll_pdf_decode_cmap_outparams)
       
    1: def ll_pdf_decode_cmap_outparams_fn(cmap, s, e, outparams):
>>>>>>     return _mupdf.ll_pdf_decode_cmap_outparams_fn(cmap, s, e, outparams)
    2: class ll_pdf_dict_get_inheritable_string_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     sizep = property(_mupdf.ll_pdf_dict_get_inheritable_string_outparams_sizep_get, _mupdf.ll_pdf_dict_get_inheritable_string_outparams_sizep_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_dict_get_inheritable_string_outparams_swiginit(self, _mupdf.new_ll_pdf_dict_get_inheritable_string_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_dict_get_inheritable_string_outparams
       
       # Register ll_pdf_dict_get_inheritable_string_outparams in _mupdf:
    1: _mupdf.ll_pdf_dict_get_inheritable_string_outparams_swigregister(ll_pdf_dict_get_inheritable_string_outparams)
       
    1: def ll_pdf_dict_get_inheritable_string_outparams_fn(dict, key, outparams):
>>>>>>     return _mupdf.ll_pdf_dict_get_inheritable_string_outparams_fn(dict, key, outparams)
    2: class ll_pdf_dict_get_put_drop_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     old_val = property(_mupdf.ll_pdf_dict_get_put_drop_outparams_old_val_get, _mupdf.ll_pdf_dict_get_put_drop_outparams_old_val_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_dict_get_put_drop_outparams_swiginit(self, _mupdf.new_ll_pdf_dict_get_put_drop_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_dict_get_put_drop_outparams
       
       # Register ll_pdf_dict_get_put_drop_outparams in _mupdf:
    1: _mupdf.ll_pdf_dict_get_put_drop_outparams_swigregister(ll_pdf_dict_get_put_drop_outparams)
       
    1: def ll_pdf_dict_get_put_drop_outparams_fn(dict, key, val, outparams):
>>>>>>     return _mupdf.ll_pdf_dict_get_put_drop_outparams_fn(dict, key, val, outparams)
    2: class ll_pdf_dict_get_string_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     sizep = property(_mupdf.ll_pdf_dict_get_string_outparams_sizep_get, _mupdf.ll_pdf_dict_get_string_outparams_sizep_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_dict_get_string_outparams_swiginit(self, _mupdf.new_ll_pdf_dict_get_string_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_dict_get_string_outparams
       
       # Register ll_pdf_dict_get_string_outparams in _mupdf:
    1: _mupdf.ll_pdf_dict_get_string_outparams_swigregister(ll_pdf_dict_get_string_outparams)
       
    1: def ll_pdf_dict_get_string_outparams_fn(dict, key, outparams):
>>>>>>     return _mupdf.ll_pdf_dict_get_string_outparams_fn(dict, key, outparams)
    2: class ll_pdf_edit_text_field_value_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     selStart = property(_mupdf.ll_pdf_edit_text_field_value_outparams_selStart_get, _mupdf.ll_pdf_edit_text_field_value_outparams_selStart_set)
    1:     selEnd = property(_mupdf.ll_pdf_edit_text_field_value_outparams_selEnd_get, _mupdf.ll_pdf_edit_text_field_value_outparams_selEnd_set)
    1:     newvalue = property(_mupdf.ll_pdf_edit_text_field_value_outparams_newvalue_get, _mupdf.ll_pdf_edit_text_field_value_outparams_newvalue_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_edit_text_field_value_outparams_swiginit(self, _mupdf.new_ll_pdf_edit_text_field_value_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_edit_text_field_value_outparams
       
       # Register ll_pdf_edit_text_field_value_outparams in _mupdf:
    1: _mupdf.ll_pdf_edit_text_field_value_outparams_swigregister(ll_pdf_edit_text_field_value_outparams)
       
    1: def ll_pdf_edit_text_field_value_outparams_fn(widget, value, change, outparams):
>>>>>>     return _mupdf.ll_pdf_edit_text_field_value_outparams_fn(widget, value, change, outparams)
    2: class ll_pdf_eval_function_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     out = property(_mupdf.ll_pdf_eval_function_outparams_out_get, _mupdf.ll_pdf_eval_function_outparams_out_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_eval_function_outparams_swiginit(self, _mupdf.new_ll_pdf_eval_function_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_eval_function_outparams
       
       # Register ll_pdf_eval_function_outparams in _mupdf:
    1: _mupdf.ll_pdf_eval_function_outparams_swigregister(ll_pdf_eval_function_outparams)
       
    1: def ll_pdf_eval_function_outparams_fn(func, _in, inlen, outlen, outparams):
>>>>>>     return _mupdf.ll_pdf_eval_function_outparams_fn(func, _in, inlen, outlen, outparams)
    2: class ll_pdf_field_event_validate_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     newvalue = property(_mupdf.ll_pdf_field_event_validate_outparams_newvalue_get, _mupdf.ll_pdf_field_event_validate_outparams_newvalue_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_field_event_validate_outparams_swiginit(self, _mupdf.new_ll_pdf_field_event_validate_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_field_event_validate_outparams
       
       # Register ll_pdf_field_event_validate_outparams in _mupdf:
    1: _mupdf.ll_pdf_field_event_validate_outparams_swigregister(ll_pdf_field_event_validate_outparams)
       
    1: def ll_pdf_field_event_validate_outparams_fn(doc, field, value, outparams):
>>>>>>     return _mupdf.ll_pdf_field_event_validate_outparams_fn(doc, field, value, outparams)
    2: class ll_pdf_js_event_result_validate_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     newvalue = property(_mupdf.ll_pdf_js_event_result_validate_outparams_newvalue_get, _mupdf.ll_pdf_js_event_result_validate_outparams_newvalue_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_js_event_result_validate_outparams_swiginit(self, _mupdf.new_ll_pdf_js_event_result_validate_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_js_event_result_validate_outparams
       
       # Register ll_pdf_js_event_result_validate_outparams in _mupdf:
    1: _mupdf.ll_pdf_js_event_result_validate_outparams_swigregister(ll_pdf_js_event_result_validate_outparams)
       
    1: def ll_pdf_js_event_result_validate_outparams_fn(js, outparams):
>>>>>>     return _mupdf.ll_pdf_js_event_result_validate_outparams_fn(js, outparams)
    2: class ll_pdf_js_execute_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     result = property(_mupdf.ll_pdf_js_execute_outparams_result_get, _mupdf.ll_pdf_js_execute_outparams_result_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_js_execute_outparams_swiginit(self, _mupdf.new_ll_pdf_js_execute_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_js_execute_outparams
       
       # Register ll_pdf_js_execute_outparams in _mupdf:
    1: _mupdf.ll_pdf_js_execute_outparams_swigregister(ll_pdf_js_execute_outparams)
       
    1: def ll_pdf_js_execute_outparams_fn(js, name, code, outparams):
>>>>>>     return _mupdf.ll_pdf_js_execute_outparams_fn(js, name, code, outparams)
    2: class ll_pdf_load_encoding_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     estrings = property(_mupdf.ll_pdf_load_encoding_outparams_estrings_get, _mupdf.ll_pdf_load_encoding_outparams_estrings_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_load_encoding_outparams_swiginit(self, _mupdf.new_ll_pdf_load_encoding_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_load_encoding_outparams
       
       # Register ll_pdf_load_encoding_outparams in _mupdf:
    1: _mupdf.ll_pdf_load_encoding_outparams_swigregister(ll_pdf_load_encoding_outparams)
       
    1: def ll_pdf_load_encoding_outparams_fn(encoding, outparams):
>>>>>>     return _mupdf.ll_pdf_load_encoding_outparams_fn(encoding, outparams)
    2: class ll_pdf_load_to_unicode_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     strings = property(_mupdf.ll_pdf_load_to_unicode_outparams_strings_get, _mupdf.ll_pdf_load_to_unicode_outparams_strings_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_load_to_unicode_outparams_swiginit(self, _mupdf.new_ll_pdf_load_to_unicode_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_load_to_unicode_outparams
       
       # Register ll_pdf_load_to_unicode_outparams in _mupdf:
    1: _mupdf.ll_pdf_load_to_unicode_outparams_swigregister(ll_pdf_load_to_unicode_outparams)
       
    1: def ll_pdf_load_to_unicode_outparams_fn(doc, font, collection, cmapstm, outparams):
>>>>>>     return _mupdf.ll_pdf_load_to_unicode_outparams_fn(doc, font, collection, cmapstm, outparams)
    2: class ll_pdf_lookup_cmap_full_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     out = property(_mupdf.ll_pdf_lookup_cmap_full_outparams_out_get, _mupdf.ll_pdf_lookup_cmap_full_outparams_out_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_lookup_cmap_full_outparams_swiginit(self, _mupdf.new_ll_pdf_lookup_cmap_full_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_lookup_cmap_full_outparams
       
       # Register ll_pdf_lookup_cmap_full_outparams in _mupdf:
    1: _mupdf.ll_pdf_lookup_cmap_full_outparams_swigregister(ll_pdf_lookup_cmap_full_outparams)
       
    1: def ll_pdf_lookup_cmap_full_outparams_fn(cmap, cpt, outparams):
>>>>>>     return _mupdf.ll_pdf_lookup_cmap_full_outparams_fn(cmap, cpt, outparams)
    2: class ll_pdf_lookup_page_loc_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     parentp = property(_mupdf.ll_pdf_lookup_page_loc_outparams_parentp_get, _mupdf.ll_pdf_lookup_page_loc_outparams_parentp_set)
    1:     indexp = property(_mupdf.ll_pdf_lookup_page_loc_outparams_indexp_get, _mupdf.ll_pdf_lookup_page_loc_outparams_indexp_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_lookup_page_loc_outparams_swiginit(self, _mupdf.new_ll_pdf_lookup_page_loc_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_lookup_page_loc_outparams
       
       # Register ll_pdf_lookup_page_loc_outparams in _mupdf:
    1: _mupdf.ll_pdf_lookup_page_loc_outparams_swigregister(ll_pdf_lookup_page_loc_outparams)
       
    1: def ll_pdf_lookup_page_loc_outparams_fn(doc, needle, outparams):
>>>>>>     return _mupdf.ll_pdf_lookup_page_loc_outparams_fn(doc, needle, outparams)
    2: class ll_pdf_lookup_substitute_font_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.ll_pdf_lookup_substitute_font_outparams_len_get, _mupdf.ll_pdf_lookup_substitute_font_outparams_len_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_lookup_substitute_font_outparams_swiginit(self, _mupdf.new_ll_pdf_lookup_substitute_font_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_lookup_substitute_font_outparams
       
       # Register ll_pdf_lookup_substitute_font_outparams in _mupdf:
    1: _mupdf.ll_pdf_lookup_substitute_font_outparams_swigregister(ll_pdf_lookup_substitute_font_outparams)
       
    1: def ll_pdf_lookup_substitute_font_outparams_fn(mono, serif, bold, italic, outparams):
>>>>>>     return _mupdf.ll_pdf_lookup_substitute_font_outparams_fn(mono, serif, bold, italic, outparams)
    2: class ll_pdf_map_one_to_many_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     many = property(_mupdf.ll_pdf_map_one_to_many_outparams_many_get, _mupdf.ll_pdf_map_one_to_many_outparams_many_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_map_one_to_many_outparams_swiginit(self, _mupdf.new_ll_pdf_map_one_to_many_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_map_one_to_many_outparams
       
       # Register ll_pdf_map_one_to_many_outparams in _mupdf:
    1: _mupdf.ll_pdf_map_one_to_many_outparams_swigregister(ll_pdf_map_one_to_many_outparams)
       
    1: def ll_pdf_map_one_to_many_outparams_fn(cmap, one, len, outparams):
>>>>>>     return _mupdf.ll_pdf_map_one_to_many_outparams_fn(cmap, one, len, outparams)
    2: class ll_pdf_obj_memo_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     memo = property(_mupdf.ll_pdf_obj_memo_outparams_memo_get, _mupdf.ll_pdf_obj_memo_outparams_memo_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_obj_memo_outparams_swiginit(self, _mupdf.new_ll_pdf_obj_memo_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_obj_memo_outparams
       
       # Register ll_pdf_obj_memo_outparams in _mupdf:
    1: _mupdf.ll_pdf_obj_memo_outparams_swigregister(ll_pdf_obj_memo_outparams)
       
    1: def ll_pdf_obj_memo_outparams_fn(obj, bit, outparams):
>>>>>>     return _mupdf.ll_pdf_obj_memo_outparams_fn(obj, bit, outparams)
    2: class ll_pdf_page_presentation_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     duration = property(_mupdf.ll_pdf_page_presentation_outparams_duration_get, _mupdf.ll_pdf_page_presentation_outparams_duration_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_page_presentation_outparams_swiginit(self, _mupdf.new_ll_pdf_page_presentation_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_page_presentation_outparams
       
       # Register ll_pdf_page_presentation_outparams in _mupdf:
    1: _mupdf.ll_pdf_page_presentation_outparams_swigregister(ll_pdf_page_presentation_outparams)
       
    1: def ll_pdf_page_presentation_outparams_fn(page, transition, outparams):
>>>>>>     return _mupdf.ll_pdf_page_presentation_outparams_fn(page, transition, outparams)
    2: class ll_pdf_page_write_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     presources = property(_mupdf.ll_pdf_page_write_outparams_presources_get, _mupdf.ll_pdf_page_write_outparams_presources_set)
    1:     pcontents = property(_mupdf.ll_pdf_page_write_outparams_pcontents_get, _mupdf.ll_pdf_page_write_outparams_pcontents_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_page_write_outparams_swiginit(self, _mupdf.new_ll_pdf_page_write_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_page_write_outparams
       
       # Register ll_pdf_page_write_outparams in _mupdf:
    1: _mupdf.ll_pdf_page_write_outparams_swigregister(ll_pdf_page_write_outparams)
       
    1: def ll_pdf_page_write_outparams_fn(doc, mediabox, outparams):
>>>>>>     return _mupdf.ll_pdf_page_write_outparams_fn(doc, mediabox, outparams)
    2: class ll_pdf_parse_default_appearance_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     font = property(_mupdf.ll_pdf_parse_default_appearance_outparams_font_get, _mupdf.ll_pdf_parse_default_appearance_outparams_font_set)
    1:     size = property(_mupdf.ll_pdf_parse_default_appearance_outparams_size_get, _mupdf.ll_pdf_parse_default_appearance_outparams_size_set)
    1:     n = property(_mupdf.ll_pdf_parse_default_appearance_outparams_n_get, _mupdf.ll_pdf_parse_default_appearance_outparams_n_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_parse_default_appearance_outparams_swiginit(self, _mupdf.new_ll_pdf_parse_default_appearance_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_parse_default_appearance_outparams
       
       # Register ll_pdf_parse_default_appearance_outparams in _mupdf:
    1: _mupdf.ll_pdf_parse_default_appearance_outparams_swigregister(ll_pdf_parse_default_appearance_outparams)
       
    1: def ll_pdf_parse_default_appearance_outparams_fn(da, color, outparams):
>>>>>>     return _mupdf.ll_pdf_parse_default_appearance_outparams_fn(da, color, outparams)
    2: class ll_pdf_parse_default_appearance_unmapped_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     size = property(_mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_size_get, _mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_size_set)
    1:     n = property(_mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_n_get, _mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_n_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_swiginit(self, _mupdf.new_ll_pdf_parse_default_appearance_unmapped_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_parse_default_appearance_unmapped_outparams
       
       # Register ll_pdf_parse_default_appearance_unmapped_outparams in _mupdf:
    1: _mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_swigregister(ll_pdf_parse_default_appearance_unmapped_outparams)
       
    1: def ll_pdf_parse_default_appearance_unmapped_outparams_fn(da, font_name, font_name_len, color, outparams):
>>>>>>     return _mupdf.ll_pdf_parse_default_appearance_unmapped_outparams_fn(da, font_name, font_name_len, color, outparams)
    2: class ll_pdf_parse_ind_obj_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     num = property(_mupdf.ll_pdf_parse_ind_obj_outparams_num_get, _mupdf.ll_pdf_parse_ind_obj_outparams_num_set)
    1:     gen = property(_mupdf.ll_pdf_parse_ind_obj_outparams_gen_get, _mupdf.ll_pdf_parse_ind_obj_outparams_gen_set)
    1:     stm_ofs = property(_mupdf.ll_pdf_parse_ind_obj_outparams_stm_ofs_get, _mupdf.ll_pdf_parse_ind_obj_outparams_stm_ofs_set)
    1:     try_repair = property(_mupdf.ll_pdf_parse_ind_obj_outparams_try_repair_get, _mupdf.ll_pdf_parse_ind_obj_outparams_try_repair_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_parse_ind_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_parse_ind_obj_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_parse_ind_obj_outparams
       
       # Register ll_pdf_parse_ind_obj_outparams in _mupdf:
    1: _mupdf.ll_pdf_parse_ind_obj_outparams_swigregister(ll_pdf_parse_ind_obj_outparams)
       
    1: def ll_pdf_parse_ind_obj_outparams_fn(doc, f, outparams):
>>>>>>     return _mupdf.ll_pdf_parse_ind_obj_outparams_fn(doc, f, outparams)
    2: class ll_pdf_parse_journal_obj_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     onum = property(_mupdf.ll_pdf_parse_journal_obj_outparams_onum_get, _mupdf.ll_pdf_parse_journal_obj_outparams_onum_set)
    1:     ostm = property(_mupdf.ll_pdf_parse_journal_obj_outparams_ostm_get, _mupdf.ll_pdf_parse_journal_obj_outparams_ostm_set)
    1:     newobj = property(_mupdf.ll_pdf_parse_journal_obj_outparams_newobj_get, _mupdf.ll_pdf_parse_journal_obj_outparams_newobj_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_parse_journal_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_parse_journal_obj_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_parse_journal_obj_outparams
       
       # Register ll_pdf_parse_journal_obj_outparams in _mupdf:
    1: _mupdf.ll_pdf_parse_journal_obj_outparams_swigregister(ll_pdf_parse_journal_obj_outparams)
       
    1: def ll_pdf_parse_journal_obj_outparams_fn(doc, stm, outparams):
>>>>>>     return _mupdf.ll_pdf_parse_journal_obj_outparams_fn(doc, stm, outparams)
    2: class ll_pdf_print_encrypted_obj_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     sep = property(_mupdf.ll_pdf_print_encrypted_obj_outparams_sep_get, _mupdf.ll_pdf_print_encrypted_obj_outparams_sep_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_print_encrypted_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_print_encrypted_obj_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_print_encrypted_obj_outparams
       
       # Register ll_pdf_print_encrypted_obj_outparams in _mupdf:
    1: _mupdf.ll_pdf_print_encrypted_obj_outparams_swigregister(ll_pdf_print_encrypted_obj_outparams)
       
    1: def ll_pdf_print_encrypted_obj_outparams_fn(out, obj, tight, ascii, crypt, num, gen, outparams):
>>>>>>     return _mupdf.ll_pdf_print_encrypted_obj_outparams_fn(out, obj, tight, ascii, crypt, num, gen, outparams)
    2: class ll_pdf_process_contents_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     out_res = property(_mupdf.ll_pdf_process_contents_outparams_out_res_get, _mupdf.ll_pdf_process_contents_outparams_out_res_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_process_contents_outparams_swiginit(self, _mupdf.new_ll_pdf_process_contents_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_process_contents_outparams
       
       # Register ll_pdf_process_contents_outparams in _mupdf:
    1: _mupdf.ll_pdf_process_contents_outparams_swigregister(ll_pdf_process_contents_outparams)
       
    1: def ll_pdf_process_contents_outparams_fn(proc, doc, res, stm, cookie, outparams):
>>>>>>     return _mupdf.ll_pdf_process_contents_outparams_fn(proc, doc, res, stm, cookie, outparams)
    2: class ll_pdf_repair_obj_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     stmofsp = property(_mupdf.ll_pdf_repair_obj_outparams_stmofsp_get, _mupdf.ll_pdf_repair_obj_outparams_stmofsp_set)
    1:     stmlenp = property(_mupdf.ll_pdf_repair_obj_outparams_stmlenp_get, _mupdf.ll_pdf_repair_obj_outparams_stmlenp_set)
    1:     encrypt = property(_mupdf.ll_pdf_repair_obj_outparams_encrypt_get, _mupdf.ll_pdf_repair_obj_outparams_encrypt_set)
    1:     id = property(_mupdf.ll_pdf_repair_obj_outparams_id_get, _mupdf.ll_pdf_repair_obj_outparams_id_set)
    1:     page = property(_mupdf.ll_pdf_repair_obj_outparams_page_get, _mupdf.ll_pdf_repair_obj_outparams_page_set)
    1:     tmpofs = property(_mupdf.ll_pdf_repair_obj_outparams_tmpofs_get, _mupdf.ll_pdf_repair_obj_outparams_tmpofs_set)
    1:     root = property(_mupdf.ll_pdf_repair_obj_outparams_root_get, _mupdf.ll_pdf_repair_obj_outparams_root_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_repair_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_repair_obj_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_repair_obj_outparams
       
       # Register ll_pdf_repair_obj_outparams in _mupdf:
    1: _mupdf.ll_pdf_repair_obj_outparams_swigregister(ll_pdf_repair_obj_outparams)
       
    1: def ll_pdf_repair_obj_outparams_fn(doc, buf, outparams):
>>>>>>     return _mupdf.ll_pdf_repair_obj_outparams_fn(doc, buf, outparams)
    2: class ll_pdf_resolve_link_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     xp = property(_mupdf.ll_pdf_resolve_link_outparams_xp_get, _mupdf.ll_pdf_resolve_link_outparams_xp_set)
    1:     yp = property(_mupdf.ll_pdf_resolve_link_outparams_yp_get, _mupdf.ll_pdf_resolve_link_outparams_yp_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_resolve_link_outparams_swiginit(self, _mupdf.new_ll_pdf_resolve_link_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_resolve_link_outparams
       
       # Register ll_pdf_resolve_link_outparams in _mupdf:
    1: _mupdf.ll_pdf_resolve_link_outparams_swigregister(ll_pdf_resolve_link_outparams)
       
    1: def ll_pdf_resolve_link_outparams_fn(doc, uri, outparams):
>>>>>>     return _mupdf.ll_pdf_resolve_link_outparams_fn(doc, uri, outparams)
    2: class ll_pdf_sample_shade_function_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     samples = property(_mupdf.ll_pdf_sample_shade_function_outparams_samples_get, _mupdf.ll_pdf_sample_shade_function_outparams_samples_set)
    1:     func = property(_mupdf.ll_pdf_sample_shade_function_outparams_func_get, _mupdf.ll_pdf_sample_shade_function_outparams_func_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_sample_shade_function_outparams_swiginit(self, _mupdf.new_ll_pdf_sample_shade_function_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_sample_shade_function_outparams
       
       # Register ll_pdf_sample_shade_function_outparams in _mupdf:
    1: _mupdf.ll_pdf_sample_shade_function_outparams_swigregister(ll_pdf_sample_shade_function_outparams)
       
    1: def ll_pdf_sample_shade_function_outparams_fn(n, funcs, t0, t1, outparams):
>>>>>>     return _mupdf.ll_pdf_sample_shade_function_outparams_fn(n, funcs, t0, t1, outparams)
    2: class ll_pdf_signature_contents_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     contents = property(_mupdf.ll_pdf_signature_contents_outparams_contents_get, _mupdf.ll_pdf_signature_contents_outparams_contents_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_signature_contents_outparams_swiginit(self, _mupdf.new_ll_pdf_signature_contents_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_signature_contents_outparams
       
       # Register ll_pdf_signature_contents_outparams in _mupdf:
    1: _mupdf.ll_pdf_signature_contents_outparams_swigregister(ll_pdf_signature_contents_outparams)
       
    1: def ll_pdf_signature_contents_outparams_fn(doc, signature, outparams):
>>>>>>     return _mupdf.ll_pdf_signature_contents_outparams_fn(doc, signature, outparams)
    2: class ll_pdf_sprint_obj_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     len = property(_mupdf.ll_pdf_sprint_obj_outparams_len_get, _mupdf.ll_pdf_sprint_obj_outparams_len_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_sprint_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_sprint_obj_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_sprint_obj_outparams
       
       # Register ll_pdf_sprint_obj_outparams in _mupdf:
    1: _mupdf.ll_pdf_sprint_obj_outparams_swigregister(ll_pdf_sprint_obj_outparams)
       
    1: def ll_pdf_sprint_obj_outparams_fn(buf, cap, obj, tight, ascii, outparams):
>>>>>>     return _mupdf.ll_pdf_sprint_obj_outparams_fn(buf, cap, obj, tight, ascii, outparams)
    2: class ll_pdf_to_string_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     sizep = property(_mupdf.ll_pdf_to_string_outparams_sizep_get, _mupdf.ll_pdf_to_string_outparams_sizep_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_to_string_outparams_swiginit(self, _mupdf.new_ll_pdf_to_string_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_to_string_outparams
       
       # Register ll_pdf_to_string_outparams in _mupdf:
    1: _mupdf.ll_pdf_to_string_outparams_swigregister(ll_pdf_to_string_outparams)
       
    1: def ll_pdf_to_string_outparams_fn(obj, outparams):
>>>>>>     return _mupdf.ll_pdf_to_string_outparams_fn(obj, outparams)
    2: class ll_pdf_tos_make_trm_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     adv = property(_mupdf.ll_pdf_tos_make_trm_outparams_adv_get, _mupdf.ll_pdf_tos_make_trm_outparams_adv_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_tos_make_trm_outparams_swiginit(self, _mupdf.new_ll_pdf_tos_make_trm_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_tos_make_trm_outparams
       
       # Register ll_pdf_tos_make_trm_outparams in _mupdf:
    1: _mupdf.ll_pdf_tos_make_trm_outparams_swigregister(ll_pdf_tos_make_trm_outparams)
       
    1: def ll_pdf_tos_make_trm_outparams_fn(tos, text, fontdesc, cid, trm, outparams):
>>>>>>     return _mupdf.ll_pdf_tos_make_trm_outparams_fn(tos, text, fontdesc, cid, trm, outparams)
    2: class ll_pdf_undoredo_state_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     steps = property(_mupdf.ll_pdf_undoredo_state_outparams_steps_get, _mupdf.ll_pdf_undoredo_state_outparams_steps_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_undoredo_state_outparams_swiginit(self, _mupdf.new_ll_pdf_undoredo_state_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_undoredo_state_outparams
       
       # Register ll_pdf_undoredo_state_outparams in _mupdf:
    1: _mupdf.ll_pdf_undoredo_state_outparams_swigregister(ll_pdf_undoredo_state_outparams)
       
    1: def ll_pdf_undoredo_state_outparams_fn(doc, outparams):
>>>>>>     return _mupdf.ll_pdf_undoredo_state_outparams_fn(doc, outparams)
    2: class ll_pdf_walk_tree_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     names = property(_mupdf.ll_pdf_walk_tree_outparams_names_get, _mupdf.ll_pdf_walk_tree_outparams_names_set)
    1:     values = property(_mupdf.ll_pdf_walk_tree_outparams_values_get, _mupdf.ll_pdf_walk_tree_outparams_values_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_walk_tree_outparams_swiginit(self, _mupdf.new_ll_pdf_walk_tree_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_walk_tree_outparams
       
       # Register ll_pdf_walk_tree_outparams in _mupdf:
    1: _mupdf.ll_pdf_walk_tree_outparams_swigregister(ll_pdf_walk_tree_outparams)
       
    1: def ll_pdf_walk_tree_outparams_fn(tree, kid_name, arrive, leave, arg, outparams):
>>>>>>     return _mupdf.ll_pdf_walk_tree_outparams_fn(tree, kid_name, arrive, leave, arg, outparams)
    2: class ll_pdf_zugferd_profile_outparams(object):
    1:     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    1:     __repr__ = _swig_repr
    1:     version = property(_mupdf.ll_pdf_zugferd_profile_outparams_version_get, _mupdf.ll_pdf_zugferd_profile_outparams_version_set)
       
    1:     def __init__(self):
>>>>>>         _mupdf.ll_pdf_zugferd_profile_outparams_swiginit(self, _mupdf.new_ll_pdf_zugferd_profile_outparams())
    1:     __swig_destroy__ = _mupdf.delete_ll_pdf_zugferd_profile_outparams
       
       # Register ll_pdf_zugferd_profile_outparams in _mupdf:
    1: _mupdf.ll_pdf_zugferd_profile_outparams_swigregister(ll_pdf_zugferd_profile_outparams)
       
    1: def ll_pdf_zugferd_profile_outparams_fn(doc, outparams):
>>>>>>     return _mupdf.ll_pdf_zugferd_profile_outparams_fn(doc, outparams)
    1: UCDN_EAST_ASIAN_F = _mupdf.UCDN_EAST_ASIAN_F
    1: UCDN_EAST_ASIAN_H = _mupdf.UCDN_EAST_ASIAN_H
    1: UCDN_EAST_ASIAN_W = _mupdf.UCDN_EAST_ASIAN_W
    1: UCDN_EAST_ASIAN_NA = _mupdf.UCDN_EAST_ASIAN_NA
    1: UCDN_EAST_ASIAN_A = _mupdf.UCDN_EAST_ASIAN_A
    1: UCDN_EAST_ASIAN_N = _mupdf.UCDN_EAST_ASIAN_N
    1: UCDN_SCRIPT_COMMON = _mupdf.UCDN_SCRIPT_COMMON
    1: UCDN_SCRIPT_LATIN = _mupdf.UCDN_SCRIPT_LATIN
    1: UCDN_SCRIPT_GREEK = _mupdf.UCDN_SCRIPT_GREEK
    1: UCDN_SCRIPT_CYRILLIC = _mupdf.UCDN_SCRIPT_CYRILLIC
    1: UCDN_SCRIPT_ARMENIAN = _mupdf.UCDN_SCRIPT_ARMENIAN
    1: UCDN_SCRIPT_HEBREW = _mupdf.UCDN_SCRIPT_HEBREW
    1: UCDN_SCRIPT_ARABIC = _mupdf.UCDN_SCRIPT_ARABIC
    1: UCDN_SCRIPT_SYRIAC = _mupdf.UCDN_SCRIPT_SYRIAC
    1: UCDN_SCRIPT_THAANA = _mupdf.UCDN_SCRIPT_THAANA
    1: UCDN_SCRIPT_DEVANAGARI = _mupdf.UCDN_SCRIPT_DEVANAGARI
    1: UCDN_SCRIPT_BENGALI = _mupdf.UCDN_SCRIPT_BENGALI
    1: UCDN_SCRIPT_GURMUKHI = _mupdf.UCDN_SCRIPT_GURMUKHI
    1: UCDN_SCRIPT_GUJARATI = _mupdf.UCDN_SCRIPT_GUJARATI
    1: UCDN_SCRIPT_ORIYA = _mupdf.UCDN_SCRIPT_ORIYA
    1: UCDN_SCRIPT_TAMIL = _mupdf.UCDN_SCRIPT_TAMIL
    1: UCDN_SCRIPT_TELUGU = _mupdf.UCDN_SCRIPT_TELUGU
    1: UCDN_SCRIPT_KANNADA = _mupdf.UCDN_SCRIPT_KANNADA
    1: UCDN_SCRIPT_MALAYALAM = _mupdf.UCDN_SCRIPT_MALAYALAM
    1: UCDN_SCRIPT_SINHALA = _mupdf.UCDN_SCRIPT_SINHALA
    1: UCDN_SCRIPT_THAI = _mupdf.UCDN_SCRIPT_THAI
    1: UCDN_SCRIPT_LAO = _mupdf.UCDN_SCRIPT_LAO
    1: UCDN_SCRIPT_TIBETAN = _mupdf.UCDN_SCRIPT_TIBETAN
    1: UCDN_SCRIPT_MYANMAR = _mupdf.UCDN_SCRIPT_MYANMAR
    1: UCDN_SCRIPT_GEORGIAN = _mupdf.UCDN_SCRIPT_GEORGIAN
    1: UCDN_SCRIPT_HANGUL = _mupdf.UCDN_SCRIPT_HANGUL
    1: UCDN_SCRIPT_ETHIOPIC = _mupdf.UCDN_SCRIPT_ETHIOPIC
    1: UCDN_SCRIPT_CHEROKEE = _mupdf.UCDN_SCRIPT_CHEROKEE
    1: UCDN_SCRIPT_CANADIAN_ABORIGINAL = _mupdf.UCDN_SCRIPT_CANADIAN_ABORIGINAL
    1: UCDN_SCRIPT_OGHAM = _mupdf.UCDN_SCRIPT_OGHAM
    1: UCDN_SCRIPT_RUNIC = _mupdf.UCDN_SCRIPT_RUNIC
    1: UCDN_SCRIPT_KHMER = _mupdf.UCDN_SCRIPT_KHMER
    1: UCDN_SCRIPT_MONGOLIAN = _mupdf.UCDN_SCRIPT_MONGOLIAN
    1: UCDN_SCRIPT_HIRAGANA = _mupdf.UCDN_SCRIPT_HIRAGANA
    1: UCDN_SCRIPT_KATAKANA = _mupdf.UCDN_SCRIPT_KATAKANA
    1: UCDN_SCRIPT_BOPOMOFO = _mupdf.UCDN_SCRIPT_BOPOMOFO
    1: UCDN_SCRIPT_HAN = _mupdf.UCDN_SCRIPT_HAN
    1: UCDN_SCRIPT_YI = _mupdf.UCDN_SCRIPT_YI
    1: UCDN_SCRIPT_OLD_ITALIC = _mupdf.UCDN_SCRIPT_OLD_ITALIC
    1: UCDN_SCRIPT_GOTHIC = _mupdf.UCDN_SCRIPT_GOTHIC
    1: UCDN_SCRIPT_DESERET = _mupdf.UCDN_SCRIPT_DESERET
    1: UCDN_SCRIPT_INHERITED = _mupdf.UCDN_SCRIPT_INHERITED
    1: UCDN_SCRIPT_TAGALOG = _mupdf.UCDN_SCRIPT_TAGALOG
    1: UCDN_SCRIPT_HANUNOO = _mupdf.UCDN_SCRIPT_HANUNOO
    1: UCDN_SCRIPT_BUHID = _mupdf.UCDN_SCRIPT_BUHID
    1: UCDN_SCRIPT_TAGBANWA = _mupdf.UCDN_SCRIPT_TAGBANWA
    1: UCDN_SCRIPT_LIMBU = _mupdf.UCDN_SCRIPT_LIMBU
    1: UCDN_SCRIPT_TAI_LE = _mupdf.UCDN_SCRIPT_TAI_LE
    1: UCDN_SCRIPT_LINEAR_B = _mupdf.UCDN_SCRIPT_LINEAR_B
    1: UCDN_SCRIPT_UGARITIC = _mupdf.UCDN_SCRIPT_UGARITIC
    1: UCDN_SCRIPT_SHAVIAN = _mupdf.UCDN_SCRIPT_SHAVIAN
    1: UCDN_SCRIPT_OSMANYA = _mupdf.UCDN_SCRIPT_OSMANYA
    1: UCDN_SCRIPT_CYPRIOT = _mupdf.UCDN_SCRIPT_CYPRIOT
    1: UCDN_SCRIPT_BRAILLE = _mupdf.UCDN_SCRIPT_BRAILLE
    1: UCDN_SCRIPT_BUGINESE = _mupdf.UCDN_SCRIPT_BUGINESE
    1: UCDN_SCRIPT_COPTIC = _mupdf.UCDN_SCRIPT_COPTIC
    1: UCDN_SCRIPT_NEW_TAI_LUE = _mupdf.UCDN_SCRIPT_NEW_TAI_LUE
    1: UCDN_SCRIPT_GLAGOLITIC = _mupdf.UCDN_SCRIPT_GLAGOLITIC
    1: UCDN_SCRIPT_TIFINAGH = _mupdf.UCDN_SCRIPT_TIFINAGH
    1: UCDN_SCRIPT_SYLOTI_NAGRI = _mupdf.UCDN_SCRIPT_SYLOTI_NAGRI
    1: UCDN_SCRIPT_OLD_PERSIAN = _mupdf.UCDN_SCRIPT_OLD_PERSIAN
    1: UCDN_SCRIPT_KHAROSHTHI = _mupdf.UCDN_SCRIPT_KHAROSHTHI
    1: UCDN_SCRIPT_BALINESE = _mupdf.UCDN_SCRIPT_BALINESE
    1: UCDN_SCRIPT_CUNEIFORM = _mupdf.UCDN_SCRIPT_CUNEIFORM
    1: UCDN_SCRIPT_PHOENICIAN = _mupdf.UCDN_SCRIPT_PHOENICIAN
    1: UCDN_SCRIPT_PHAGS_PA = _mupdf.UCDN_SCRIPT_PHAGS_PA
    1: UCDN_SCRIPT_NKO = _mupdf.UCDN_SCRIPT_NKO
    1: UCDN_SCRIPT_SUNDANESE = _mupdf.UCDN_SCRIPT_SUNDANESE
    1: UCDN_SCRIPT_LEPCHA = _mupdf.UCDN_SCRIPT_LEPCHA
    1: UCDN_SCRIPT_OL_CHIKI = _mupdf.UCDN_SCRIPT_OL_CHIKI
    1: UCDN_SCRIPT_VAI = _mupdf.UCDN_SCRIPT_VAI
    1: UCDN_SCRIPT_SAURASHTRA = _mupdf.UCDN_SCRIPT_SAURASHTRA
    1: UCDN_SCRIPT_KAYAH_LI = _mupdf.UCDN_SCRIPT_KAYAH_LI
    1: UCDN_SCRIPT_REJANG = _mupdf.UCDN_SCRIPT_REJANG
    1: UCDN_SCRIPT_LYCIAN = _mupdf.UCDN_SCRIPT_LYCIAN
    1: UCDN_SCRIPT_CARIAN = _mupdf.UCDN_SCRIPT_CARIAN
    1: UCDN_SCRIPT_LYDIAN = _mupdf.UCDN_SCRIPT_LYDIAN
    1: UCDN_SCRIPT_CHAM = _mupdf.UCDN_SCRIPT_CHAM
    1: UCDN_SCRIPT_TAI_THAM = _mupdf.UCDN_SCRIPT_TAI_THAM
    1: UCDN_SCRIPT_TAI_VIET = _mupdf.UCDN_SCRIPT_TAI_VIET
    1: UCDN_SCRIPT_AVESTAN = _mupdf.UCDN_SCRIPT_AVESTAN
    1: UCDN_SCRIPT_EGYPTIAN_HIEROGLYPHS = _mupdf.UCDN_SCRIPT_EGYPTIAN_HIEROGLYPHS
    1: UCDN_SCRIPT_SAMARITAN = _mupdf.UCDN_SCRIPT_SAMARITAN
    1: UCDN_SCRIPT_LISU = _mupdf.UCDN_SCRIPT_LISU
    1: UCDN_SCRIPT_BAMUM = _mupdf.UCDN_SCRIPT_BAMUM
    1: UCDN_SCRIPT_JAVANESE = _mupdf.UCDN_SCRIPT_JAVANESE
    1: UCDN_SCRIPT_MEETEI_MAYEK = _mupdf.UCDN_SCRIPT_MEETEI_MAYEK
    1: UCDN_SCRIPT_IMPERIAL_ARAMAIC = _mupdf.UCDN_SCRIPT_IMPERIAL_ARAMAIC
    1: UCDN_SCRIPT_OLD_SOUTH_ARABIAN = _mupdf.UCDN_SCRIPT_OLD_SOUTH_ARABIAN
    1: UCDN_SCRIPT_INSCRIPTIONAL_PARTHIAN = _mupdf.UCDN_SCRIPT_INSCRIPTIONAL_PARTHIAN
    1: UCDN_SCRIPT_INSCRIPTIONAL_PAHLAVI = _mupdf.UCDN_SCRIPT_INSCRIPTIONAL_PAHLAVI
    1: UCDN_SCRIPT_OLD_TURKIC = _mupdf.UCDN_SCRIPT_OLD_TURKIC
    1: UCDN_SCRIPT_KAITHI = _mupdf.UCDN_SCRIPT_KAITHI
    1: UCDN_SCRIPT_BATAK = _mupdf.UCDN_SCRIPT_BATAK
    1: UCDN_SCRIPT_BRAHMI = _mupdf.UCDN_SCRIPT_BRAHMI
    1: UCDN_SCRIPT_MANDAIC = _mupdf.UCDN_SCRIPT_MANDAIC
    1: UCDN_SCRIPT_CHAKMA = _mupdf.UCDN_SCRIPT_CHAKMA
    1: UCDN_SCRIPT_MEROITIC_CURSIVE = _mupdf.UCDN_SCRIPT_MEROITIC_CURSIVE
    1: UCDN_SCRIPT_MEROITIC_HIEROGLYPHS = _mupdf.UCDN_SCRIPT_MEROITIC_HIEROGLYPHS
    1: UCDN_SCRIPT_MIAO = _mupdf.UCDN_SCRIPT_MIAO
    1: UCDN_SCRIPT_SHARADA = _mupdf.UCDN_SCRIPT_SHARADA
    1: UCDN_SCRIPT_SORA_SOMPENG = _mupdf.UCDN_SCRIPT_SORA_SOMPENG
    1: UCDN_SCRIPT_TAKRI = _mupdf.UCDN_SCRIPT_TAKRI
    1: UCDN_SCRIPT_UNKNOWN = _mupdf.UCDN_SCRIPT_UNKNOWN
    1: UCDN_SCRIPT_BASSA_VAH = _mupdf.UCDN_SCRIPT_BASSA_VAH
    1: UCDN_SCRIPT_CAUCASIAN_ALBANIAN = _mupdf.UCDN_SCRIPT_CAUCASIAN_ALBANIAN
    1: UCDN_SCRIPT_DUPLOYAN = _mupdf.UCDN_SCRIPT_DUPLOYAN
    1: UCDN_SCRIPT_ELBASAN = _mupdf.UCDN_SCRIPT_ELBASAN
    1: UCDN_SCRIPT_GRANTHA = _mupdf.UCDN_SCRIPT_GRANTHA
    1: UCDN_SCRIPT_KHOJKI = _mupdf.UCDN_SCRIPT_KHOJKI
    1: UCDN_SCRIPT_KHUDAWADI = _mupdf.UCDN_SCRIPT_KHUDAWADI
    1: UCDN_SCRIPT_LINEAR_A = _mupdf.UCDN_SCRIPT_LINEAR_A
    1: UCDN_SCRIPT_MAHAJANI = _mupdf.UCDN_SCRIPT_MAHAJANI
    1: UCDN_SCRIPT_MANICHAEAN = _mupdf.UCDN_SCRIPT_MANICHAEAN
    1: UCDN_SCRIPT_MENDE_KIKAKUI = _mupdf.UCDN_SCRIPT_MENDE_KIKAKUI
    1: UCDN_SCRIPT_MODI = _mupdf.UCDN_SCRIPT_MODI
    1: UCDN_SCRIPT_MRO = _mupdf.UCDN_SCRIPT_MRO
    1: UCDN_SCRIPT_NABATAEAN = _mupdf.UCDN_SCRIPT_NABATAEAN
    1: UCDN_SCRIPT_OLD_NORTH_ARABIAN = _mupdf.UCDN_SCRIPT_OLD_NORTH_ARABIAN
    1: UCDN_SCRIPT_OLD_PERMIC = _mupdf.UCDN_SCRIPT_OLD_PERMIC
    1: UCDN_SCRIPT_PAHAWH_HMONG = _mupdf.UCDN_SCRIPT_PAHAWH_HMONG
    1: UCDN_SCRIPT_PALMYRENE = _mupdf.UCDN_SCRIPT_PALMYRENE
    1: UCDN_SCRIPT_PAU_CIN_HAU = _mupdf.UCDN_SCRIPT_PAU_CIN_HAU
    1: UCDN_SCRIPT_PSALTER_PAHLAVI = _mupdf.UCDN_SCRIPT_PSALTER_PAHLAVI
    1: UCDN_SCRIPT_SIDDHAM = _mupdf.UCDN_SCRIPT_SIDDHAM
    1: UCDN_SCRIPT_TIRHUTA = _mupdf.UCDN_SCRIPT_TIRHUTA
    1: UCDN_SCRIPT_WARANG_CITI = _mupdf.UCDN_SCRIPT_WARANG_CITI
    1: UCDN_SCRIPT_AHOM = _mupdf.UCDN_SCRIPT_AHOM
    1: UCDN_SCRIPT_ANATOLIAN_HIEROGLYPHS = _mupdf.UCDN_SCRIPT_ANATOLIAN_HIEROGLYPHS
    1: UCDN_SCRIPT_HATRAN = _mupdf.UCDN_SCRIPT_HATRAN
    1: UCDN_SCRIPT_MULTANI = _mupdf.UCDN_SCRIPT_MULTANI
    1: UCDN_SCRIPT_OLD_HUNGARIAN = _mupdf.UCDN_SCRIPT_OLD_HUNGARIAN
    1: UCDN_SCRIPT_SIGNWRITING = _mupdf.UCDN_SCRIPT_SIGNWRITING
    1: UCDN_SCRIPT_ADLAM = _mupdf.UCDN_SCRIPT_ADLAM
    1: UCDN_SCRIPT_BHAIKSUKI = _mupdf.UCDN_SCRIPT_BHAIKSUKI
    1: UCDN_SCRIPT_MARCHEN = _mupdf.UCDN_SCRIPT_MARCHEN
    1: UCDN_SCRIPT_NEWA = _mupdf.UCDN_SCRIPT_NEWA
    1: UCDN_SCRIPT_OSAGE = _mupdf.UCDN_SCRIPT_OSAGE
    1: UCDN_SCRIPT_TANGUT = _mupdf.UCDN_SCRIPT_TANGUT
    1: UCDN_SCRIPT_MASARAM_GONDI = _mupdf.UCDN_SCRIPT_MASARAM_GONDI
    1: UCDN_SCRIPT_NUSHU = _mupdf.UCDN_SCRIPT_NUSHU
    1: UCDN_SCRIPT_SOYOMBO = _mupdf.UCDN_SCRIPT_SOYOMBO
    1: UCDN_SCRIPT_ZANABAZAR_SQUARE = _mupdf.UCDN_SCRIPT_ZANABAZAR_SQUARE
    1: UCDN_SCRIPT_DOGRA = _mupdf.UCDN_SCRIPT_DOGRA
    1: UCDN_SCRIPT_GUNJALA_GONDI = _mupdf.UCDN_SCRIPT_GUNJALA_GONDI
    1: UCDN_SCRIPT_HANIFI_ROHINGYA = _mupdf.UCDN_SCRIPT_HANIFI_ROHINGYA
    1: UCDN_SCRIPT_MAKASAR = _mupdf.UCDN_SCRIPT_MAKASAR
    1: UCDN_SCRIPT_MEDEFAIDRIN = _mupdf.UCDN_SCRIPT_MEDEFAIDRIN
    1: UCDN_SCRIPT_OLD_SOGDIAN = _mupdf.UCDN_SCRIPT_OLD_SOGDIAN
    1: UCDN_SCRIPT_SOGDIAN = _mupdf.UCDN_SCRIPT_SOGDIAN
    1: UCDN_SCRIPT_ELYMAIC = _mupdf.UCDN_SCRIPT_ELYMAIC
    1: UCDN_SCRIPT_NANDINAGARI = _mupdf.UCDN_SCRIPT_NANDINAGARI
    1: UCDN_SCRIPT_NYIAKENG_PUACHUE_HMONG = _mupdf.UCDN_SCRIPT_NYIAKENG_PUACHUE_HMONG
    1: UCDN_SCRIPT_WANCHO = _mupdf.UCDN_SCRIPT_WANCHO
    1: UCDN_SCRIPT_CHORASMIAN = _mupdf.UCDN_SCRIPT_CHORASMIAN
    1: UCDN_SCRIPT_DIVES_AKURU = _mupdf.UCDN_SCRIPT_DIVES_AKURU
    1: UCDN_SCRIPT_KHITAN_SMALL_SCRIPT = _mupdf.UCDN_SCRIPT_KHITAN_SMALL_SCRIPT
    1: UCDN_SCRIPT_YEZIDI = _mupdf.UCDN_SCRIPT_YEZIDI
    1: UCDN_SCRIPT_VITHKUQI = _mupdf.UCDN_SCRIPT_VITHKUQI
    1: UCDN_SCRIPT_OLD_UYGHUR = _mupdf.UCDN_SCRIPT_OLD_UYGHUR
    1: UCDN_SCRIPT_CYPRO_MINOAN = _mupdf.UCDN_SCRIPT_CYPRO_MINOAN
    1: UCDN_SCRIPT_TANGSA = _mupdf.UCDN_SCRIPT_TANGSA
    1: UCDN_SCRIPT_TOTO = _mupdf.UCDN_SCRIPT_TOTO
    1: UCDN_SCRIPT_KAWI = _mupdf.UCDN_SCRIPT_KAWI
    1: UCDN_SCRIPT_NAG_MUNDARI = _mupdf.UCDN_SCRIPT_NAG_MUNDARI
    1: UCDN_SCRIPT_TODHRI = _mupdf.UCDN_SCRIPT_TODHRI
    1: UCDN_SCRIPT_GARAY = _mupdf.UCDN_SCRIPT_GARAY
    1: UCDN_SCRIPT_TULU_TIGALARI = _mupdf.UCDN_SCRIPT_TULU_TIGALARI
    1: UCDN_SCRIPT_SUNUWAR = _mupdf.UCDN_SCRIPT_SUNUWAR
    1: UCDN_SCRIPT_GURUNG_KHEMA = _mupdf.UCDN_SCRIPT_GURUNG_KHEMA
    1: UCDN_SCRIPT_KIRAT_RAI = _mupdf.UCDN_SCRIPT_KIRAT_RAI
    1: UCDN_SCRIPT_OL_ONAL = _mupdf.UCDN_SCRIPT_OL_ONAL
    1: UCDN_LAST_SCRIPT = _mupdf.UCDN_LAST_SCRIPT
    1: UCDN_LINEBREAK_CLASS_OP = _mupdf.UCDN_LINEBREAK_CLASS_OP
    1: UCDN_LINEBREAK_CLASS_CL = _mupdf.UCDN_LINEBREAK_CLASS_CL
    1: UCDN_LINEBREAK_CLASS_CP = _mupdf.UCDN_LINEBREAK_CLASS_CP
    1: UCDN_LINEBREAK_CLASS_QU = _mupdf.UCDN_LINEBREAK_CLASS_QU
    1: UCDN_LINEBREAK_CLASS_GL = _mupdf.UCDN_LINEBREAK_CLASS_GL
    1: UCDN_LINEBREAK_CLASS_NS = _mupdf.UCDN_LINEBREAK_CLASS_NS
    1: UCDN_LINEBREAK_CLASS_EX = _mupdf.UCDN_LINEBREAK_CLASS_EX
    1: UCDN_LINEBREAK_CLASS_SY = _mupdf.UCDN_LINEBREAK_CLASS_SY
    1: UCDN_LINEBREAK_CLASS_IS = _mupdf.UCDN_LINEBREAK_CLASS_IS
    1: UCDN_LINEBREAK_CLASS_PR = _mupdf.UCDN_LINEBREAK_CLASS_PR
    1: UCDN_LINEBREAK_CLASS_PO = _mupdf.UCDN_LINEBREAK_CLASS_PO
    1: UCDN_LINEBREAK_CLASS_NU = _mupdf.UCDN_LINEBREAK_CLASS_NU
    1: UCDN_LINEBREAK_CLASS_AL = _mupdf.UCDN_LINEBREAK_CLASS_AL
    1: UCDN_LINEBREAK_CLASS_HL = _mupdf.UCDN_LINEBREAK_CLASS_HL
    1: UCDN_LINEBREAK_CLASS_ID = _mupdf.UCDN_LINEBREAK_CLASS_ID
    1: UCDN_LINEBREAK_CLASS_IN = _mupdf.UCDN_LINEBREAK_CLASS_IN
    1: UCDN_LINEBREAK_CLASS_HY = _mupdf.UCDN_LINEBREAK_CLASS_HY
    1: UCDN_LINEBREAK_CLASS_BA = _mupdf.UCDN_LINEBREAK_CLASS_BA
    1: UCDN_LINEBREAK_CLASS_BB = _mupdf.UCDN_LINEBREAK_CLASS_BB
    1: UCDN_LINEBREAK_CLASS_B2 = _mupdf.UCDN_LINEBREAK_CLASS_B2
    1: UCDN_LINEBREAK_CLASS_ZW = _mupdf.UCDN_LINEBREAK_CLASS_ZW
    1: UCDN_LINEBREAK_CLASS_CM = _mupdf.UCDN_LINEBREAK_CLASS_CM
    1: UCDN_LINEBREAK_CLASS_WJ = _mupdf.UCDN_LINEBREAK_CLASS_WJ
    1: UCDN_LINEBREAK_CLASS_H2 = _mupdf.UCDN_LINEBREAK_CLASS_H2
    1: UCDN_LINEBREAK_CLASS_H3 = _mupdf.UCDN_LINEBREAK_CLASS_H3
    1: UCDN_LINEBREAK_CLASS_JL = _mupdf.UCDN_LINEBREAK_CLASS_JL
    1: UCDN_LINEBREAK_CLASS_JV = _mupdf.UCDN_LINEBREAK_CLASS_JV
    1: UCDN_LINEBREAK_CLASS_JT = _mupdf.UCDN_LINEBREAK_CLASS_JT
    1: UCDN_LINEBREAK_CLASS_RI = _mupdf.UCDN_LINEBREAK_CLASS_RI
    1: UCDN_LINEBREAK_CLASS_EB = _mupdf.UCDN_LINEBREAK_CLASS_EB
    1: UCDN_LINEBREAK_CLASS_EM = _mupdf.UCDN_LINEBREAK_CLASS_EM
    1: UCDN_LINEBREAK_CLASS_ZWJ = _mupdf.UCDN_LINEBREAK_CLASS_ZWJ
    1: UCDN_LINEBREAK_CLASS_AI = _mupdf.UCDN_LINEBREAK_CLASS_AI
    1: UCDN_LINEBREAK_CLASS_BK = _mupdf.UCDN_LINEBREAK_CLASS_BK
    1: UCDN_LINEBREAK_CLASS_CB = _mupdf.UCDN_LINEBREAK_CLASS_CB
    1: UCDN_LINEBREAK_CLASS_CJ = _mupdf.UCDN_LINEBREAK_CLASS_CJ
    1: UCDN_LINEBREAK_CLASS_CR = _mupdf.UCDN_LINEBREAK_CLASS_CR
    1: UCDN_LINEBREAK_CLASS_LF = _mupdf.UCDN_LINEBREAK_CLASS_LF
    1: UCDN_LINEBREAK_CLASS_NL = _mupdf.UCDN_LINEBREAK_CLASS_NL
    1: UCDN_LINEBREAK_CLASS_SA = _mupdf.UCDN_LINEBREAK_CLASS_SA
    1: UCDN_LINEBREAK_CLASS_SG = _mupdf.UCDN_LINEBREAK_CLASS_SG
    1: UCDN_LINEBREAK_CLASS_SP = _mupdf.UCDN_LINEBREAK_CLASS_SP
    1: UCDN_LINEBREAK_CLASS_XX = _mupdf.UCDN_LINEBREAK_CLASS_XX
    1: UCDN_LINEBREAK_CLASS_AK = _mupdf.UCDN_LINEBREAK_CLASS_AK
    1: UCDN_LINEBREAK_CLASS_AP = _mupdf.UCDN_LINEBREAK_CLASS_AP
    1: UCDN_LINEBREAK_CLASS_AS = _mupdf.UCDN_LINEBREAK_CLASS_AS
    1: UCDN_LINEBREAK_CLASS_VF = _mupdf.UCDN_LINEBREAK_CLASS_VF
    1: UCDN_LINEBREAK_CLASS_VI = _mupdf.UCDN_LINEBREAK_CLASS_VI
    1: UCDN_GENERAL_CATEGORY_CC = _mupdf.UCDN_GENERAL_CATEGORY_CC
    1: UCDN_GENERAL_CATEGORY_CF = _mupdf.UCDN_GENERAL_CATEGORY_CF
    1: UCDN_GENERAL_CATEGORY_CN = _mupdf.UCDN_GENERAL_CATEGORY_CN
    1: UCDN_GENERAL_CATEGORY_CO = _mupdf.UCDN_GENERAL_CATEGORY_CO
    1: UCDN_GENERAL_CATEGORY_CS = _mupdf.UCDN_GENERAL_CATEGORY_CS
    1: UCDN_GENERAL_CATEGORY_LL = _mupdf.UCDN_GENERAL_CATEGORY_LL
    1: UCDN_GENERAL_CATEGORY_LM = _mupdf.UCDN_GENERAL_CATEGORY_LM
    1: UCDN_GENERAL_CATEGORY_LO = _mupdf.UCDN_GENERAL_CATEGORY_LO
    1: UCDN_GENERAL_CATEGORY_LT = _mupdf.UCDN_GENERAL_CATEGORY_LT
    1: UCDN_GENERAL_CATEGORY_LU = _mupdf.UCDN_GENERAL_CATEGORY_LU
    1: UCDN_GENERAL_CATEGORY_MC = _mupdf.UCDN_GENERAL_CATEGORY_MC
    1: UCDN_GENERAL_CATEGORY_ME = _mupdf.UCDN_GENERAL_CATEGORY_ME
    1: UCDN_GENERAL_CATEGORY_MN = _mupdf.UCDN_GENERAL_CATEGORY_MN
    1: UCDN_GENERAL_CATEGORY_ND = _mupdf.UCDN_GENERAL_CATEGORY_ND
    1: UCDN_GENERAL_CATEGORY_NL = _mupdf.UCDN_GENERAL_CATEGORY_NL
    1: UCDN_GENERAL_CATEGORY_NO = _mupdf.UCDN_GENERAL_CATEGORY_NO
    1: UCDN_GENERAL_CATEGORY_PC = _mupdf.UCDN_GENERAL_CATEGORY_PC
    1: UCDN_GENERAL_CATEGORY_PD = _mupdf.UCDN_GENERAL_CATEGORY_PD
    1: UCDN_GENERAL_CATEGORY_PE = _mupdf.UCDN_GENERAL_CATEGORY_PE
    1: UCDN_GENERAL_CATEGORY_PF = _mupdf.UCDN_GENERAL_CATEGORY_PF
    1: UCDN_GENERAL_CATEGORY_PI = _mupdf.UCDN_GENERAL_CATEGORY_PI
    1: UCDN_GENERAL_CATEGORY_PO = _mupdf.UCDN_GENERAL_CATEGORY_PO
    1: UCDN_GENERAL_CATEGORY_PS = _mupdf.UCDN_GENERAL_CATEGORY_PS
    1: UCDN_GENERAL_CATEGORY_SC = _mupdf.UCDN_GENERAL_CATEGORY_SC
    1: UCDN_GENERAL_CATEGORY_SK = _mupdf.UCDN_GENERAL_CATEGORY_SK
    1: UCDN_GENERAL_CATEGORY_SM = _mupdf.UCDN_GENERAL_CATEGORY_SM
    1: UCDN_GENERAL_CATEGORY_SO = _mupdf.UCDN_GENERAL_CATEGORY_SO
    1: UCDN_GENERAL_CATEGORY_ZL = _mupdf.UCDN_GENERAL_CATEGORY_ZL
    1: UCDN_GENERAL_CATEGORY_ZP = _mupdf.UCDN_GENERAL_CATEGORY_ZP
    1: UCDN_GENERAL_CATEGORY_ZS = _mupdf.UCDN_GENERAL_CATEGORY_ZS
    1: UCDN_BIDI_CLASS_L = _mupdf.UCDN_BIDI_CLASS_L
    1: UCDN_BIDI_CLASS_LRE = _mupdf.UCDN_BIDI_CLASS_LRE
    1: UCDN_BIDI_CLASS_LRO = _mupdf.UCDN_BIDI_CLASS_LRO
    1: UCDN_BIDI_CLASS_R = _mupdf.UCDN_BIDI_CLASS_R
    1: UCDN_BIDI_CLASS_AL = _mupdf.UCDN_BIDI_CLASS_AL
    1: UCDN_BIDI_CLASS_RLE = _mupdf.UCDN_BIDI_CLASS_RLE
    1: UCDN_BIDI_CLASS_RLO = _mupdf.UCDN_BIDI_CLASS_RLO
    1: UCDN_BIDI_CLASS_PDF = _mupdf.UCDN_BIDI_CLASS_PDF
    1: UCDN_BIDI_CLASS_EN = _mupdf.UCDN_BIDI_CLASS_EN
    1: UCDN_BIDI_CLASS_ES = _mupdf.UCDN_BIDI_CLASS_ES
    1: UCDN_BIDI_CLASS_ET = _mupdf.UCDN_BIDI_CLASS_ET
    1: UCDN_BIDI_CLASS_AN = _mupdf.UCDN_BIDI_CLASS_AN
    1: UCDN_BIDI_CLASS_CS = _mupdf.UCDN_BIDI_CLASS_CS
    1: UCDN_BIDI_CLASS_NSM = _mupdf.UCDN_BIDI_CLASS_NSM
    1: UCDN_BIDI_CLASS_BN = _mupdf.UCDN_BIDI_CLASS_BN
    1: UCDN_BIDI_CLASS_B = _mupdf.UCDN_BIDI_CLASS_B
    1: UCDN_BIDI_CLASS_S = _mupdf.UCDN_BIDI_CLASS_S
    1: UCDN_BIDI_CLASS_WS = _mupdf.UCDN_BIDI_CLASS_WS
    1: UCDN_BIDI_CLASS_ON = _mupdf.UCDN_BIDI_CLASS_ON
    1: UCDN_BIDI_CLASS_LRI = _mupdf.UCDN_BIDI_CLASS_LRI
    1: UCDN_BIDI_CLASS_RLI = _mupdf.UCDN_BIDI_CLASS_RLI
    1: UCDN_BIDI_CLASS_FSI = _mupdf.UCDN_BIDI_CLASS_FSI
    1: UCDN_BIDI_CLASS_PDI = _mupdf.UCDN_BIDI_CLASS_PDI
    1: UCDN_BIDI_PAIRED_BRACKET_TYPE_OPEN = _mupdf.UCDN_BIDI_PAIRED_BRACKET_TYPE_OPEN
    1: UCDN_BIDI_PAIRED_BRACKET_TYPE_CLOSE = _mupdf.UCDN_BIDI_PAIRED_BRACKET_TYPE_CLOSE
    1: UCDN_BIDI_PAIRED_BRACKET_TYPE_NONE = _mupdf.UCDN_BIDI_PAIRED_BRACKET_TYPE_NONE
       
    1: def new_pint():
>>>>>>     return _mupdf.new_pint()
       
    1: def copy_pint(value):
>>>>>>     return _mupdf.copy_pint(value)
       
    1: def delete_pint(obj):
>>>>>>     return _mupdf.delete_pint(obj)
       
    1: def pint_assign(obj, value):
>>>>>>     return _mupdf.pint_assign(obj, value)
       
    1: def pint_value(obj):
>>>>>>     return _mupdf.pint_value(obj)
       
       
    1: import inspect
    1: import os
    1: import re
    1: import sys
    1: import traceback
       
    1: def log( text):
>>>>>>     print( text, file=sys.stderr)
       
    1: g_mupdf_trace_director = (os.environ.get('MUPDF_trace_director') == '1')
       
    1: def fz_lookup_metadata(document, key):
           """
           Like fz_lookup_metadata2() but returns None on error
           instead of raising exception.
           """
>>>>>>     try:
>>>>>>         return fz_lookup_metadata2(document, key)
>>>>>>     except Exception:
>>>>>>         return
    1: FzDocument.fz_lookup_metadata                         = fz_lookup_metadata
       
    1: def pdf_lookup_metadata(document, key):
           """
           Likepsd_lookup_metadata2() but returns None on error
           instead of raising exception.
           """
>>>>>>     try:
>>>>>>         return pdf_lookup_metadata2(document, key)
>>>>>>     except Exception:
>>>>>>         return
    1: PdfDocument.pdf_lookup_metadata                         = pdf_lookup_metadata
       
    1: import inspect
    1: import io
    1: import os
    1: import sys
    1: import traceback
    1: import types
    1: def exception_info(
    1:         exception_or_traceback=None,
    1:         limit=None,
    1:         file=None,
    1:         chain=True,
    1:         outer=True,
    1:         show_exception_type=True,
    1:         _filelinefn=True,
               ):
           '''
           Shows an exception and/or backtrace.
       
           Alternative to `traceback.*` functions that print/return information about
           exceptions and backtraces, such as:
       
               * `traceback.format_exc()`
               * `traceback.format_exception()`
               * `traceback.print_exc()`
               * `traceback.print_exception()`
       
           Install as system default with:
       
               `sys.excepthook = lambda type_, exception, traceback: jlib.exception_info( exception)`
       
           Returns `None`, or the generated text if `file` is 'return'.
       
           Args:
               exception_or_traceback:
                   `None`, a `BaseException`, a `types.TracebackType` (typically from
                   an exception's `.__traceback__` member) or an `inspect.FrameInfo`.
       
                   If `None` we use current exception from `sys.exc_info()` if set,
                   otherwise the current backtrace from `inspect.stack()`.
               limit:
                   As in `traceback.*` functions: `None` to show all frames, positive
                   to show last `limit` frames, negative to exclude outermost `-limit`
                   frames. Zero to not show any backtraces.
               file:
                   As in `traceback.*` functions: file-like object to which we write
                   output, or `sys.stderr` if `None`. Special value 'return' makes us
                   return our output as a string.
               chain:
                   As in `traceback.*` functions: if true (the default) we show
                   chained exceptions as described in PEP-3134. Special value
                   'because' reverses the usual ordering, showing higher-level
                   exceptions first and joining with 'Because:' text.
               outer:
                   If true (the default) we also show an exception's outer frames
                   above the `catch` block (see next section for details). We
                   use `outer=false` internally for chained exceptions to avoid
                   duplication.
               show_exception_type:
                   Controls whether exception text is prefixed by
                   `f'{type(exception)}: '`. If callable we only include this prefix
                   if `show_exception_type(exception)` is true. Otherwise if true (the
                   default) we include the prefix for all exceptions (this mimcs the
                   behaviour of `traceback.*` functions). Otherwise we exclude the
                   prefix for all exceptions.
               _filelinefn:
                   Internal only; makes us omit file:line: information to allow simple
                   doctest comparison with expected output.
       
           Differences from `traceback.*` functions:
       
               Frames are displayed as one line in the form::
       
                   <file>:<line>:<function>: <text>
       
               Filenames are displayed as relative to the current directory if
               applicable.
       
               Inclusion of outer frames:
                   Unlike `traceback.*` functions, stack traces for exceptions include
                   outer stack frames above the point at which an exception was caught
                   - i.e. frames from the top-level <module> or thread creation to the
                   catch block. [Search for 'sys.exc_info backtrace incomplete' for
                   more details.]
       
                   We separate the two parts of the backtrace using a marker line
                   '^except raise:' where '^except' points upwards to the frame that
                   caught the exception and 'raise:' refers downwards to the frame
                   that raised the exception.
       
                   So the backtrace for an exception looks like this::
       
                       <file>:<line>:<fn>: <text>  [in root module.]
                       ...                         [... other frames]
                       <file>:<line>:<fn>: <text>  [in except: block where exception was caught.]
                       ^except raise:              [marker line]
                       <file>:<line>:<fn>: <text>  [in try: block.]
                       ...                         [... other frames]
                       <file>:<line>:<fn>: <text>  [where the exception was raised.]
       
           Examples:
       
               In these examples we use `file=sys.stdout` so we can check the output
               with `doctest`, and set `_filelinefn=0` so that the output can be
               matched easily. We also use `+ELLIPSIS` and `...` to match arbitrary
               outer frames from the doctest code itself.
       
               Basic handling of an exception:
       
                   >>> def c():
                   ...     raise Exception( 'c() failed')
                   >>> def b():
                   ...     try:
                   ...         c()
                   ...     except Exception as e:
                   ...         exception_info( e, file=sys.stdout, _filelinefn=0)
                   >>> def a():
                   ...     b()
       
                   >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
                   Traceback (most recent call last):
                       ...
                       a(): b()
                       b(): exception_info( e, file=sys.stdout, _filelinefn=0)
                       ^except raise:
                       b(): c()
                       c(): raise Exception( 'c() failed')
                   Exception: c() failed
       
               Handling of chained exceptions:
       
                   >>> def e():
                   ...     raise Exception( 'e(): deliberate error')
                   >>> def d():
                   ...     e()
                   >>> def c():
                   ...     try:
                   ...         d()
                   ...     except Exception as e:
                   ...         raise Exception( 'c: d() failed') from e
                   >>> def b():
                   ...     try:
                   ...         c()
                   ...     except Exception as e:
                   ...         exception_info( file=sys.stdout, chain=g_chain, _filelinefn=0)
                   >>> def a():
                   ...     b()
       
                   With `chain=True` (the default), we output low-level exceptions
                   first, matching the behaviour of `traceback.*` functions:
       
                       >>> g_chain = True
                       >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
                       Traceback (most recent call last):
                           c(): d()
                           d(): e()
                           e(): raise Exception( 'e(): deliberate error')
                       Exception: e(): deliberate error
                       <BLANKLINE>
                       The above exception was the direct cause of the following exception:
                       Traceback (most recent call last):
                           ...
                           <module>(): a() # doctest: +REPORT_UDIFF +ELLIPSIS
                           a(): b()
                           b(): exception_info( file=sys.stdout, chain=g_chain, _filelinefn=0)
                           ^except raise:
                           b(): c()
                           c(): raise Exception( 'c: d() failed') from e
                       Exception: c: d() failed
       
                   With `chain='because'`, we output high-level exceptions first:
                       >>> g_chain = 'because'
                       >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
                       Traceback (most recent call last):
                           ...
                           <module>(): a() # doctest: +REPORT_UDIFF +ELLIPSIS
                           a(): b()
                           b(): exception_info( file=sys.stdout, chain=g_chain, _filelinefn=0)
                           ^except raise:
                           b(): c()
                           c(): raise Exception( 'c: d() failed') from e
                       Exception: c: d() failed
                       <BLANKLINE>
                       Because:
                       Traceback (most recent call last):
                           c(): d()
                           d(): e()
                           e(): raise Exception( 'e(): deliberate error')
                       Exception: e(): deliberate error
       
               Show current backtrace by passing `exception_or_traceback=None`:
                   >>> def c():
                   ...     exception_info( None, file=sys.stdout, _filelinefn=0)
                   >>> def b():
                   ...     return c()
                   >>> def a():
                   ...     return b()
       
                   >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
                   Traceback (most recent call last):
                       ...
                       <module>(): a() # doctest: +REPORT_UDIFF +ELLIPSIS
                       a(): return b()
                       b(): return c()
                       c(): exception_info( None, file=sys.stdout, _filelinefn=0)
       
               Show an exception's `.__traceback__` backtrace:
                   >>> def c():
                   ...     raise Exception( 'foo') # raise
                   >>> def b():
                   ...     return c()  # call c
                   >>> def a():
                   ...     try:
                   ...         b() # call b
                   ...     except Exception as e:
                   ...         exception_info( e.__traceback__, file=sys.stdout, _filelinefn=0)
       
                   >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
                   Traceback (most recent call last):
                       ...
                       a(): b() # call b
                       b(): return c()  # call c
                       c(): raise Exception( 'foo') # raise
           '''
       # Set exactly one of <exception> and <tb>.
       #
>>>>>>     if isinstance( exception_or_traceback, (types.TracebackType, inspect.FrameInfo)):
       # Simple backtrace, no Exception information.
>>>>>>         exception = None
>>>>>>         tb = exception_or_traceback
>>>>>>     elif isinstance( exception_or_traceback, BaseException):
>>>>>>         exception = exception_or_traceback
>>>>>>         tb = None
>>>>>>     elif exception_or_traceback is None:
       # Show exception if available, else backtrace.
>>>>>>         _, exception, tb = sys.exc_info()
>>>>>>         tb = None if exception else inspect.stack()[1:]
           else:
>>>>>>         assert 0, f'Unrecognised exception_or_traceback type: {type(exception_or_traceback)}'
       
>>>>>>     if file == 'return':
>>>>>>         out = io.StringIO()
           else:
>>>>>>         out = file if file else sys.stderr
       
>>>>>>     def do_chain( exception):
>>>>>>         exception_info(
>>>>>>                 exception,
>>>>>>                 limit,
>>>>>>                 out,
>>>>>>                 chain,
>>>>>>                 outer=False,
>>>>>>                 show_exception_type=show_exception_type,
>>>>>>                 _filelinefn=_filelinefn,
                       )
       
>>>>>>     if exception and chain and chain != 'because' and chain != 'because-compact':
       # Output current exception first.
>>>>>>         if exception.__cause__:
>>>>>>             do_chain( exception.__cause__)
>>>>>>             out.write( '\nThe above exception was the direct cause of the following exception:\n')
>>>>>>         elif exception.__context__:
>>>>>>             do_chain( exception.__context__)
>>>>>>             out.write( '\nDuring handling of the above exception, another exception occurred:\n')
       
>>>>>>     cwd = os.getcwd() + os.sep
       
>>>>>>     def output_frames( frames, reverse, limit):
>>>>>>         if limit == 0:
>>>>>>             return
>>>>>>         if reverse:
>>>>>>             assert isinstance( frames, list)
>>>>>>             frames = reversed( frames)
>>>>>>         if limit is not None:
>>>>>>             frames = list( frames)
>>>>>>             frames = frames[ -limit:]
>>>>>>         for frame in frames:
>>>>>>             f, filename, line, fnname, text, index = frame
>>>>>>             text = text[0].strip() if text else ''
>>>>>>             if filename.startswith( cwd):
>>>>>>                 filename = filename[ len(cwd):]
>>>>>>             if filename.startswith( f'.{os.sep}'):
>>>>>>                 filename = filename[ 2:]
>>>>>>             if _filelinefn:
>>>>>>                 out.write( f'    {filename}:{line}:{fnname}(): {text}\n')
                   else:
>>>>>>                 out.write( f'    {fnname}(): {text}\n')
       
>>>>>>     if limit != 0:
>>>>>>         out.write( 'Traceback (most recent call last):\n')
>>>>>>         if exception:
>>>>>>             tb = exception.__traceback__
>>>>>>             assert tb
>>>>>>             if outer:
>>>>>>                 output_frames( inspect.getouterframes( tb.tb_frame), reverse=True, limit=limit)
>>>>>>                 out.write( '    ^except raise:\n')
>>>>>>             limit2 = 0 if limit == 0 else None
>>>>>>             output_frames( inspect.getinnerframes( tb), reverse=False, limit=limit2)
               else:
>>>>>>             if not isinstance( tb, list):
>>>>>>                 inner = inspect.getinnerframes(tb)
>>>>>>                 outer = inspect.getouterframes(tb.tb_frame)
>>>>>>                 tb = outer + inner
>>>>>>                 tb.reverse()
>>>>>>             output_frames( tb, reverse=True, limit=limit)
       
>>>>>>     if exception:
>>>>>>         if callable(show_exception_type):
>>>>>>             show_exception_type2 = show_exception_type( exception)
               else:
>>>>>>             show_exception_type2 = show_exception_type
>>>>>>         if show_exception_type2:
>>>>>>             lines = traceback.format_exception_only( type(exception), exception)
>>>>>>             for line in lines:
>>>>>>                 out.write( line)
               else:
>>>>>>             out.write( str( exception) + '\n')
       
>>>>>>     if exception and (chain == 'because' or chain == 'because-compact'):
       # Output current exception afterwards.
>>>>>>         pre, post = ('\n', '\n') if chain == 'because' else ('', ' ')
>>>>>>         if exception.__cause__:
>>>>>>             out.write( f'{pre}Because:{post}')
>>>>>>             do_chain( exception.__cause__)
>>>>>>         elif exception.__context__:
>>>>>>             out.write( f'{pre}Because: error occurred handling this exception:{post}')
>>>>>>             do_chain( exception.__context__)
       
>>>>>>     if file == 'return':
>>>>>>         return out.getvalue()
    1: def ll_fz_bidi_fragment_text(text, textlen, callback, arg, flags):
           """
           Wrapper for out-params of fz_bidi_fragment_text().
           Returns: ::fz_bidi_direction baseDir
           """
>>>>>>     outparams = ll_fz_bidi_fragment_text_outparams()
>>>>>>     ret = ll_fz_bidi_fragment_text_outparams_fn(text, textlen, callback, arg, flags, outparams)
>>>>>>     return outparams.baseDir
       
    1: def fz_bidi_fragment_text_outparams_fn(text, textlen, callback, arg, flags):
           """
           Class-aware helper for out-params of fz_bidi_fragment_text() [fz_bidi_fragment_text()].
           """
>>>>>>     baseDir = ll_fz_bidi_fragment_text(text, textlen, callback, arg, flags)
>>>>>>     return baseDir
       
    1: fz_bidi_fragment_text = fz_bidi_fragment_text_outparams_fn
       
       
    1: def ll_fz_bitmap_details(bitmap):
           """
           Wrapper for out-params of fz_bitmap_details().
           Returns: int w, int h, int n, int stride
           """
>>>>>>     outparams = ll_fz_bitmap_details_outparams()
>>>>>>     ret = ll_fz_bitmap_details_outparams_fn(bitmap, outparams)
>>>>>>     return outparams.w, outparams.h, outparams.n, outparams.stride
       
    1: def fz_bitmap_details_outparams_fn(bitmap):
           """
           Class-aware helper for out-params of fz_bitmap_details() [fz_bitmap_details()].
           """
>>>>>>     w, h, n, stride = ll_fz_bitmap_details(bitmap.m_internal)
>>>>>>     return w, h, n, stride
       
    1: fz_bitmap_details = fz_bitmap_details_outparams_fn
       
       
    1: def ll_fz_buffer_extract(buf):
           """
           Wrapper for out-params of fz_buffer_extract().
           Returns: size_t, unsigned char *data
           """
>>>>>>     outparams = ll_fz_buffer_extract_outparams()
>>>>>>     ret = ll_fz_buffer_extract_outparams_fn(buf, outparams)
>>>>>>     return ret, outparams.data
       
    1: def fz_buffer_extract_outparams_fn(buf):
           """
           Class-aware helper for out-params of fz_buffer_extract() [fz_buffer_extract()].
           """
>>>>>>     ret, data = ll_fz_buffer_extract(buf.m_internal)
>>>>>>     return ret, data
       
    1: fz_buffer_extract = fz_buffer_extract_outparams_fn
       
       
    1: def ll_fz_buffer_storage(buf):
           """
           Wrapper for out-params of fz_buffer_storage().
           Returns: size_t, unsigned char *datap
           """
>>>>>>     outparams = ll_fz_buffer_storage_outparams()
>>>>>>     ret = ll_fz_buffer_storage_outparams_fn(buf, outparams)
>>>>>>     return ret, outparams.datap
       
    1: def fz_buffer_storage_outparams_fn(buf):
           """
           Class-aware helper for out-params of fz_buffer_storage() [fz_buffer_storage()].
           """
>>>>>>     ret, datap = ll_fz_buffer_storage(buf.m_internal)
>>>>>>     return ret, datap
       
    1: fz_buffer_storage = fz_buffer_storage_outparams_fn
       
       
    1: def ll_fz_chartorune(str):
           """
           Wrapper for out-params of fz_chartorune().
           Returns: int, int rune
           """
>>>>>>     outparams = ll_fz_chartorune_outparams()
>>>>>>     ret = ll_fz_chartorune_outparams_fn(str, outparams)
>>>>>>     return ret, outparams.rune
       
    1: def fz_chartorune_outparams_fn(str):
           """
           Class-aware helper for out-params of fz_chartorune() [fz_chartorune()].
           """
>>>>>>     ret, rune = ll_fz_chartorune(str)
>>>>>>     return ret, rune
       
    1: fz_chartorune = fz_chartorune_outparams_fn
       
       
    1: def ll_fz_chartorunen(str, n):
           """
           Wrapper for out-params of fz_chartorunen().
           Returns: int, int rune
           """
>>>>>>     outparams = ll_fz_chartorunen_outparams()
>>>>>>     ret = ll_fz_chartorunen_outparams_fn(str, n, outparams)
>>>>>>     return ret, outparams.rune
       
    1: def fz_chartorunen_outparams_fn(str, n):
           """
           Class-aware helper for out-params of fz_chartorunen() [fz_chartorunen()].
           """
>>>>>>     ret, rune = ll_fz_chartorunen(str, n)
>>>>>>     return ret, rune
       
    1: fz_chartorunen = fz_chartorunen_outparams_fn
       
       
    1: def ll_fz_clamp_color(cs, in_):
           """
           Wrapper for out-params of fz_clamp_color().
           Returns: float out
           """
>>>>>>     outparams = ll_fz_clamp_color_outparams()
>>>>>>     ret = ll_fz_clamp_color_outparams_fn(cs, in_, outparams)
>>>>>>     return outparams.out
       
    1: def fz_clamp_color_outparams_fn(cs, in_):
           """
           Class-aware helper for out-params of fz_clamp_color() [fz_clamp_color()].
           """
>>>>>>     out = ll_fz_clamp_color(cs.m_internal, in_)
>>>>>>     return out
       
    1: fz_clamp_color = fz_clamp_color_outparams_fn
       
       
    1: def ll_fz_compress_brotli(dest, source, source_length, level):
           """
           Wrapper for out-params of fz_compress_brotli().
           Returns: size_t compressed_length
           """
>>>>>>     outparams = ll_fz_compress_brotli_outparams()
>>>>>>     ret = ll_fz_compress_brotli_outparams_fn(dest, source, source_length, level, outparams)
>>>>>>     return outparams.compressed_length
       
    1: def fz_compress_brotli_outparams_fn(dest, source, source_length, level):
           """
           Class-aware helper for out-params of fz_compress_brotli() [fz_compress_brotli()].
           """
>>>>>>     compressed_length = ll_fz_compress_brotli(dest, source, source_length, level)
>>>>>>     return compressed_length
       
    1: fz_compress_brotli = fz_compress_brotli_outparams_fn
       
       
    1: def ll_fz_convert_color(ss, sv, ds, is_, params):
           """
           Wrapper for out-params of fz_convert_color().
           Returns: float dv
           """
>>>>>>     outparams = ll_fz_convert_color_outparams()
>>>>>>     ret = ll_fz_convert_color_outparams_fn(ss, sv, ds, is_, params, outparams)
>>>>>>     return outparams.dv
       
    1: def fz_convert_color_outparams_fn(ss, sv, ds, is_, params):
           """
           Class-aware helper for out-params of fz_convert_color() [fz_convert_color()].
           """
>>>>>>     dv = ll_fz_convert_color(ss.m_internal, sv, ds.m_internal, is_.m_internal, params.internal())
>>>>>>     return dv
       
    1: fz_convert_color = fz_convert_color_outparams_fn
       
       
    1: def ll_fz_convert_error():
           """
           Wrapper for out-params of fz_convert_error().
           Returns: const char *, int code
           """
>>>>>>     outparams = ll_fz_convert_error_outparams()
>>>>>>     ret = ll_fz_convert_error_outparams_fn(outparams)
>>>>>>     return ret, outparams.code
       
    1: def fz_convert_error_outparams_fn():
           """
           Class-aware helper for out-params of fz_convert_error() [fz_convert_error()].
           """
>>>>>>     ret, code = ll_fz_convert_error()
>>>>>>     return ret, code
       
    1: fz_convert_error = fz_convert_error_outparams_fn
       
       
    1: def ll_fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, color_params):
           """
           Wrapper for out-params of fz_convert_separation_colors().
           Returns: float dst_color
           """
>>>>>>     outparams = ll_fz_convert_separation_colors_outparams()
>>>>>>     ret = ll_fz_convert_separation_colors_outparams_fn(src_cs, src_color, dst_seps, dst_cs, color_params, outparams)
>>>>>>     return outparams.dst_color
       
    1: def fz_convert_separation_colors_outparams_fn(src_cs, src_color, dst_seps, dst_cs, color_params):
           """
           Class-aware helper for out-params of fz_convert_separation_colors() [fz_convert_separation_colors()].
           """
>>>>>>     dst_color = ll_fz_convert_separation_colors(src_cs.m_internal, src_color, dst_seps.m_internal, dst_cs.m_internal, color_params.internal())
>>>>>>     return dst_color
       
    1: fz_convert_separation_colors = fz_convert_separation_colors_outparams_fn
       
       
    1: def ll_fz_decode_barcode_from_display_list(list, subarea, rotate):
           """
           Wrapper for out-params of fz_decode_barcode_from_display_list().
           Returns: char *, ::fz_barcode_type type
           """
>>>>>>     outparams = ll_fz_decode_barcode_from_display_list_outparams()
>>>>>>     ret = ll_fz_decode_barcode_from_display_list_outparams_fn(list, subarea, rotate, outparams)
>>>>>>     return ret, outparams.type
       
    1: def fz_decode_barcode_from_display_list_outparams_fn(list, subarea, rotate):
           """
           Class-aware helper for out-params of fz_decode_barcode_from_display_list() [fz_decode_barcode_from_display_list()].
           """
>>>>>>     ret, type = ll_fz_decode_barcode_from_display_list(list.m_internal, subarea.internal(), rotate)
>>>>>>     return ret, type
       
    1: fz_decode_barcode_from_display_list = fz_decode_barcode_from_display_list_outparams_fn
       
       
    1: def ll_fz_decode_barcode_from_display_list2(list, subarea, rotate):
           """
           Wrapper for out-params of fz_decode_barcode_from_display_list2().
           Returns: std::string, ::fz_barcode_type type
           """
>>>>>>     outparams = ll_fz_decode_barcode_from_display_list2_outparams()
>>>>>>     ret = ll_fz_decode_barcode_from_display_list2_outparams_fn(list, subarea, rotate, outparams)
>>>>>>     return ret, outparams.type
       
    1: def fz_decode_barcode_from_display_list2_outparams_fn(list, subarea, rotate):
           """
           Class-aware helper for out-params of fz_decode_barcode_from_display_list2() [fz_decode_barcode_from_display_list2()].
           """
>>>>>>     ret, type = ll_fz_decode_barcode_from_display_list2(list.m_internal, subarea.internal(), rotate)
>>>>>>     return ret, type
       
    1: fz_decode_barcode_from_display_list2 = fz_decode_barcode_from_display_list2_outparams_fn
       
       
    1: def ll_fz_decode_barcode_from_page(page, subarea, rotate):
           """
           Wrapper for out-params of fz_decode_barcode_from_page().
           Returns: char *, ::fz_barcode_type type
           """
>>>>>>     outparams = ll_fz_decode_barcode_from_page_outparams()
>>>>>>     ret = ll_fz_decode_barcode_from_page_outparams_fn(page, subarea, rotate, outparams)
>>>>>>     return ret, outparams.type
       
    1: def fz_decode_barcode_from_page_outparams_fn(page, subarea, rotate):
           """
           Class-aware helper for out-params of fz_decode_barcode_from_page() [fz_decode_barcode_from_page()].
           """
>>>>>>     ret, type = ll_fz_decode_barcode_from_page(page.m_internal, subarea.internal(), rotate)
>>>>>>     return ret, type
       
    1: fz_decode_barcode_from_page = fz_decode_barcode_from_page_outparams_fn
       
       
    1: def ll_fz_decode_barcode_from_page2(page, subarea, rotate):
           """
           Wrapper for out-params of fz_decode_barcode_from_page2().
           Returns: std::string, ::fz_barcode_type type
           """
>>>>>>     outparams = ll_fz_decode_barcode_from_page2_outparams()
>>>>>>     ret = ll_fz_decode_barcode_from_page2_outparams_fn(page, subarea, rotate, outparams)
>>>>>>     return ret, outparams.type
       
    1: def fz_decode_barcode_from_page2_outparams_fn(page, subarea, rotate):
           """
           Class-aware helper for out-params of fz_decode_barcode_from_page2() [fz_decode_barcode_from_page2()].
           """
>>>>>>     ret, type = ll_fz_decode_barcode_from_page2(page.m_internal, subarea.internal(), rotate)
>>>>>>     return ret, type
       
    1: fz_decode_barcode_from_page2 = fz_decode_barcode_from_page2_outparams_fn
       
       
    1: def ll_fz_decode_barcode_from_pixmap(pix, rotate):
           """
           Wrapper for out-params of fz_decode_barcode_from_pixmap().
           Returns: char *, ::fz_barcode_type type
           """
>>>>>>     outparams = ll_fz_decode_barcode_from_pixmap_outparams()
>>>>>>     ret = ll_fz_decode_barcode_from_pixmap_outparams_fn(pix, rotate, outparams)
>>>>>>     return ret, outparams.type
       
    1: def fz_decode_barcode_from_pixmap_outparams_fn(pix, rotate):
           """
           Class-aware helper for out-params of fz_decode_barcode_from_pixmap() [fz_decode_barcode_from_pixmap()].
           """
>>>>>>     ret, type = ll_fz_decode_barcode_from_pixmap(pix.m_internal, rotate)
>>>>>>     return ret, type
       
    1: fz_decode_barcode_from_pixmap = fz_decode_barcode_from_pixmap_outparams_fn
       
       
    1: def ll_fz_decode_barcode_from_pixmap2(pix, rotate):
           """
           Wrapper for out-params of fz_decode_barcode_from_pixmap2().
           Returns: std::string, ::fz_barcode_type type
           """
>>>>>>     outparams = ll_fz_decode_barcode_from_pixmap2_outparams()
>>>>>>     ret = ll_fz_decode_barcode_from_pixmap2_outparams_fn(pix, rotate, outparams)
>>>>>>     return ret, outparams.type
       
    1: def fz_decode_barcode_from_pixmap2_outparams_fn(pix, rotate):
           """
           Class-aware helper for out-params of fz_decode_barcode_from_pixmap2() [fz_decode_barcode_from_pixmap2()].
           """
>>>>>>     ret, type = ll_fz_decode_barcode_from_pixmap2(pix.m_internal, rotate)
>>>>>>     return ret, type
       
    1: fz_decode_barcode_from_pixmap2 = fz_decode_barcode_from_pixmap2_outparams_fn
       
       
    1: def ll_fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor):
           """
           Wrapper for out-params of fz_decomp_image_from_stream().
           Returns: fz_pixmap *, int l2extra
           """
>>>>>>     outparams = ll_fz_decomp_image_from_stream_outparams()
>>>>>>     ret = ll_fz_decomp_image_from_stream_outparams_fn(stm, image, subarea, indexed, l2factor, outparams)
>>>>>>     return ret, outparams.l2extra
       
    1: def fz_decomp_image_from_stream_outparams_fn(stm, image, subarea, indexed, l2factor):
           """
           Class-aware helper for out-params of fz_decomp_image_from_stream() [fz_decomp_image_from_stream()].
           """
>>>>>>     ret, l2extra = ll_fz_decomp_image_from_stream(stm.m_internal, image.m_internal, subarea.internal(), indexed, l2factor)
>>>>>>     return FzPixmap(ret), l2extra
       
    1: fz_decomp_image_from_stream = fz_decomp_image_from_stream_outparams_fn
       
       
    1: def ll_fz_deflate(dest, source, source_length, level):
           """
           Wrapper for out-params of fz_deflate().
           Returns: size_t compressed_length
           """
>>>>>>     outparams = ll_fz_deflate_outparams()
>>>>>>     ret = ll_fz_deflate_outparams_fn(dest, source, source_length, level, outparams)
>>>>>>     return outparams.compressed_length
       
    1: def fz_deflate_outparams_fn(dest, source, source_length, level):
           """
           Class-aware helper for out-params of fz_deflate() [fz_deflate()].
           """
>>>>>>     compressed_length = ll_fz_deflate(dest, source, source_length, level)
>>>>>>     return compressed_length
       
    1: fz_deflate = fz_deflate_outparams_fn
       
       
    1: def ll_fz_dom_get_attribute(elt, i):
           """
           Wrapper for out-params of fz_dom_get_attribute().
           Returns: const char *, const char *att
           """
>>>>>>     outparams = ll_fz_dom_get_attribute_outparams()
>>>>>>     ret = ll_fz_dom_get_attribute_outparams_fn(elt, i, outparams)
>>>>>>     return ret, outparams.att
       
    1: def fz_dom_get_attribute_outparams_fn(elt, i):
           """
           Class-aware helper for out-params of fz_dom_get_attribute() [fz_dom_get_attribute()].
           """
>>>>>>     ret, att = ll_fz_dom_get_attribute(elt.m_internal, i)
>>>>>>     return ret, att
       
    1: fz_dom_get_attribute = fz_dom_get_attribute_outparams_fn
       
       
    1: def ll_fz_drop_imp(p):
           """
           Wrapper for out-params of fz_drop_imp().
           Returns: int, int refs
           """
>>>>>>     outparams = ll_fz_drop_imp_outparams()
>>>>>>     ret = ll_fz_drop_imp_outparams_fn(p, outparams)
>>>>>>     return ret, outparams.refs
       
    1: def ll_fz_drop_imp16(p):
           """
           Wrapper for out-params of fz_drop_imp16().
           Returns: int, int16_t refs
           """
>>>>>>     outparams = ll_fz_drop_imp16_outparams()
>>>>>>     ret = ll_fz_drop_imp16_outparams_fn(p, outparams)
>>>>>>     return ret, outparams.refs
       
    1: def ll_fz_encode_character_with_fallback(font, unicode, script, language):
           """
           Wrapper for out-params of fz_encode_character_with_fallback().
           Returns: int, ::fz_font *out_font
           """
>>>>>>     outparams = ll_fz_encode_character_with_fallback_outparams()
>>>>>>     ret = ll_fz_encode_character_with_fallback_outparams_fn(font, unicode, script, language, outparams)
>>>>>>     return ret, outparams.out_font
       
    1: def fz_encode_character_with_fallback_outparams_fn(font, unicode, script, language):
           """
           Class-aware helper for out-params of fz_encode_character_with_fallback() [fz_encode_character_with_fallback()].
           """
>>>>>>     ret, out_font = ll_fz_encode_character_with_fallback(font.m_internal, unicode, script, language)
>>>>>>     return ret, FzFont(ll_fz_keep_font( out_font))
       
    1: fz_encode_character_with_fallback = fz_encode_character_with_fallback_outparams_fn
       
       
    1: def ll_fz_error_callback():
           """
           Wrapper for out-params of fz_error_callback().
           Returns: fz_error_cb *, void *user
           """
>>>>>>     outparams = ll_fz_error_callback_outparams()
>>>>>>     ret = ll_fz_error_callback_outparams_fn(outparams)
>>>>>>     return ret, outparams.user
       
    1: def fz_error_callback_outparams_fn():
           """
           Class-aware helper for out-params of fz_error_callback() [fz_error_callback()].
           """
>>>>>>     ret, user = ll_fz_error_callback()
>>>>>>     return ret, user
       
    1: fz_error_callback = fz_error_callback_outparams_fn
       
       
    1: def ll_fz_eval_function(func, in_, inlen, outlen):
           """
           Wrapper for out-params of fz_eval_function().
           Returns: float out
           """
>>>>>>     outparams = ll_fz_eval_function_outparams()
>>>>>>     ret = ll_fz_eval_function_outparams_fn(func, in_, inlen, outlen, outparams)
>>>>>>     return outparams.out
       
    1: def fz_eval_function_outparams_fn(func, in_, inlen, outlen):
           """
           Class-aware helper for out-params of fz_eval_function() [fz_eval_function()].
           """
>>>>>>     out = ll_fz_eval_function(func.m_internal, in_, inlen, outlen)
>>>>>>     return out
       
    1: fz_eval_function = fz_eval_function_outparams_fn
       
       
    1: def ll_fz_fill_pixmap_with_color(pix, colorspace, color_params):
           """
           Wrapper for out-params of fz_fill_pixmap_with_color().
           Returns: float color
           """
>>>>>>     outparams = ll_fz_fill_pixmap_with_color_outparams()
>>>>>>     ret = ll_fz_fill_pixmap_with_color_outparams_fn(pix, colorspace, color_params, outparams)
>>>>>>     return outparams.color
       
    1: def fz_fill_pixmap_with_color_outparams_fn(pix, colorspace, color_params):
           """
           Class-aware helper for out-params of fz_fill_pixmap_with_color() [fz_fill_pixmap_with_color()].
           """
>>>>>>     color = ll_fz_fill_pixmap_with_color(pix.m_internal, colorspace.m_internal, color_params.internal())
>>>>>>     return color
       
    1: fz_fill_pixmap_with_color = fz_fill_pixmap_with_color_outparams_fn
       
       
    1: def ll_fz_get_pixmap_from_image(image, subarea, ctm):
           """
           Wrapper for out-params of fz_get_pixmap_from_image().
           Returns: fz_pixmap *, int w, int h
           """
>>>>>>     outparams = ll_fz_get_pixmap_from_image_outparams()
>>>>>>     ret = ll_fz_get_pixmap_from_image_outparams_fn(image, subarea, ctm, outparams)
>>>>>>     return ret, outparams.w, outparams.h
       
    1: def fz_get_pixmap_from_image_outparams_fn(image, subarea, ctm):
           """
           Class-aware helper for out-params of fz_get_pixmap_from_image() [fz_get_pixmap_from_image()].
           """
>>>>>>     ret, w, h = ll_fz_get_pixmap_from_image(image.m_internal, subarea.internal(), ctm.internal())
>>>>>>     return FzPixmap(ret), w, h
       
    1: fz_get_pixmap_from_image = fz_get_pixmap_from_image_outparams_fn
       
       
    1: def ll_fz_getopt(nargc, ostr):
           """
           Wrapper for out-params of fz_getopt().
           Returns: int, char *nargv
           """
>>>>>>     outparams = ll_fz_getopt_outparams()
>>>>>>     ret = ll_fz_getopt_outparams_fn(nargc, ostr, outparams)
>>>>>>     return ret, outparams.nargv
       
    1: def fz_getopt_outparams_fn(nargc, ostr):
           """
           Class-aware helper for out-params of fz_getopt() [fz_getopt()].
           """
>>>>>>     ret, nargv = ll_fz_getopt(nargc, ostr)
>>>>>>     return ret, nargv
       
    1: fz_getopt = fz_getopt_outparams_fn
       
       
    1: def ll_fz_getopt_long(nargc, ostr, longopts):
           """
           Wrapper for out-params of fz_getopt_long().
           Returns: int, char *nargv
           """
>>>>>>     outparams = ll_fz_getopt_long_outparams()
>>>>>>     ret = ll_fz_getopt_long_outparams_fn(nargc, ostr, longopts, outparams)
>>>>>>     return ret, outparams.nargv
       
    1: def fz_getopt_long_outparams_fn(nargc, ostr, longopts):
           """
           Class-aware helper for out-params of fz_getopt_long() [fz_getopt_long()].
           """
>>>>>>     ret, nargv = ll_fz_getopt_long(nargc, ostr, longopts.m_internal)
>>>>>>     return ret, nargv
       
    1: fz_getopt_long = fz_getopt_long_outparams_fn
       
       
    1: def ll_fz_grisu(f, s):
           """
           Wrapper for out-params of fz_grisu().
           Returns: int, int exp
           """
>>>>>>     outparams = ll_fz_grisu_outparams()
>>>>>>     ret = ll_fz_grisu_outparams_fn(f, s, outparams)
>>>>>>     return ret, outparams.exp
       
    1: def fz_grisu_outparams_fn(f, s):
           """
           Class-aware helper for out-params of fz_grisu() [fz_grisu()].
           """
>>>>>>     ret, exp = ll_fz_grisu(f, s)
>>>>>>     return ret, exp
       
    1: fz_grisu = fz_grisu_outparams_fn
       
       
    1: def ll_fz_has_option(opts, key):
           """
           Wrapper for out-params of fz_has_option().
           Returns: int, const char *val
           """
>>>>>>     outparams = ll_fz_has_option_outparams()
>>>>>>     ret = ll_fz_has_option_outparams_fn(opts, key, outparams)
>>>>>>     return ret, outparams.val
       
    1: def fz_has_option_outparams_fn(opts, key):
           """
           Class-aware helper for out-params of fz_has_option() [fz_has_option()].
           """
>>>>>>     ret, val = ll_fz_has_option(opts, key)
>>>>>>     return ret, val
       
    1: fz_has_option = fz_has_option_outparams_fn
       
       
    1: def ll_fz_image_resolution(image):
           """
           Wrapper for out-params of fz_image_resolution().
           Returns: int xres, int yres
           """
>>>>>>     outparams = ll_fz_image_resolution_outparams()
>>>>>>     ret = ll_fz_image_resolution_outparams_fn(image, outparams)
>>>>>>     return outparams.xres, outparams.yres
       
    1: def fz_image_resolution_outparams_fn(image):
           """
           Class-aware helper for out-params of fz_image_resolution() [fz_image_resolution()].
           """
>>>>>>     xres, yres = ll_fz_image_resolution(image.m_internal)
>>>>>>     return xres, yres
       
    1: fz_image_resolution = fz_image_resolution_outparams_fn
       
       
    1: def ll_fz_keep_imp(p):
           """
           Wrapper for out-params of fz_keep_imp().
           Returns: void *, int refs
           """
>>>>>>     outparams = ll_fz_keep_imp_outparams()
>>>>>>     ret = ll_fz_keep_imp_outparams_fn(p, outparams)
>>>>>>     return ret, outparams.refs
       
    1: def ll_fz_keep_imp16(p):
           """
           Wrapper for out-params of fz_keep_imp16().
           Returns: void *, int16_t refs
           """
>>>>>>     outparams = ll_fz_keep_imp16_outparams()
>>>>>>     ret = ll_fz_keep_imp16_outparams_fn(p, outparams)
>>>>>>     return ret, outparams.refs
       
    1: def ll_fz_keep_imp_locked(p):
           """
           Wrapper for out-params of fz_keep_imp_locked().
           Returns: void *, int refs
           """
>>>>>>     outparams = ll_fz_keep_imp_locked_outparams()
>>>>>>     ret = ll_fz_keep_imp_locked_outparams_fn(p, outparams)
>>>>>>     return ret, outparams.refs
       
    1: def ll_fz_lookup_base14_font(name):
           """
           Wrapper for out-params of fz_lookup_base14_font().
           Returns: const unsigned char *, int len
           """
>>>>>>     outparams = ll_fz_lookup_base14_font_outparams()
>>>>>>     ret = ll_fz_lookup_base14_font_outparams_fn(name, outparams)
>>>>>>     return ret, outparams.len
       
    1: def fz_lookup_base14_font_outparams_fn(name):
           """
           Class-aware helper for out-params of fz_lookup_base14_font() [fz_lookup_base14_font()].
           """
>>>>>>     ret, len = ll_fz_lookup_base14_font(name)
>>>>>>     return ret, len
       
    1: fz_lookup_base14_font = fz_lookup_base14_font_outparams_fn
       
       
    1: def ll_fz_lookup_builtin_font(name, bold, italic):
           """
           Wrapper for out-params of fz_lookup_builtin_font().
           Returns: const unsigned char *, int len
           """
>>>>>>     outparams = ll_fz_lookup_builtin_font_outparams()
>>>>>>     ret = ll_fz_lookup_builtin_font_outparams_fn(name, bold, italic, outparams)
>>>>>>     return ret, outparams.len
       
    1: def fz_lookup_builtin_font_outparams_fn(name, bold, italic):
           """
           Class-aware helper for out-params of fz_lookup_builtin_font() [fz_lookup_builtin_font()].
           """
>>>>>>     ret, len = ll_fz_lookup_builtin_font(name, bold, italic)
>>>>>>     return ret, len
       
    1: fz_lookup_builtin_font = fz_lookup_builtin_font_outparams_fn
       
       
    1: def ll_fz_lookup_cjk_font(ordering):
           """
           Wrapper for out-params of fz_lookup_cjk_font().
           Returns: const unsigned char *, int len, int index
           """
>>>>>>     outparams = ll_fz_lookup_cjk_font_outparams()
>>>>>>     ret = ll_fz_lookup_cjk_font_outparams_fn(ordering, outparams)
>>>>>>     return ret, outparams.len, outparams.index
       
    1: def fz_lookup_cjk_font_outparams_fn(ordering):
           """
           Class-aware helper for out-params of fz_lookup_cjk_font() [fz_lookup_cjk_font()].
           """
>>>>>>     ret, len, index = ll_fz_lookup_cjk_font(ordering)
>>>>>>     return ret, len, index
       
    1: fz_lookup_cjk_font = fz_lookup_cjk_font_outparams_fn
       
       
    1: def ll_fz_lookup_cjk_font_by_language(lang):
           """
           Wrapper for out-params of fz_lookup_cjk_font_by_language().
           Returns: const unsigned char *, int len, int subfont
           """
>>>>>>     outparams = ll_fz_lookup_cjk_font_by_language_outparams()
>>>>>>     ret = ll_fz_lookup_cjk_font_by_language_outparams_fn(lang, outparams)
>>>>>>     return ret, outparams.len, outparams.subfont
       
    1: def fz_lookup_cjk_font_by_language_outparams_fn(lang):
           """
           Class-aware helper for out-params of fz_lookup_cjk_font_by_language() [fz_lookup_cjk_font_by_language()].
           """
>>>>>>     ret, len, subfont = ll_fz_lookup_cjk_font_by_language(lang)
>>>>>>     return ret, len, subfont
       
    1: fz_lookup_cjk_font_by_language = fz_lookup_cjk_font_by_language_outparams_fn
       
       
    1: def ll_fz_lookup_noto_boxes_font():
           """
           Wrapper for out-params of fz_lookup_noto_boxes_font().
           Returns: const unsigned char *, int len
           """
>>>>>>     outparams = ll_fz_lookup_noto_boxes_font_outparams()
>>>>>>     ret = ll_fz_lookup_noto_boxes_font_outparams_fn(outparams)
>>>>>>     return ret, outparams.len
       
    1: def fz_lookup_noto_boxes_font_outparams_fn():
           """
           Class-aware helper for out-params of fz_lookup_noto_boxes_font() [fz_lookup_noto_boxes_font()].
           """
>>>>>>     ret, len = ll_fz_lookup_noto_boxes_font()
>>>>>>     return ret, len
       
    1: fz_lookup_noto_boxes_font = fz_lookup_noto_boxes_font_outparams_fn
       
       
    1: def ll_fz_lookup_noto_emoji_font():
           """
           Wrapper for out-params of fz_lookup_noto_emoji_font().
           Returns: const unsigned char *, int len
           """
>>>>>>     outparams = ll_fz_lookup_noto_emoji_font_outparams()
>>>>>>     ret = ll_fz_lookup_noto_emoji_font_outparams_fn(outparams)
>>>>>>     return ret, outparams.len
       
    1: def fz_lookup_noto_emoji_font_outparams_fn():
           """
           Class-aware helper for out-params of fz_lookup_noto_emoji_font() [fz_lookup_noto_emoji_font()].
           """
>>>>>>     ret, len = ll_fz_lookup_noto_emoji_font()
>>>>>>     return ret, len
       
    1: fz_lookup_noto_emoji_font = fz_lookup_noto_emoji_font_outparams_fn
       
       
    1: def ll_fz_lookup_noto_font(script, lang):
           """
           Wrapper for out-params of fz_lookup_noto_font().
           Returns: const unsigned char *, int len, int subfont
           """
>>>>>>     outparams = ll_fz_lookup_noto_font_outparams()
>>>>>>     ret = ll_fz_lookup_noto_font_outparams_fn(script, lang, outparams)
>>>>>>     return ret, outparams.len, outparams.subfont
       
    1: def fz_lookup_noto_font_outparams_fn(script, lang):
           """
           Class-aware helper for out-params of fz_lookup_noto_font() [fz_lookup_noto_font()].
           """
>>>>>>     ret, len, subfont = ll_fz_lookup_noto_font(script, lang)
>>>>>>     return ret, len, subfont
       
    1: fz_lookup_noto_font = fz_lookup_noto_font_outparams_fn
       
       
    1: def ll_fz_lookup_noto_math_font():
           """
           Wrapper for out-params of fz_lookup_noto_math_font().
           Returns: const unsigned char *, int len
           """
>>>>>>     outparams = ll_fz_lookup_noto_math_font_outparams()
>>>>>>     ret = ll_fz_lookup_noto_math_font_outparams_fn(outparams)
>>>>>>     return ret, outparams.len
       
    1: def fz_lookup_noto_math_font_outparams_fn():
           """
           Class-aware helper for out-params of fz_lookup_noto_math_font() [fz_lookup_noto_math_font()].
           """
>>>>>>     ret, len = ll_fz_lookup_noto_math_font()
>>>>>>     return ret, len
       
    1: fz_lookup_noto_math_font = fz_lookup_noto_math_font_outparams_fn
       
       
    1: def ll_fz_lookup_noto_music_font():
           """
           Wrapper for out-params of fz_lookup_noto_music_font().
           Returns: const unsigned char *, int len
           """
>>>>>>     outparams = ll_fz_lookup_noto_music_font_outparams()
>>>>>>     ret = ll_fz_lookup_noto_music_font_outparams_fn(outparams)
>>>>>>     return ret, outparams.len
       
    1: def fz_lookup_noto_music_font_outparams_fn():
           """
           Class-aware helper for out-params of fz_lookup_noto_music_font() [fz_lookup_noto_music_font()].
           """
>>>>>>     ret, len = ll_fz_lookup_noto_music_font()
>>>>>>     return ret, len
       
    1: fz_lookup_noto_music_font = fz_lookup_noto_music_font_outparams_fn
       
       
    1: def ll_fz_lookup_noto_symbol1_font():
           """
           Wrapper for out-params of fz_lookup_noto_symbol1_font().
           Returns: const unsigned char *, int len
           """
>>>>>>     outparams = ll_fz_lookup_noto_symbol1_font_outparams()
>>>>>>     ret = ll_fz_lookup_noto_symbol1_font_outparams_fn(outparams)
>>>>>>     return ret, outparams.len
       
    1: def fz_lookup_noto_symbol1_font_outparams_fn():
           """
           Class-aware helper for out-params of fz_lookup_noto_symbol1_font() [fz_lookup_noto_symbol1_font()].
           """
>>>>>>     ret, len = ll_fz_lookup_noto_symbol1_font()
>>>>>>     return ret, len
       
    1: fz_lookup_noto_symbol1_font = fz_lookup_noto_symbol1_font_outparams_fn
       
       
    1: def ll_fz_lookup_noto_symbol2_font():
           """
           Wrapper for out-params of fz_lookup_noto_symbol2_font().
           Returns: const unsigned char *, int len
           """
>>>>>>     outparams = ll_fz_lookup_noto_symbol2_font_outparams()
>>>>>>     ret = ll_fz_lookup_noto_symbol2_font_outparams_fn(outparams)
>>>>>>     return ret, outparams.len
       
    1: def fz_lookup_noto_symbol2_font_outparams_fn():
           """
           Class-aware helper for out-params of fz_lookup_noto_symbol2_font() [fz_lookup_noto_symbol2_font()].
           """
>>>>>>     ret, len = ll_fz_lookup_noto_symbol2_font()
>>>>>>     return ret, len
       
    1: fz_lookup_noto_symbol2_font = fz_lookup_noto_symbol2_font_outparams_fn
       
       
    1: def ll_fz_new_brotli_data(source, source_length, level):
           """
           Wrapper for out-params of fz_new_brotli_data().
           Returns: unsigned char *, size_t compressed_length
           """
>>>>>>     outparams = ll_fz_new_brotli_data_outparams()
>>>>>>     ret = ll_fz_new_brotli_data_outparams_fn(source, source_length, level, outparams)
>>>>>>     return ret, outparams.compressed_length
       
    1: def fz_new_brotli_data_outparams_fn(source, source_length, level):
           """
           Class-aware helper for out-params of fz_new_brotli_data() [fz_new_brotli_data()].
           """
>>>>>>     ret, compressed_length = ll_fz_new_brotli_data(source, source_length, level)
>>>>>>     return ret, compressed_length
       
    1: fz_new_brotli_data = fz_new_brotli_data_outparams_fn
       
       
    1: def ll_fz_new_brotli_data_from_buffer(buffer, level):
           """
           Wrapper for out-params of fz_new_brotli_data_from_buffer().
           Returns: unsigned char *, size_t compressed_length
           """
>>>>>>     outparams = ll_fz_new_brotli_data_from_buffer_outparams()
>>>>>>     ret = ll_fz_new_brotli_data_from_buffer_outparams_fn(buffer, level, outparams)
>>>>>>     return ret, outparams.compressed_length
       
    1: def fz_new_brotli_data_from_buffer_outparams_fn(buffer, level):
           """
           Class-aware helper for out-params of fz_new_brotli_data_from_buffer() [fz_new_brotli_data_from_buffer()].
           """
>>>>>>     ret, compressed_length = ll_fz_new_brotli_data_from_buffer(buffer.m_internal, level)
>>>>>>     return ret, compressed_length
       
    1: fz_new_brotli_data_from_buffer = fz_new_brotli_data_from_buffer_outparams_fn
       
       
    1: def ll_fz_new_deflated_data(source, source_length, level):
           """
           Wrapper for out-params of fz_new_deflated_data().
           Returns: unsigned char *, size_t compressed_length
           """
>>>>>>     outparams = ll_fz_new_deflated_data_outparams()
>>>>>>     ret = ll_fz_new_deflated_data_outparams_fn(source, source_length, level, outparams)
>>>>>>     return ret, outparams.compressed_length
       
    1: def fz_new_deflated_data_outparams_fn(source, source_length, level):
           """
           Class-aware helper for out-params of fz_new_deflated_data() [fz_new_deflated_data()].
           """
>>>>>>     ret, compressed_length = ll_fz_new_deflated_data(source, source_length, level)
>>>>>>     return ret, compressed_length
       
    1: fz_new_deflated_data = fz_new_deflated_data_outparams_fn
       
       
    1: def ll_fz_new_deflated_data_from_buffer(buffer, level):
           """
           Wrapper for out-params of fz_new_deflated_data_from_buffer().
           Returns: unsigned char *, size_t compressed_length
           """
>>>>>>     outparams = ll_fz_new_deflated_data_from_buffer_outparams()
>>>>>>     ret = ll_fz_new_deflated_data_from_buffer_outparams_fn(buffer, level, outparams)
>>>>>>     return ret, outparams.compressed_length
       
    1: def fz_new_deflated_data_from_buffer_outparams_fn(buffer, level):
           """
           Class-aware helper for out-params of fz_new_deflated_data_from_buffer() [fz_new_deflated_data_from_buffer()].
           """
>>>>>>     ret, compressed_length = ll_fz_new_deflated_data_from_buffer(buffer.m_internal, level)
>>>>>>     return ret, compressed_length
       
    1: fz_new_deflated_data_from_buffer = fz_new_deflated_data_from_buffer_outparams_fn
       
       
    1: def ll_fz_new_display_list_from_svg(buf, base_uri, dir):
           """
           Wrapper for out-params of fz_new_display_list_from_svg().
           Returns: fz_display_list *, float w, float h
           """
>>>>>>     outparams = ll_fz_new_display_list_from_svg_outparams()
>>>>>>     ret = ll_fz_new_display_list_from_svg_outparams_fn(buf, base_uri, dir, outparams)
>>>>>>     return ret, outparams.w, outparams.h
       
    1: def fz_new_display_list_from_svg_outparams_fn(buf, base_uri, dir):
           """
           Class-aware helper for out-params of fz_new_display_list_from_svg() [fz_new_display_list_from_svg()].
           """
>>>>>>     ret, w, h = ll_fz_new_display_list_from_svg(buf.m_internal, base_uri, dir.m_internal)
>>>>>>     return FzDisplayList(ret), w, h
       
    1: fz_new_display_list_from_svg = fz_new_display_list_from_svg_outparams_fn
       
       
    1: def ll_fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir):
           """
           Wrapper for out-params of fz_new_display_list_from_svg_xml().
           Returns: fz_display_list *, float w, float h
           """
>>>>>>     outparams = ll_fz_new_display_list_from_svg_xml_outparams()
>>>>>>     ret = ll_fz_new_display_list_from_svg_xml_outparams_fn(xmldoc, xml, base_uri, dir, outparams)
>>>>>>     return ret, outparams.w, outparams.h
       
    1: def fz_new_display_list_from_svg_xml_outparams_fn(xmldoc, xml, base_uri, dir):
           """
           Class-aware helper for out-params of fz_new_display_list_from_svg_xml() [fz_new_display_list_from_svg_xml()].
           """
>>>>>>     ret, w, h = ll_fz_new_display_list_from_svg_xml(xmldoc.m_internal, xml.m_internal, base_uri, dir.m_internal)
>>>>>>     return FzDisplayList(ret), w, h
       
    1: fz_new_display_list_from_svg_xml = fz_new_display_list_from_svg_xml_outparams_fn
       
       
    1: def ll_fz_new_draw_device_with_options(options, mediabox):
           """
           Wrapper for out-params of fz_new_draw_device_with_options().
           Returns: fz_device *, ::fz_pixmap *pixmap
           """
>>>>>>     outparams = ll_fz_new_draw_device_with_options_outparams()
>>>>>>     ret = ll_fz_new_draw_device_with_options_outparams_fn(options, mediabox, outparams)
>>>>>>     return ret, outparams.pixmap
       
    1: def fz_new_draw_device_with_options_outparams_fn(options, mediabox):
           """
           Class-aware helper for out-params of fz_new_draw_device_with_options() [fz_new_draw_device_with_options()].
           """
>>>>>>     ret, pixmap = ll_fz_new_draw_device_with_options(options.internal(), mediabox.internal())
>>>>>>     return FzDevice(ret), FzPixmap( pixmap)
       
    1: fz_new_draw_device_with_options = fz_new_draw_device_with_options_outparams_fn
       
       
    1: def ll_fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images):
           """
           Wrapper for out-params of fz_new_svg_device_with_id().
           Returns: fz_device *, int id
           """
>>>>>>     outparams = ll_fz_new_svg_device_with_id_outparams()
>>>>>>     ret = ll_fz_new_svg_device_with_id_outparams_fn(out, page_width, page_height, text_format, reuse_images, outparams)
>>>>>>     return ret, outparams.id
       
    1: def fz_new_svg_device_with_id_outparams_fn(out, page_width, page_height, text_format, reuse_images):
           """
           Class-aware helper for out-params of fz_new_svg_device_with_id() [fz_new_svg_device_with_id()].
           """
>>>>>>     ret, id = ll_fz_new_svg_device_with_id(out.m_internal, page_width, page_height, text_format, reuse_images)
>>>>>>     return FzDevice(ret), id
       
    1: fz_new_svg_device_with_id = fz_new_svg_device_with_id_outparams_fn
       
       
    1: def ll_fz_new_test_device(threshold, options, passthrough):
           """
           Wrapper for out-params of fz_new_test_device().
           Returns: fz_device *, int is_color
           """
>>>>>>     outparams = ll_fz_new_test_device_outparams()
>>>>>>     ret = ll_fz_new_test_device_outparams_fn(threshold, options, passthrough, outparams)
>>>>>>     return ret, outparams.is_color
       
    1: def fz_new_test_device_outparams_fn(threshold, options, passthrough):
           """
           Class-aware helper for out-params of fz_new_test_device() [fz_new_test_device()].
           """
>>>>>>     ret, is_color = ll_fz_new_test_device(threshold, options, passthrough.m_internal)
>>>>>>     return FzDevice(ret), is_color
       
    1: fz_new_test_device = fz_new_test_device_outparams_fn
       
       
    1: def ll_fz_open_image_decomp_stream(arg_0, arg_1):
           """
           Wrapper for out-params of fz_open_image_decomp_stream().
           Returns: fz_stream *, int l2factor
           """
>>>>>>     outparams = ll_fz_open_image_decomp_stream_outparams()
>>>>>>     ret = ll_fz_open_image_decomp_stream_outparams_fn(arg_0, arg_1, outparams)
>>>>>>     return ret, outparams.l2factor
       
    1: def fz_open_image_decomp_stream_outparams_fn(arg_0, arg_1):
           """
           Class-aware helper for out-params of fz_open_image_decomp_stream() [fz_open_image_decomp_stream()].
           """
>>>>>>     ret, l2factor = ll_fz_open_image_decomp_stream(arg_0.m_internal, arg_1.m_internal)
>>>>>>     return FzStream(ret), l2factor
       
    1: fz_open_image_decomp_stream = fz_open_image_decomp_stream_outparams_fn
       
       
    1: def ll_fz_open_image_decomp_stream_from_buffer(arg_0):
           """
           Wrapper for out-params of fz_open_image_decomp_stream_from_buffer().
           Returns: fz_stream *, int l2factor
           """
>>>>>>     outparams = ll_fz_open_image_decomp_stream_from_buffer_outparams()
>>>>>>     ret = ll_fz_open_image_decomp_stream_from_buffer_outparams_fn(arg_0, outparams)
>>>>>>     return ret, outparams.l2factor
       
    1: def fz_open_image_decomp_stream_from_buffer_outparams_fn(arg_0):
           """
           Class-aware helper for out-params of fz_open_image_decomp_stream_from_buffer() [fz_open_image_decomp_stream_from_buffer()].
           """
>>>>>>     ret, l2factor = ll_fz_open_image_decomp_stream_from_buffer(arg_0.m_internal)
>>>>>>     return FzStream(ret), l2factor
       
    1: fz_open_image_decomp_stream_from_buffer = fz_open_image_decomp_stream_from_buffer_outparams_fn
       
       
    1: def ll_fz_page_presentation(page, transition):
           """
           Wrapper for out-params of fz_page_presentation().
           Returns: fz_transition *, float duration
           """
>>>>>>     outparams = ll_fz_page_presentation_outparams()
>>>>>>     ret = ll_fz_page_presentation_outparams_fn(page, transition, outparams)
>>>>>>     return ret, outparams.duration
       
    1: def fz_page_presentation_outparams_fn(page, transition):
           """
           Class-aware helper for out-params of fz_page_presentation() [fz_page_presentation()].
           """
>>>>>>     ret, duration = ll_fz_page_presentation(page.m_internal, transition.internal())
>>>>>>     return FzTransition(ret), duration
       
    1: fz_page_presentation = fz_page_presentation_outparams_fn
       
       
    1: def ll_fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop):
           """
           Wrapper for out-params of fz_paint_shade().
           Returns: ::fz_shade_color_cache *cache
           """
>>>>>>     outparams = ll_fz_paint_shade_outparams()
>>>>>>     ret = ll_fz_paint_shade_outparams_fn(shade, override_cs, ctm, dest, color_params, bbox, eop, outparams)
>>>>>>     return outparams.cache
       
    1: def fz_paint_shade_outparams_fn(shade, override_cs, ctm, dest, color_params, bbox, eop):
           """
           Class-aware helper for out-params of fz_paint_shade() [fz_paint_shade()].
           """
>>>>>>     cache = ll_fz_paint_shade(shade.m_internal, override_cs.m_internal, ctm.internal(), dest.m_internal, color_params.internal(), bbox.internal(), eop.m_internal)
>>>>>>     return FzShadeColorCache(ll_fz_keep_shade_color_cache( cache))
       
    1: fz_paint_shade = fz_paint_shade_outparams_fn
       
       
    1: def ll_fz_parse_page_range(s, n):
           """
           Wrapper for out-params of fz_parse_page_range().
           Returns: const char *, int a, int b
           """
>>>>>>     outparams = ll_fz_parse_page_range_outparams()
>>>>>>     ret = ll_fz_parse_page_range_outparams_fn(s, n, outparams)
>>>>>>     return ret, outparams.a, outparams.b
       
    1: def fz_parse_page_range_outparams_fn(s, n):
           """
           Class-aware helper for out-params of fz_parse_page_range() [fz_parse_page_range()].
           """
>>>>>>     ret, a, b = ll_fz_parse_page_range(s, n)
>>>>>>     return ret, a, b
       
    1: fz_parse_page_range = fz_parse_page_range_outparams_fn
       
       
    1: def ll_fz_pool_array_append(arr):
           """
           Wrapper for out-params of fz_pool_array_append().
           Returns: void *, size_t idx
           """
>>>>>>     outparams = ll_fz_pool_array_append_outparams()
>>>>>>     ret = ll_fz_pool_array_append_outparams_fn(arr, outparams)
>>>>>>     return ret, outparams.idx
       
    1: def fz_pool_array_append_outparams_fn(arr):
           """
           Class-aware helper for out-params of fz_pool_array_append() [fz_pool_array_append()].
           """
>>>>>>     ret, idx = ll_fz_pool_array_append(arr.m_internal)
>>>>>>     return ret, idx
       
    1: fz_pool_array_append = fz_pool_array_append_outparams_fn
       
       
    1: def ll_fz_read_best(stm, initial, worst_case):
           """
           Wrapper for out-params of fz_read_best().
           Returns: fz_buffer *, int truncated
           """
>>>>>>     outparams = ll_fz_read_best_outparams()
>>>>>>     ret = ll_fz_read_best_outparams_fn(stm, initial, worst_case, outparams)
>>>>>>     return ret, outparams.truncated
       
    1: def fz_read_best_outparams_fn(stm, initial, worst_case):
           """
           Class-aware helper for out-params of fz_read_best() [fz_read_best()].
           """
>>>>>>     ret, truncated = ll_fz_read_best(stm.m_internal, initial, worst_case)
>>>>>>     return FzBuffer(ret), truncated
       
    1: fz_read_best = fz_read_best_outparams_fn
       
       
    1: def ll_fz_resolve_link(doc, uri):
           """
           Wrapper for out-params of fz_resolve_link().
           Returns: fz_location, float xp, float yp
           """
>>>>>>     outparams = ll_fz_resolve_link_outparams()
>>>>>>     ret = ll_fz_resolve_link_outparams_fn(doc, uri, outparams)
>>>>>>     return ret, outparams.xp, outparams.yp
       
    1: def fz_resolve_link_outparams_fn(doc, uri):
           """
           Class-aware helper for out-params of fz_resolve_link() [fz_resolve_link()].
           """
>>>>>>     ret, xp, yp = ll_fz_resolve_link(doc.m_internal, uri)
>>>>>>     return FzLocation(ret), xp, yp
       
    1: fz_resolve_link = fz_resolve_link_outparams_fn
       
       
    1: def ll_fz_search_chapter_page_number(doc, chapter, page, needle, hit_bbox, hit_max):
           """
           Wrapper for out-params of fz_search_chapter_page_number().
           Returns: int, int hit_mark
           """
>>>>>>     outparams = ll_fz_search_chapter_page_number_outparams()
>>>>>>     ret = ll_fz_search_chapter_page_number_outparams_fn(doc, chapter, page, needle, hit_bbox, hit_max, outparams)
>>>>>>     return ret, outparams.hit_mark
       
    1: def fz_search_chapter_page_number_outparams_fn(doc, chapter, page, needle, hit_bbox, hit_max):
           """
           Class-aware helper for out-params of fz_search_chapter_page_number() [fz_search_chapter_page_number()].
           """
>>>>>>     ret, hit_mark = ll_fz_search_chapter_page_number(doc.m_internal, chapter, page, needle, hit_bbox.internal(), hit_max)
>>>>>>     return ret, hit_mark
       
    1: fz_search_chapter_page_number = fz_search_chapter_page_number_outparams_fn
       
       
    1: def ll_fz_search_display_list(list, needle, hit_bbox, hit_max):
           """
           Wrapper for out-params of fz_search_display_list().
           Returns: int, int hit_mark
           """
>>>>>>     outparams = ll_fz_search_display_list_outparams()
>>>>>>     ret = ll_fz_search_display_list_outparams_fn(list, needle, hit_bbox, hit_max, outparams)
>>>>>>     return ret, outparams.hit_mark
       
    1: def fz_search_display_list_outparams_fn(list, needle, hit_bbox, hit_max):
           """
           Class-aware helper for out-params of fz_search_display_list() [fz_search_display_list()].
           """
>>>>>>     ret, hit_mark = ll_fz_search_display_list(list.m_internal, needle, hit_bbox.internal(), hit_max)
>>>>>>     return ret, hit_mark
       
    1: fz_search_display_list = fz_search_display_list_outparams_fn
       
       
    1: def ll_fz_search_page(page, needle, hit_bbox, hit_max):
           """
           Wrapper for out-params of fz_search_page().
           Returns: int, int hit_mark
           """
>>>>>>     outparams = ll_fz_search_page_outparams()
>>>>>>     ret = ll_fz_search_page_outparams_fn(page, needle, hit_bbox, hit_max, outparams)
>>>>>>     return ret, outparams.hit_mark
       
    1: def fz_search_page_outparams_fn(page, needle, hit_bbox, hit_max):
           """
           Class-aware helper for out-params of fz_search_page() [fz_search_page()].
           """
>>>>>>     ret, hit_mark = ll_fz_search_page(page.m_internal, needle, hit_bbox.internal(), hit_max)
>>>>>>     return ret, hit_mark
       
    1: fz_search_page = fz_search_page_outparams_fn
       
       
    1: def ll_fz_search_page_number(doc, number, needle, hit_bbox, hit_max):
           """
           Wrapper for out-params of fz_search_page_number().
           Returns: int, int hit_mark
           """
>>>>>>     outparams = ll_fz_search_page_number_outparams()
>>>>>>     ret = ll_fz_search_page_number_outparams_fn(doc, number, needle, hit_bbox, hit_max, outparams)
>>>>>>     return ret, outparams.hit_mark
       
    1: def fz_search_page_number_outparams_fn(doc, number, needle, hit_bbox, hit_max):
           """
           Class-aware helper for out-params of fz_search_page_number() [fz_search_page_number()].
           """
>>>>>>     ret, hit_mark = ll_fz_search_page_number(doc.m_internal, number, needle, hit_bbox.internal(), hit_max)
>>>>>>     return ret, hit_mark
       
    1: fz_search_page_number = fz_search_page_number_outparams_fn
       
       
    1: def ll_fz_search_stext_page(text, needle, hit_bbox, hit_max):
           """
           Wrapper for out-params of fz_search_stext_page().
           Returns: int, int hit_mark
           """
>>>>>>     outparams = ll_fz_search_stext_page_outparams()
>>>>>>     ret = ll_fz_search_stext_page_outparams_fn(text, needle, hit_bbox, hit_max, outparams)
>>>>>>     return ret, outparams.hit_mark
       
    1: def fz_search_stext_page_outparams_fn(text, needle, hit_bbox, hit_max):
           """
           Class-aware helper for out-params of fz_search_stext_page() [fz_search_stext_page()].
           """
>>>>>>     ret, hit_mark = ll_fz_search_stext_page(text.m_internal, needle, hit_bbox.internal(), hit_max)
>>>>>>     return ret, hit_mark
       
    1: fz_search_stext_page = fz_search_stext_page_outparams_fn
       
       
    1: def ll_fz_separation_equivalent(seps, idx, dst_cs, prf, color_params):
           """
           Wrapper for out-params of fz_separation_equivalent().
           Returns: float dst_color
           """
>>>>>>     outparams = ll_fz_separation_equivalent_outparams()
>>>>>>     ret = ll_fz_separation_equivalent_outparams_fn(seps, idx, dst_cs, prf, color_params, outparams)
>>>>>>     return outparams.dst_color
       
    1: def fz_separation_equivalent_outparams_fn(seps, idx, dst_cs, prf, color_params):
           """
           Class-aware helper for out-params of fz_separation_equivalent() [fz_separation_equivalent()].
           """
>>>>>>     dst_color = ll_fz_separation_equivalent(seps.m_internal, idx, dst_cs.m_internal, prf.m_internal, color_params.internal())
>>>>>>     return dst_color
       
    1: fz_separation_equivalent = fz_separation_equivalent_outparams_fn
       
       
    1: def ll_fz_store_scavenge(size):
           """
           Wrapper for out-params of fz_store_scavenge().
           Returns: int, int phase
           """
>>>>>>     outparams = ll_fz_store_scavenge_outparams()
>>>>>>     ret = ll_fz_store_scavenge_outparams_fn(size, outparams)
>>>>>>     return ret, outparams.phase
       
    1: def fz_store_scavenge_outparams_fn(size):
           """
           Class-aware helper for out-params of fz_store_scavenge() [fz_store_scavenge()].
           """
>>>>>>     ret, phase = ll_fz_store_scavenge(size)
>>>>>>     return ret, phase
       
    1: fz_store_scavenge = fz_store_scavenge_outparams_fn
       
       
    1: def ll_fz_store_scavenge_external(size):
           """
           Wrapper for out-params of fz_store_scavenge_external().
           Returns: int, int phase
           """
>>>>>>     outparams = ll_fz_store_scavenge_external_outparams()
>>>>>>     ret = ll_fz_store_scavenge_external_outparams_fn(size, outparams)
>>>>>>     return ret, outparams.phase
       
    1: def fz_store_scavenge_external_outparams_fn(size):
           """
           Class-aware helper for out-params of fz_store_scavenge_external() [fz_store_scavenge_external()].
           """
>>>>>>     ret, phase = ll_fz_store_scavenge_external(size)
>>>>>>     return ret, phase
       
    1: fz_store_scavenge_external = fz_store_scavenge_external_outparams_fn
       
       
    1: def ll_fz_strsep(delim):
           """
           Wrapper for out-params of fz_strsep().
           Returns: char *, char *stringp
           """
>>>>>>     outparams = ll_fz_strsep_outparams()
>>>>>>     ret = ll_fz_strsep_outparams_fn(delim, outparams)
>>>>>>     return ret, outparams.stringp
       
    1: def fz_strsep_outparams_fn(delim):
           """
           Class-aware helper for out-params of fz_strsep() [fz_strsep()].
           """
>>>>>>     ret, stringp = ll_fz_strsep(delim)
>>>>>>     return ret, stringp
       
    1: fz_strsep = fz_strsep_outparams_fn
       
       
    1: def ll_fz_strtof(s):
           """
           Wrapper for out-params of fz_strtof().
           Returns: float, char *es
           """
>>>>>>     outparams = ll_fz_strtof_outparams()
>>>>>>     ret = ll_fz_strtof_outparams_fn(s, outparams)
>>>>>>     return ret, outparams.es
       
    1: def fz_strtof_outparams_fn(s):
           """
           Class-aware helper for out-params of fz_strtof() [fz_strtof()].
           """
>>>>>>     ret, es = ll_fz_strtof(s)
>>>>>>     return ret, es
       
    1: fz_strtof = fz_strtof_outparams_fn
       
       
    1: def ll_fz_subset_cff_for_gids(orig, num_gids, symbolic, cidfont):
           """
           Wrapper for out-params of fz_subset_cff_for_gids().
           Returns: fz_buffer *, int gids
           """
>>>>>>     outparams = ll_fz_subset_cff_for_gids_outparams()
>>>>>>     ret = ll_fz_subset_cff_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams)
>>>>>>     return ret, outparams.gids
       
    1: def fz_subset_cff_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont):
           """
           Class-aware helper for out-params of fz_subset_cff_for_gids() [fz_subset_cff_for_gids()].
           """
>>>>>>     ret, gids = ll_fz_subset_cff_for_gids(orig.m_internal, num_gids, symbolic, cidfont)
>>>>>>     return FzBuffer( ll_fz_keep_buffer( ret)), gids
       
    1: fz_subset_cff_for_gids = fz_subset_cff_for_gids_outparams_fn
       
       
    1: def ll_fz_subset_ttf_for_gids(orig, num_gids, symbolic, cidfont):
           """
           Wrapper for out-params of fz_subset_ttf_for_gids().
           Returns: fz_buffer *, int gids
           """
>>>>>>     outparams = ll_fz_subset_ttf_for_gids_outparams()
>>>>>>     ret = ll_fz_subset_ttf_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams)
>>>>>>     return ret, outparams.gids
       
    1: def fz_subset_ttf_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont):
           """
           Class-aware helper for out-params of fz_subset_ttf_for_gids() [fz_subset_ttf_for_gids()].
           """
>>>>>>     ret, gids = ll_fz_subset_ttf_for_gids(orig.m_internal, num_gids, symbolic, cidfont)
>>>>>>     return FzBuffer( ll_fz_keep_buffer( ret)), gids
       
    1: fz_subset_ttf_for_gids = fz_subset_ttf_for_gids_outparams_fn
       
       
    1: def ll_fz_warning_callback():
           """
           Wrapper for out-params of fz_warning_callback().
           Returns: fz_warning_cb *, void *user
           """
>>>>>>     outparams = ll_fz_warning_callback_outparams()
>>>>>>     ret = ll_fz_warning_callback_outparams_fn(outparams)
>>>>>>     return ret, outparams.user
       
    1: def fz_warning_callback_outparams_fn():
           """
           Class-aware helper for out-params of fz_warning_callback() [fz_warning_callback()].
           """
>>>>>>     ret, user = ll_fz_warning_callback()
>>>>>>     return ret, user
       
    1: fz_warning_callback = fz_warning_callback_outparams_fn
       
       
    1: def ll_pdf_annot_MK_BC(annot, color):
           """
           Wrapper for out-params of pdf_annot_MK_BC().
           Returns: int n
           """
>>>>>>     outparams = ll_pdf_annot_MK_BC_outparams()
>>>>>>     ret = ll_pdf_annot_MK_BC_outparams_fn(annot, color, outparams)
>>>>>>     return outparams.n
       
    1: def pdf_annot_MK_BC_outparams_fn(annot, color):
           """
           Class-aware helper for out-params of pdf_annot_MK_BC() [pdf_annot_MK_BC()].
           """
>>>>>>     n = ll_pdf_annot_MK_BC(annot.m_internal, color)
>>>>>>     return n
       
    1: pdf_annot_MK_BC = pdf_annot_MK_BC_outparams_fn
       
       
    1: def ll_pdf_annot_MK_BG(annot, color):
           """
           Wrapper for out-params of pdf_annot_MK_BG().
           Returns: int n
           """
>>>>>>     outparams = ll_pdf_annot_MK_BG_outparams()
>>>>>>     ret = ll_pdf_annot_MK_BG_outparams_fn(annot, color, outparams)
>>>>>>     return outparams.n
       
    1: def pdf_annot_MK_BG_outparams_fn(annot, color):
           """
           Class-aware helper for out-params of pdf_annot_MK_BG() [pdf_annot_MK_BG()].
           """
>>>>>>     n = ll_pdf_annot_MK_BG(annot.m_internal, color)
>>>>>>     return n
       
    1: pdf_annot_MK_BG = pdf_annot_MK_BG_outparams_fn
       
       
    1: def ll_pdf_annot_callout_line(annot, callout):
           """
           Wrapper for out-params of pdf_annot_callout_line().
           Returns: int n
           """
>>>>>>     outparams = ll_pdf_annot_callout_line_outparams()
>>>>>>     ret = ll_pdf_annot_callout_line_outparams_fn(annot, callout, outparams)
>>>>>>     return outparams.n
       
    1: def pdf_annot_callout_line_outparams_fn(annot, callout):
           """
           Class-aware helper for out-params of pdf_annot_callout_line() [pdf_annot_callout_line()].
           """
>>>>>>     n = ll_pdf_annot_callout_line(annot.m_internal, callout)
>>>>>>     return n
       
    1: pdf_annot_callout_line = pdf_annot_callout_line_outparams_fn
       
       
    1: def ll_pdf_annot_color(annot, color):
           """
           Wrapper for out-params of pdf_annot_color().
           Returns: int n
           """
>>>>>>     outparams = ll_pdf_annot_color_outparams()
>>>>>>     ret = ll_pdf_annot_color_outparams_fn(annot, color, outparams)
>>>>>>     return outparams.n
       
    1: def pdf_annot_color_outparams_fn(annot, color):
           """
           Class-aware helper for out-params of pdf_annot_color() [pdf_annot_color()].
           """
>>>>>>     n = ll_pdf_annot_color(annot.m_internal, color)
>>>>>>     return n
       
    1: pdf_annot_color = pdf_annot_color_outparams_fn
       
       
    1: def ll_pdf_annot_default_appearance(annot, color):
           """
           Wrapper for out-params of pdf_annot_default_appearance().
           Returns: const char *font, float size, int n
           """
>>>>>>     outparams = ll_pdf_annot_default_appearance_outparams()
>>>>>>     ret = ll_pdf_annot_default_appearance_outparams_fn(annot, color, outparams)
>>>>>>     return outparams.font, outparams.size, outparams.n
       
    1: def pdf_annot_default_appearance_outparams_fn(annot, color):
           """
           Class-aware helper for out-params of pdf_annot_default_appearance() [pdf_annot_default_appearance()].
           """
>>>>>>     font, size, n = ll_pdf_annot_default_appearance(annot.m_internal, color)
>>>>>>     return font, size, n
       
    1: pdf_annot_default_appearance = pdf_annot_default_appearance_outparams_fn
       
       
    1: def ll_pdf_annot_default_appearance_unmapped(annot, font_name, font_name_len, color):
           """
           Wrapper for out-params of pdf_annot_default_appearance_unmapped().
           Returns: float size, int n
           """
>>>>>>     outparams = ll_pdf_annot_default_appearance_unmapped_outparams()
>>>>>>     ret = ll_pdf_annot_default_appearance_unmapped_outparams_fn(annot, font_name, font_name_len, color, outparams)
>>>>>>     return outparams.size, outparams.n
       
    1: def pdf_annot_default_appearance_unmapped_outparams_fn(annot, font_name, font_name_len, color):
           """
           Class-aware helper for out-params of pdf_annot_default_appearance_unmapped() [pdf_annot_default_appearance_unmapped()].
           """
>>>>>>     size, n = ll_pdf_annot_default_appearance_unmapped(annot.m_internal, font_name, font_name_len, color)
>>>>>>     return size, n
       
    1: pdf_annot_default_appearance_unmapped = pdf_annot_default_appearance_unmapped_outparams_fn
       
       
    1: def ll_pdf_annot_interior_color(annot, color):
           """
           Wrapper for out-params of pdf_annot_interior_color().
           Returns: int n
           """
>>>>>>     outparams = ll_pdf_annot_interior_color_outparams()
>>>>>>     ret = ll_pdf_annot_interior_color_outparams_fn(annot, color, outparams)
>>>>>>     return outparams.n
       
    1: def pdf_annot_interior_color_outparams_fn(annot, color):
           """
           Class-aware helper for out-params of pdf_annot_interior_color() [pdf_annot_interior_color()].
           """
>>>>>>     n = ll_pdf_annot_interior_color(annot.m_internal, color)
>>>>>>     return n
       
    1: pdf_annot_interior_color = pdf_annot_interior_color_outparams_fn
       
       
    1: def ll_pdf_annot_line_ending_styles(annot):
           """
           Wrapper for out-params of pdf_annot_line_ending_styles().
           Returns: enum pdf_line_ending start_style, enum pdf_line_ending end_style
           """
>>>>>>     outparams = ll_pdf_annot_line_ending_styles_outparams()
>>>>>>     ret = ll_pdf_annot_line_ending_styles_outparams_fn(annot, outparams)
>>>>>>     return outparams.start_style, outparams.end_style
       
    1: def pdf_annot_line_ending_styles_outparams_fn(annot):
           """
           Class-aware helper for out-params of pdf_annot_line_ending_styles() [pdf_annot_line_ending_styles()].
           """
>>>>>>     start_style, end_style = ll_pdf_annot_line_ending_styles(annot.m_internal)
>>>>>>     return start_style, end_style
       
    1: pdf_annot_line_ending_styles = pdf_annot_line_ending_styles_outparams_fn
       
       
    1: def ll_pdf_array_get_string(array, index):
           """
           Wrapper for out-params of pdf_array_get_string().
           Returns: const char *, size_t sizep
           """
>>>>>>     outparams = ll_pdf_array_get_string_outparams()
>>>>>>     ret = ll_pdf_array_get_string_outparams_fn(array, index, outparams)
>>>>>>     return ret, outparams.sizep
       
    1: def pdf_array_get_string_outparams_fn(array, index):
           """
           Class-aware helper for out-params of pdf_array_get_string() [pdf_array_get_string()].
           """
>>>>>>     ret, sizep = ll_pdf_array_get_string(array.m_internal, index)
>>>>>>     return ret, sizep
       
    1: pdf_array_get_string = pdf_array_get_string_outparams_fn
       
       
    1: def ll_pdf_count_q_balance(doc, res, stm):
           """
           Wrapper for out-params of pdf_count_q_balance().
           Returns: int prepend, int append
           """
>>>>>>     outparams = ll_pdf_count_q_balance_outparams()
>>>>>>     ret = ll_pdf_count_q_balance_outparams_fn(doc, res, stm, outparams)
>>>>>>     return outparams.prepend, outparams.append
       
    1: def pdf_count_q_balance_outparams_fn(doc, res, stm):
           """
           Class-aware helper for out-params of pdf_count_q_balance() [pdf_count_q_balance()].
           """
>>>>>>     prepend, append = ll_pdf_count_q_balance(doc.m_internal, res.m_internal, stm.m_internal)
>>>>>>     return prepend, append
       
    1: pdf_count_q_balance = pdf_count_q_balance_outparams_fn
       
       
    1: def ll_pdf_decode_cmap(cmap, s, e):
           """
           Wrapper for out-params of pdf_decode_cmap().
           Returns: int, unsigned int cpt
           """
>>>>>>     outparams = ll_pdf_decode_cmap_outparams()
>>>>>>     ret = ll_pdf_decode_cmap_outparams_fn(cmap, s, e, outparams)
>>>>>>     return ret, outparams.cpt
       
    1: def pdf_decode_cmap_outparams_fn(cmap, s, e):
           """
           Class-aware helper for out-params of pdf_decode_cmap() [pdf_decode_cmap()].
           """
>>>>>>     ret, cpt = ll_pdf_decode_cmap(cmap.m_internal, s, e)
>>>>>>     return ret, cpt
       
    1: pdf_decode_cmap = pdf_decode_cmap_outparams_fn
       
       
    1: def ll_pdf_dict_get_inheritable_string(dict, key):
           """
           Wrapper for out-params of pdf_dict_get_inheritable_string().
           Returns: const char *, size_t sizep
           """
>>>>>>     outparams = ll_pdf_dict_get_inheritable_string_outparams()
>>>>>>     ret = ll_pdf_dict_get_inheritable_string_outparams_fn(dict, key, outparams)
>>>>>>     return ret, outparams.sizep
       
    1: def pdf_dict_get_inheritable_string_outparams_fn(dict, key):
           """
           Class-aware helper for out-params of pdf_dict_get_inheritable_string() [pdf_dict_get_inheritable_string()].
           """
>>>>>>     ret, sizep = ll_pdf_dict_get_inheritable_string(dict.m_internal, key.m_internal)
>>>>>>     return ret, sizep
       
    1: pdf_dict_get_inheritable_string = pdf_dict_get_inheritable_string_outparams_fn
       
       
    1: def ll_pdf_dict_get_put_drop(dict, key, val):
           """
           Wrapper for out-params of pdf_dict_get_put_drop().
           Returns: ::pdf_obj *old_val
           """
>>>>>>     outparams = ll_pdf_dict_get_put_drop_outparams()
>>>>>>     ret = ll_pdf_dict_get_put_drop_outparams_fn(dict, key, val, outparams)
>>>>>>     return outparams.old_val
       
    1: def ll_pdf_dict_get_string(dict, key):
           """
           Wrapper for out-params of pdf_dict_get_string().
           Returns: const char *, size_t sizep
           """
>>>>>>     outparams = ll_pdf_dict_get_string_outparams()
>>>>>>     ret = ll_pdf_dict_get_string_outparams_fn(dict, key, outparams)
>>>>>>     return ret, outparams.sizep
       
    1: def pdf_dict_get_string_outparams_fn(dict, key):
           """
           Class-aware helper for out-params of pdf_dict_get_string() [pdf_dict_get_string()].
           """
>>>>>>     ret, sizep = ll_pdf_dict_get_string(dict.m_internal, key.m_internal)
>>>>>>     return ret, sizep
       
    1: pdf_dict_get_string = pdf_dict_get_string_outparams_fn
       
       
    1: def ll_pdf_edit_text_field_value(widget, value, change):
           """
           Wrapper for out-params of pdf_edit_text_field_value().
           Returns: int, int selStart, int selEnd, char *newvalue
           """
>>>>>>     outparams = ll_pdf_edit_text_field_value_outparams()
>>>>>>     ret = ll_pdf_edit_text_field_value_outparams_fn(widget, value, change, outparams)
>>>>>>     return ret, outparams.selStart, outparams.selEnd, outparams.newvalue
       
    1: def pdf_edit_text_field_value_outparams_fn(widget, value, change):
           """
           Class-aware helper for out-params of pdf_edit_text_field_value() [pdf_edit_text_field_value()].
           """
>>>>>>     ret, selStart, selEnd, newvalue = ll_pdf_edit_text_field_value(widget.m_internal, value, change)
>>>>>>     return ret, selStart, selEnd, newvalue
       
    1: pdf_edit_text_field_value = pdf_edit_text_field_value_outparams_fn
       
       
    1: def ll_pdf_eval_function(func, in_, inlen, outlen):
           """
           Wrapper for out-params of pdf_eval_function().
           Returns: float out
           """
>>>>>>     outparams = ll_pdf_eval_function_outparams()
>>>>>>     ret = ll_pdf_eval_function_outparams_fn(func, in_, inlen, outlen, outparams)
>>>>>>     return outparams.out
       
    1: def pdf_eval_function_outparams_fn(func, in_, inlen, outlen):
           """
           Class-aware helper for out-params of pdf_eval_function() [pdf_eval_function()].
           """
>>>>>>     out = ll_pdf_eval_function(func.m_internal, in_, inlen, outlen)
>>>>>>     return out
       
    1: pdf_eval_function = pdf_eval_function_outparams_fn
       
       
    1: def ll_pdf_field_event_validate(doc, field, value):
           """
           Wrapper for out-params of pdf_field_event_validate().
           Returns: int, char *newvalue
           """
>>>>>>     outparams = ll_pdf_field_event_validate_outparams()
>>>>>>     ret = ll_pdf_field_event_validate_outparams_fn(doc, field, value, outparams)
>>>>>>     return ret, outparams.newvalue
       
    1: def pdf_field_event_validate_outparams_fn(doc, field, value):
           """
           Class-aware helper for out-params of pdf_field_event_validate() [pdf_field_event_validate()].
           """
>>>>>>     ret, newvalue = ll_pdf_field_event_validate(doc.m_internal, field.m_internal, value)
>>>>>>     return ret, newvalue
       
    1: pdf_field_event_validate = pdf_field_event_validate_outparams_fn
       
       
    1: def ll_pdf_js_event_result_validate(js):
           """
           Wrapper for out-params of pdf_js_event_result_validate().
           Returns: int, char *newvalue
           """
>>>>>>     outparams = ll_pdf_js_event_result_validate_outparams()
>>>>>>     ret = ll_pdf_js_event_result_validate_outparams_fn(js, outparams)
>>>>>>     return ret, outparams.newvalue
       
    1: def pdf_js_event_result_validate_outparams_fn(js):
           """
           Class-aware helper for out-params of pdf_js_event_result_validate() [pdf_js_event_result_validate()].
           """
>>>>>>     ret, newvalue = ll_pdf_js_event_result_validate(js.m_internal)
>>>>>>     return ret, newvalue
       
    1: pdf_js_event_result_validate = pdf_js_event_result_validate_outparams_fn
       
       
    1: def ll_pdf_js_execute(js, name, code):
           """
           Wrapper for out-params of pdf_js_execute().
           Returns: char *result
           """
>>>>>>     outparams = ll_pdf_js_execute_outparams()
>>>>>>     ret = ll_pdf_js_execute_outparams_fn(js, name, code, outparams)
>>>>>>     return outparams.result
       
    1: def pdf_js_execute_outparams_fn(js, name, code):
           """
           Class-aware helper for out-params of pdf_js_execute() [pdf_js_execute()].
           """
>>>>>>     result = ll_pdf_js_execute(js.m_internal, name, code)
>>>>>>     return result
       
    1: pdf_js_execute = pdf_js_execute_outparams_fn
       
       
    1: def ll_pdf_load_encoding(encoding):
           """
           Wrapper for out-params of pdf_load_encoding().
           Returns: const char *estrings
           """
>>>>>>     outparams = ll_pdf_load_encoding_outparams()
>>>>>>     ret = ll_pdf_load_encoding_outparams_fn(encoding, outparams)
>>>>>>     return outparams.estrings
       
    1: def pdf_load_encoding_outparams_fn(encoding):
           """
           Class-aware helper for out-params of pdf_load_encoding() [pdf_load_encoding()].
           """
>>>>>>     estrings = ll_pdf_load_encoding(encoding)
>>>>>>     return estrings
       
    1: pdf_load_encoding = pdf_load_encoding_outparams_fn
       
       
    1: def ll_pdf_load_to_unicode(doc, font, collection, cmapstm):
           """
           Wrapper for out-params of pdf_load_to_unicode().
           Returns: const char *strings
           """
>>>>>>     outparams = ll_pdf_load_to_unicode_outparams()
>>>>>>     ret = ll_pdf_load_to_unicode_outparams_fn(doc, font, collection, cmapstm, outparams)
>>>>>>     return outparams.strings
       
    1: def pdf_load_to_unicode_outparams_fn(doc, font, collection, cmapstm):
           """
           Class-aware helper for out-params of pdf_load_to_unicode() [pdf_load_to_unicode()].
           """
>>>>>>     strings = ll_pdf_load_to_unicode(doc.m_internal, font.m_internal, collection, cmapstm.m_internal)
>>>>>>     return strings
       
    1: pdf_load_to_unicode = pdf_load_to_unicode_outparams_fn
       
       
    1: def ll_pdf_lookup_cmap_full(cmap, cpt):
           """
           Wrapper for out-params of pdf_lookup_cmap_full().
           Returns: int, int out
           """
>>>>>>     outparams = ll_pdf_lookup_cmap_full_outparams()
>>>>>>     ret = ll_pdf_lookup_cmap_full_outparams_fn(cmap, cpt, outparams)
>>>>>>     return ret, outparams.out
       
    1: def pdf_lookup_cmap_full_outparams_fn(cmap, cpt):
           """
           Class-aware helper for out-params of pdf_lookup_cmap_full() [pdf_lookup_cmap_full()].
           """
>>>>>>     ret, out = ll_pdf_lookup_cmap_full(cmap.m_internal, cpt)
>>>>>>     return ret, out
       
    1: pdf_lookup_cmap_full = pdf_lookup_cmap_full_outparams_fn
       
       
    1: def ll_pdf_lookup_page_loc(doc, needle):
           """
           Wrapper for out-params of pdf_lookup_page_loc().
           Returns: pdf_obj *, ::pdf_obj *parentp, int indexp
           """
>>>>>>     outparams = ll_pdf_lookup_page_loc_outparams()
>>>>>>     ret = ll_pdf_lookup_page_loc_outparams_fn(doc, needle, outparams)
>>>>>>     return ret, outparams.parentp, outparams.indexp
       
    1: def pdf_lookup_page_loc_outparams_fn(doc, needle):
           """
           Class-aware helper for out-params of pdf_lookup_page_loc() [pdf_lookup_page_loc()].
           """
>>>>>>     ret, parentp, indexp = ll_pdf_lookup_page_loc(doc.m_internal, needle)
>>>>>>     return PdfObj( ll_pdf_keep_obj( ret)), PdfObj(ll_pdf_keep_obj( parentp)), indexp
       
    1: pdf_lookup_page_loc = pdf_lookup_page_loc_outparams_fn
       
       
    1: def ll_pdf_lookup_substitute_font(mono, serif, bold, italic):
           """
           Wrapper for out-params of pdf_lookup_substitute_font().
           Returns: const unsigned char *, int len
           """
>>>>>>     outparams = ll_pdf_lookup_substitute_font_outparams()
>>>>>>     ret = ll_pdf_lookup_substitute_font_outparams_fn(mono, serif, bold, italic, outparams)
>>>>>>     return ret, outparams.len
       
    1: def pdf_lookup_substitute_font_outparams_fn(mono, serif, bold, italic):
           """
           Class-aware helper for out-params of pdf_lookup_substitute_font() [pdf_lookup_substitute_font()].
           """
>>>>>>     ret, len = ll_pdf_lookup_substitute_font(mono, serif, bold, italic)
>>>>>>     return ret, len
       
    1: pdf_lookup_substitute_font = pdf_lookup_substitute_font_outparams_fn
       
       
    1: def ll_pdf_map_one_to_many(cmap, one, len):
           """
           Wrapper for out-params of pdf_map_one_to_many().
           Returns: int many
           """
>>>>>>     outparams = ll_pdf_map_one_to_many_outparams()
>>>>>>     ret = ll_pdf_map_one_to_many_outparams_fn(cmap, one, len, outparams)
>>>>>>     return outparams.many
       
    1: def pdf_map_one_to_many_outparams_fn(cmap, one, len):
           """
           Class-aware helper for out-params of pdf_map_one_to_many() [pdf_map_one_to_many()].
           """
>>>>>>     many = ll_pdf_map_one_to_many(cmap.m_internal, one, len)
>>>>>>     return many
       
    1: pdf_map_one_to_many = pdf_map_one_to_many_outparams_fn
       
       
    1: def ll_pdf_obj_memo(obj, bit):
           """
           Wrapper for out-params of pdf_obj_memo().
           Returns: int, int memo
           """
>>>>>>     outparams = ll_pdf_obj_memo_outparams()
>>>>>>     ret = ll_pdf_obj_memo_outparams_fn(obj, bit, outparams)
>>>>>>     return ret, outparams.memo
       
    1: def pdf_obj_memo_outparams_fn(obj, bit):
           """
           Class-aware helper for out-params of pdf_obj_memo() [pdf_obj_memo()].
           """
>>>>>>     ret, memo = ll_pdf_obj_memo(obj.m_internal, bit)
>>>>>>     return ret, memo
       
    1: pdf_obj_memo = pdf_obj_memo_outparams_fn
       
       
    1: def ll_pdf_page_presentation(page, transition):
           """
           Wrapper for out-params of pdf_page_presentation().
           Returns: fz_transition *, float duration
           """
>>>>>>     outparams = ll_pdf_page_presentation_outparams()
>>>>>>     ret = ll_pdf_page_presentation_outparams_fn(page, transition, outparams)
>>>>>>     return ret, outparams.duration
       
    1: def pdf_page_presentation_outparams_fn(page, transition):
           """
           Class-aware helper for out-params of pdf_page_presentation() [pdf_page_presentation()].
           """
>>>>>>     ret, duration = ll_pdf_page_presentation(page.m_internal, transition.internal())
>>>>>>     return FzTransition(ret), duration
       
    1: pdf_page_presentation = pdf_page_presentation_outparams_fn
       
       
    1: def ll_pdf_page_write(doc, mediabox):
           """
           Wrapper for out-params of pdf_page_write().
           Returns: fz_device *, ::pdf_obj *presources, ::fz_buffer *pcontents
           """
>>>>>>     outparams = ll_pdf_page_write_outparams()
>>>>>>     ret = ll_pdf_page_write_outparams_fn(doc, mediabox, outparams)
>>>>>>     return ret, outparams.presources, outparams.pcontents
       
    1: def pdf_page_write_outparams_fn(doc, mediabox):
           """
           Class-aware helper for out-params of pdf_page_write() [pdf_page_write()].
           """
>>>>>>     ret, presources, pcontents = ll_pdf_page_write(doc.m_internal, mediabox.internal())
>>>>>>     return FzDevice(ret), PdfObj( presources), FzBuffer( pcontents)
       
    1: pdf_page_write = pdf_page_write_outparams_fn
       
       
    1: def ll_pdf_parse_default_appearance(da, color):
           """
           Wrapper for out-params of pdf_parse_default_appearance().
           Returns: const char *font, float size, int n
           """
>>>>>>     outparams = ll_pdf_parse_default_appearance_outparams()
>>>>>>     ret = ll_pdf_parse_default_appearance_outparams_fn(da, color, outparams)
>>>>>>     return outparams.font, outparams.size, outparams.n
       
    1: def pdf_parse_default_appearance_outparams_fn(da, color):
           """
           Class-aware helper for out-params of pdf_parse_default_appearance() [pdf_parse_default_appearance()].
           """
>>>>>>     font, size, n = ll_pdf_parse_default_appearance(da, color)
>>>>>>     return font, size, n
       
    1: pdf_parse_default_appearance = pdf_parse_default_appearance_outparams_fn
       
       
    1: def ll_pdf_parse_default_appearance_unmapped(da, font_name, font_name_len, color):
           """
           Wrapper for out-params of pdf_parse_default_appearance_unmapped().
           Returns: float size, int n
           """
>>>>>>     outparams = ll_pdf_parse_default_appearance_unmapped_outparams()
>>>>>>     ret = ll_pdf_parse_default_appearance_unmapped_outparams_fn(da, font_name, font_name_len, color, outparams)
>>>>>>     return outparams.size, outparams.n
       
    1: def pdf_parse_default_appearance_unmapped_outparams_fn(da, font_name, font_name_len, color):
           """
           Class-aware helper for out-params of pdf_parse_default_appearance_unmapped() [pdf_parse_default_appearance_unmapped()].
           """
>>>>>>     size, n = ll_pdf_parse_default_appearance_unmapped(da, font_name, font_name_len, color)
>>>>>>     return size, n
       
    1: pdf_parse_default_appearance_unmapped = pdf_parse_default_appearance_unmapped_outparams_fn
       
       
    1: def ll_pdf_parse_ind_obj(doc, f):
           """
           Wrapper for out-params of pdf_parse_ind_obj().
           Returns: pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair
           """
>>>>>>     outparams = ll_pdf_parse_ind_obj_outparams()
>>>>>>     ret = ll_pdf_parse_ind_obj_outparams_fn(doc, f, outparams)
>>>>>>     return ret, outparams.num, outparams.gen, outparams.stm_ofs, outparams.try_repair
       
    1: def pdf_parse_ind_obj_outparams_fn(doc, f):
           """
           Class-aware helper for out-params of pdf_parse_ind_obj() [pdf_parse_ind_obj()].
           """
>>>>>>     ret, num, gen, stm_ofs, try_repair = ll_pdf_parse_ind_obj(doc.m_internal, f.m_internal)
>>>>>>     return PdfObj(ret), num, gen, stm_ofs, try_repair
       
    1: pdf_parse_ind_obj = pdf_parse_ind_obj_outparams_fn
       
       
    1: def ll_pdf_parse_journal_obj(doc, stm):
           """
           Wrapper for out-params of pdf_parse_journal_obj().
           Returns: pdf_obj *, int onum, ::fz_buffer *ostm, int newobj
           """
>>>>>>     outparams = ll_pdf_parse_journal_obj_outparams()
>>>>>>     ret = ll_pdf_parse_journal_obj_outparams_fn(doc, stm, outparams)
>>>>>>     return ret, outparams.onum, outparams.ostm, outparams.newobj
       
    1: def pdf_parse_journal_obj_outparams_fn(doc, stm):
           """
           Class-aware helper for out-params of pdf_parse_journal_obj() [pdf_parse_journal_obj()].
           """
>>>>>>     ret, onum, ostm, newobj = ll_pdf_parse_journal_obj(doc.m_internal, stm.m_internal)
>>>>>>     return PdfObj(ret), onum, FzBuffer( ostm), newobj
       
    1: pdf_parse_journal_obj = pdf_parse_journal_obj_outparams_fn
       
       
    1: def ll_pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen):
           """
           Wrapper for out-params of pdf_print_encrypted_obj().
           Returns: int sep
           """
>>>>>>     outparams = ll_pdf_print_encrypted_obj_outparams()
>>>>>>     ret = ll_pdf_print_encrypted_obj_outparams_fn(out, obj, tight, ascii, crypt, num, gen, outparams)
>>>>>>     return outparams.sep
       
    1: def pdf_print_encrypted_obj_outparams_fn(out, obj, tight, ascii, crypt, num, gen):
           """
           Class-aware helper for out-params of pdf_print_encrypted_obj() [pdf_print_encrypted_obj()].
           """
>>>>>>     sep = ll_pdf_print_encrypted_obj(out.m_internal, obj.m_internal, tight, ascii, crypt.m_internal, num, gen)
>>>>>>     return sep
       
    1: pdf_print_encrypted_obj = pdf_print_encrypted_obj_outparams_fn
       
       
    1: def ll_pdf_process_contents(proc, doc, res, stm, cookie):
           """
           Wrapper for out-params of pdf_process_contents().
           Returns: ::pdf_obj *out_res
           """
>>>>>>     outparams = ll_pdf_process_contents_outparams()
>>>>>>     ret = ll_pdf_process_contents_outparams_fn(proc, doc, res, stm, cookie, outparams)
>>>>>>     return outparams.out_res
       
    1: def pdf_process_contents_outparams_fn(proc, doc, res, stm, cookie):
           """
           Class-aware helper for out-params of pdf_process_contents() [pdf_process_contents()].
           """
>>>>>>     out_res = ll_pdf_process_contents(proc.m_internal, doc.m_internal, res.m_internal, stm.m_internal, cookie.m_internal)
>>>>>>     return PdfObj(ll_pdf_keep_obj( out_res))
       
    1: pdf_process_contents = pdf_process_contents_outparams_fn
       
       
    1: def ll_pdf_repair_obj(doc, buf):
           """
           Wrapper for out-params of pdf_repair_obj().
           Returns: int, int64_t stmofsp, int64_t stmlenp, ::pdf_obj *encrypt, ::pdf_obj *id, ::pdf_obj *page, int64_t tmpofs, ::pdf_obj *root
           """
>>>>>>     outparams = ll_pdf_repair_obj_outparams()
>>>>>>     ret = ll_pdf_repair_obj_outparams_fn(doc, buf, outparams)
>>>>>>     return ret, outparams.stmofsp, outparams.stmlenp, outparams.encrypt, outparams.id, outparams.page, outparams.tmpofs, outparams.root
       
    1: def pdf_repair_obj_outparams_fn(doc, buf):
           """
           Class-aware helper for out-params of pdf_repair_obj() [pdf_repair_obj()].
           """
>>>>>>     ret, stmofsp, stmlenp, encrypt, id, page, tmpofs, root = ll_pdf_repair_obj(doc.m_internal, buf.m_internal)
>>>>>>     return ret, stmofsp, stmlenp, PdfObj(ll_pdf_keep_obj( encrypt)), PdfObj(ll_pdf_keep_obj( id)), PdfObj(ll_pdf_keep_obj( page)), tmpofs, PdfObj(ll_pdf_keep_obj( root))
       
    1: pdf_repair_obj = pdf_repair_obj_outparams_fn
       
       
    1: def ll_pdf_resolve_link(doc, uri):
           """
           Wrapper for out-params of pdf_resolve_link().
           Returns: int, float xp, float yp
           """
>>>>>>     outparams = ll_pdf_resolve_link_outparams()
>>>>>>     ret = ll_pdf_resolve_link_outparams_fn(doc, uri, outparams)
>>>>>>     return ret, outparams.xp, outparams.yp
       
    1: def pdf_resolve_link_outparams_fn(doc, uri):
           """
           Class-aware helper for out-params of pdf_resolve_link() [pdf_resolve_link()].
           """
>>>>>>     ret, xp, yp = ll_pdf_resolve_link(doc.m_internal, uri)
>>>>>>     return ret, xp, yp
       
    1: pdf_resolve_link = pdf_resolve_link_outparams_fn
       
       
    1: def ll_pdf_sample_shade_function(n, funcs, t0, t1):
           """
           Wrapper for out-params of pdf_sample_shade_function().
           Returns: float samples, ::pdf_function *func
           """
>>>>>>     outparams = ll_pdf_sample_shade_function_outparams()
>>>>>>     ret = ll_pdf_sample_shade_function_outparams_fn(n, funcs, t0, t1, outparams)
>>>>>>     return outparams.samples, outparams.func
       
    1: def pdf_sample_shade_function_outparams_fn(n, funcs, t0, t1):
           """
           Class-aware helper for out-params of pdf_sample_shade_function() [pdf_sample_shade_function()].
           """
>>>>>>     samples, func = ll_pdf_sample_shade_function(n, funcs, t0, t1)
>>>>>>     return samples, PdfFunction(ll_pdf_keep_function( func))
       
    1: pdf_sample_shade_function = pdf_sample_shade_function_outparams_fn
       
       
    1: def ll_pdf_signature_contents(doc, signature):
           """
           Wrapper for out-params of pdf_signature_contents().
           Returns: size_t, char *contents
           """
>>>>>>     outparams = ll_pdf_signature_contents_outparams()
>>>>>>     ret = ll_pdf_signature_contents_outparams_fn(doc, signature, outparams)
>>>>>>     return ret, outparams.contents
       
    1: def pdf_signature_contents_outparams_fn(doc, signature):
           """
           Class-aware helper for out-params of pdf_signature_contents() [pdf_signature_contents()].
           """
>>>>>>     ret, contents = ll_pdf_signature_contents(doc.m_internal, signature.m_internal)
>>>>>>     return ret, contents
       
    1: pdf_signature_contents = pdf_signature_contents_outparams_fn
       
       
    1: def ll_pdf_sprint_obj(buf, cap, obj, tight, ascii):
           """
           Wrapper for out-params of pdf_sprint_obj().
           Returns: char *, size_t len
           """
>>>>>>     outparams = ll_pdf_sprint_obj_outparams()
>>>>>>     ret = ll_pdf_sprint_obj_outparams_fn(buf, cap, obj, tight, ascii, outparams)
>>>>>>     return ret, outparams.len
       
    1: def pdf_sprint_obj_outparams_fn(buf, cap, obj, tight, ascii):
           """
           Class-aware helper for out-params of pdf_sprint_obj() [pdf_sprint_obj()].
           """
>>>>>>     ret, len = ll_pdf_sprint_obj(buf, cap, obj.m_internal, tight, ascii)
>>>>>>     return ret, len
       
    1: pdf_sprint_obj = pdf_sprint_obj_outparams_fn
       
       
    1: def ll_pdf_to_string(obj):
           """
           Wrapper for out-params of pdf_to_string().
           Returns: const char *, size_t sizep
           """
>>>>>>     outparams = ll_pdf_to_string_outparams()
>>>>>>     ret = ll_pdf_to_string_outparams_fn(obj, outparams)
>>>>>>     return ret, outparams.sizep
       
    1: def pdf_to_string_outparams_fn(obj):
           """
           Class-aware helper for out-params of pdf_to_string() [pdf_to_string()].
           """
>>>>>>     ret, sizep = ll_pdf_to_string(obj.m_internal)
>>>>>>     return ret, sizep
       
    1: pdf_to_string = pdf_to_string_outparams_fn
       
       
    1: def ll_pdf_tos_make_trm(tos, text, fontdesc, cid, trm):
           """
           Wrapper for out-params of pdf_tos_make_trm().
           Returns: int, float adv
           """
>>>>>>     outparams = ll_pdf_tos_make_trm_outparams()
>>>>>>     ret = ll_pdf_tos_make_trm_outparams_fn(tos, text, fontdesc, cid, trm, outparams)
>>>>>>     return ret, outparams.adv
       
    1: def pdf_tos_make_trm_outparams_fn(tos, text, fontdesc, cid, trm):
           """
           Class-aware helper for out-params of pdf_tos_make_trm() [pdf_tos_make_trm()].
           """
>>>>>>     ret, adv = ll_pdf_tos_make_trm(tos.m_internal, text.m_internal, fontdesc.m_internal, cid, trm.internal())
>>>>>>     return ret, adv
       
    1: pdf_tos_make_trm = pdf_tos_make_trm_outparams_fn
       
       
    1: def ll_pdf_undoredo_state(doc):
           """
           Wrapper for out-params of pdf_undoredo_state().
           Returns: int, int steps
           """
>>>>>>     outparams = ll_pdf_undoredo_state_outparams()
>>>>>>     ret = ll_pdf_undoredo_state_outparams_fn(doc, outparams)
>>>>>>     return ret, outparams.steps
       
    1: def pdf_undoredo_state_outparams_fn(doc):
           """
           Class-aware helper for out-params of pdf_undoredo_state() [pdf_undoredo_state()].
           """
>>>>>>     ret, steps = ll_pdf_undoredo_state(doc.m_internal)
>>>>>>     return ret, steps
       
    1: pdf_undoredo_state = pdf_undoredo_state_outparams_fn
       
       
    1: def ll_pdf_walk_tree(tree, kid_name, arrive, leave, arg):
           """
           Wrapper for out-params of pdf_walk_tree().
           Returns: ::pdf_obj *names, ::pdf_obj *values
           """
>>>>>>     outparams = ll_pdf_walk_tree_outparams()
>>>>>>     ret = ll_pdf_walk_tree_outparams_fn(tree, kid_name, arrive, leave, arg, outparams)
>>>>>>     return outparams.names, outparams.values
       
    1: def pdf_walk_tree_outparams_fn(tree, kid_name, arrive, leave, arg):
           """
           Class-aware helper for out-params of pdf_walk_tree() [pdf_walk_tree()].
           """
>>>>>>     names, values = ll_pdf_walk_tree(tree.m_internal, kid_name.m_internal, arrive, leave, arg)
>>>>>>     return PdfObj(ll_pdf_keep_obj( names)), PdfObj(ll_pdf_keep_obj( values))
       
    1: pdf_walk_tree = pdf_walk_tree_outparams_fn
       
       
    1: def ll_pdf_zugferd_profile(doc):
           """
           Wrapper for out-params of pdf_zugferd_profile().
           Returns: enum pdf_zugferd_profile, float version
           """
>>>>>>     outparams = ll_pdf_zugferd_profile_outparams()
>>>>>>     ret = ll_pdf_zugferd_profile_outparams_fn(doc, outparams)
>>>>>>     return ret, outparams.version
       
    1: def pdf_zugferd_profile_outparams_fn(doc):
           """
           Class-aware helper for out-params of pdf_zugferd_profile() [pdf_zugferd_profile()].
           """
>>>>>>     ret, version = ll_pdf_zugferd_profile(doc.m_internal)
>>>>>>     return ret, version
       
    1: pdf_zugferd_profile = pdf_zugferd_profile_outparams_fn
       
       
    1: def FzBitmap_fz_bitmap_details_outparams_fn( self):
           """
           Helper for out-params of class method fz_bitmap::ll_fz_bitmap_details() [fz_bitmap_details()].
           """
>>>>>>     w, h, n, stride = ll_fz_bitmap_details( self.m_internal)
>>>>>>     return w, h, n, stride
       
    1: FzBitmap.fz_bitmap_details = FzBitmap_fz_bitmap_details_outparams_fn
       
       
    1: def FzBuffer_fz_buffer_extract_outparams_fn( self):
           """
           Helper for out-params of class method fz_buffer::ll_fz_buffer_extract() [fz_buffer_extract()].
           """
>>>>>>     ret, data = ll_fz_buffer_extract( self.m_internal)
>>>>>>     return ret, data
       
    1: FzBuffer.fz_buffer_extract = FzBuffer_fz_buffer_extract_outparams_fn
       
       
    1: def FzBuffer_fz_buffer_storage_outparams_fn( self):
           """
           Helper for out-params of class method fz_buffer::ll_fz_buffer_storage() [fz_buffer_storage()].
           """
>>>>>>     ret, datap = ll_fz_buffer_storage( self.m_internal)
>>>>>>     return ret, datap
       
    1: FzBuffer.fz_buffer_storage = FzBuffer_fz_buffer_storage_outparams_fn
       
       
    1: def FzBuffer_fz_new_display_list_from_svg_outparams_fn( self, base_uri, dir):
           """
           Helper for out-params of class method fz_buffer::ll_fz_new_display_list_from_svg() [fz_new_display_list_from_svg()].
           """
>>>>>>     ret, w, h = ll_fz_new_display_list_from_svg( self.m_internal, base_uri, dir.m_internal)
>>>>>>     return FzDisplayList(ret), w, h
       
    1: FzBuffer.fz_new_display_list_from_svg = FzBuffer_fz_new_display_list_from_svg_outparams_fn
       
       
    1: def FzBuffer_fz_subset_cff_for_gids_outparams_fn( self, num_gids, symbolic, cidfont):
           """
           Helper for out-params of class method fz_buffer::ll_fz_subset_cff_for_gids() [fz_subset_cff_for_gids()].
           """
>>>>>>     ret, gids = ll_fz_subset_cff_for_gids( self.m_internal, num_gids, symbolic, cidfont)
>>>>>>     return FzBuffer( ll_fz_keep_buffer( ret)), gids
       
    1: FzBuffer.fz_subset_cff_for_gids = FzBuffer_fz_subset_cff_for_gids_outparams_fn
       
       
    1: def FzBuffer_fz_subset_ttf_for_gids_outparams_fn( self, num_gids, symbolic, cidfont):
           """
           Helper for out-params of class method fz_buffer::ll_fz_subset_ttf_for_gids() [fz_subset_ttf_for_gids()].
           """
>>>>>>     ret, gids = ll_fz_subset_ttf_for_gids( self.m_internal, num_gids, symbolic, cidfont)
>>>>>>     return FzBuffer( ll_fz_keep_buffer( ret)), gids
       
    1: FzBuffer.fz_subset_ttf_for_gids = FzBuffer_fz_subset_ttf_for_gids_outparams_fn
       
       
    1: def FzColorspace_fz_clamp_color_outparams_fn( self, in_):
           """
           Helper for out-params of class method fz_colorspace::ll_fz_clamp_color() [fz_clamp_color()].
           """
>>>>>>     out = ll_fz_clamp_color( self.m_internal, in_)
>>>>>>     return out
       
    1: FzColorspace.fz_clamp_color = FzColorspace_fz_clamp_color_outparams_fn
       
       
    1: def FzColorspace_fz_convert_color_outparams_fn( self, sv, params):
           """
           Helper for out-params of class method fz_colorspace::ll_fz_convert_color() [fz_convert_color()].
           """
>>>>>>     dv = ll_fz_convert_color( self.m_internal, sv, params.internal())
>>>>>>     return dv
       
    1: FzColorspace.fz_convert_color = FzColorspace_fz_convert_color_outparams_fn
       
       
    1: def FzColorspace_fz_convert_separation_colors_outparams_fn( self, src_color, dst_seps, color_params):
           """
           Helper for out-params of class method fz_colorspace::ll_fz_convert_separation_colors() [fz_convert_separation_colors()].
           """
>>>>>>     dst_color = ll_fz_convert_separation_colors( self.m_internal, src_color, dst_seps.m_internal, color_params.internal())
>>>>>>     return dst_color
       
    1: FzColorspace.fz_convert_separation_colors = FzColorspace_fz_convert_separation_colors_outparams_fn
       
       
    1: def FzCompressedBuffer_fz_open_image_decomp_stream_from_buffer_outparams_fn( self):
           """
           Helper for out-params of class method fz_compressed_buffer::ll_fz_open_image_decomp_stream_from_buffer() [fz_open_image_decomp_stream_from_buffer()].
           """
>>>>>>     ret, l2factor = ll_fz_open_image_decomp_stream_from_buffer( self.m_internal)
>>>>>>     return FzStream(ret), l2factor
       
    1: FzCompressedBuffer.fz_open_image_decomp_stream_from_buffer = FzCompressedBuffer_fz_open_image_decomp_stream_from_buffer_outparams_fn
       
       
    1: def FzDisplayList_fz_search_display_list_outparams_fn( self, needle, hit_bbox, hit_max):
           """
           Helper for out-params of class method fz_display_list::ll_fz_search_display_list() [fz_search_display_list()].
           """
>>>>>>     ret, hit_mark = ll_fz_search_display_list( self.m_internal, needle, hit_bbox.internal(), hit_max)
>>>>>>     return ret, hit_mark
       
    1: FzDisplayList.fz_search_display_list = FzDisplayList_fz_search_display_list_outparams_fn
       
       
    1: def FzDocument_fz_resolve_link_outparams_fn( self, uri):
           """
           Helper for out-params of class method fz_document::ll_fz_resolve_link() [fz_resolve_link()].
           """
>>>>>>     ret, xp, yp = ll_fz_resolve_link( self.m_internal, uri)
>>>>>>     return FzLocation(ret), xp, yp
       
    1: FzDocument.fz_resolve_link = FzDocument_fz_resolve_link_outparams_fn
       
       
    1: def FzDocument_fz_search_chapter_page_number_outparams_fn( self, chapter, page, needle, hit_bbox, hit_max):
           """
           Helper for out-params of class method fz_document::ll_fz_search_chapter_page_number() [fz_search_chapter_page_number()].
           """
>>>>>>     ret, hit_mark = ll_fz_search_chapter_page_number( self.m_internal, chapter, page, needle, hit_bbox.internal(), hit_max)
>>>>>>     return ret, hit_mark
       
    1: FzDocument.fz_search_chapter_page_number = FzDocument_fz_search_chapter_page_number_outparams_fn
       
       
    1: def FzDocument_fz_search_page_number_outparams_fn( self, number, needle, hit_bbox, hit_max):
           """
           Helper for out-params of class method fz_document::ll_fz_search_page_number() [fz_search_page_number()].
           """
>>>>>>     ret, hit_mark = ll_fz_search_page_number( self.m_internal, number, needle, hit_bbox.internal(), hit_max)
>>>>>>     return ret, hit_mark
       
    1: FzDocument.fz_search_page_number = FzDocument_fz_search_page_number_outparams_fn
       
       
    1: def FzFont_fz_encode_character_with_fallback_outparams_fn( self, unicode, script, language):
           """
           Helper for out-params of class method fz_font::ll_fz_encode_character_with_fallback() [fz_encode_character_with_fallback()].
           """
>>>>>>     ret, out_font = ll_fz_encode_character_with_fallback( self.m_internal, unicode, script, language)
>>>>>>     return ret, FzFont(ll_fz_keep_font( out_font))
       
    1: FzFont.fz_encode_character_with_fallback = FzFont_fz_encode_character_with_fallback_outparams_fn
       
       
    1: def FzFunction_fz_eval_function_outparams_fn( self, in_, inlen, outlen):
           """
           Helper for out-params of class method fz_function::ll_fz_eval_function() [fz_eval_function()].
           """
>>>>>>     out = ll_fz_eval_function( self.m_internal, in_, inlen, outlen)
>>>>>>     return out
       
    1: FzFunction.fz_eval_function = FzFunction_fz_eval_function_outparams_fn
       
       
    1: def FzImage_fz_get_pixmap_from_image_outparams_fn( self, subarea, ctm):
           """
           Helper for out-params of class method fz_image::ll_fz_get_pixmap_from_image() [fz_get_pixmap_from_image()].
           """
>>>>>>     ret, w, h = ll_fz_get_pixmap_from_image( self.m_internal, subarea.internal(), ctm.internal())
>>>>>>     return FzPixmap(ret), w, h
       
    1: FzImage.fz_get_pixmap_from_image = FzImage_fz_get_pixmap_from_image_outparams_fn
       
       
    1: def FzImage_fz_image_resolution_outparams_fn( self):
           """
           Helper for out-params of class method fz_image::ll_fz_image_resolution() [fz_image_resolution()].
           """
>>>>>>     xres, yres = ll_fz_image_resolution( self.m_internal)
>>>>>>     return xres, yres
       
    1: FzImage.fz_image_resolution = FzImage_fz_image_resolution_outparams_fn
       
       
    1: def FzOutput_fz_new_svg_device_with_id_outparams_fn( self, page_width, page_height, text_format, reuse_images):
           """
           Helper for out-params of class method fz_output::ll_fz_new_svg_device_with_id() [fz_new_svg_device_with_id()].
           """
>>>>>>     ret, id = ll_fz_new_svg_device_with_id( self.m_internal, page_width, page_height, text_format, reuse_images)
>>>>>>     return FzDevice(ret), id
       
    1: FzOutput.fz_new_svg_device_with_id = FzOutput_fz_new_svg_device_with_id_outparams_fn
       
       
    1: def FzOutput_pdf_print_encrypted_obj_outparams_fn( self, obj, tight, ascii, crypt, num, gen):
           """
           Helper for out-params of class method fz_output::ll_pdf_print_encrypted_obj() [pdf_print_encrypted_obj()].
           """
>>>>>>     sep = ll_pdf_print_encrypted_obj( self.m_internal, obj.m_internal, tight, ascii, crypt.m_internal, num, gen)
>>>>>>     return sep
       
    1: FzOutput.pdf_print_encrypted_obj = FzOutput_pdf_print_encrypted_obj_outparams_fn
       
       
    1: def FzPage_fz_page_presentation_outparams_fn( self, transition):
           """
           Helper for out-params of class method fz_page::ll_fz_page_presentation() [fz_page_presentation()].
           """
>>>>>>     ret, duration = ll_fz_page_presentation( self.m_internal, transition.internal())
>>>>>>     return FzTransition(ret), duration
       
    1: FzPage.fz_page_presentation = FzPage_fz_page_presentation_outparams_fn
       
       
    1: def FzPage_fz_search_page_outparams_fn( self, needle, hit_bbox, hit_max):
           """
           Helper for out-params of class method fz_page::ll_fz_search_page() [fz_search_page()].
           """
>>>>>>     ret, hit_mark = ll_fz_search_page( self.m_internal, needle, hit_bbox.internal(), hit_max)
>>>>>>     return ret, hit_mark
       
    1: FzPage.fz_search_page = FzPage_fz_search_page_outparams_fn
       
       
    1: def FzPixmap_fz_fill_pixmap_with_color_outparams_fn( self, colorspace, color_params):
           """
           Helper for out-params of class method fz_pixmap::ll_fz_fill_pixmap_with_color() [fz_fill_pixmap_with_color()].
           """
>>>>>>     color = ll_fz_fill_pixmap_with_color( self.m_internal, colorspace.m_internal, color_params.internal())
>>>>>>     return color
       
    1: FzPixmap.fz_fill_pixmap_with_color = FzPixmap_fz_fill_pixmap_with_color_outparams_fn
       
       
    1: def FzPoolArray_fz_pool_array_append_outparams_fn( self):
           """
           Helper for out-params of class method fz_pool_array::ll_fz_pool_array_append() [fz_pool_array_append()].
           """
>>>>>>     ret, idx = ll_fz_pool_array_append( self.m_internal)
>>>>>>     return ret, idx
       
    1: FzPoolArray.fz_pool_array_append = FzPoolArray_fz_pool_array_append_outparams_fn
       
       
    1: def FzSeparations_fz_separation_equivalent_outparams_fn( self, idx, dst_cs, prf, color_params):
           """
           Helper for out-params of class method fz_separations::ll_fz_separation_equivalent() [fz_separation_equivalent()].
           """
>>>>>>     dst_color = ll_fz_separation_equivalent( self.m_internal, idx, dst_cs.m_internal, prf.m_internal, color_params.internal())
>>>>>>     return dst_color
       
    1: FzSeparations.fz_separation_equivalent = FzSeparations_fz_separation_equivalent_outparams_fn
       
       
    1: def FzShade_fz_paint_shade_outparams_fn( self, override_cs, ctm, dest, color_params, bbox, eop):
           """
           Helper for out-params of class method fz_shade::ll_fz_paint_shade() [fz_paint_shade()].
           """
>>>>>>     cache = ll_fz_paint_shade( self.m_internal, override_cs.m_internal, ctm.internal(), dest.m_internal, color_params.internal(), bbox.internal(), eop.m_internal)
>>>>>>     return FzShadeColorCache(ll_fz_keep_shade_color_cache( cache))
       
    1: FzShade.fz_paint_shade = FzShade_fz_paint_shade_outparams_fn
       
       
    1: def FzStextPage_fz_search_stext_page_outparams_fn( self, needle, hit_bbox, hit_max):
           """
           Helper for out-params of class method fz_stext_page::ll_fz_search_stext_page() [fz_search_stext_page()].
           """
>>>>>>     ret, hit_mark = ll_fz_search_stext_page( self.m_internal, needle, hit_bbox.internal(), hit_max)
>>>>>>     return ret, hit_mark
       
    1: FzStextPage.fz_search_stext_page = FzStextPage_fz_search_stext_page_outparams_fn
       
       
    1: def FzStream_fz_decomp_image_from_stream_outparams_fn( self, image, subarea, indexed, l2factor):
           """
           Helper for out-params of class method fz_stream::ll_fz_decomp_image_from_stream() [fz_decomp_image_from_stream()].
           """
>>>>>>     ret, l2extra = ll_fz_decomp_image_from_stream( self.m_internal, image.m_internal, subarea.internal(), indexed, l2factor)
>>>>>>     return FzPixmap(ret), l2extra
       
    1: FzStream.fz_decomp_image_from_stream = FzStream_fz_decomp_image_from_stream_outparams_fn
       
       
    1: def FzStream_fz_open_image_decomp_stream_outparams_fn( self, arg_1):
           """
           Helper for out-params of class method fz_stream::ll_fz_open_image_decomp_stream() [fz_open_image_decomp_stream()].
           """
>>>>>>     ret, l2factor = ll_fz_open_image_decomp_stream( self.m_internal, arg_1.m_internal)
>>>>>>     return FzStream(ret), l2factor
       
    1: FzStream.fz_open_image_decomp_stream = FzStream_fz_open_image_decomp_stream_outparams_fn
       
       
    1: def FzStream_fz_read_best_outparams_fn( self, initial, worst_case):
           """
           Helper for out-params of class method fz_stream::ll_fz_read_best() [fz_read_best()].
           """
>>>>>>     ret, truncated = ll_fz_read_best( self.m_internal, initial, worst_case)
>>>>>>     return FzBuffer(ret), truncated
       
    1: FzStream.fz_read_best = FzStream_fz_read_best_outparams_fn
       
       
    1: def FzXml_fz_dom_get_attribute_outparams_fn( self, i):
           """
           Helper for out-params of class method fz_xml::ll_fz_dom_get_attribute() [fz_dom_get_attribute()].
           """
>>>>>>     ret, att = ll_fz_dom_get_attribute( self.m_internal, i)
>>>>>>     return ret, att
       
    1: FzXml.fz_dom_get_attribute = FzXml_fz_dom_get_attribute_outparams_fn
       
       
    1: def FzXml_fz_new_display_list_from_svg_xml_outparams_fn( self, xmldoc, base_uri, dir):
           """
           Helper for out-params of class method fz_xml::ll_fz_new_display_list_from_svg_xml() [fz_new_display_list_from_svg_xml()].
           """
>>>>>>     ret, w, h = ll_fz_new_display_list_from_svg_xml( self.m_internal, xmldoc.m_internal, base_uri, dir.m_internal)
>>>>>>     return FzDisplayList(ret), w, h
       
    1: FzXml.fz_new_display_list_from_svg_xml = FzXml_fz_new_display_list_from_svg_xml_outparams_fn
       
       
    1: def PdfAnnot_pdf_annot_MK_BC_outparams_fn( self, color):
           """
           Helper for out-params of class method pdf_annot::ll_pdf_annot_MK_BC() [pdf_annot_MK_BC()].
           """
>>>>>>     n = ll_pdf_annot_MK_BC( self.m_internal, color)
>>>>>>     return n
       
    1: PdfAnnot.pdf_annot_MK_BC = PdfAnnot_pdf_annot_MK_BC_outparams_fn
       
       
    1: def PdfAnnot_pdf_annot_MK_BG_outparams_fn( self, color):
           """
           Helper for out-params of class method pdf_annot::ll_pdf_annot_MK_BG() [pdf_annot_MK_BG()].
           """
>>>>>>     n = ll_pdf_annot_MK_BG( self.m_internal, color)
>>>>>>     return n
       
    1: PdfAnnot.pdf_annot_MK_BG = PdfAnnot_pdf_annot_MK_BG_outparams_fn
       
       
    1: def PdfAnnot_pdf_annot_color_outparams_fn( self, color):
           """
           Helper for out-params of class method pdf_annot::ll_pdf_annot_color() [pdf_annot_color()].
           """
>>>>>>     n = ll_pdf_annot_color( self.m_internal, color)
>>>>>>     return n
       
    1: PdfAnnot.pdf_annot_color = PdfAnnot_pdf_annot_color_outparams_fn
       
       
    1: def PdfAnnot_pdf_annot_default_appearance_outparams_fn( self, color):
           """
           Helper for out-params of class method pdf_annot::ll_pdf_annot_default_appearance() [pdf_annot_default_appearance()].
           """
>>>>>>     font, size, n = ll_pdf_annot_default_appearance( self.m_internal, color)
>>>>>>     return font, size, n
       
    1: PdfAnnot.pdf_annot_default_appearance = PdfAnnot_pdf_annot_default_appearance_outparams_fn
       
       
    1: def PdfAnnot_pdf_annot_default_appearance_unmapped_outparams_fn( self, font_name, font_name_len, color):
           """
           Helper for out-params of class method pdf_annot::ll_pdf_annot_default_appearance_unmapped() [pdf_annot_default_appearance_unmapped()].
           """
>>>>>>     size, n = ll_pdf_annot_default_appearance_unmapped( self.m_internal, font_name, font_name_len, color)
>>>>>>     return size, n
       
    1: PdfAnnot.pdf_annot_default_appearance_unmapped = PdfAnnot_pdf_annot_default_appearance_unmapped_outparams_fn
       
       
    1: def PdfAnnot_pdf_annot_interior_color_outparams_fn( self, color):
           """
           Helper for out-params of class method pdf_annot::ll_pdf_annot_interior_color() [pdf_annot_interior_color()].
           """
>>>>>>     n = ll_pdf_annot_interior_color( self.m_internal, color)
>>>>>>     return n
       
    1: PdfAnnot.pdf_annot_interior_color = PdfAnnot_pdf_annot_interior_color_outparams_fn
       
       
    1: def PdfAnnot_pdf_annot_line_ending_styles_outparams_fn( self):
           """
           Helper for out-params of class method pdf_annot::ll_pdf_annot_line_ending_styles() [pdf_annot_line_ending_styles()].
           """
>>>>>>     start_style, end_style = ll_pdf_annot_line_ending_styles( self.m_internal)
>>>>>>     return start_style, end_style
       
    1: PdfAnnot.pdf_annot_line_ending_styles = PdfAnnot_pdf_annot_line_ending_styles_outparams_fn
       
       
    1: def PdfAnnot_pdf_edit_text_field_value_outparams_fn( self, value, change):
           """
           Helper for out-params of class method pdf_annot::ll_pdf_edit_text_field_value() [pdf_edit_text_field_value()].
           """
>>>>>>     ret, selStart, selEnd, newvalue = ll_pdf_edit_text_field_value( self.m_internal, value, change)
>>>>>>     return ret, selStart, selEnd, newvalue
       
    1: PdfAnnot.pdf_edit_text_field_value = PdfAnnot_pdf_edit_text_field_value_outparams_fn
       
       
    1: def PdfCmap_pdf_decode_cmap_outparams_fn( self, s, e):
           """
           Helper for out-params of class method pdf_cmap::ll_pdf_decode_cmap() [pdf_decode_cmap()].
           """
>>>>>>     ret, cpt = ll_pdf_decode_cmap( self.m_internal, s, e)
>>>>>>     return ret, cpt
       
    1: PdfCmap.pdf_decode_cmap = PdfCmap_pdf_decode_cmap_outparams_fn
       
       
    1: def PdfCmap_pdf_lookup_cmap_full_outparams_fn( self, cpt):
           """
           Helper for out-params of class method pdf_cmap::ll_pdf_lookup_cmap_full() [pdf_lookup_cmap_full()].
           """
>>>>>>     ret, out = ll_pdf_lookup_cmap_full( self.m_internal, cpt)
>>>>>>     return ret, out
       
    1: PdfCmap.pdf_lookup_cmap_full = PdfCmap_pdf_lookup_cmap_full_outparams_fn
       
       
    1: def PdfCmap_pdf_map_one_to_many_outparams_fn( self, one, len):
           """
           Helper for out-params of class method pdf_cmap::ll_pdf_map_one_to_many() [pdf_map_one_to_many()].
           """
>>>>>>     many = ll_pdf_map_one_to_many( self.m_internal, one, len)
>>>>>>     return many
       
    1: PdfCmap.pdf_map_one_to_many = PdfCmap_pdf_map_one_to_many_outparams_fn
       
       
    1: def PdfDocument_pdf_count_q_balance_outparams_fn( self, res, stm):
           """
           Helper for out-params of class method pdf_document::ll_pdf_count_q_balance() [pdf_count_q_balance()].
           """
>>>>>>     prepend, append = ll_pdf_count_q_balance( self.m_internal, res.m_internal, stm.m_internal)
>>>>>>     return prepend, append
       
    1: PdfDocument.pdf_count_q_balance = PdfDocument_pdf_count_q_balance_outparams_fn
       
       
    1: def PdfDocument_pdf_field_event_validate_outparams_fn( self, field, value):
           """
           Helper for out-params of class method pdf_document::ll_pdf_field_event_validate() [pdf_field_event_validate()].
           """
>>>>>>     ret, newvalue = ll_pdf_field_event_validate( self.m_internal, field.m_internal, value)
>>>>>>     return ret, newvalue
       
    1: PdfDocument.pdf_field_event_validate = PdfDocument_pdf_field_event_validate_outparams_fn
       
       
    1: def PdfDocument_pdf_load_to_unicode_outparams_fn( self, font, collection, cmapstm):
           """
           Helper for out-params of class method pdf_document::ll_pdf_load_to_unicode() [pdf_load_to_unicode()].
           """
>>>>>>     strings = ll_pdf_load_to_unicode( self.m_internal, font.m_internal, collection, cmapstm.m_internal)
>>>>>>     return strings
       
    1: PdfDocument.pdf_load_to_unicode = PdfDocument_pdf_load_to_unicode_outparams_fn
       
       
    1: def PdfDocument_pdf_lookup_page_loc_outparams_fn( self, needle):
           """
           Helper for out-params of class method pdf_document::ll_pdf_lookup_page_loc() [pdf_lookup_page_loc()].
           """
>>>>>>     ret, parentp, indexp = ll_pdf_lookup_page_loc( self.m_internal, needle)
>>>>>>     return PdfObj( ll_pdf_keep_obj( ret)), PdfObj(ll_pdf_keep_obj( parentp)), indexp
       
    1: PdfDocument.pdf_lookup_page_loc = PdfDocument_pdf_lookup_page_loc_outparams_fn
       
       
    1: def PdfDocument_pdf_page_write_outparams_fn( self, mediabox):
           """
           Helper for out-params of class method pdf_document::ll_pdf_page_write() [pdf_page_write()].
           """
>>>>>>     ret, presources, pcontents = ll_pdf_page_write( self.m_internal, mediabox.internal())
>>>>>>     return FzDevice(ret), PdfObj( presources), FzBuffer( pcontents)
       
    1: PdfDocument.pdf_page_write = PdfDocument_pdf_page_write_outparams_fn
       
       
    1: def PdfDocument_pdf_parse_ind_obj_outparams_fn( self, f):
           """
           Helper for out-params of class method pdf_document::ll_pdf_parse_ind_obj() [pdf_parse_ind_obj()].
           """
>>>>>>     ret, num, gen, stm_ofs, try_repair = ll_pdf_parse_ind_obj( self.m_internal, f.m_internal)
>>>>>>     return PdfObj(ret), num, gen, stm_ofs, try_repair
       
    1: PdfDocument.pdf_parse_ind_obj = PdfDocument_pdf_parse_ind_obj_outparams_fn
       
       
    1: def PdfDocument_pdf_parse_journal_obj_outparams_fn( self, stm):
           """
           Helper for out-params of class method pdf_document::ll_pdf_parse_journal_obj() [pdf_parse_journal_obj()].
           """
>>>>>>     ret, onum, ostm, newobj = ll_pdf_parse_journal_obj( self.m_internal, stm.m_internal)
>>>>>>     return PdfObj(ret), onum, FzBuffer( ostm), newobj
       
    1: PdfDocument.pdf_parse_journal_obj = PdfDocument_pdf_parse_journal_obj_outparams_fn
       
       
    1: def PdfDocument_pdf_repair_obj_outparams_fn( self, buf):
           """
           Helper for out-params of class method pdf_document::ll_pdf_repair_obj() [pdf_repair_obj()].
           """
>>>>>>     ret, stmofsp, stmlenp, encrypt, id, page, tmpofs, root = ll_pdf_repair_obj( self.m_internal, buf.m_internal)
>>>>>>     return ret, stmofsp, stmlenp, PdfObj(ll_pdf_keep_obj( encrypt)), PdfObj(ll_pdf_keep_obj( id)), PdfObj(ll_pdf_keep_obj( page)), tmpofs, PdfObj(ll_pdf_keep_obj( root))
       
    1: PdfDocument.pdf_repair_obj = PdfDocument_pdf_repair_obj_outparams_fn
       
       
    1: def PdfDocument_pdf_resolve_link_outparams_fn( self, uri):
           """
           Helper for out-params of class method pdf_document::ll_pdf_resolve_link() [pdf_resolve_link()].
           """
>>>>>>     ret, xp, yp = ll_pdf_resolve_link( self.m_internal, uri)
>>>>>>     return ret, xp, yp
       
    1: PdfDocument.pdf_resolve_link = PdfDocument_pdf_resolve_link_outparams_fn
       
       
    1: def PdfDocument_pdf_signature_contents_outparams_fn( self, signature):
           """
           Helper for out-params of class method pdf_document::ll_pdf_signature_contents() [pdf_signature_contents()].
           """
>>>>>>     ret, contents = ll_pdf_signature_contents( self.m_internal, signature.m_internal)
>>>>>>     return ret, contents
       
    1: PdfDocument.pdf_signature_contents = PdfDocument_pdf_signature_contents_outparams_fn
       
       
    1: def PdfDocument_pdf_undoredo_state_outparams_fn( self):
           """
           Helper for out-params of class method pdf_document::ll_pdf_undoredo_state() [pdf_undoredo_state()].
           """
>>>>>>     ret, steps = ll_pdf_undoredo_state( self.m_internal)
>>>>>>     return ret, steps
       
    1: PdfDocument.pdf_undoredo_state = PdfDocument_pdf_undoredo_state_outparams_fn
       
       
    1: def PdfDocument_pdf_zugferd_profile_outparams_fn( self):
           """
           Helper for out-params of class method pdf_document::ll_pdf_zugferd_profile() [pdf_zugferd_profile()].
           """
>>>>>>     ret, version = ll_pdf_zugferd_profile( self.m_internal)
>>>>>>     return ret, version
       
    1: PdfDocument.pdf_zugferd_profile = PdfDocument_pdf_zugferd_profile_outparams_fn
       
       
    1: def PdfFunction_pdf_eval_function_outparams_fn( self, in_, inlen, outlen):
           """
           Helper for out-params of class method pdf_function::ll_pdf_eval_function() [pdf_eval_function()].
           """
>>>>>>     out = ll_pdf_eval_function( self.m_internal, in_, inlen, outlen)
>>>>>>     return out
       
    1: PdfFunction.pdf_eval_function = PdfFunction_pdf_eval_function_outparams_fn
       
       
    1: def PdfJs_pdf_js_event_result_validate_outparams_fn( self):
           """
           Helper for out-params of class method pdf_js::ll_pdf_js_event_result_validate() [pdf_js_event_result_validate()].
           """
>>>>>>     ret, newvalue = ll_pdf_js_event_result_validate( self.m_internal)
>>>>>>     return ret, newvalue
       
    1: PdfJs.pdf_js_event_result_validate = PdfJs_pdf_js_event_result_validate_outparams_fn
       
       
    1: def PdfJs_pdf_js_execute_outparams_fn( self, name, code):
           """
           Helper for out-params of class method pdf_js::ll_pdf_js_execute() [pdf_js_execute()].
           """
>>>>>>     result = ll_pdf_js_execute( self.m_internal, name, code)
>>>>>>     return result
       
    1: PdfJs.pdf_js_execute = PdfJs_pdf_js_execute_outparams_fn
       
       
    1: def PdfObj_pdf_array_get_string_outparams_fn( self, index):
           """
           Helper for out-params of class method pdf_obj::ll_pdf_array_get_string() [pdf_array_get_string()].
           """
>>>>>>     ret, sizep = ll_pdf_array_get_string( self.m_internal, index)
>>>>>>     return ret, sizep
       
    1: PdfObj.pdf_array_get_string = PdfObj_pdf_array_get_string_outparams_fn
       
       
    1: def PdfObj_pdf_dict_get_inheritable_string_outparams_fn( self):
           """
           Helper for out-params of class method pdf_obj::ll_pdf_dict_get_inheritable_string() [pdf_dict_get_inheritable_string()].
           """
>>>>>>     ret, sizep = ll_pdf_dict_get_inheritable_string( self.m_internal)
>>>>>>     return ret, sizep
       
    1: PdfObj.pdf_dict_get_inheritable_string = PdfObj_pdf_dict_get_inheritable_string_outparams_fn
       
       
    1: def PdfObj_pdf_dict_get_string_outparams_fn( self):
           """
           Helper for out-params of class method pdf_obj::ll_pdf_dict_get_string() [pdf_dict_get_string()].
           """
>>>>>>     ret, sizep = ll_pdf_dict_get_string( self.m_internal)
>>>>>>     return ret, sizep
       
    1: PdfObj.pdf_dict_get_string = PdfObj_pdf_dict_get_string_outparams_fn
       
       
    1: def PdfObj_pdf_obj_memo_outparams_fn( self, bit):
           """
           Helper for out-params of class method pdf_obj::ll_pdf_obj_memo() [pdf_obj_memo()].
           """
>>>>>>     ret, memo = ll_pdf_obj_memo( self.m_internal, bit)
>>>>>>     return ret, memo
       
    1: PdfObj.pdf_obj_memo = PdfObj_pdf_obj_memo_outparams_fn
       
       
    1: def PdfObj_pdf_to_string_outparams_fn( self):
           """
           Helper for out-params of class method pdf_obj::ll_pdf_to_string() [pdf_to_string()].
           """
>>>>>>     ret, sizep = ll_pdf_to_string( self.m_internal)
>>>>>>     return ret, sizep
       
    1: PdfObj.pdf_to_string = PdfObj_pdf_to_string_outparams_fn
       
       
    1: def PdfObj_pdf_walk_tree_outparams_fn( self, arrive, leave, arg):
           """
           Helper for out-params of class method pdf_obj::ll_pdf_walk_tree() [pdf_walk_tree()].
           """
>>>>>>     names, values = ll_pdf_walk_tree( self.m_internal, arrive, leave, arg)
>>>>>>     return PdfObj(ll_pdf_keep_obj( names)), PdfObj(ll_pdf_keep_obj( values))
       
    1: PdfObj.pdf_walk_tree = PdfObj_pdf_walk_tree_outparams_fn
       
       
    1: def PdfPage_pdf_page_presentation_outparams_fn( self, transition):
           """
           Helper for out-params of class method pdf_page::ll_pdf_page_presentation() [pdf_page_presentation()].
           """
>>>>>>     ret, duration = ll_pdf_page_presentation( self.m_internal, transition.internal())
>>>>>>     return FzTransition(ret), duration
       
    1: PdfPage.pdf_page_presentation = PdfPage_pdf_page_presentation_outparams_fn
       
       
    1: def PdfProcessor_pdf_process_contents_outparams_fn( self, doc, res, stm, cookie):
           """
           Helper for out-params of class method pdf_processor::ll_pdf_process_contents() [pdf_process_contents()].
           """
>>>>>>     out_res = ll_pdf_process_contents( self.m_internal, doc.m_internal, res.m_internal, stm.m_internal, cookie.m_internal)
>>>>>>     return PdfObj(ll_pdf_keep_obj( out_res))
       
    1: PdfProcessor.pdf_process_contents = PdfProcessor_pdf_process_contents_outparams_fn
       
       
    1: def PdfTextObjectState_pdf_tos_make_trm_outparams_fn( self, text, fontdesc, cid, trm):
           """
           Helper for out-params of class method pdf_text_object_state::ll_pdf_tos_make_trm() [pdf_tos_make_trm()].
           """
>>>>>>     ret, adv = ll_pdf_tos_make_trm( self.m_internal, text.m_internal, fontdesc.m_internal, cid, trm.internal())
>>>>>>     return ret, adv
       
    1: PdfTextObjectState.pdf_tos_make_trm = PdfTextObjectState_pdf_tos_make_trm_outparams_fn
       
       
       # Define __str()__ for each error/exception class, to use self.what().
    1: FzErrorBase.__str__ = lambda self: self.what()
    1: FzErrorNone.__str__ = lambda self: self.what()
    1: FzErrorGeneric.__str__ = lambda self: self.what()
    1: FzErrorSystem.__str__ = lambda self: self.what()
    1: FzErrorLibrary.__str__ = lambda self: self.what()
    1: FzErrorArgument.__str__ = lambda self: self.what()
    1: FzErrorLimit.__str__ = lambda self: self.what()
    1: FzErrorUnsupported.__str__ = lambda self: self.what()
    1: FzErrorFormat.__str__ = lambda self: self.what()
    1: FzErrorSyntax.__str__ = lambda self: self.what()
    1: FzErrorTrylater.__str__ = lambda self: self.what()
    1: FzErrorAbort.__str__ = lambda self: self.what()
    1: FzErrorRepaired.__str__ = lambda self: self.what()
       
       # This must be after the declaration of mupdf::FzError*
       # classes in mupdf/exceptions.h and declaration of
       # `internal_set_error_classes()`, otherwise generated code is
       # before the declaration of the Python class or similar. */
    2: internal_set_error_classes([
    1:         FzErrorNone,
    1:         FzErrorGeneric,
    1:         FzErrorSystem,
    1:         FzErrorLibrary,
    1:         FzErrorArgument,
    1:         FzErrorLimit,
    1:         FzErrorUnsupported,
    1:         FzErrorFormat,
    1:         FzErrorSyntax,
    1:         FzErrorTrylater,
    1:         FzErrorAbort,
    1:         FzErrorRepaired,
       
    1: FzErrorBase,
       ])
       
       
       # Wrap fz_parse_page_range() to fix SWIG bug where a NULL return
       # value seems to mess up the returned list - we end up with ret
       # containing two elements rather than three, e.g. [0, 2]. This
       # occurs with SWIG-3.0; maybe fixed in SWIG-4?
       #
    1: ll_fz_parse_page_range_orig = ll_fz_parse_page_range
    1: def ll_fz_parse_page_range(s, n):
>>>>>>     ret = ll_fz_parse_page_range_orig(s, n)
>>>>>>     if len(ret) == 2:
>>>>>>         return None, 0, 0
           else:
>>>>>>         return ret[0], ret[1], ret[2]
    1: fz_parse_page_range = ll_fz_parse_page_range
       
       # Provide native python implementation of format_output_path() (->
       # fz_format_output_path).
       #
    1: def ll_fz_format_output_path( format, page):
>>>>>>     m = re.search( '(%[0-9]*d)', format)
>>>>>>     if m:
>>>>>>         ret = format[ :m.start(1)] + str(page) + format[ m.end(1):]
           else:
>>>>>>         dot = format.rfind( '.')
>>>>>>         if dot < 0:
>>>>>>             dot = len( format)
>>>>>>         ret = format[:dot] + str(page) + format[dot:]
>>>>>>     return ret
    1: fz_format_output_path = ll_fz_format_output_path
       
    2: class IteratorWrap:
    1:     """
           This is a Python iterator for containers that have C++-style
           begin() and end() methods that return iterators.
       
           Iterators must have the following methods:
       
               __increment__(): move to next item in the container.
               __ref__(): return reference to item in the container.
       
           Must also be able to compare two iterators for equality.
       
           """
    1:     def __init__( self, container):
>>>>>>         self.container = container
>>>>>>         self.pos = None
>>>>>>         self.end = container.end()
    1:     def __iter__( self):
>>>>>>         return self
    1:     def __next__( self):    # for python2.
>>>>>>         if self.pos is None:
>>>>>>             self.pos = self.container.begin()
               else:
>>>>>>             self.pos.__increment__()
>>>>>>         if self.pos == self.end:
>>>>>>             raise StopIteration()
>>>>>>         return self.pos.__ref__()
    1:     def next( self):    # for python3.
>>>>>>         return self.__next__()
       
       # The auto-generated Python class method
       # FzBuffer.fz_buffer_extract() returns (size, data).
       #
       # But these raw values aren't particularly useful to
       # Python code so we change the method to return a Python
       # bytes instance instead, using the special C function
       # buffer_extract_bytes() defined above.
       #
       # The raw values for a buffer are available via
       # fz_buffer_storage().
       
    1: def ll_fz_buffer_extract(buffer):
           """
           Returns buffer data as a Python bytes instance, leaving the
           buffer empty.
           """
>>>>>>     assert isinstance( buffer, fz_buffer)
>>>>>>     return ll_fz_buffer_to_bytes_internal(buffer, clear=1)
    1: def fz_buffer_extract(buffer):
           """
           Returns buffer data as a Python bytes instance, leaving the
           buffer empty.
           """
>>>>>>     assert isinstance( buffer, FzBuffer)
>>>>>>     return ll_fz_buffer_extract(buffer.m_internal)
    1: FzBuffer.fz_buffer_extract = fz_buffer_extract
       
    1: def ll_fz_buffer_extract_copy( buffer):
           """
           Returns buffer data as a Python bytes instance, leaving the
           buffer unchanged.
           """
>>>>>>     assert isinstance( buffer, fz_buffer)
>>>>>>     return ll_fz_buffer_to_bytes_internal(buffer, clear=0)
    1: def fz_buffer_extract_copy( buffer):
           """
           Returns buffer data as a Python bytes instance, leaving the
           buffer unchanged.
           """
>>>>>>     assert isinstance( buffer, FzBuffer)
>>>>>>     return ll_fz_buffer_extract_copy(buffer.m_internal)
    1: FzBuffer.fz_buffer_extract_copy = fz_buffer_extract_copy
       
       # [ll_fz_buffer_storage_memoryview() is implemented in C.]
    1: def fz_buffer_storage_memoryview( buffer, writable=False):
           """
           Returns a read-only or writable Python `memoryview` onto
           `fz_buffer` data. This relies on `buffer` existing and
           not changing size while the `memoryview` is used.
           """
>>>>>>     assert isinstance( buffer, FzBuffer)
>>>>>>     return ll_fz_buffer_storage_memoryview( buffer.m_internal, writable)
    1: FzBuffer.fz_buffer_storage_memoryview = fz_buffer_storage_memoryview
       
       # Overwrite wrappers for fz_new_buffer_from_copied_data() to
       # take Python buffer.
       #
    1: ll_fz_new_buffer_from_copied_data_orig = ll_fz_new_buffer_from_copied_data
    1: def ll_fz_new_buffer_from_copied_data(data):
           """
           Returns fz_buffer containing copy of `data`, which should
           be a `bytes` or similar Python buffer instance.
           """
>>>>>>     buffer_ = ll_fz_new_buffer_from_copied_data_orig(python_buffer_data(data), len(data))
>>>>>>     return buffer_
    1: def fz_new_buffer_from_copied_data(data):
           """
           Returns FzBuffer containing copy of `data`, which should be
           a `bytes` or similar Python buffer instance.
           """
>>>>>>     return FzBuffer( ll_fz_new_buffer_from_copied_data( data))
    1: FzBuffer.fz_new_buffer_from_copied_data = fz_new_buffer_from_copied_data
       
    1: def ll_pdf_dict_getl(obj, *tail):
           """
           Python implementation of ll_pdf_dict_getl(), because SWIG
           doesn't handle variadic args. Each item in `tail` should be
           `mupdf.pdf_obj`.
           """
>>>>>>     for key in tail:
>>>>>>         if not obj:
>>>>>>             break
>>>>>>         obj = ll_pdf_dict_get(obj, key)
>>>>>>     assert isinstance(obj, pdf_obj)
>>>>>>     return obj
    1: def pdf_dict_getl(obj, *tail):
           """
           Python implementation of pdf_dict_getl(), because SWIG
           doesn't handle variadic args. Each item in `tail` should be
           a `mupdf.PdfObj`.
           """
>>>>>>     for key in tail:
>>>>>>         if not obj.m_internal:
>>>>>>             break
>>>>>>         obj = pdf_dict_get(obj, key)
>>>>>>     assert isinstance(obj, PdfObj)
>>>>>>     return obj
    1: PdfObj.pdf_dict_getl = pdf_dict_getl
       
    1: def ll_pdf_dict_putl(obj, val, *tail):
           """
           Python implementation of ll_pdf_dict_putl() because SWIG
           doesn't handle variadic args. Each item in `tail` should
           be a SWIG wrapper for a `pdf_obj`.
           """
>>>>>>     if ll_pdf_is_indirect( obj):
>>>>>>         obj = ll_pdf_resolve_indirect_chain( obj)
>>>>>>     if not pdf_is_dict( obj):
>>>>>>         raise Exception(f'not a dict: {obj}')
>>>>>>     if not tail:
>>>>>>         return
>>>>>>     doc = ll_pdf_get_bound_document( obj)
>>>>>>     for i, key in enumerate( tail[:-1]):
>>>>>>         assert isinstance( key, PdfObj), f'Item {i} in `tail` should be a pdf_obj but is a {type(key)}.'
>>>>>>         next_obj = ll_pdf_dict_get( obj, key)
>>>>>>         if not next_obj:
       # We have to create entries
>>>>>>             next_obj = ll_pdf_new_dict( doc, 1)
>>>>>>             ll_pdf_dict_put( obj, key, next_obj)
>>>>>>         obj = next_obj
>>>>>>     key = tail[-1]
>>>>>>     ll_pdf_dict_put( obj, key, val)
    1: def pdf_dict_putl(obj, val, *tail):
           """
           Python implementation of pdf_dict_putl(fz_context *ctx,
           pdf_obj *obj, pdf_obj *val, ...) because SWIG doesn't
           handle variadic args. Each item in `tail` should
           be a SWIG wrapper for a `PdfObj`.
           """
>>>>>>     if pdf_is_indirect( obj):
>>>>>>         obj = pdf_resolve_indirect_chain( obj)
>>>>>>     if not pdf_is_dict( obj):
>>>>>>         raise Exception(f'not a dict: {obj}')
>>>>>>     if not tail:
>>>>>>         return
>>>>>>     doc = pdf_get_bound_document( obj)
>>>>>>     for i, key in enumerate( tail[:-1]):
>>>>>>         assert isinstance( key, PdfObj), f'item {i} in `tail` should be a PdfObj but is a {type(key)}.'
>>>>>>         next_obj = pdf_dict_get( obj, key)
>>>>>>         if not next_obj.m_internal:
       # We have to create entries
>>>>>>             next_obj = pdf_new_dict( doc, 1)
>>>>>>             pdf_dict_put( obj, key, next_obj)
>>>>>>         obj = next_obj
>>>>>>     key = tail[-1]
>>>>>>     pdf_dict_put( obj, key, val)
    1: PdfObj.pdf_dict_putl = pdf_dict_putl
       
    1: def pdf_dict_putl_drop(obj, *tail):
>>>>>>     raise Exception('mupdf.pdf_dict_putl_drop() is unsupported and unnecessary in Python because reference counting is automatic. Instead use mupdf.pdf_dict_putl().')
    1: PdfObj.pdf_dict_putl_drop = pdf_dict_putl_drop
       
    1: def ll_pdf_set_annot_color(annot, color):
           """
           Low-level Python implementation of pdf_set_annot_color()
           using ll_pdf_set_annot_color2().
           """
>>>>>>     if isinstance(color, float):
>>>>>>         ll_pdf_set_annot_color2(annot, 1, color, 0, 0, 0)
>>>>>>     elif len(color) == 1:
>>>>>>         ll_pdf_set_annot_color2(annot, 1, color[0], 0, 0, 0)
>>>>>>     elif len(color) == 2:
>>>>>>         ll_pdf_set_annot_color2(annot, 2, color[0], color[1], 0, 0)
>>>>>>     elif len(color) == 3:
>>>>>>         ll_pdf_set_annot_color2(annot, 3, color[0], color[1], color[2], 0)
>>>>>>     elif len(color) == 4:
>>>>>>         ll_pdf_set_annot_color2(annot, 4, color[0], color[1], color[2], color[3])
           else:
>>>>>>         raise Exception( f'Unexpected color should be float or list of 1-4 floats: {color}')
    1: def pdf_set_annot_color(self, color):
>>>>>>     return ll_pdf_set_annot_color(self.m_internal, color)
    1: PdfAnnot.pdf_set_annot_color = pdf_set_annot_color
       
    1: def ll_pdf_set_annot_interior_color(annot, color):
           """
           Low-level Python version of pdf_set_annot_color() using
           pdf_set_annot_color2().
           """
>>>>>>     if isinstance(color, float):
>>>>>>         ll_pdf_set_annot_interior_color2(annot, 1, color, 0, 0, 0)
>>>>>>     elif len(color) == 1:
>>>>>>         ll_pdf_set_annot_interior_color2(annot, 1, color[0], 0, 0, 0)
>>>>>>     elif len(color) == 2:
>>>>>>         ll_pdf_set_annot_interior_color2(annot, 2, color[0], color[1], 0, 0)
>>>>>>     elif len(color) == 3:
>>>>>>         ll_pdf_set_annot_interior_color2(annot, 3, color[0], color[1], color[2], 0)
>>>>>>     elif len(color) == 4:
>>>>>>         ll_pdf_set_annot_interior_color2(annot, 4, color[0], color[1], color[2], color[3])
           else:
>>>>>>         raise Exception( f'Unexpected color should be float or list of 1-4 floats: {color}')
    1: def pdf_set_annot_interior_color(self, color):
           """
           Python version of pdf_set_annot_color() using
           pdf_set_annot_color2().
           """
>>>>>>     return ll_pdf_set_annot_interior_color(self.m_internal, color)
    1: PdfAnnot.pdf_set_annot_interior_color = pdf_set_annot_interior_color
       
    1: def ll_fz_fill_text( dev, text, ctm, colorspace, color, alpha, color_params):
           """
           Low-level Python version of fz_fill_text() taking list/tuple for `color`.
           """
>>>>>>     color = tuple(color) + (0,) * (4-len(color))
>>>>>>     assert len(color) == 4, f'color not len 4: len={len(color)}: {color}'
>>>>>>     return ll_fz_fill_text2(dev, text, ctm, colorspace, *color, alpha, color_params)
    1: def fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params):
           """
           Python version of fz_fill_text() taking list/tuple for `color`.
           """
>>>>>>     return ll_fz_fill_text(
>>>>>>             dev.m_internal,
>>>>>>             text.m_internal,
>>>>>>             ctm.internal(),
>>>>>>             colorspace.m_internal,
>>>>>>             color,
>>>>>>             alpha,
>>>>>>             color_params.internal(),
                   )
    1: FzDevice.fz_fill_text = fz_fill_text
       
       # Override mupdf_convert_color() to return (rgb0, rgb1, rgb2, rgb3).
    1: def ll_fz_convert_color( ss, sv, ds, is_, params):
           """
           Low-level Python version of fz_convert_color().
       
           `sv` should be a float or list of 1-4 floats or a SWIG
           representation of a float*.
       
           Returns (dv0, dv1, dv2, dv3).
           """
>>>>>>     dv = fz_convert_color2_v()
>>>>>>     if isinstance( sv, float):
>>>>>>        ll_fz_convert_color2( ss, sv, 0.0, 0.0, 0.0, ds, dv, is_, params)
>>>>>>     elif isinstance( sv, (tuple, list)):
>>>>>>         sv2 = tuple(sv) + (0,) * (4-len(sv))
>>>>>>         ll_fz_convert_color2( ss, *sv2, ds, dv, is_, params)
           else:
       # Assume `sv` is SWIG representation of a `float*`.
>>>>>>         ll_fz_convert_color2( ss, sv, ds, dv, is_, params)
>>>>>>     return dv.v0, dv.v1, dv.v2, dv.v3
    1: def fz_convert_color( ss, sv, ds, is_, params):
           """
           Python version of fz_convert_color().
       
           `sv` should be a float or list of 1-4 floats or a SWIG
           representation of a float*.
       
           Returns (dv0, dv1, dv2, dv3).
           """
>>>>>>     return ll_fz_convert_color( ss.m_internal, sv, ds.m_internal, is_.m_internal, params.internal())
    1: FzColorspace.fz_convert_color = fz_convert_color
       
       # Override fz_set_warning_callback() and
       # fz_set_error_callback() to use Python classes derived from
       # our SWIG Director class DiagnosticCallback (defined in C), so
       # that fnptrs can call Python code.
       #
       
       # We store DiagnosticCallbackPython instances in these
       # globals to ensure they continue to exist after
       # set_diagnostic_callback() returns.
       #
    1: set_warning_callback_s = None
    1: set_error_callback_s = None
       
       # Override set_error_callback().
    2: class DiagnosticCallbackPython( DiagnosticCallback):
    1:     """
           Overrides Director class DiagnosticCallback's virtual
           `_print()` method in Python.
           """
    1:     def __init__( self, description, printfn):
    2:         super().__init__( description)
    2:         self.printfn = printfn
    2:         if g_mupdf_trace_director:
>>>>>>             log( f'DiagnosticCallbackPython[{self.m_description}].__init__() self={self!r} printfn={printfn!r}')
    1:     def __del__( self):
>>>>>>         if g_mupdf_trace_director:
>>>>>>             log( f'DiagnosticCallbackPython[{self.m_description}].__del__() destructor called.')
    1:     def _print( self, message):
>>>>>>         if g_mupdf_trace_director:
>>>>>>             log( f'DiagnosticCallbackPython[{self.m_description}]._print(): Calling self.printfn={self.printfn!r} with message={message!r}')
>>>>>>         try:
>>>>>>             self.printfn( message)
>>>>>>         except Exception as e:
       # This shouldn't happen, so always output a diagnostic.
>>>>>>             log( f'DiagnosticCallbackPython[{self.m_description}]._print(): Warning: exception from self.printfn={self.printfn!r}: e={e!r}')
       # Calling `raise` here serves to test
       # `DiagnosticCallback()`'s swallowing of what will
       # be a C++ exception. But we could swallow the
       # exception here instead.
>>>>>>             raise
       
    1: def set_diagnostic_callback( description, printfn):
    2:     if g_mupdf_trace_director:
>>>>>>         log( f'set_diagnostic_callback() description={description!r} printfn={printfn!r}')
    2:     if printfn:
    2:         ret = DiagnosticCallbackPython( description, printfn)
    2:         return ret
           else:
>>>>>>         if g_mupdf_trace_director:
>>>>>>             log( f'Calling ll_fz_set_{description}_callback() with (None, None)')
>>>>>>         if description == 'error':
>>>>>>             ll_fz_set_error_callback( None, None)
>>>>>>         elif description == 'warning':
>>>>>>             ll_fz_set_warning_callback( None, None)
               else:
>>>>>>             assert 0, f'Unrecognised description={description!r}'
>>>>>>         return None
       
    1: def fz_set_error_callback( printfn):
           global set_error_callback_s
    1:     set_error_callback_s = set_diagnostic_callback( 'error', printfn)
       
    1: def fz_set_warning_callback( printfn):
           global set_warning_callback_s
    1:     set_warning_callback_s = set_diagnostic_callback( 'warning', printfn)
       
       # Direct access to fz_pixmap samples.
    1: def ll_fz_pixmap_samples_memoryview( pixmap):
           """
           Returns a writable Python `memoryview` for a `fz_pixmap`.
           """
>>>>>>     assert isinstance( pixmap, fz_pixmap)
>>>>>>     ret = python_memoryview_from_memory(
>>>>>>             ll_fz_pixmap_samples( pixmap),
>>>>>>             ll_fz_pixmap_stride( pixmap) * ll_fz_pixmap_height( pixmap),
>>>>>>             1, # writable
                   )
>>>>>>     return ret
    1: def fz_pixmap_samples_memoryview( pixmap):
           """
           Returns a writable Python `memoryview` for a `FzPixmap`.
           """
>>>>>>     return ll_fz_pixmap_samples_memoryview( pixmap.m_internal)
    1: FzPixmap.fz_pixmap_samples_memoryview = fz_pixmap_samples_memoryview
       
       # Avoid potential unsafe use of variadic args by forcing a
       # single arg and escaping all '%' characters. (Passing ('%s',
       # text) does not work - results in "(null)" being output.)
       #
    1: ll_fz_warn_original = ll_fz_warn
    1: def ll_fz_warn( text):
>>>>>>     assert isinstance( text, str), f'text={text!r} str={str!r}'
>>>>>>     text = text.replace( '%', '%%')
>>>>>>     return ll_fz_warn_original( text)
    1: fz_warn = ll_fz_warn
       
       # Force use of pdf_load_field_name2() instead of
       # pdf_load_field_name() because the latter returns a char*
       # buffer that must be freed by the caller.
    1: ll_pdf_load_field_name = ll_pdf_load_field_name2
    1: pdf_load_field_name = pdf_load_field_name2
    1: PdfObj.pdf_load_field_name = pdf_load_field_name
       
       # It's important that when we create class derived
       # from StoryPositionsCallback, we ensure that
       # StoryPositionsCallback's constructor is called. Otherwise
       # the new instance doesn't seem to be an instance of
       # StoryPositionsCallback.
       #
    2: class StoryPositionsCallback_python( StoryPositionsCallback):
    1:     def __init__( self, python_callback):
>>>>>>         super().__init__()
>>>>>>         self.python_callback = python_callback
    1:     def call( self, position):
>>>>>>         self.python_callback( position)
       
    1: ll_fz_story_positions_orig = ll_fz_story_positions
    1: def ll_fz_story_positions( story, python_callback):
           """
           Custom replacement for `ll_fz_story_positions()` that takes
           a Python callable `python_callback`.
           """
       #log( f'll_fz_story_positions() type(story)={type(story)!r} type(python_callback)={type(python_callback)!r}')
>>>>>>     python_callback_instance = StoryPositionsCallback_python( python_callback)
>>>>>>     ll_fz_story_positions_director( story, python_callback_instance)
    1: def fz_story_positions( story, python_callback):
       #log( f'fz_story_positions() type(story)={type(story)!r} type(python_callback)={type(python_callback)!r}')
>>>>>>     assert isinstance( story, FzStory)
>>>>>>     assert callable( python_callback)
>>>>>>     def python_callback2( position):
>>>>>>         position2 = FzStoryElementPosition( position)
>>>>>>         python_callback( position2)
>>>>>>     ll_fz_story_positions( story.m_internal, python_callback2)
    1: FzStory.fz_story_positions = fz_story_positions
       
       # Monkey-patch `FzDocumentWriter.__init__()` to set `self._out`
       # to any `FzOutput2` arg. This ensures that the Python part of
       # the derived `FzOutput2` instance is kept alive for use by the
       # `FzDocumentWriter`, otherwise Python can delete it, then get
       # a SEGV if C++ tries to call the derived Python methods.
       #
       # [We don't patch equivalent class-aware functions such
       # as `fz_new_pdf_writer_with_output()` because they are
       # not available to C++/Python, because FzDocumentWriter is
       # non-copyable.]
       #
    1: FzDocumentWriter__init__0 = FzDocumentWriter.__init__
    1: def FzDocumentWriter__init__1(self, *args):
>>>>>>     out = None
>>>>>>     for arg in args:
>>>>>>         if isinstance( arg, FzOutput2):
>>>>>>             assert not out, "More than one FzOutput2 passed to FzDocumentWriter.__init__()"
>>>>>>             out = arg
>>>>>>     if out is not None:
>>>>>>         self._out = out
>>>>>>     return FzDocumentWriter__init__0(self, *args)
    1: FzDocumentWriter.__init__ = FzDocumentWriter__init__1
       
       # Create class derived from
       # fz_install_load_system_font_funcs_args class wrapper with
       # overrides of the virtual functions to allow calling of Python
       # callbacks.
       #
    2: class fz_install_load_system_font_funcs_args3(FzInstallLoadSystemFontFuncsArgs2):
    1:     """
           Class derived from Swig Director class
           fz_install_load_system_font_funcs_args2, to allow
           implementation of fz_install_load_system_font_funcs with
           Python callbacks.
           """
    1:     def __init__(self, f=None, f_cjk=None, f_fallback=None):
>>>>>>         super().__init__()
       
>>>>>>         self.f3 = f
>>>>>>         self.f_cjk3 = f_cjk
>>>>>>         self.f_fallback3 = f_fallback
       
>>>>>>         self.use_virtual_f(True if f else False)
>>>>>>         self.use_virtual_f_cjk(True if f_cjk else False)
>>>>>>         self.use_virtual_f_fallback(True if f_fallback else False)
       
    1:     def ret_font(self, font):
>>>>>>         if font is None:
>>>>>>             return None
>>>>>>         elif isinstance(font, FzFont):
>>>>>>             return ll_fz_keep_font(font.m_internal)
>>>>>>         elif isinstance(font, fz_font):
>>>>>>             return font
               else:
>>>>>>             assert 0, f'Expected FzFont or fz_font, but fz_install_load_system_font_funcs() callback returned {type(font)=}'
       
    1:     def f(self, ctx, name, bold, italic, needs_exact_metrics):
>>>>>>         font = self.f3(name, bold, italic, needs_exact_metrics)
>>>>>>         return self.ret_font(font)
       
    1:     def f_cjk(self, ctx, name, ordering, serif):
>>>>>>         font = self.f_cjk3(name, ordering, serif)
>>>>>>         return self.ret_font(font)
       
    1:     def f_fallback(self, ctx, script, language, serif, bold, italic):
>>>>>>         font = self.f_fallback3(script, language, serif, bold, italic)
>>>>>>         return self.ret_font(font)
       
       # We store the most recently created
       # fz_install_load_system_font_funcs_args in this global so that
       # it is not cleaned up by Python.
    1: g_fz_install_load_system_font_funcs_args = None
       
    1: def fz_install_load_system_font_funcs(f=None, f_cjk=None, f_fallback=None):
           """
           Python override for MuPDF
           fz_install_load_system_font_funcs() using Swig Director
           support. Python callbacks are not passed a `ctx` arg, and
           can return None, a mupdf.fz_font or a mupdf.FzFont.
           """
           global g_fz_install_load_system_font_funcs_args
>>>>>>     g_fz_install_load_system_font_funcs_args = fz_install_load_system_font_funcs_args3(
>>>>>>             f,
>>>>>>             f_cjk,
>>>>>>             f_fallback,
                   )
>>>>>>     fz_install_load_system_font_funcs2(g_fz_install_load_system_font_funcs_args)
       
    1: Py_LIMITED_API = '0x030a0000'
    1: FzLink.__iter__ = lambda self: IteratorWrap( self)
    1: FzStextBlock.__iter__ = lambda self: IteratorWrap( self)
    1: FzStextLine.__iter__ = lambda self: IteratorWrap( self)
    1: FzStextPage.__iter__ = lambda self: IteratorWrap( self)
    1: fz_aa_context.__str__ = lambda s: to_string_fz_aa_context(s)
    1: fz_aa_context.__repr__ = lambda s: to_string_fz_aa_context(s)
    1: fz_color_params.__str__ = lambda s: to_string_fz_color_params(s)
    1: fz_color_params.__repr__ = lambda s: to_string_fz_color_params(s)
    1: fz_cookie.__str__ = lambda s: to_string_fz_cookie(s)
    1: fz_cookie.__repr__ = lambda s: to_string_fz_cookie(s)
    1: fz_draw_options.__str__ = lambda s: to_string_fz_draw_options(s)
    1: fz_draw_options.__repr__ = lambda s: to_string_fz_draw_options(s)
    1: fz_install_load_system_font_funcs_args.__str__ = lambda s: to_string_fz_install_load_system_font_funcs_args(s)
    1: fz_install_load_system_font_funcs_args.__repr__ = lambda s: to_string_fz_install_load_system_font_funcs_args(s)
    1: fz_irect.__str__ = lambda s: to_string_fz_irect(s)
    1: fz_irect.__repr__ = lambda s: to_string_fz_irect(s)
    1: fz_location.__str__ = lambda s: to_string_fz_location(s)
    1: fz_location.__repr__ = lambda s: to_string_fz_location(s)
    1: fz_matrix.__str__ = lambda s: to_string_fz_matrix(s)
    1: fz_matrix.__repr__ = lambda s: to_string_fz_matrix(s)
    1: fz_md5.__str__ = lambda s: to_string_fz_md5(s)
    1: fz_md5.__repr__ = lambda s: to_string_fz_md5(s)
    1: fz_pdfocr_options.__str__ = lambda s: to_string_fz_pdfocr_options(s)
    1: fz_pdfocr_options.__repr__ = lambda s: to_string_fz_pdfocr_options(s)
    1: fz_point.__str__ = lambda s: to_string_fz_point(s)
    1: fz_point.__repr__ = lambda s: to_string_fz_point(s)
    1: fz_pwg_options.__str__ = lambda s: to_string_fz_pwg_options(s)
    1: fz_pwg_options.__repr__ = lambda s: to_string_fz_pwg_options(s)
    1: fz_quad.__str__ = lambda s: to_string_fz_quad(s)
    1: fz_quad.__repr__ = lambda s: to_string_fz_quad(s)
    1: fz_rect.__str__ = lambda s: to_string_fz_rect(s)
    1: fz_rect.__repr__ = lambda s: to_string_fz_rect(s)
    1: fz_stext_options.__str__ = lambda s: to_string_fz_stext_options(s)
    1: fz_stext_options.__repr__ = lambda s: to_string_fz_stext_options(s)
    1: fz_story_element_position.__str__ = lambda s: to_string_fz_story_element_position(s)
    1: fz_story_element_position.__repr__ = lambda s: to_string_fz_story_element_position(s)
    1: fz_transition.__str__ = lambda s: to_string_fz_transition(s)
    1: fz_transition.__repr__ = lambda s: to_string_fz_transition(s)
    1: pdf_clean_options.__str__ = lambda s: to_string_pdf_clean_options(s)
    1: pdf_clean_options.__repr__ = lambda s: to_string_pdf_clean_options(s)
    1: pdf_filter_factory.__str__ = lambda s: to_string_pdf_filter_factory(s)
    1: pdf_filter_factory.__repr__ = lambda s: to_string_pdf_filter_factory(s)
    1: pdf_filter_options.__str__ = lambda s: to_string_pdf_filter_options(s)
    1: pdf_filter_options.__repr__ = lambda s: to_string_pdf_filter_options(s)
    1: pdf_image_rewriter_options.__str__ = lambda s: to_string_pdf_image_rewriter_options(s)
    1: pdf_image_rewriter_options.__repr__ = lambda s: to_string_pdf_image_rewriter_options(s)
    1: pdf_layer_config.__str__ = lambda s: to_string_pdf_layer_config(s)
    1: pdf_layer_config.__repr__ = lambda s: to_string_pdf_layer_config(s)
    1: pdf_layer_config_ui.__str__ = lambda s: to_string_pdf_layer_config_ui(s)
    1: pdf_layer_config_ui.__repr__ = lambda s: to_string_pdf_layer_config_ui(s)
    1: pdf_recolor_options.__str__ = lambda s: to_string_pdf_recolor_options(s)
    1: pdf_recolor_options.__repr__ = lambda s: to_string_pdf_recolor_options(s)
    1: pdf_redact_options.__str__ = lambda s: to_string_pdf_redact_options(s)
    1: pdf_redact_options.__repr__ = lambda s: to_string_pdf_redact_options(s)
    1: pdf_sanitize_filter_options.__str__ = lambda s: to_string_pdf_sanitize_filter_options(s)
    1: pdf_sanitize_filter_options.__repr__ = lambda s: to_string_pdf_sanitize_filter_options(s)
    1: pdf_write_options.__str__ = lambda s: to_string_pdf_write_options(s)
    1: pdf_write_options.__repr__ = lambda s: to_string_pdf_write_options(s)
    1: FzAaContext.__str__ = lambda self: self.to_string()
    1: FzAaContext.__repr__ = lambda self: self.to_string()
    1: FzColorParams.__str__ = lambda self: self.to_string()
    1: FzColorParams.__repr__ = lambda self: self.to_string()
    1: FzCookie.__str__ = lambda self: self.to_string()
    1: FzCookie.__repr__ = lambda self: self.to_string()
    1: FzDrawOptions.__str__ = lambda self: self.to_string()
    1: FzDrawOptions.__repr__ = lambda self: self.to_string()
    1: FzInstallLoadSystemFontFuncsArgs.__str__ = lambda self: self.to_string()
    1: FzInstallLoadSystemFontFuncsArgs.__repr__ = lambda self: self.to_string()
    1: FzIrect.__str__ = lambda self: self.to_string()
    1: FzIrect.__repr__ = lambda self: self.to_string()
    1: FzLocation.__str__ = lambda self: self.to_string()
    1: FzLocation.__repr__ = lambda self: self.to_string()
    1: FzMatrix.__str__ = lambda self: self.to_string()
    1: FzMatrix.__repr__ = lambda self: self.to_string()
    1: FzMd5.__str__ = lambda self: self.to_string()
    1: FzMd5.__repr__ = lambda self: self.to_string()
    1: FzPdfocrOptions.__str__ = lambda self: self.to_string()
    1: FzPdfocrOptions.__repr__ = lambda self: self.to_string()
    1: FzPoint.__str__ = lambda self: self.to_string()
    1: FzPoint.__repr__ = lambda self: self.to_string()
    1: FzPwgOptions.__str__ = lambda self: self.to_string()
    1: FzPwgOptions.__repr__ = lambda self: self.to_string()
    1: FzQuad.__str__ = lambda self: self.to_string()
    1: FzQuad.__repr__ = lambda self: self.to_string()
    1: FzRect.__str__ = lambda self: self.to_string()
    1: FzRect.__repr__ = lambda self: self.to_string()
    1: FzStextOptions.__str__ = lambda self: self.to_string()
    1: FzStextOptions.__repr__ = lambda self: self.to_string()
    1: FzStoryElementPosition.__str__ = lambda self: self.to_string()
    1: FzStoryElementPosition.__repr__ = lambda self: self.to_string()
    1: FzTransition.__str__ = lambda self: self.to_string()
    1: FzTransition.__repr__ = lambda self: self.to_string()
    1: PdfCleanOptions.__str__ = lambda self: self.to_string()
    1: PdfCleanOptions.__repr__ = lambda self: self.to_string()
    1: PdfFilterFactory.__str__ = lambda self: self.to_string()
    1: PdfFilterFactory.__repr__ = lambda self: self.to_string()
    1: PdfFilterOptions.__str__ = lambda self: self.to_string()
    1: PdfFilterOptions.__repr__ = lambda self: self.to_string()
    1: PdfImageRewriterOptions.__str__ = lambda self: self.to_string()
    1: PdfImageRewriterOptions.__repr__ = lambda self: self.to_string()
    1: PdfLayerConfig.__str__ = lambda self: self.to_string()
    1: PdfLayerConfig.__repr__ = lambda self: self.to_string()
    1: PdfLayerConfigUi.__str__ = lambda self: self.to_string()
    1: PdfLayerConfigUi.__repr__ = lambda self: self.to_string()
    1: PdfRecolorOptions.__str__ = lambda self: self.to_string()
    1: PdfRecolorOptions.__repr__ = lambda self: self.to_string()
    1: PdfRedactOptions.__str__ = lambda self: self.to_string()
    1: PdfRedactOptions.__repr__ = lambda self: self.to_string()
    1: PdfSanitizeFilterOptions.__str__ = lambda self: self.to_string()
    1: PdfSanitizeFilterOptions.__repr__ = lambda self: self.to_string()
    1: PdfWriteOptions.__str__ = lambda self: self.to_string()
    1: PdfWriteOptions.__repr__ = lambda self: self.to_string()
       
       
    1: PDF_ENUM_NAME_1_2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_1_2))
    1: PDF_ENUM_NAME_1_5 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_1_5))
    1: PDF_ENUM_NAME_3D = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_3D))
    1: PDF_ENUM_NAME_A = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_A))
    1: PDF_ENUM_NAME_A85 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_A85))
    1: PDF_ENUM_NAME_AA = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AA))
    1: PDF_ENUM_NAME_AC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AC))
    1: PDF_ENUM_NAME_AESV2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AESV2))
    1: PDF_ENUM_NAME_AESV3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AESV3))
    1: PDF_ENUM_NAME_AF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AF))
    1: PDF_ENUM_NAME_AFRelationship = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AFRelationship))
    1: PDF_ENUM_NAME_AHx = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AHx))
    1: PDF_ENUM_NAME_AP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AP))
    1: PDF_ENUM_NAME_AS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AS))
    1: PDF_ENUM_NAME_ASCII85Decode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ASCII85Decode))
    1: PDF_ENUM_NAME_ASCIIHexDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ASCIIHexDecode))
    1: PDF_ENUM_NAME_AbsoluteColorimetric = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AbsoluteColorimetric))
    1: PDF_ENUM_NAME_AcroForm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AcroForm))
    1: PDF_ENUM_NAME_Action = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Action))
    1: PDF_ENUM_NAME_ActualText = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ActualText))
    1: PDF_ENUM_NAME_Adobe_PPKLite = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Adobe_PPKLite))
    1: PDF_ENUM_NAME_All = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_All))
    1: PDF_ENUM_NAME_AllOff = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AllOff))
    1: PDF_ENUM_NAME_AllOn = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AllOn))
    1: PDF_ENUM_NAME_Alpha = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Alpha))
    1: PDF_ENUM_NAME_Alt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Alt))
    1: PDF_ENUM_NAME_Alternate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Alternate))
    1: PDF_ENUM_NAME_Alternative = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Alternative))
    1: PDF_ENUM_NAME_Annot = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Annot))
    1: PDF_ENUM_NAME_Annots = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Annots))
    1: PDF_ENUM_NAME_AnyOff = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AnyOff))
    1: PDF_ENUM_NAME_App = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_App))
    1: PDF_ENUM_NAME_Approved = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Approved))
    1: PDF_ENUM_NAME_Art = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Art))
    1: PDF_ENUM_NAME_ArtBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ArtBox))
    1: PDF_ENUM_NAME_Artifact = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Artifact))
    1: PDF_ENUM_NAME_AsIs = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AsIs))
    1: PDF_ENUM_NAME_Ascent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ascent))
    1: PDF_ENUM_NAME_Aside = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Aside))
    1: PDF_ENUM_NAME_AuthEvent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AuthEvent))
    1: PDF_ENUM_NAME_Author = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Author))
    1: PDF_ENUM_NAME_B = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_B))
    1: PDF_ENUM_NAME_BBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BBox))
    1: PDF_ENUM_NAME_BC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BC))
    1: PDF_ENUM_NAME_BE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BE))
    1: PDF_ENUM_NAME_BG = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BG))
    1: PDF_ENUM_NAME_BM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BM))
    1: PDF_ENUM_NAME_BPC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BPC))
    1: PDF_ENUM_NAME_BS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BS))
    1: PDF_ENUM_NAME_Background = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Background))
    1: PDF_ENUM_NAME_BaseEncoding = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BaseEncoding))
    1: PDF_ENUM_NAME_BaseFont = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BaseFont))
    1: PDF_ENUM_NAME_BaseState = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BaseState))
    1: PDF_ENUM_NAME_BibEntry = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BibEntry))
    1: PDF_ENUM_NAME_BitsPerComponent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BitsPerComponent))
    1: PDF_ENUM_NAME_BitsPerCoordinate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BitsPerCoordinate))
    1: PDF_ENUM_NAME_BitsPerFlag = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BitsPerFlag))
    1: PDF_ENUM_NAME_BitsPerSample = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BitsPerSample))
    1: PDF_ENUM_NAME_BlackIs1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BlackIs1))
    1: PDF_ENUM_NAME_BlackPoint = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BlackPoint))
    1: PDF_ENUM_NAME_BleedBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BleedBox))
    1: PDF_ENUM_NAME_Blinds = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Blinds))
    1: PDF_ENUM_NAME_BlockQuote = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BlockQuote))
    1: PDF_ENUM_NAME_Border = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Border))
    1: PDF_ENUM_NAME_Bounds = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Bounds))
    1: PDF_ENUM_NAME_Box = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Box))
    1: PDF_ENUM_NAME_Br = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Br))
    1: PDF_ENUM_NAME_BrotliDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BrotliDecode))
    1: PDF_ENUM_NAME_Bt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Bt))
    1: PDF_ENUM_NAME_Btn = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Btn))
    1: PDF_ENUM_NAME_Butt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Butt))
    1: PDF_ENUM_NAME_ByteRange = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ByteRange))
    1: PDF_ENUM_NAME_C = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_C))
    1: PDF_ENUM_NAME_C0 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_C0))
    1: PDF_ENUM_NAME_C1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_C1))
    1: PDF_ENUM_NAME_CA = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CA))
    1: PDF_ENUM_NAME_CCF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CCF))
    1: PDF_ENUM_NAME_CCITTFaxDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CCITTFaxDecode))
    1: PDF_ENUM_NAME_CF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CF))
    1: PDF_ENUM_NAME_CFM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CFM))
    1: PDF_ENUM_NAME_CI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CI))
    1: PDF_ENUM_NAME_CIDFontType0 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDFontType0))
    1: PDF_ENUM_NAME_CIDFontType0C = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDFontType0C))
    1: PDF_ENUM_NAME_CIDFontType2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDFontType2))
    1: PDF_ENUM_NAME_CIDSystemInfo = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDSystemInfo))
    1: PDF_ENUM_NAME_CIDToGIDMap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDToGIDMap))
    1: PDF_ENUM_NAME_CL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CL))
    1: PDF_ENUM_NAME_CMYK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CMYK))
    1: PDF_ENUM_NAME_CO = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CO))
    1: PDF_ENUM_NAME_CP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CP))
    1: PDF_ENUM_NAME_CS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CS))
    1: PDF_ENUM_NAME_CalCMYK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CalCMYK))
    1: PDF_ENUM_NAME_CalGray = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CalGray))
    1: PDF_ENUM_NAME_CalRGB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CalRGB))
    1: PDF_ENUM_NAME_Cap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Cap))
    1: PDF_ENUM_NAME_CapHeight = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CapHeight))
    1: PDF_ENUM_NAME_Caption = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Caption))
    1: PDF_ENUM_NAME_Caret = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Caret))
    1: PDF_ENUM_NAME_Catalog = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Catalog))
    1: PDF_ENUM_NAME_Cert = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Cert))
    1: PDF_ENUM_NAME_Ch = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ch))
    1: PDF_ENUM_NAME_Changes = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Changes))
    1: PDF_ENUM_NAME_CharProcs = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CharProcs))
    1: PDF_ENUM_NAME_CheckSum = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CheckSum))
    1: PDF_ENUM_NAME_Circle = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Circle))
    1: PDF_ENUM_NAME_ClosedArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ClosedArrow))
    1: PDF_ENUM_NAME_Code = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Code))
    1: PDF_ENUM_NAME_Collection = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Collection))
    1: PDF_ENUM_NAME_ColorSpace = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ColorSpace))
    1: PDF_ENUM_NAME_ColorTransform = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ColorTransform))
    1: PDF_ENUM_NAME_Colorants = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Colorants))
    1: PDF_ENUM_NAME_Colors = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Colors))
    1: PDF_ENUM_NAME_Columns = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Columns))
    1: PDF_ENUM_NAME_Confidential = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Confidential))
    1: PDF_ENUM_NAME_Configs = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Configs))
    1: PDF_ENUM_NAME_ContactInfo = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ContactInfo))
    1: PDF_ENUM_NAME_Contents = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Contents))
    1: PDF_ENUM_NAME_Coords = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Coords))
    1: PDF_ENUM_NAME_Count = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Count))
    1: PDF_ENUM_NAME_Cover = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Cover))
    1: PDF_ENUM_NAME_CreationDate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CreationDate))
    1: PDF_ENUM_NAME_Creator = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Creator))
    1: PDF_ENUM_NAME_CropBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CropBox))
    1: PDF_ENUM_NAME_Crypt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Crypt))
    1: PDF_ENUM_NAME_D = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_D))
    1: PDF_ENUM_NAME_DA = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DA))
    1: PDF_ENUM_NAME_DC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DC))
    1: PDF_ENUM_NAME_DCT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DCT))
    1: PDF_ENUM_NAME_DCTDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DCTDecode))
    1: PDF_ENUM_NAME_DL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DL))
    1: PDF_ENUM_NAME_DOS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DOS))
    1: PDF_ENUM_NAME_DP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DP))
    1: PDF_ENUM_NAME_DR = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DR))
    1: PDF_ENUM_NAME_DS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DS))
    1: PDF_ENUM_NAME_DV = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DV))
    1: PDF_ENUM_NAME_DW = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DW))
    1: PDF_ENUM_NAME_DW2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DW2))
    1: PDF_ENUM_NAME_DamagedRowsBeforeError = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DamagedRowsBeforeError))
    1: PDF_ENUM_NAME_Data = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Data))
    1: PDF_ENUM_NAME_Date = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Date))
    1: PDF_ENUM_NAME_Decode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Decode))
    1: PDF_ENUM_NAME_DecodeParms = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DecodeParms))
    1: PDF_ENUM_NAME_Default = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Default))
    1: PDF_ENUM_NAME_DefaultCMYK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DefaultCMYK))
    1: PDF_ENUM_NAME_DefaultGray = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DefaultGray))
    1: PDF_ENUM_NAME_DefaultRGB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DefaultRGB))
    1: PDF_ENUM_NAME_Departmental = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Departmental))
    1: PDF_ENUM_NAME_Desc = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Desc))
    1: PDF_ENUM_NAME_DescendantFonts = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DescendantFonts))
    1: PDF_ENUM_NAME_Descent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Descent))
    1: PDF_ENUM_NAME_Design = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Design))
    1: PDF_ENUM_NAME_Dest = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dest))
    1: PDF_ENUM_NAME_DestOutputProfile = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DestOutputProfile))
    1: PDF_ENUM_NAME_Dests = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dests))
    1: PDF_ENUM_NAME_DeviceCMYK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DeviceCMYK))
    1: PDF_ENUM_NAME_DeviceGray = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DeviceGray))
    1: PDF_ENUM_NAME_DeviceN = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DeviceN))
    1: PDF_ENUM_NAME_DeviceRGB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DeviceRGB))
    1: PDF_ENUM_NAME_Di = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Di))
    1: PDF_ENUM_NAME_Diamond = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Diamond))
    1: PDF_ENUM_NAME_Differences = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Differences))
    1: PDF_ENUM_NAME_DigestLocation = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DigestLocation))
    1: PDF_ENUM_NAME_DigestMethod = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DigestMethod))
    1: PDF_ENUM_NAME_DigestValue = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DigestValue))
    1: PDF_ENUM_NAME_Dissolve = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dissolve))
    1: PDF_ENUM_NAME_Div = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Div))
    1: PDF_ENUM_NAME_Dm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dm))
    1: PDF_ENUM_NAME_DocMDP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DocMDP))
    1: PDF_ENUM_NAME_Document = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Document))
    1: PDF_ENUM_NAME_DocumentFragment = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DocumentFragment))
    1: PDF_ENUM_NAME_Domain = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Domain))
    1: PDF_ENUM_NAME_Draft = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Draft))
    1: PDF_ENUM_NAME_Dur = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dur))
    1: PDF_ENUM_NAME_E = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_E))
    1: PDF_ENUM_NAME_EF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EF))
    1: PDF_ENUM_NAME_EarlyChange = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EarlyChange))
    1: PDF_ENUM_NAME_Em = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Em))
    1: PDF_ENUM_NAME_EmbeddedFile = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EmbeddedFile))
    1: PDF_ENUM_NAME_EmbeddedFiles = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EmbeddedFiles))
    1: PDF_ENUM_NAME_Encode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Encode))
    1: PDF_ENUM_NAME_EncodedByteAlign = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EncodedByteAlign))
    1: PDF_ENUM_NAME_Encoding = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Encoding))
    1: PDF_ENUM_NAME_Encrypt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Encrypt))
    1: PDF_ENUM_NAME_EncryptMetadata = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EncryptMetadata))
    1: PDF_ENUM_NAME_EncryptedPayload = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EncryptedPayload))
    1: PDF_ENUM_NAME_EndOfBlock = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EndOfBlock))
    1: PDF_ENUM_NAME_EndOfLine = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EndOfLine))
    1: PDF_ENUM_NAME_Exclude = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Exclude))
    1: PDF_ENUM_NAME_Experimental = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Experimental))
    1: PDF_ENUM_NAME_Expired = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Expired))
    1: PDF_ENUM_NAME_ExtGState = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ExtGState))
    1: PDF_ENUM_NAME_Extend = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Extend))
    1: PDF_ENUM_NAME_F = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_F))
    1: PDF_ENUM_NAME_FENote = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FENote))
    1: PDF_ENUM_NAME_FL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FL))
    1: PDF_ENUM_NAME_FRM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FRM))
    1: PDF_ENUM_NAME_FS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FS))
    1: PDF_ENUM_NAME_FT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FT))
    1: PDF_ENUM_NAME_Fade = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fade))
    1: PDF_ENUM_NAME_Ff = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ff))
    1: PDF_ENUM_NAME_FieldMDP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FieldMDP))
    1: PDF_ENUM_NAME_Fields = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fields))
    1: PDF_ENUM_NAME_Figure = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Figure))
    1: PDF_ENUM_NAME_FileAttachment = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FileAttachment))
    1: PDF_ENUM_NAME_FileSize = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FileSize))
    1: PDF_ENUM_NAME_Filespec = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Filespec))
    1: PDF_ENUM_NAME_Filter = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Filter))
    1: PDF_ENUM_NAME_Final = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Final))
    1: PDF_ENUM_NAME_Fingerprint = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fingerprint))
    1: PDF_ENUM_NAME_First = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_First))
    1: PDF_ENUM_NAME_FirstChar = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FirstChar))
    1: PDF_ENUM_NAME_FirstPage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FirstPage))
    1: PDF_ENUM_NAME_Fit = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fit))
    1: PDF_ENUM_NAME_FitB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitB))
    1: PDF_ENUM_NAME_FitBH = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitBH))
    1: PDF_ENUM_NAME_FitBV = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitBV))
    1: PDF_ENUM_NAME_FitH = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitH))
    1: PDF_ENUM_NAME_FitR = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitR))
    1: PDF_ENUM_NAME_FitV = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitV))
    1: PDF_ENUM_NAME_Fl = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fl))
    1: PDF_ENUM_NAME_Flags = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Flags))
    1: PDF_ENUM_NAME_FlateDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FlateDecode))
    1: PDF_ENUM_NAME_Fly = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fly))
    1: PDF_ENUM_NAME_Font = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Font))
    1: PDF_ENUM_NAME_FontBBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontBBox))
    1: PDF_ENUM_NAME_FontDescriptor = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontDescriptor))
    1: PDF_ENUM_NAME_FontFile = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontFile))
    1: PDF_ENUM_NAME_FontFile2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontFile2))
    1: PDF_ENUM_NAME_FontFile3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontFile3))
    1: PDF_ENUM_NAME_FontMatrix = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontMatrix))
    1: PDF_ENUM_NAME_FontName = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontName))
    1: PDF_ENUM_NAME_ForComment = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ForComment))
    1: PDF_ENUM_NAME_ForPublicRelease = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ForPublicRelease))
    1: PDF_ENUM_NAME_Form = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Form))
    1: PDF_ENUM_NAME_FormData = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FormData))
    1: PDF_ENUM_NAME_FormEx = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FormEx))
    1: PDF_ENUM_NAME_FormType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FormType))
    1: PDF_ENUM_NAME_Formula = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Formula))
    1: PDF_ENUM_NAME_FreeText = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FreeText))
    1: PDF_ENUM_NAME_FreeTextCallout = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FreeTextCallout))
    1: PDF_ENUM_NAME_FreeTextTypeWriter = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FreeTextTypeWriter))
    1: PDF_ENUM_NAME_Function = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Function))
    1: PDF_ENUM_NAME_FunctionType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FunctionType))
    1: PDF_ENUM_NAME_Functions = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Functions))
    1: PDF_ENUM_NAME_G = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_G))
    1: PDF_ENUM_NAME_GTS_PDFX = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_GTS_PDFX))
    1: PDF_ENUM_NAME_Gamma = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Gamma))
    1: PDF_ENUM_NAME_Glitter = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Glitter))
    1: PDF_ENUM_NAME_GoTo = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_GoTo))
    1: PDF_ENUM_NAME_GoToR = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_GoToR))
    1: PDF_ENUM_NAME_Group = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Group))
    1: PDF_ENUM_NAME_H = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H))
    1: PDF_ENUM_NAME_H1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H1))
    1: PDF_ENUM_NAME_H2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H2))
    1: PDF_ENUM_NAME_H3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H3))
    1: PDF_ENUM_NAME_H4 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H4))
    1: PDF_ENUM_NAME_H5 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H5))
    1: PDF_ENUM_NAME_H6 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H6))
    1: PDF_ENUM_NAME_Height = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Height))
    1: PDF_ENUM_NAME_Helv = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Helv))
    1: PDF_ENUM_NAME_Highlight = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Highlight))
    1: PDF_ENUM_NAME_HistoryPos = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_HistoryPos))
    1: PDF_ENUM_NAME_I = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_I))
    1: PDF_ENUM_NAME_IC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IC))
    1: PDF_ENUM_NAME_ICCBased = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ICCBased))
    1: PDF_ENUM_NAME_ID = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ID))
    1: PDF_ENUM_NAME_IM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IM))
    1: PDF_ENUM_NAME_IRT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IRT))
    1: PDF_ENUM_NAME_IT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IT))
    1: PDF_ENUM_NAME_Identity = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Identity))
    1: PDF_ENUM_NAME_Identity_H = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Identity_H))
    1: PDF_ENUM_NAME_Identity_V = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Identity_V))
    1: PDF_ENUM_NAME_Image = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Image))
    1: PDF_ENUM_NAME_ImageB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ImageB))
    1: PDF_ENUM_NAME_ImageC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ImageC))
    1: PDF_ENUM_NAME_ImageI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ImageI))
    1: PDF_ENUM_NAME_ImageMask = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ImageMask))
    1: PDF_ENUM_NAME_Include = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Include))
    1: PDF_ENUM_NAME_Index = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Index))
    1: PDF_ENUM_NAME_Indexed = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Indexed))
    1: PDF_ENUM_NAME_Info = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Info))
    1: PDF_ENUM_NAME_Ink = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ink))
    1: PDF_ENUM_NAME_InkList = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_InkList))
    1: PDF_ENUM_NAME_Intent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Intent))
    1: PDF_ENUM_NAME_Interpolate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Interpolate))
    1: PDF_ENUM_NAME_IsMap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IsMap))
    1: PDF_ENUM_NAME_ItalicAngle = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ItalicAngle))
    1: PDF_ENUM_NAME_JBIG2Decode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JBIG2Decode))
    1: PDF_ENUM_NAME_JBIG2Globals = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JBIG2Globals))
    1: PDF_ENUM_NAME_JPXDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JPXDecode))
    1: PDF_ENUM_NAME_JS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JS))
    1: PDF_ENUM_NAME_JavaScript = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JavaScript))
    1: PDF_ENUM_NAME_K = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_K))
    1: PDF_ENUM_NAME_Keywords = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Keywords))
    1: PDF_ENUM_NAME_Kids = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Kids))
    1: PDF_ENUM_NAME_L = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_L))
    1: PDF_ENUM_NAME_LBody = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LBody))
    1: PDF_ENUM_NAME_LC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LC))
    1: PDF_ENUM_NAME_LE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LE))
    1: PDF_ENUM_NAME_LI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LI))
    1: PDF_ENUM_NAME_LJ = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LJ))
    1: PDF_ENUM_NAME_LL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LL))
    1: PDF_ENUM_NAME_LLE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LLE))
    1: PDF_ENUM_NAME_LLO = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LLO))
    1: PDF_ENUM_NAME_LW = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LW))
    1: PDF_ENUM_NAME_LZ = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LZ))
    1: PDF_ENUM_NAME_LZW = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LZW))
    1: PDF_ENUM_NAME_LZWDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LZWDecode))
    1: PDF_ENUM_NAME_Lab = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Lab))
    1: PDF_ENUM_NAME_Label = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Label))
    1: PDF_ENUM_NAME_Lang = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Lang))
    1: PDF_ENUM_NAME_Last = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Last))
    1: PDF_ENUM_NAME_LastChar = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LastChar))
    1: PDF_ENUM_NAME_LastPage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LastPage))
    1: PDF_ENUM_NAME_Launch = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Launch))
    1: PDF_ENUM_NAME_Layer = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Layer))
    1: PDF_ENUM_NAME_Lbl = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Lbl))
    1: PDF_ENUM_NAME_Length = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Length))
    1: PDF_ENUM_NAME_Length1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Length1))
    1: PDF_ENUM_NAME_Length2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Length2))
    1: PDF_ENUM_NAME_Length3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Length3))
    1: PDF_ENUM_NAME_Limits = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Limits))
    1: PDF_ENUM_NAME_Line = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Line))
    1: PDF_ENUM_NAME_LineArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LineArrow))
    1: PDF_ENUM_NAME_LineDimension = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LineDimension))
    1: PDF_ENUM_NAME_Linearized = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Linearized))
    1: PDF_ENUM_NAME_Link = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Link))
    1: PDF_ENUM_NAME_List = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_List))
    1: PDF_ENUM_NAME_Location = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Location))
    1: PDF_ENUM_NAME_Lock = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Lock))
    1: PDF_ENUM_NAME_Locked = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Locked))
    1: PDF_ENUM_NAME_Luminosity = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Luminosity))
    1: PDF_ENUM_NAME_M = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_M))
    1: PDF_ENUM_NAME_MCID = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MCID))
    1: PDF_ENUM_NAME_MK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MK))
    1: PDF_ENUM_NAME_ML = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ML))
    1: PDF_ENUM_NAME_MMType1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MMType1))
    1: PDF_ENUM_NAME_Mac = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Mac))
    1: PDF_ENUM_NAME_Mask = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Mask))
    1: PDF_ENUM_NAME_Matrix = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Matrix))
    1: PDF_ENUM_NAME_Matte = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Matte))
    1: PDF_ENUM_NAME_MaxLen = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MaxLen))
    1: PDF_ENUM_NAME_MediaBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MediaBox))
    1: PDF_ENUM_NAME_Metadata = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Metadata))
    1: PDF_ENUM_NAME_MissingWidth = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MissingWidth))
    1: PDF_ENUM_NAME_ModDate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ModDate))
    1: PDF_ENUM_NAME_Movie = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Movie))
    1: PDF_ENUM_NAME_Msg = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Msg))
    1: PDF_ENUM_NAME_Multiply = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Multiply))
    1: PDF_ENUM_NAME_N = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_N))
    1: PDF_ENUM_NAME_Name = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Name))
    1: PDF_ENUM_NAME_Named = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Named))
    1: PDF_ENUM_NAME_Names = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Names))
    1: PDF_ENUM_NAME_NewWindow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NewWindow))
    1: PDF_ENUM_NAME_Next = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Next))
    1: PDF_ENUM_NAME_NextPage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NextPage))
    1: PDF_ENUM_NAME_NonEFontNoWarn = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NonEFontNoWarn))
    1: PDF_ENUM_NAME_NonStruct = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NonStruct))
    1: PDF_ENUM_NAME_None = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_None))
    1: PDF_ENUM_NAME_Normal = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Normal))
    1: PDF_ENUM_NAME_NotApproved = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NotApproved))
    1: PDF_ENUM_NAME_NotForPublicRelease = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NotForPublicRelease))
    1: PDF_ENUM_NAME_Note = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Note))
    1: PDF_ENUM_NAME_NumSections = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NumSections))
    1: PDF_ENUM_NAME_Nums = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Nums))
    1: PDF_ENUM_NAME_O = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_O))
    1: PDF_ENUM_NAME_OC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OC))
    1: PDF_ENUM_NAME_OCG = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OCG))
    1: PDF_ENUM_NAME_OCGs = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OCGs))
    1: PDF_ENUM_NAME_OCMD = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OCMD))
    1: PDF_ENUM_NAME_OCProperties = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OCProperties))
    1: PDF_ENUM_NAME_OE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OE))
    1: PDF_ENUM_NAME_OFF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OFF))
    1: PDF_ENUM_NAME_ON = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ON))
    1: PDF_ENUM_NAME_OP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OP))
    1: PDF_ENUM_NAME_OPM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OPM))
    1: PDF_ENUM_NAME_OS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OS))
    1: PDF_ENUM_NAME_ObjStm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ObjStm))
    1: PDF_ENUM_NAME_Of = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Of))
    1: PDF_ENUM_NAME_Off = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Off))
    1: PDF_ENUM_NAME_Open = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Open))
    1: PDF_ENUM_NAME_OpenArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OpenArrow))
    1: PDF_ENUM_NAME_OpenType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OpenType))
    1: PDF_ENUM_NAME_Opt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Opt))
    1: PDF_ENUM_NAME_Order = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Order))
    1: PDF_ENUM_NAME_Ordering = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ordering))
    1: PDF_ENUM_NAME_Outlines = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Outlines))
    1: PDF_ENUM_NAME_OutputCondition = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OutputCondition))
    1: PDF_ENUM_NAME_OutputConditionIdentifier = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OutputConditionIdentifier))
    1: PDF_ENUM_NAME_OutputIntent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OutputIntent))
    1: PDF_ENUM_NAME_OutputIntents = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OutputIntents))
    1: PDF_ENUM_NAME_P = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_P))
    1: PDF_ENUM_NAME_PDF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PDF))
    1: PDF_ENUM_NAME_PS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PS))
    1: PDF_ENUM_NAME_Page = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Page))
    1: PDF_ENUM_NAME_PageLabels = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PageLabels))
    1: PDF_ENUM_NAME_PageMode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PageMode))
    1: PDF_ENUM_NAME_Pages = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Pages))
    1: PDF_ENUM_NAME_PaintType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PaintType))
    1: PDF_ENUM_NAME_Params = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Params))
    1: PDF_ENUM_NAME_Parent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Parent))
    1: PDF_ENUM_NAME_ParentTree = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ParentTree))
    1: PDF_ENUM_NAME_Part = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Part))
    1: PDF_ENUM_NAME_Pattern = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Pattern))
    1: PDF_ENUM_NAME_PatternType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PatternType))
    1: PDF_ENUM_NAME_Perceptual = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Perceptual))
    1: PDF_ENUM_NAME_Perms = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Perms))
    1: PDF_ENUM_NAME_PieceInfo = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PieceInfo))
    1: PDF_ENUM_NAME_PolyLine = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PolyLine))
    1: PDF_ENUM_NAME_PolyLineDimension = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PolyLineDimension))
    1: PDF_ENUM_NAME_Polygon = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Polygon))
    1: PDF_ENUM_NAME_PolygonCloud = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PolygonCloud))
    1: PDF_ENUM_NAME_PolygonDimension = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PolygonDimension))
    1: PDF_ENUM_NAME_Popup = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Popup))
    1: PDF_ENUM_NAME_PreRelease = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PreRelease))
    1: PDF_ENUM_NAME_Predictor = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Predictor))
    1: PDF_ENUM_NAME_Prev = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Prev))
    1: PDF_ENUM_NAME_PrevPage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PrevPage))
    1: PDF_ENUM_NAME_Preview = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Preview))
    1: PDF_ENUM_NAME_Print = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Print))
    1: PDF_ENUM_NAME_PrinterMark = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PrinterMark))
    1: PDF_ENUM_NAME_Private = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Private))
    1: PDF_ENUM_NAME_ProcSet = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ProcSet))
    1: PDF_ENUM_NAME_Producer = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Producer))
    1: PDF_ENUM_NAME_Prop_AuthTime = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Prop_AuthTime))
    1: PDF_ENUM_NAME_Prop_AuthType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Prop_AuthType))
    1: PDF_ENUM_NAME_Prop_Build = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Prop_Build))
    1: PDF_ENUM_NAME_Properties = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Properties))
    1: PDF_ENUM_NAME_PubSec = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PubSec))
    1: PDF_ENUM_NAME_Push = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Push))
    1: PDF_ENUM_NAME_Q = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Q))
    1: PDF_ENUM_NAME_QuadPoints = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_QuadPoints))
    1: PDF_ENUM_NAME_Quote = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Quote))
    1: PDF_ENUM_NAME_R = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_R))
    1: PDF_ENUM_NAME_RB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RB))
    1: PDF_ENUM_NAME_RBGroups = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RBGroups))
    1: PDF_ENUM_NAME_RC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RC))
    1: PDF_ENUM_NAME_RClosedArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RClosedArrow))
    1: PDF_ENUM_NAME_RD = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RD))
    1: PDF_ENUM_NAME_REx = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_REx))
    1: PDF_ENUM_NAME_RGB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RGB))
    1: PDF_ENUM_NAME_RI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RI))
    1: PDF_ENUM_NAME_RL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RL))
    1: PDF_ENUM_NAME_RO = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RO))
    1: PDF_ENUM_NAME_ROpenArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ROpenArrow))
    1: PDF_ENUM_NAME_RP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RP))
    1: PDF_ENUM_NAME_RT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RT))
    1: PDF_ENUM_NAME_RV = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RV))
    1: PDF_ENUM_NAME_Range = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Range))
    1: PDF_ENUM_NAME_Reason = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Reason))
    1: PDF_ENUM_NAME_Rect = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Rect))
    1: PDF_ENUM_NAME_Redact = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Redact))
    1: PDF_ENUM_NAME_Ref = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ref))
    1: PDF_ENUM_NAME_Reference = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Reference))
    1: PDF_ENUM_NAME_Registry = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Registry))
    1: PDF_ENUM_NAME_RelativeColorimetric = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RelativeColorimetric))
    1: PDF_ENUM_NAME_ResetForm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ResetForm))
    1: PDF_ENUM_NAME_Resources = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Resources))
    1: PDF_ENUM_NAME_RoleMap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RoleMap))
    1: PDF_ENUM_NAME_Root = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Root))
    1: PDF_ENUM_NAME_Rotate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Rotate))
    1: PDF_ENUM_NAME_Rows = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Rows))
    1: PDF_ENUM_NAME_Ruby = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ruby))
    1: PDF_ENUM_NAME_RunLengthDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RunLengthDecode))
    1: PDF_ENUM_NAME_S = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_S))
    1: PDF_ENUM_NAME_SMask = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SMask))
    1: PDF_ENUM_NAME_SMaskInData = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SMaskInData))
    1: PDF_ENUM_NAME_Saturation = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Saturation))
    1: PDF_ENUM_NAME_Schema = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Schema))
    1: PDF_ENUM_NAME_Screen = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Screen))
    1: PDF_ENUM_NAME_Sect = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sect))
    1: PDF_ENUM_NAME_Separation = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Separation))
    1: PDF_ENUM_NAME_Shading = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Shading))
    1: PDF_ENUM_NAME_ShadingType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ShadingType))
    1: PDF_ENUM_NAME_Si = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Si))
    1: PDF_ENUM_NAME_Sig = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sig))
    1: PDF_ENUM_NAME_SigFlags = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SigFlags))
    1: PDF_ENUM_NAME_SigQ = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SigQ))
    1: PDF_ENUM_NAME_SigRef = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SigRef))
    1: PDF_ENUM_NAME_Size = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Size))
    1: PDF_ENUM_NAME_Slash = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Slash))
    1: PDF_ENUM_NAME_Sold = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sold))
    1: PDF_ENUM_NAME_Sound = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sound))
    1: PDF_ENUM_NAME_Source = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Source))
    1: PDF_ENUM_NAME_Span = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Span))
    1: PDF_ENUM_NAME_Split = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Split))
    1: PDF_ENUM_NAME_Square = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Square))
    1: PDF_ENUM_NAME_Squiggly = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Squiggly))
    1: PDF_ENUM_NAME_St = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_St))
    1: PDF_ENUM_NAME_Stamp = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Stamp))
    1: PDF_ENUM_NAME_StampImage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StampImage))
    1: PDF_ENUM_NAME_StampSnapshot = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StampSnapshot))
    1: PDF_ENUM_NAME_Standard = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Standard))
    1: PDF_ENUM_NAME_StdCF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StdCF))
    1: PDF_ENUM_NAME_StemV = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StemV))
    1: PDF_ENUM_NAME_StmF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StmF))
    1: PDF_ENUM_NAME_StrF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StrF))
    1: PDF_ENUM_NAME_StrikeOut = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StrikeOut))
    1: PDF_ENUM_NAME_Strong = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Strong))
    1: PDF_ENUM_NAME_StructParent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StructParent))
    1: PDF_ENUM_NAME_StructParents = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StructParents))
    1: PDF_ENUM_NAME_StructTreeRoot = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StructTreeRoot))
    1: PDF_ENUM_NAME_Sub = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sub))
    1: PDF_ENUM_NAME_SubFilter = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SubFilter))
    1: PDF_ENUM_NAME_Subject = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Subject))
    1: PDF_ENUM_NAME_Subtype = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Subtype))
    1: PDF_ENUM_NAME_Subtype2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Subtype2))
    1: PDF_ENUM_NAME_Supplement = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Supplement))
    1: PDF_ENUM_NAME_Symb = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Symb))
    1: PDF_ENUM_NAME_T = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_T))
    1: PDF_ENUM_NAME_TBody = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TBody))
    1: PDF_ENUM_NAME_TD = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TD))
    1: PDF_ENUM_NAME_TFoot = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TFoot))
    1: PDF_ENUM_NAME_TH = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TH))
    1: PDF_ENUM_NAME_THead = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_THead))
    1: PDF_ENUM_NAME_TI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TI))
    1: PDF_ENUM_NAME_TOC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TOC))
    1: PDF_ENUM_NAME_TOCI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TOCI))
    1: PDF_ENUM_NAME_TR = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TR))
    1: PDF_ENUM_NAME_TR2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TR2))
    1: PDF_ENUM_NAME_TU = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TU))
    1: PDF_ENUM_NAME_Table = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Table))
    1: PDF_ENUM_NAME_Text = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Text))
    1: PDF_ENUM_NAME_Thumb = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Thumb))
    1: PDF_ENUM_NAME_TilingType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TilingType))
    1: PDF_ENUM_NAME_Times = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Times))
    1: PDF_ENUM_NAME_Title = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Title))
    1: PDF_ENUM_NAME_ToUnicode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ToUnicode))
    1: PDF_ENUM_NAME_Top = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Top))
    1: PDF_ENUM_NAME_TopSecret = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TopSecret))
    1: PDF_ENUM_NAME_Trans = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Trans))
    1: PDF_ENUM_NAME_TransformMethod = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TransformMethod))
    1: PDF_ENUM_NAME_TransformParams = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TransformParams))
    1: PDF_ENUM_NAME_Transparency = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Transparency))
    1: PDF_ENUM_NAME_TrapNet = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TrapNet))
    1: PDF_ENUM_NAME_TrimBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TrimBox))
    1: PDF_ENUM_NAME_TrueType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TrueType))
    1: PDF_ENUM_NAME_TrustedMode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TrustedMode))
    1: PDF_ENUM_NAME_Tx = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Tx))
    1: PDF_ENUM_NAME_Type = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type))
    1: PDF_ENUM_NAME_Type0 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type0))
    1: PDF_ENUM_NAME_Type1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type1))
    1: PDF_ENUM_NAME_Type1C = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type1C))
    1: PDF_ENUM_NAME_Type3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type3))
    1: PDF_ENUM_NAME_U = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_U))
    1: PDF_ENUM_NAME_UE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UE))
    1: PDF_ENUM_NAME_UF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UF))
    1: PDF_ENUM_NAME_URI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_URI))
    1: PDF_ENUM_NAME_URL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_URL))
    1: PDF_ENUM_NAME_Unchanged = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Unchanged))
    1: PDF_ENUM_NAME_Uncover = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Uncover))
    1: PDF_ENUM_NAME_Underline = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Underline))
    1: PDF_ENUM_NAME_Unix = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Unix))
    1: PDF_ENUM_NAME_Unspecified = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Unspecified))
    1: PDF_ENUM_NAME_Usage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Usage))
    1: PDF_ENUM_NAME_UseBlackPtComp = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UseBlackPtComp))
    1: PDF_ENUM_NAME_UseCMap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UseCMap))
    1: PDF_ENUM_NAME_UseOutlines = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UseOutlines))
    1: PDF_ENUM_NAME_UserUnit = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UserUnit))
    1: PDF_ENUM_NAME_V = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_V))
    1: PDF_ENUM_NAME_V2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_V2))
    1: PDF_ENUM_NAME_VE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_VE))
    1: PDF_ENUM_NAME_Version = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Version))
    1: PDF_ENUM_NAME_Vertices = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Vertices))
    1: PDF_ENUM_NAME_VerticesPerRow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_VerticesPerRow))
    1: PDF_ENUM_NAME_View = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_View))
    1: PDF_ENUM_NAME_W = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_W))
    1: PDF_ENUM_NAME_W2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_W2))
    1: PDF_ENUM_NAME_WMode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WMode))
    1: PDF_ENUM_NAME_WP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WP))
    1: PDF_ENUM_NAME_WT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WT))
    1: PDF_ENUM_NAME_Warichu = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Warichu))
    1: PDF_ENUM_NAME_Watermark = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Watermark))
    1: PDF_ENUM_NAME_WhitePoint = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WhitePoint))
    1: PDF_ENUM_NAME_Widget = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Widget))
    1: PDF_ENUM_NAME_Width = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Width))
    1: PDF_ENUM_NAME_Widths = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Widths))
    1: PDF_ENUM_NAME_WinAnsiEncoding = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WinAnsiEncoding))
    1: PDF_ENUM_NAME_Wipe = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Wipe))
    1: PDF_ENUM_NAME_XFA = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XFA))
    1: PDF_ENUM_NAME_XHeight = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XHeight))
    1: PDF_ENUM_NAME_XML = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XML))
    1: PDF_ENUM_NAME_XObject = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XObject))
    1: PDF_ENUM_NAME_XRef = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XRef))
    1: PDF_ENUM_NAME_XRefStm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XRefStm))
    1: PDF_ENUM_NAME_XStep = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XStep))
    1: PDF_ENUM_NAME_XYZ = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XYZ))
    1: PDF_ENUM_NAME_YStep = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_YStep))
    1: PDF_ENUM_NAME_Yes = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Yes))
    1: PDF_ENUM_NAME_ZaDb = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ZaDb))
    1: PDF_ENUM_NAME_a = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_a))
    1: PDF_ENUM_NAME_adbe_pkcs7_detached = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_adbe_pkcs7_detached))
    1: PDF_ENUM_NAME_ca = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ca))
    1: PDF_ENUM_NAME_n0 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_n0))
    1: PDF_ENUM_NAME_n1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_n1))
    1: PDF_ENUM_NAME_n2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_n2))
    1: PDF_ENUM_NAME_op = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_op))
    1: PDF_ENUM_NAME_r = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_r))
    1: PDF_NULL = PdfObj( obj_enum_to_obj( PDF_ENUM_NULL))
    1: PDF_TRUE = PdfObj( obj_enum_to_obj( PDF_ENUM_TRUE))
    1: PDF_FALSE = PdfObj( obj_enum_to_obj( PDF_ENUM_FALSE))
