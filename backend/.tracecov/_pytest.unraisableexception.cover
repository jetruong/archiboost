    1: from __future__ import annotations
       
    1: import collections
    1: from collections.abc import Callable
    1: import functools
    1: import gc
    1: import sys
    1: import traceback
    1: from typing import NamedTuple
    1: from typing import TYPE_CHECKING
    1: import warnings
       
    1: from _pytest.config import Config
    1: from _pytest.nodes import Item
    1: from _pytest.stash import StashKey
    1: from _pytest.tracemalloc import tracemalloc_message
    1: import pytest
       
       
    1: if TYPE_CHECKING:
>>>>>>     pass
       
    1: if sys.version_info < (3, 11):
>>>>>>     from exceptiongroup import ExceptionGroup
       
       
       # This is a stash item and not a simple constant to allow pytester to override it.
    1: gc_collect_iterations_key = StashKey[int]()
       
       
    1: def gc_collect_harder(iterations: int) -> None:
    6:     for _ in range(iterations):
    5:         gc.collect()
       
       
    2: class UnraisableMeta(NamedTuple):
    1:     msg: str
    1:     cause_msg: str
    1:     exc_value: BaseException | None
       
       
    1: unraisable_exceptions: StashKey[collections.deque[UnraisableMeta | BaseException]] = (
    1:     StashKey()
       )
       
       
    1: def collect_unraisable(config: Config) -> None:
  268:     pop_unraisable = config.stash[unraisable_exceptions].pop
  268:     errors: list[pytest.PytestUnraisableExceptionWarning | RuntimeError] = []
  268:     meta = None
  268:     hook_error = None
  268:     try:
  268:         while True:
  268:             try:
  268:                 meta = pop_unraisable()
  268:             except IndexError:
  268:                 break
       
>>>>>>             if isinstance(meta, BaseException):
>>>>>>                 hook_error = RuntimeError("Failed to process unraisable exception")
>>>>>>                 hook_error.__cause__ = meta
>>>>>>                 errors.append(hook_error)
>>>>>>                 continue
       
>>>>>>             msg = meta.msg
>>>>>>             try:
>>>>>>                 warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
>>>>>>             except pytest.PytestUnraisableExceptionWarning as e:
                       # This except happens when the warning is treated as an error (e.g. `-Werror`).
>>>>>>                 if meta.exc_value is not None:
                           # Exceptions have a better way to show the traceback, but
                           # warnings do not, so hide the traceback from the msg and
                           # set the cause so the traceback shows up in the right place.
>>>>>>                     e.args = (meta.cause_msg,)
>>>>>>                     e.__cause__ = meta.exc_value
>>>>>>                 errors.append(e)
       
  268:         if len(errors) == 1:
>>>>>>             raise errors[0]
  268:         if errors:
>>>>>>             raise ExceptionGroup("multiple unraisable exception warnings", errors)
           finally:
  268:         del errors, meta, hook_error
       
       
    4: def cleanup(
    2:     *, config: Config, prev_hook: Callable[[sys.UnraisableHookArgs], object]
    1: ) -> None:
           # A single collection doesn't necessarily collect everything.
           # Constant determined experimentally by the Trio project.
    1:     gc_collect_iterations = config.stash.get(gc_collect_iterations_key, 5)
    1:     try:
    1:         try:
    1:             gc_collect_harder(gc_collect_iterations)
    1:             collect_unraisable(config)
               finally:
    1:             sys.unraisablehook = prev_hook
           finally:
    1:         del config.stash[unraisable_exceptions]
       
       
    4: def unraisable_hook(
    1:     unraisable: sys.UnraisableHookArgs,
           /,
           *,
    1:     append: Callable[[UnraisableMeta | BaseException], object],
    1: ) -> None:
>>>>>>     try:
               # we need to compute these strings here as they might change after
               # the unraisablehook finishes and before the metadata object is
               # collected by a pytest hook
>>>>>>         err_msg = (
>>>>>>             "Exception ignored in" if unraisable.err_msg is None else unraisable.err_msg
               )
>>>>>>         summary = f"{err_msg}: {unraisable.object!r}"
>>>>>>         traceback_message = "\n\n" + "".join(
>>>>>>             traceback.format_exception(
>>>>>>                 unraisable.exc_type,
>>>>>>                 unraisable.exc_value,
>>>>>>                 unraisable.exc_traceback,
                   )
               )
>>>>>>         tracemalloc_tb = "\n" + tracemalloc_message(unraisable.object)
>>>>>>         msg = summary + traceback_message + tracemalloc_tb
>>>>>>         cause_msg = summary + tracemalloc_tb
       
>>>>>>         append(
>>>>>>             UnraisableMeta(
>>>>>>                 msg=msg,
>>>>>>                 cause_msg=cause_msg,
>>>>>>                 exc_value=unraisable.exc_value,
                   )
               )
>>>>>>     except BaseException as e:
>>>>>>         append(e)
               # Raising this will cause the exception to be logged twice, once in our
               # collect_unraisable and once by the unraisablehook calling machinery
               # which is fine - this should never happen anyway and if it does
               # it should probably be reported as a pytest bug.
>>>>>>         raise
       
       
    1: def pytest_configure(config: Config) -> None:
    1:     prev_hook = sys.unraisablehook
    1:     deque: collections.deque[UnraisableMeta | BaseException] = collections.deque()
    1:     config.stash[unraisable_exceptions] = deque
    1:     config.add_cleanup(functools.partial(cleanup, config=config, prev_hook=prev_hook))
    1:     sys.unraisablehook = functools.partial(unraisable_hook, append=deque.append)
       
       
    2: @pytest.hookimpl(trylast=True)
    2: def pytest_runtest_setup(item: Item) -> None:
   89:     collect_unraisable(item.config)
       
       
    2: @pytest.hookimpl(trylast=True)
    2: def pytest_runtest_call(item: Item) -> None:
   89:     collect_unraisable(item.config)
       
       
    2: @pytest.hookimpl(trylast=True)
    2: def pytest_runtest_teardown(item: Item) -> None:
   89:     collect_unraisable(item.config)
