    1: import io
    1: import logging
    1: import os
    1: import pathlib
    1: import shutil
    1: import stat
    1: import sys
    1: import tempfile
    1: from collections import OrderedDict
    1: from contextlib import contextmanager
    1: from typing import IO, Dict, Iterable, Iterator, Mapping, Optional, Tuple, Union
       
    1: from .parser import Binding, parse_stream
    1: from .variables import parse_variables
       
       # A type alias for a string path to be used for the paths in this file.
       # These paths may flow to `open()` and `shutil.move()`; `shutil.move()`
       # only accepts string paths, not byte paths or file descriptors. See
       # https://github.com/python/typeshed/pull/6832.
    1: StrPath = Union[str, "os.PathLike[str]"]
       
    1: logger = logging.getLogger(__name__)
       
       
    1: def _load_dotenv_disabled() -> bool:
           """
           Determine if dotenv loading has been disabled.
           """
>>>>>>     if "PYTHON_DOTENV_DISABLED" not in os.environ:
>>>>>>         return False
>>>>>>     value = os.environ["PYTHON_DOTENV_DISABLED"].casefold()
>>>>>>     return value in {"1", "true", "t", "yes", "y"}
       
       
    1: def with_warn_for_invalid_lines(mappings: Iterator[Binding]) -> Iterator[Binding]:
    4:     for mapping in mappings:
    3:         if mapping.error:
>>>>>>             logger.warning(
>>>>>>                 "python-dotenv could not parse statement starting at line %s",
>>>>>>                 mapping.original.line,
                   )
    3:         yield mapping
       
       
    2: class DotEnv:
    8:     def __init__(
               self,
    1:         dotenv_path: Optional[StrPath],
    2:         stream: Optional[IO[str]] = None,
    2:         verbose: bool = False,
    2:         encoding: Optional[str] = None,
    2:         interpolate: bool = True,
    2:         override: bool = True,
    1:     ) -> None:
    1:         self.dotenv_path: Optional[StrPath] = dotenv_path
    1:         self.stream: Optional[IO[str]] = stream
    1:         self._dict: Optional[Dict[str, Optional[str]]] = None
    1:         self.verbose: bool = verbose
    1:         self.encoding: Optional[str] = encoding
    1:         self.interpolate: bool = interpolate
    1:         self.override: bool = override
       
    2:     @contextmanager
    2:     def _get_stream(self) -> Iterator[IO[str]]:
    1:         if self.dotenv_path and _is_file_or_fifo(self.dotenv_path):
    2:             with open(self.dotenv_path, encoding=self.encoding) as stream:
    1:                 yield stream
>>>>>>         elif self.stream is not None:
>>>>>>             yield self.stream
               else:
>>>>>>             if self.verbose:
>>>>>>                 logger.info(
>>>>>>                     "python-dotenv could not find configuration file %s.",
>>>>>>                     self.dotenv_path or ".env",
                       )
>>>>>>             yield io.StringIO("")
       
    1:     def dict(self) -> Dict[str, Optional[str]]:
               """Return dotenv as dict"""
    1:         if self._dict:
>>>>>>             return self._dict
       
    1:         raw_values = self.parse()
       
    1:         if self.interpolate:
    2:             self._dict = OrderedDict(
    1:                 resolve_variables(raw_values, override=self.override)
                   )
               else:
>>>>>>             self._dict = OrderedDict(raw_values)
       
    1:         return self._dict
       
    1:     def parse(self) -> Iterator[Tuple[str, Optional[str]]]:
    2:         with self._get_stream() as stream:
    4:             for mapping in with_warn_for_invalid_lines(parse_stream(stream)):
    3:                 if mapping.key is not None:
    3:                     yield mapping.key, mapping.value
       
    1:     def set_as_environment_variables(self) -> bool:
               """
               Load the current dotenv as system environment variable.
               """
>>>>>>         if not self.dict():
>>>>>>             return False
       
>>>>>>         for k, v in self.dict().items():
>>>>>>             if k in os.environ and not self.override:
>>>>>>                 continue
>>>>>>             if v is not None:
>>>>>>                 os.environ[k] = v
       
>>>>>>         return True
       
    1:     def get(self, key: str) -> Optional[str]:
               """ """
>>>>>>         data = self.dict()
       
>>>>>>         if key in data:
>>>>>>             return data[key]
       
>>>>>>         if self.verbose:
>>>>>>             logger.warning("Key %s not found in %s.", key, self.dotenv_path)
       
>>>>>>         return None
       
       
    5: def get_key(
    1:     dotenv_path: StrPath,
    1:     key_to_get: str,
    2:     encoding: Optional[str] = "utf-8",
    1: ) -> Optional[str]:
           """
           Get the value of a given key from the given .env.
       
           Returns `None` if the key isn't found or doesn't have a value.
           """
>>>>>>     return DotEnv(dotenv_path, verbose=True, encoding=encoding).get(key_to_get)
       
       
    2: @contextmanager
    5: def rewrite(
    1:     path: StrPath,
    1:     encoding: Optional[str],
    1: ) -> Iterator[Tuple[IO[str], IO[str]]]:
>>>>>>     pathlib.Path(path).touch()
       
>>>>>>     with tempfile.NamedTemporaryFile(mode="w", encoding=encoding, delete=False) as dest:
>>>>>>         error = None
>>>>>>         try:
>>>>>>             with open(path, encoding=encoding) as source:
>>>>>>                 yield (source, dest)
>>>>>>         except BaseException as err:
>>>>>>             error = err
       
>>>>>>     if error is None:
>>>>>>         shutil.move(dest.name, path)
           else:
>>>>>>         os.unlink(dest.name)
>>>>>>         raise error from None
       
       
    8: def set_key(
    1:     dotenv_path: StrPath,
    1:     key_to_set: str,
    1:     value_to_set: str,
    2:     quote_mode: str = "always",
    2:     export: bool = False,
    2:     encoding: Optional[str] = "utf-8",
    1: ) -> Tuple[Optional[bool], str, str]:
           """
           Adds or Updates a key/value to the given .env
       
           If the .env path given doesn't exist, fails instead of risking creating
           an orphan .env somewhere in the filesystem
           """
>>>>>>     if quote_mode not in ("always", "auto", "never"):
>>>>>>         raise ValueError(f"Unknown quote_mode: {quote_mode}")
       
>>>>>>     quote = quote_mode == "always" or (
>>>>>>         quote_mode == "auto" and not value_to_set.isalnum()
           )
       
>>>>>>     if quote:
>>>>>>         value_out = "'{}'".format(value_to_set.replace("'", "\\'"))
           else:
>>>>>>         value_out = value_to_set
>>>>>>     if export:
>>>>>>         line_out = f"export {key_to_set}={value_out}\n"
           else:
>>>>>>         line_out = f"{key_to_set}={value_out}\n"
       
>>>>>>     with rewrite(dotenv_path, encoding=encoding) as (source, dest):
>>>>>>         replaced = False
>>>>>>         missing_newline = False
>>>>>>         for mapping in with_warn_for_invalid_lines(parse_stream(source)):
>>>>>>             if mapping.key == key_to_set:
>>>>>>                 dest.write(line_out)
>>>>>>                 replaced = True
                   else:
>>>>>>                 dest.write(mapping.original.string)
>>>>>>                 missing_newline = not mapping.original.string.endswith("\n")
>>>>>>         if not replaced:
>>>>>>             if missing_newline:
>>>>>>                 dest.write("\n")
>>>>>>             dest.write(line_out)
       
>>>>>>     return True, key_to_set, value_to_set
       
       
    6: def unset_key(
    1:     dotenv_path: StrPath,
    1:     key_to_unset: str,
    2:     quote_mode: str = "always",
    2:     encoding: Optional[str] = "utf-8",
    1: ) -> Tuple[Optional[bool], str]:
           """
           Removes a given key from the given `.env` file.
       
           If the .env path given doesn't exist, fails.
           If the given key doesn't exist in the .env, fails.
           """
>>>>>>     if not os.path.exists(dotenv_path):
>>>>>>         logger.warning("Can't delete from %s - it doesn't exist.", dotenv_path)
>>>>>>         return None, key_to_unset
       
>>>>>>     removed = False
>>>>>>     with rewrite(dotenv_path, encoding=encoding) as (source, dest):
>>>>>>         for mapping in with_warn_for_invalid_lines(parse_stream(source)):
>>>>>>             if mapping.key == key_to_unset:
>>>>>>                 removed = True
                   else:
>>>>>>                 dest.write(mapping.original.string)
       
>>>>>>     if not removed:
>>>>>>         logger.warning(
>>>>>>             "Key %s not removed from %s - key doesn't exist.", key_to_unset, dotenv_path
               )
>>>>>>         return None, key_to_unset
       
>>>>>>     return removed, key_to_unset
       
       
    4: def resolve_variables(
    1:     values: Iterable[Tuple[str, Optional[str]]],
    1:     override: bool,
    1: ) -> Mapping[str, Optional[str]]:
    1:     new_values: Dict[str, Optional[str]] = {}
       
    4:     for name, value in values:
    3:         if value is None:
>>>>>>             result = None
               else:
    3:             atoms = parse_variables(value)
    3:             env: Dict[str, Optional[str]] = {}
    3:             if override:
    3:                 env.update(os.environ)  # type: ignore
    3:                 env.update(new_values)
                   else:
>>>>>>                 env.update(new_values)
>>>>>>                 env.update(os.environ)  # type: ignore
    9:             result = "".join(atom.resolve(env) for atom in atoms)
       
    3:         new_values[name] = result
       
    1:     return new_values
       
       
    1: def _walk_to_root(path: str) -> Iterator[str]:
           """
           Yield directories starting from the given directory up to the root
           """
>>>>>>     if not os.path.exists(path):
>>>>>>         raise IOError("Starting path not found")
       
>>>>>>     if os.path.isfile(path):
>>>>>>         path = os.path.dirname(path)
       
>>>>>>     last_dir = None
>>>>>>     current_dir = os.path.abspath(path)
>>>>>>     while last_dir != current_dir:
>>>>>>         yield current_dir
>>>>>>         parent_dir = os.path.abspath(os.path.join(current_dir, os.path.pardir))
>>>>>>         last_dir, current_dir = current_dir, parent_dir
       
       
    5: def find_dotenv(
    2:     filename: str = ".env",
    2:     raise_error_if_not_found: bool = False,
    2:     usecwd: bool = False,
    1: ) -> str:
           """
           Search in increasingly higher folders for the given file
       
           Returns path to the file if found, or an empty string otherwise
           """
       
>>>>>>     def _is_interactive():
               """Decide whether this is running in a REPL or IPython notebook"""
>>>>>>         if hasattr(sys, "ps1") or hasattr(sys, "ps2"):
>>>>>>             return True
>>>>>>         try:
>>>>>>             main = __import__("__main__", None, None, fromlist=["__file__"])
>>>>>>         except ModuleNotFoundError:
>>>>>>             return False
>>>>>>         return not hasattr(main, "__file__")
       
>>>>>>     def _is_debugger():
>>>>>>         return sys.gettrace() is not None
       
>>>>>>     if usecwd or _is_interactive() or _is_debugger() or getattr(sys, "frozen", False):
               # Should work without __file__, e.g. in REPL or IPython notebook.
>>>>>>         path = os.getcwd()
           else:
               # will work for .py files
>>>>>>         frame = sys._getframe()
>>>>>>         current_file = __file__
       
>>>>>>         while frame.f_code.co_filename == current_file or not os.path.exists(
>>>>>>             frame.f_code.co_filename
               ):
>>>>>>             assert frame.f_back is not None
>>>>>>             frame = frame.f_back
>>>>>>         frame_filename = frame.f_code.co_filename
>>>>>>         path = os.path.dirname(os.path.abspath(frame_filename))
       
>>>>>>     for dirname in _walk_to_root(path):
>>>>>>         check_path = os.path.join(dirname, filename)
>>>>>>         if _is_file_or_fifo(check_path):
>>>>>>             return check_path
       
>>>>>>     if raise_error_if_not_found:
>>>>>>         raise IOError("File not found")
       
>>>>>>     return ""
       
       
    8: def load_dotenv(
    2:     dotenv_path: Optional[StrPath] = None,
    2:     stream: Optional[IO[str]] = None,
    2:     verbose: bool = False,
    2:     override: bool = False,
    2:     interpolate: bool = True,
    2:     encoding: Optional[str] = "utf-8",
    1: ) -> bool:
           """Parse a .env file and then load all the variables found as environment variables.
       
           Parameters:
               dotenv_path: Absolute or relative path to .env file.
               stream: Text stream (such as `io.StringIO`) with .env content, used if
                   `dotenv_path` is `None`.
               verbose: Whether to output a warning the .env file is missing.
               override: Whether to override the system environment variables with the variables
                   from the `.env` file.
               encoding: Encoding to be used to read the file.
           Returns:
               Bool: True if at least one environment variable is set else False
       
           If both `dotenv_path` and `stream` are `None`, `find_dotenv()` is used to find the
           .env file with it's default parameters. If you need to change the default parameters
           of `find_dotenv()`, you can explicitly call `find_dotenv()` and pass the result
           to this function as `dotenv_path`.
       
           If the environment variable `PYTHON_DOTENV_DISABLED` is set to a truthy value,
           .env loading is disabled.
           """
>>>>>>     if _load_dotenv_disabled():
>>>>>>         logger.debug(
>>>>>>             "python-dotenv: .env loading disabled by PYTHON_DOTENV_DISABLED environment variable"
               )
>>>>>>         return False
       
>>>>>>     if dotenv_path is None and stream is None:
>>>>>>         dotenv_path = find_dotenv()
       
>>>>>>     dotenv = DotEnv(
>>>>>>         dotenv_path=dotenv_path,
>>>>>>         stream=stream,
>>>>>>         verbose=verbose,
>>>>>>         interpolate=interpolate,
>>>>>>         override=override,
>>>>>>         encoding=encoding,
           )
>>>>>>     return dotenv.set_as_environment_variables()
       
       
    7: def dotenv_values(
    2:     dotenv_path: Optional[StrPath] = None,
    2:     stream: Optional[IO[str]] = None,
    2:     verbose: bool = False,
    2:     interpolate: bool = True,
    2:     encoding: Optional[str] = "utf-8",
    1: ) -> Dict[str, Optional[str]]:
           """
           Parse a .env file and return its content as a dict.
       
           The returned dict will have `None` values for keys without values in the .env file.
           For example, `foo=bar` results in `{"foo": "bar"}` whereas `foo` alone results in
           `{"foo": None}`
       
           Parameters:
               dotenv_path: Absolute or relative path to the .env file.
               stream: `StringIO` object with .env content, used if `dotenv_path` is `None`.
               verbose: Whether to output a warning if the .env file is missing.
               encoding: Encoding to be used to read the file.
       
           If both `dotenv_path` and `stream` are `None`, `find_dotenv()` is used to find the
           .env file.
           """
    1:     if dotenv_path is None and stream is None:
>>>>>>         dotenv_path = find_dotenv()
       
    3:     return DotEnv(
    1:         dotenv_path=dotenv_path,
    1:         stream=stream,
    1:         verbose=verbose,
    1:         interpolate=interpolate,
    1:         override=True,
    1:         encoding=encoding,
    1:     ).dict()
       
       
    1: def _is_file_or_fifo(path: StrPath) -> bool:
           """
           Return True if `path` exists and is either a regular file or a FIFO.
           """
    1:     if os.path.isfile(path):
    1:         return True
       
>>>>>>     try:
>>>>>>         st = os.stat(path)
>>>>>>     except (FileNotFoundError, OSError):
>>>>>>         return False
       
>>>>>>     return stat.S_ISFIFO(st.st_mode)
