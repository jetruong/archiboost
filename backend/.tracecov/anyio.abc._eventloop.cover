    1: from __future__ import annotations
       
    1: import math
    1: import sys
    1: from abc import ABCMeta, abstractmethod
    1: from collections.abc import AsyncIterator, Awaitable, Callable, Sequence
    1: from contextlib import AbstractContextManager
    1: from os import PathLike
    1: from signal import Signals
    1: from socket import AddressFamily, SocketKind, socket
    1: from typing import (
           IO,
           TYPE_CHECKING,
           Any,
           TypeVar,
           Union,
           overload,
       )
       
    1: if sys.version_info >= (3, 11):
    1:     from typing import TypeVarTuple, Unpack
       else:
>>>>>>     from typing_extensions import TypeVarTuple, Unpack
       
    1: if sys.version_info >= (3, 10):
    1:     from typing import TypeAlias
       else:
>>>>>>     from typing_extensions import TypeAlias
       
    1: if TYPE_CHECKING:
>>>>>>     from _typeshed import FileDescriptorLike
       
>>>>>>     from .._core._synchronization import CapacityLimiter, Event, Lock, Semaphore
>>>>>>     from .._core._tasks import CancelScope
>>>>>>     from .._core._testing import TaskInfo
>>>>>>     from ._sockets import (
               ConnectedUDPSocket,
               ConnectedUNIXDatagramSocket,
               IPSockAddrType,
               SocketListener,
               SocketStream,
               UDPSocket,
               UNIXDatagramSocket,
               UNIXSocketStream,
           )
>>>>>>     from ._subprocesses import Process
>>>>>>     from ._tasks import TaskGroup
>>>>>>     from ._testing import TestRunner
       
    1: T_Retval = TypeVar("T_Retval")
    1: PosArgsT = TypeVarTuple("PosArgsT")
    1: StrOrBytesPath: TypeAlias = Union[str, bytes, "PathLike[str]", "PathLike[bytes]"]
       
       
    2: class AsyncBackend(metaclass=ABCMeta):
    2:     @classmethod
    2:     @abstractmethod
    7:     def run(
               cls,
    1:         func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval]],
    1:         args: tuple[Unpack[PosArgsT]],
    1:         kwargs: dict[str, Any],
    1:         options: dict[str, Any],
    1:     ) -> T_Retval:
               """
               Run the given coroutine function in an asynchronous event loop.
       
               The current thread must not be already running an event loop.
       
               :param func: a coroutine function
               :param args: positional arguments to ``func``
               :param kwargs: positional arguments to ``func``
               :param options: keyword arguments to call the backend ``run()`` implementation
                   with
               :return: the return value of the coroutine function
               """
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def current_token(cls) -> object:
               """
               Return an object that allows other threads to run code inside the event loop.
       
               :return: a token object, specific to the event loop running in the current
                   thread
               """
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def current_time(cls) -> float:
               """
               Return the current value of the event loop's internal clock.
       
               :return: the clock value (seconds)
               """
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def cancelled_exception_class(cls) -> type[BaseException]:
               """Return the exception class that is raised in a task if it's cancelled."""
       
    2:     @classmethod
    2:     @abstractmethod
    2:     async def checkpoint(cls) -> None:
               """
               Check if the task has been cancelled, and allow rescheduling of other tasks.
       
               This is effectively the same as running :meth:`checkpoint_if_cancelled` and then
               :meth:`cancel_shielded_checkpoint`.
               """
       
    2:     @classmethod
    2:     async def checkpoint_if_cancelled(cls) -> None:
               """
               Check if the current task group has been cancelled.
       
               This will check if the task has been cancelled, but will not allow other tasks
               to be scheduled if not.
       
               """
>>>>>>         if cls.current_effective_deadline() == -math.inf:
>>>>>>             await cls.checkpoint()
       
    2:     @classmethod
    2:     async def cancel_shielded_checkpoint(cls) -> None:
               """
               Allow the rescheduling of other tasks.
       
               This will give other tasks the opportunity to run, but without checking if the
               current task group has been cancelled, unlike with :meth:`checkpoint`.
       
               """
>>>>>>         with cls.create_cancel_scope(shield=True):
>>>>>>             await cls.sleep(0)
       
    2:     @classmethod
    2:     @abstractmethod
    2:     async def sleep(cls, delay: float) -> None:
               """
               Pause the current task for the specified duration.
       
               :param delay: the duration, in seconds
               """
       
    2:     @classmethod
    2:     @abstractmethod
    5:     def create_cancel_scope(
    3:         cls, *, deadline: float = math.inf, shield: bool = False
    1:     ) -> CancelScope:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def current_effective_deadline(cls) -> float:
               """
               Return the nearest deadline among all the cancel scopes effective for the
               current task.
       
               :return:
                   - a clock value from the event loop's internal clock
                   - ``inf`` if there is no deadline in effect
                   - ``-inf`` if the current scope has been cancelled
               :rtype: float
               """
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def create_task_group(cls) -> TaskGroup:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def create_event(cls) -> Event:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def create_lock(cls, *, fast_acquire: bool) -> Lock:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    6:     def create_semaphore(
               cls,
    1:         initial_value: int,
               *,
    2:         max_value: int | None = None,
    2:         fast_acquire: bool = False,
    1:     ) -> Semaphore:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def create_capacity_limiter(cls, total_tokens: float) -> CapacityLimiter:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    7:     async def run_sync_in_worker_thread(
               cls,
    1:         func: Callable[[Unpack[PosArgsT]], T_Retval],
    1:         args: tuple[Unpack[PosArgsT]],
    2:         abandon_on_cancel: bool = False,
    2:         limiter: CapacityLimiter | None = None,
    1:     ) -> T_Retval:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def check_cancelled(cls) -> None:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    6:     def run_async_from_thread(
               cls,
    1:         func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval]],
    1:         args: tuple[Unpack[PosArgsT]],
    1:         token: object,
    1:     ) -> T_Retval:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    6:     def run_sync_from_thread(
               cls,
    1:         func: Callable[[Unpack[PosArgsT]], T_Retval],
    1:         args: tuple[Unpack[PosArgsT]],
    1:         token: object,
    1:     ) -> T_Retval:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    8:     async def open_process(
               cls,
    1:         command: StrOrBytesPath | Sequence[StrOrBytesPath],
               *,
    1:         stdin: int | IO[Any] | None,
    1:         stdout: int | IO[Any] | None,
    1:         stderr: int | IO[Any] | None,
    1:         **kwargs: Any,
    1:     ) -> Process:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def setup_process_pool_exit_at_shutdown(cls, workers: set[Process]) -> None:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    6:     async def connect_tcp(
    4:         cls, host: str, port: int, local_address: IPSockAddrType | None = None
    1:     ) -> SocketStream:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     async def connect_unix(cls, path: str | bytes) -> UNIXSocketStream:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def create_tcp_listener(cls, sock: socket) -> SocketListener:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def create_unix_listener(cls, sock: socket) -> SocketListener:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    7:     async def create_udp_socket(
               cls,
    1:         family: AddressFamily,
    1:         local_address: IPSockAddrType | None,
    1:         remote_address: IPSockAddrType | None,
    1:         reuse_port: bool,
    1:     ) -> UDPSocket | ConnectedUDPSocket:
>>>>>>         pass
       
    2:     @classmethod
    2:     @overload
    5:     async def create_unix_datagram_socket(
    2:         cls, raw_socket: socket, remote_path: None
    1:     ) -> UNIXDatagramSocket: ...
       
    2:     @classmethod
    2:     @overload
    5:     async def create_unix_datagram_socket(
    2:         cls, raw_socket: socket, remote_path: str | bytes
    1:     ) -> ConnectedUNIXDatagramSocket: ...
       
    2:     @classmethod
    2:     @abstractmethod
    5:     async def create_unix_datagram_socket(
    2:         cls, raw_socket: socket, remote_path: str | bytes | None
    1:     ) -> UNIXDatagramSocket | ConnectedUNIXDatagramSocket:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    9:     async def getaddrinfo(
               cls,
    1:         host: bytes | str | None,
    1:         port: str | int | None,
               *,
    2:         family: int | AddressFamily = 0,
    2:         type: int | SocketKind = 0,
    2:         proto: int = 0,
    2:         flags: int = 0,
    1:     ) -> Sequence[
               tuple[
                   AddressFamily,
                   SocketKind,
                   int,
                   str,
                   tuple[str, int] | tuple[str, int, int, int] | tuple[int, bytes],
               ]
           ]:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    5:     async def getnameinfo(
    3:         cls, sockaddr: IPSockAddrType, flags: int = 0
    1:     ) -> tuple[str, str]:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     async def wait_readable(cls, obj: FileDescriptorLike) -> None:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     async def wait_writable(cls, obj: FileDescriptorLike) -> None:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def notify_closing(cls, obj: FileDescriptorLike) -> None:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     async def wrap_listener_socket(cls, sock: socket) -> SocketListener:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     async def wrap_stream_socket(cls, sock: socket) -> SocketStream:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     async def wrap_unix_stream_socket(cls, sock: socket) -> UNIXSocketStream:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     async def wrap_udp_socket(cls, sock: socket) -> UDPSocket:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     async def wrap_connected_udp_socket(cls, sock: socket) -> ConnectedUDPSocket:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     async def wrap_unix_datagram_socket(cls, sock: socket) -> UNIXDatagramSocket:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    4:     async def wrap_connected_unix_datagram_socket(
    1:         cls, sock: socket
    1:     ) -> ConnectedUNIXDatagramSocket:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def current_default_thread_limiter(cls) -> CapacityLimiter:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    4:     def open_signal_receiver(
    1:         cls, *signals: Signals
    1:     ) -> AbstractContextManager[AsyncIterator[Signals]]:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def get_current_task(cls) -> TaskInfo:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def get_running_tasks(cls) -> Sequence[TaskInfo]:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     async def wait_all_tasks_blocked(cls) -> None:
>>>>>>         pass
       
    2:     @classmethod
    2:     @abstractmethod
    2:     def create_test_runner(cls, options: dict[str, Any]) -> TestRunner:
>>>>>>         pass
