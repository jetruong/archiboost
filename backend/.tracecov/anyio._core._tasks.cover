    1: from __future__ import annotations
       
    1: import math
    1: from collections.abc import Generator
    1: from contextlib import contextmanager
    1: from types import TracebackType
       
    1: from ..abc._tasks import TaskGroup, TaskStatus
    1: from ._eventloop import get_async_backend
       
       
    2: class _IgnoredTaskStatus(TaskStatus[object]):
    1:     def started(self, value: object = None) -> None:
>>>>>>         pass
       
       
    1: TASK_STATUS_IGNORED = _IgnoredTaskStatus()
       
       
    2: class CancelScope:
    1:     """
           Wraps a unit of work that can be made separately cancellable.
       
           :param deadline: The time (clock value) when this scope is cancelled automatically
           :param shield: ``True`` to shield the cancel scope from external cancellation
           :raises NoEventLoopError: if no supported asynchronous event loop is running in the
               current thread
           """
       
    4:     def __new__(
    3:         cls, *, deadline: float = math.inf, shield: bool = False
    1:     ) -> CancelScope:
   18:         return get_async_backend().create_cancel_scope(shield=shield, deadline=deadline)
       
    1:     def cancel(self, reason: str | None = None) -> None:
               """
               Cancel this scope immediately.
       
               :param reason: a message describing the reason for the cancellation
       
               """
>>>>>>         raise NotImplementedError
       
    2:     @property
    2:     def deadline(self) -> float:
               """
               The time (clock value) when this scope is cancelled automatically.
       
               Will be ``float('inf')`` if no timeout has been set.
       
               """
>>>>>>         raise NotImplementedError
       
    2:     @deadline.setter
    2:     def deadline(self, value: float) -> None:
>>>>>>         raise NotImplementedError
       
    2:     @property
    2:     def cancel_called(self) -> bool:
               """``True`` if :meth:`cancel` has been called."""
>>>>>>         raise NotImplementedError
       
    2:     @property
    2:     def cancelled_caught(self) -> bool:
               """
               ``True`` if this scope suppressed a cancellation exception it itself raised.
       
               This is typically used to check if any work was interrupted, or to see if the
               scope was cancelled due to its deadline being reached. The value will, however,
               only be ``True`` if the cancellation was triggered by the scope itself (and not
               an outer scope).
       
               """
>>>>>>         raise NotImplementedError
       
    2:     @property
    2:     def shield(self) -> bool:
               """
               ``True`` if this scope is shielded from external cancellation.
       
               While a scope is shielded, it will not receive cancellations from outside.
       
               """
>>>>>>         raise NotImplementedError
       
    2:     @shield.setter
    2:     def shield(self, value: bool) -> None:
>>>>>>         raise NotImplementedError
       
    1:     def __enter__(self) -> CancelScope:
>>>>>>         raise NotImplementedError
       
    5:     def __exit__(
               self,
    1:         exc_type: type[BaseException] | None,
    1:         exc_val: BaseException | None,
    1:         exc_tb: TracebackType | None,
    1:     ) -> bool:
>>>>>>         raise NotImplementedError
       
       
    2: @contextmanager
    5: def fail_after(
    3:     delay: float | None, shield: bool = False
    1: ) -> Generator[CancelScope, None, None]:
           """
           Create a context manager which raises a :class:`TimeoutError` if does not finish in
           time.
       
           :param delay: maximum allowed time (in seconds) before raising the exception, or
               ``None`` to disable the timeout
           :param shield: ``True`` to shield the cancel scope from external cancellation
           :return: a context manager that yields a cancel scope
           :rtype: :class:`~typing.ContextManager`\\[:class:`~anyio.CancelScope`\\]
           :raises NoEventLoopError: if no supported asynchronous event loop is running in the
               current thread
       
           """
>>>>>>     current_time = get_async_backend().current_time
>>>>>>     deadline = (current_time() + delay) if delay is not None else math.inf
>>>>>>     with get_async_backend().create_cancel_scope(
>>>>>>         deadline=deadline, shield=shield
>>>>>>     ) as cancel_scope:
>>>>>>         yield cancel_scope
       
>>>>>>     if cancel_scope.cancelled_caught and current_time() >= cancel_scope.deadline:
>>>>>>         raise TimeoutError
       
       
    1: def move_on_after(delay: float | None, shield: bool = False) -> CancelScope:
           """
           Create a cancel scope with a deadline that expires after the given delay.
       
           :param delay: maximum allowed time (in seconds) before exiting the context block, or
               ``None`` to disable the timeout
           :param shield: ``True`` to shield the cancel scope from external cancellation
           :return: a cancel scope
           :raises NoEventLoopError: if no supported asynchronous event loop is running in the
               current thread
       
           """
>>>>>>     deadline = (
>>>>>>         (get_async_backend().current_time() + delay) if delay is not None else math.inf
           )
>>>>>>     return get_async_backend().create_cancel_scope(deadline=deadline, shield=shield)
       
       
    1: def current_effective_deadline() -> float:
           """
           Return the nearest deadline among all the cancel scopes effective for the current
           task.
       
           :return: a clock value from the event loop's internal clock (or ``float('inf')`` if
               there is no deadline in effect, or ``float('-inf')`` if the current scope has
               been cancelled)
           :rtype: float
           :raises NoEventLoopError: if no supported asynchronous event loop is running in the
               current thread
       
           """
>>>>>>     return get_async_backend().current_effective_deadline()
       
       
    1: def create_task_group() -> TaskGroup:
           """
           Create a task group.
       
           :return: a task group
           :raises NoEventLoopError: if no supported asynchronous event loop is running in the
               current thread
       
           """
    9:     return get_async_backend().create_task_group()
