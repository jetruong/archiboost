    1: from __future__ import annotations
       
    1: import importlib.metadata as importlib_metadata
    1: import os
    1: import warnings
    1: from collections.abc import Iterable
    1: from typing import TYPE_CHECKING, Final
       
    1: if TYPE_CHECKING:
>>>>>>     from . import PydanticPluginProtocol
       
       
    1: PYDANTIC_ENTRY_POINT_GROUP: Final[str] = 'pydantic'
       
       # cache of plugins
    1: _plugins: dict[str, PydanticPluginProtocol] | None = None
       # return no plugins while loading plugins to avoid recursion and errors while import plugins
       # this means that if plugins use pydantic
    1: _loading_plugins: bool = False
       
       
    1: def get_plugins() -> Iterable[PydanticPluginProtocol]:
           """Load plugins for Pydantic.
       
           Inspired by: https://github.com/pytest-dev/pluggy/blob/1.3.0/src/pluggy/_manager.py#L376-L402
           """
  235:     disabled_plugins = os.getenv('PYDANTIC_DISABLE_PLUGINS')
           global _plugins, _loading_plugins
  235:     if _loading_plugins:
               # this happens when plugins themselves use pydantic, we return no plugins
>>>>>>         return ()
  235:     elif disabled_plugins in ('__all__', '1', 'true'):
>>>>>>         return ()
  235:     elif _plugins is None:
    1:         _plugins = {}
               # set _loading_plugins so any plugins that use pydantic don't themselves use plugins
    1:         _loading_plugins = True
    1:         try:
   63:             for dist in importlib_metadata.distributions():
   88:                 for entry_point in dist.entry_points:
   26:                     if entry_point.group != PYDANTIC_ENTRY_POINT_GROUP:
   26:                         continue
>>>>>>                     if entry_point.value in _plugins:
>>>>>>                         continue
>>>>>>                     if disabled_plugins is not None and entry_point.name in disabled_plugins.split(','):
>>>>>>                         continue
>>>>>>                     try:
>>>>>>                         _plugins[entry_point.value] = entry_point.load()
>>>>>>                     except (ImportError, AttributeError) as e:
>>>>>>                         warnings.warn(
>>>>>>                             f'{e.__class__.__name__} while loading the `{entry_point.name}` Pydantic plugin, '
>>>>>>                             f'this plugin will not be installed.\n\n{e!r}',
>>>>>>                             stacklevel=2,
                               )
               finally:
    1:             _loading_plugins = False
       
  235:     return _plugins.values()
