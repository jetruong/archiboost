    1: from __future__ import annotations
       
    1: import collections
    1: from collections.abc import Callable
    1: import functools
    1: import sys
    1: import threading
    1: import traceback
    1: from typing import NamedTuple
    1: from typing import TYPE_CHECKING
    1: import warnings
       
    1: from _pytest.config import Config
    1: from _pytest.nodes import Item
    1: from _pytest.stash import StashKey
    1: from _pytest.tracemalloc import tracemalloc_message
    1: import pytest
       
       
    1: if TYPE_CHECKING:
>>>>>>     pass
       
    1: if sys.version_info < (3, 11):
>>>>>>     from exceptiongroup import ExceptionGroup
       
       
    2: class ThreadExceptionMeta(NamedTuple):
    1:     msg: str
    1:     cause_msg: str
    1:     exc_value: BaseException | None
       
       
    1: thread_exceptions: StashKey[collections.deque[ThreadExceptionMeta | BaseException]] = (
    1:     StashKey()
       )
       
       
    1: def collect_thread_exception(config: Config) -> None:
  268:     pop_thread_exception = config.stash[thread_exceptions].pop
  268:     errors: list[pytest.PytestUnhandledThreadExceptionWarning | RuntimeError] = []
  268:     meta = None
  268:     hook_error = None
  268:     try:
  268:         while True:
  268:             try:
  268:                 meta = pop_thread_exception()
  268:             except IndexError:
  268:                 break
       
>>>>>>             if isinstance(meta, BaseException):
>>>>>>                 hook_error = RuntimeError("Failed to process thread exception")
>>>>>>                 hook_error.__cause__ = meta
>>>>>>                 errors.append(hook_error)
>>>>>>                 continue
       
>>>>>>             msg = meta.msg
>>>>>>             try:
>>>>>>                 warnings.warn(pytest.PytestUnhandledThreadExceptionWarning(msg))
>>>>>>             except pytest.PytestUnhandledThreadExceptionWarning as e:
                       # This except happens when the warning is treated as an error (e.g. `-Werror`).
>>>>>>                 if meta.exc_value is not None:
                           # Exceptions have a better way to show the traceback, but
                           # warnings do not, so hide the traceback from the msg and
                           # set the cause so the traceback shows up in the right place.
>>>>>>                     e.args = (meta.cause_msg,)
>>>>>>                     e.__cause__ = meta.exc_value
>>>>>>                 errors.append(e)
       
  268:         if len(errors) == 1:
>>>>>>             raise errors[0]
  268:         if errors:
>>>>>>             raise ExceptionGroup("multiple thread exception warnings", errors)
           finally:
  268:         del errors, meta, hook_error
       
       
    4: def cleanup(
    2:     *, config: Config, prev_hook: Callable[[threading.ExceptHookArgs], object]
    1: ) -> None:
    1:     try:
    1:         try:
                   # We don't join threads here, so exceptions raised from any
                   # threads still running by the time _threading_atexits joins them
                   # do not get captured (see #13027).
    1:             collect_thread_exception(config)
               finally:
    1:             threading.excepthook = prev_hook
           finally:
    1:         del config.stash[thread_exceptions]
       
       
    4: def thread_exception_hook(
    1:     args: threading.ExceptHookArgs,
           /,
           *,
    1:     append: Callable[[ThreadExceptionMeta | BaseException], object],
    1: ) -> None:
>>>>>>     try:
               # we need to compute these strings here as they might change after
               # the excepthook finishes and before the metadata object is
               # collected by a pytest hook
>>>>>>         thread_name = "<unknown>" if args.thread is None else args.thread.name
>>>>>>         summary = f"Exception in thread {thread_name}"
>>>>>>         traceback_message = "\n\n" + "".join(
>>>>>>             traceback.format_exception(
>>>>>>                 args.exc_type,
>>>>>>                 args.exc_value,
>>>>>>                 args.exc_traceback,
                   )
               )
>>>>>>         tracemalloc_tb = "\n" + tracemalloc_message(args.thread)
>>>>>>         msg = summary + traceback_message + tracemalloc_tb
>>>>>>         cause_msg = summary + tracemalloc_tb
       
>>>>>>         append(
>>>>>>             ThreadExceptionMeta(
                       # Compute these strings here as they might change later
>>>>>>                 msg=msg,
>>>>>>                 cause_msg=cause_msg,
>>>>>>                 exc_value=args.exc_value,
                   )
               )
>>>>>>     except BaseException as e:
>>>>>>         append(e)
               # Raising this will cause the exception to be logged twice, once in our
               # collect_thread_exception and once by sys.excepthook
               # which is fine - this should never happen anyway and if it does
               # it should probably be reported as a pytest bug.
>>>>>>         raise
       
       
    1: def pytest_configure(config: Config) -> None:
    1:     prev_hook = threading.excepthook
    1:     deque: collections.deque[ThreadExceptionMeta | BaseException] = collections.deque()
    1:     config.stash[thread_exceptions] = deque
    1:     config.add_cleanup(functools.partial(cleanup, config=config, prev_hook=prev_hook))
    1:     threading.excepthook = functools.partial(thread_exception_hook, append=deque.append)
       
       
    2: @pytest.hookimpl(trylast=True)
    2: def pytest_runtest_setup(item: Item) -> None:
   89:     collect_thread_exception(item.config)
       
       
    2: @pytest.hookimpl(trylast=True)
    2: def pytest_runtest_call(item: Item) -> None:
   89:     collect_thread_exception(item.config)
       
       
    2: @pytest.hookimpl(trylast=True)
    2: def pytest_runtest_teardown(item: Item) -> None:
   89:     collect_thread_exception(item.config)
