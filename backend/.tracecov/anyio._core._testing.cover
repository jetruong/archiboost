    1: from __future__ import annotations
       
    1: from collections.abc import Awaitable, Generator
    1: from typing import Any, cast
       
    1: from ._eventloop import get_async_backend
       
       
    2: class TaskInfo:
    1:     """
           Represents an asynchronous task.
       
           :ivar int id: the unique identifier of the task
           :ivar parent_id: the identifier of the parent task, if any
           :vartype parent_id: Optional[int]
           :ivar str name: the description of the task (if any)
           :ivar ~collections.abc.Coroutine coro: the coroutine object of the task
           """
       
    1:     __slots__ = "_name", "id", "parent_id", "name", "coro"
       
    5:     def __init__(
               self,
    1:         id: int,
    1:         parent_id: int | None,
    1:         name: str | None,
    1:         coro: Generator[Any, Any, Any] | Awaitable[Any],
           ):
>>>>>>         func = get_current_task
>>>>>>         self._name = f"{func.__module__}.{func.__qualname__}"
>>>>>>         self.id: int = id
>>>>>>         self.parent_id: int | None = parent_id
>>>>>>         self.name: str | None = name
>>>>>>         self.coro: Generator[Any, Any, Any] | Awaitable[Any] = coro
       
    1:     def __eq__(self, other: object) -> bool:
>>>>>>         if isinstance(other, TaskInfo):
>>>>>>             return self.id == other.id
       
>>>>>>         return NotImplemented
       
    1:     def __hash__(self) -> int:
>>>>>>         return hash(self.id)
       
    1:     def __repr__(self) -> str:
>>>>>>         return f"{self.__class__.__name__}(id={self.id!r}, name={self.name!r})"
       
    1:     def has_pending_cancellation(self) -> bool:
               """
               Return ``True`` if the task has a cancellation pending, ``False`` otherwise.
       
               """
>>>>>>         return False
       
       
    1: def get_current_task() -> TaskInfo:
           """
           Return the current task.
       
           :return: a representation of the current task
           :raises NoEventLoopError: if no supported asynchronous event loop is running in the
               current thread
       
           """
>>>>>>     return get_async_backend().get_current_task()
       
       
    1: def get_running_tasks() -> list[TaskInfo]:
           """
           Return a list of running tasks in the current event loop.
       
           :return: a list of task info objects
           :raises NoEventLoopError: if no supported asynchronous event loop is running in the
               current thread
       
           """
>>>>>>     return cast("list[TaskInfo]", get_async_backend().get_running_tasks())
       
       
    1: async def wait_all_tasks_blocked() -> None:
           """Wait until all other tasks are waiting for something."""
>>>>>>     await get_async_backend().wait_all_tasks_blocked()
