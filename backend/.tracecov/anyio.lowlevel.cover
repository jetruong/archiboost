    1: from __future__ import annotations
       
    1: __all__ = (
           "EventLoopToken",
           "RunvarToken",
           "RunVar",
           "checkpoint",
           "checkpoint_if_cancelled",
           "cancel_shielded_checkpoint",
           "current_token",
       )
       
    1: import enum
    1: from dataclasses import dataclass
    1: from types import TracebackType
    1: from typing import Any, Generic, Literal, TypeVar, final, overload
    1: from weakref import WeakKeyDictionary
       
    1: from ._core._eventloop import get_async_backend
    1: from .abc import AsyncBackend
       
    1: T = TypeVar("T")
    1: D = TypeVar("D")
       
       
    1: async def checkpoint() -> None:
           """
           Check for cancellation and allow the scheduler to switch to another task.
       
           Equivalent to (but more efficient than)::
       
               await checkpoint_if_cancelled()
               await cancel_shielded_checkpoint()
       
           .. versionadded:: 3.0
       
           """
>>>>>>     await get_async_backend().checkpoint()
       
       
    1: async def checkpoint_if_cancelled() -> None:
           """
           Enter a checkpoint if the enclosing cancel scope has been cancelled.
       
           This does not allow the scheduler to switch to a different task.
       
           .. versionadded:: 3.0
       
           """
>>>>>>     await get_async_backend().checkpoint_if_cancelled()
       
       
    1: async def cancel_shielded_checkpoint() -> None:
           """
           Allow the scheduler to switch to another task but without checking for cancellation.
       
           Equivalent to (but potentially more efficient than)::
       
               with CancelScope(shield=True):
                   await checkpoint()
       
           .. versionadded:: 3.0
       
           """
>>>>>>     await get_async_backend().cancel_shielded_checkpoint()
       
       
    3: @final
    2: @dataclass(frozen=True, repr=False)
    2: class EventLoopToken:
    1:     """
           An opaque object that holds a reference to an event loop.
       
           .. versionadded:: 4.11.0
           """
       
    1:     backend_class: type[AsyncBackend]
    1:     native_token: object
       
       
    1: def current_token() -> EventLoopToken:
           """
           Return a token object that can be used to call code in the current event loop from
           another thread.
       
           :raises NoEventLoopError: if no supported asynchronous event loop is running in the
               current thread
       
           .. versionadded:: 4.11.0
       
           """
    9:     backend_class = get_async_backend()
    9:     raw_token = backend_class.current_token()
    9:     return EventLoopToken(backend_class, raw_token)
       
       
    1: _run_vars: WeakKeyDictionary[object, dict[RunVar[Any], Any]] = WeakKeyDictionary()
       
       
    2: class _NoValueSet(enum.Enum):
    1:     NO_VALUE_SET = enum.auto()
       
       
    2: class RunvarToken(Generic[T]):
    1:     __slots__ = "_var", "_value", "_redeemed"
       
    1:     def __init__(self, var: RunVar[T], value: T | Literal[_NoValueSet.NO_VALUE_SET]):
>>>>>>         self._var = var
>>>>>>         self._value: T | Literal[_NoValueSet.NO_VALUE_SET] = value
>>>>>>         self._redeemed = False
       
    1:     def __enter__(self) -> RunvarToken[T]:
>>>>>>         return self
       
    5:     def __exit__(
               self,
    1:         exc_type: type[BaseException] | None,
    1:         exc_val: BaseException | None,
    1:         exc_tb: TracebackType | None,
    1:     ) -> None:
>>>>>>         self._var.reset(self)
       
       
    2: class RunVar(Generic[T]):
    1:     """
           Like a :class:`~contextvars.ContextVar`, except scoped to the running event loop.
       
           Can be used as a context manager, Just like :class:`~contextvars.ContextVar`, that
           will reset the variable to its previous value when the context block is exited.
           """
       
    1:     __slots__ = "_name", "_default"
       
    1:     NO_VALUE_SET: Literal[_NoValueSet.NO_VALUE_SET] = _NoValueSet.NO_VALUE_SET
       
    3:     def __init__(
    3:         self, name: str, default: T | Literal[_NoValueSet.NO_VALUE_SET] = NO_VALUE_SET
           ):
    6:         self._name = name
    6:         self._default = default
       
    2:     @property
    2:     def _current_vars(self) -> dict[RunVar[T], T]:
>>>>>>         native_token = current_token().native_token
>>>>>>         try:
>>>>>>             return _run_vars[native_token]
>>>>>>         except KeyError:
>>>>>>             run_vars = _run_vars[native_token] = {}
>>>>>>             return run_vars
       
    2:     @overload
    2:     def get(self, default: D) -> T | D: ...
       
    2:     @overload
    2:     def get(self) -> T: ...
       
    3:     def get(
    2:         self, default: D | Literal[_NoValueSet.NO_VALUE_SET] = NO_VALUE_SET
    1:     ) -> T | D:
>>>>>>         try:
>>>>>>             return self._current_vars[self]
>>>>>>         except KeyError:
>>>>>>             if default is not RunVar.NO_VALUE_SET:
>>>>>>                 return default
>>>>>>             elif self._default is not RunVar.NO_VALUE_SET:
>>>>>>                 return self._default
       
>>>>>>         raise LookupError(
>>>>>>             f'Run variable "{self._name}" has no value and no default set'
               )
       
    1:     def set(self, value: T) -> RunvarToken[T]:
>>>>>>         current_vars = self._current_vars
>>>>>>         token = RunvarToken(self, current_vars.get(self, RunVar.NO_VALUE_SET))
>>>>>>         current_vars[self] = value
>>>>>>         return token
       
    1:     def reset(self, token: RunvarToken[T]) -> None:
>>>>>>         if token._var is not self:
>>>>>>             raise ValueError("This token does not belong to this RunVar")
       
>>>>>>         if token._redeemed:
>>>>>>             raise ValueError("This token has already been used")
       
>>>>>>         if token._value is _NoValueSet.NO_VALUE_SET:
>>>>>>             try:
>>>>>>                 del self._current_vars[self]
>>>>>>             except KeyError:
>>>>>>                 pass
               else:
>>>>>>             self._current_vars[self] = token._value
       
>>>>>>         token._redeemed = True
       
    1:     def __repr__(self) -> str:
>>>>>>         return f"<RunVar name={self._name!r}>"
