    1: from __future__ import annotations
       
    1: __all__ = (
           "MultiListener",
           "StapledByteStream",
           "StapledObjectStream",
       )
       
    1: from collections.abc import Callable, Mapping, Sequence
    1: from dataclasses import dataclass
    1: from typing import Any, Generic, TypeVar
       
    1: from ..abc import (
           ByteReceiveStream,
           ByteSendStream,
           ByteStream,
           Listener,
           ObjectReceiveStream,
           ObjectSendStream,
           ObjectStream,
           TaskGroup,
       )
       
    1: T_Item = TypeVar("T_Item")
    1: T_Stream = TypeVar("T_Stream")
       
       
    3: @dataclass(eq=False)
    2: class StapledByteStream(ByteStream):
    1:     """
           Combines two byte streams into a single, bidirectional byte stream.
       
           Extra attributes will be provided from both streams, with the receive stream
           providing the values in case of a conflict.
       
           :param ByteSendStream send_stream: the sending byte stream
           :param ByteReceiveStream receive_stream: the receiving byte stream
           """
       
    1:     send_stream: ByteSendStream
    1:     receive_stream: ByteReceiveStream
       
    1:     async def receive(self, max_bytes: int = 65536) -> bytes:
>>>>>>         return await self.receive_stream.receive(max_bytes)
       
    1:     async def send(self, item: bytes) -> None:
>>>>>>         await self.send_stream.send(item)
       
    1:     async def send_eof(self) -> None:
>>>>>>         await self.send_stream.aclose()
       
    1:     async def aclose(self) -> None:
>>>>>>         await self.send_stream.aclose()
>>>>>>         await self.receive_stream.aclose()
       
    2:     @property
    2:     def extra_attributes(self) -> Mapping[Any, Callable[[], Any]]:
>>>>>>         return {
>>>>>>             **self.send_stream.extra_attributes,
>>>>>>             **self.receive_stream.extra_attributes,
               }
       
       
    3: @dataclass(eq=False)
    2: class StapledObjectStream(Generic[T_Item], ObjectStream[T_Item]):
    1:     """
           Combines two object streams into a single, bidirectional object stream.
       
           Extra attributes will be provided from both streams, with the receive stream
           providing the values in case of a conflict.
       
           :param ObjectSendStream send_stream: the sending object stream
           :param ObjectReceiveStream receive_stream: the receiving object stream
           """
       
    1:     send_stream: ObjectSendStream[T_Item]
    1:     receive_stream: ObjectReceiveStream[T_Item]
       
    1:     async def receive(self) -> T_Item:
>>>>>>         return await self.receive_stream.receive()
       
    1:     async def send(self, item: T_Item) -> None:
>>>>>>         await self.send_stream.send(item)
       
    1:     async def send_eof(self) -> None:
>>>>>>         await self.send_stream.aclose()
       
    1:     async def aclose(self) -> None:
>>>>>>         await self.send_stream.aclose()
>>>>>>         await self.receive_stream.aclose()
       
    2:     @property
    2:     def extra_attributes(self) -> Mapping[Any, Callable[[], Any]]:
>>>>>>         return {
>>>>>>             **self.send_stream.extra_attributes,
>>>>>>             **self.receive_stream.extra_attributes,
               }
       
       
    3: @dataclass(eq=False)
    2: class MultiListener(Generic[T_Stream], Listener[T_Stream]):
    1:     """
           Combines multiple listeners into one, serving connections from all of them at once.
       
           Any MultiListeners in the given collection of listeners will have their listeners
           moved into this one.
       
           Extra attributes are provided from each listener, with each successive listener
           overriding any conflicting attributes from the previous one.
       
           :param listeners: listeners to serve
           :type listeners: Sequence[Listener[T_Stream]]
           """
       
    1:     listeners: Sequence[Listener[T_Stream]]
       
    1:     def __post_init__(self) -> None:
>>>>>>         listeners: list[Listener[T_Stream]] = []
>>>>>>         for listener in self.listeners:
>>>>>>             if isinstance(listener, MultiListener):
>>>>>>                 listeners.extend(listener.listeners)
>>>>>>                 del listener.listeners[:]  # type: ignore[attr-defined]
                   else:
>>>>>>                 listeners.append(listener)
       
>>>>>>         self.listeners = listeners
       
    4:     async def serve(
    3:         self, handler: Callable[[T_Stream], Any], task_group: TaskGroup | None = None
    1:     ) -> None:
>>>>>>         from .. import create_task_group
       
>>>>>>         async with create_task_group() as tg:
>>>>>>             for listener in self.listeners:
>>>>>>                 tg.start_soon(listener.serve, handler, task_group)
       
    1:     async def aclose(self) -> None:
>>>>>>         for listener in self.listeners:
>>>>>>             await listener.aclose()
       
    2:     @property
    2:     def extra_attributes(self) -> Mapping[Any, Callable[[], Any]]:
>>>>>>         attributes: dict = {}
>>>>>>         for listener in self.listeners:
>>>>>>             attributes.update(listener.extra_attributes)
       
>>>>>>         return attributes
