    1: from __future__ import annotations
       
    1: import os
    1: import pathlib
    1: import sys
    1: from collections.abc import (
           AsyncIterator,
           Callable,
           Iterable,
           Iterator,
           Sequence,
       )
    1: from dataclasses import dataclass
    1: from functools import partial
    1: from os import PathLike
    1: from typing import (
           IO,
           TYPE_CHECKING,
           Any,
           AnyStr,
           ClassVar,
           Final,
           Generic,
           overload,
       )
       
    1: from .. import to_thread
    1: from ..abc import AsyncResource
       
    1: if TYPE_CHECKING:
>>>>>>     from types import ModuleType
       
>>>>>>     from _typeshed import OpenBinaryMode, OpenTextMode, ReadableBuffer, WriteableBuffer
       else:
    1:     ReadableBuffer = OpenBinaryMode = OpenTextMode = WriteableBuffer = object
       
       
    2: class AsyncFile(AsyncResource, Generic[AnyStr]):
    1:     """
           An asynchronous file object.
       
           This class wraps a standard file object and provides async friendly versions of the
           following blocking methods (where available on the original file object):
       
           * read
           * read1
           * readline
           * readlines
           * readinto
           * readinto1
           * write
           * writelines
           * truncate
           * seek
           * tell
           * flush
       
           All other methods are directly passed through.
       
           This class supports the asynchronous context manager protocol which closes the
           underlying file at the end of the context block.
       
           This class also supports asynchronous iteration::
       
               async with await open_file(...) as f:
                   async for line in f:
                       print(line)
           """
       
    1:     def __init__(self, fp: IO[AnyStr]) -> None:
>>>>>>         self._fp: Any = fp
       
    1:     def __getattr__(self, name: str) -> object:
>>>>>>         return getattr(self._fp, name)
       
    2:     @property
    2:     def wrapped(self) -> IO[AnyStr]:
               """The wrapped file object."""
>>>>>>         return self._fp
       
    1:     async def __aiter__(self) -> AsyncIterator[AnyStr]:
>>>>>>         while True:
>>>>>>             line = await self.readline()
>>>>>>             if line:
>>>>>>                 yield line
                   else:
>>>>>>                 break
       
    1:     async def aclose(self) -> None:
>>>>>>         return await to_thread.run_sync(self._fp.close)
       
    1:     async def read(self, size: int = -1) -> AnyStr:
>>>>>>         return await to_thread.run_sync(self._fp.read, size)
       
    1:     async def read1(self: AsyncFile[bytes], size: int = -1) -> bytes:
>>>>>>         return await to_thread.run_sync(self._fp.read1, size)
       
    1:     async def readline(self) -> AnyStr:
>>>>>>         return await to_thread.run_sync(self._fp.readline)
       
    1:     async def readlines(self) -> list[AnyStr]:
>>>>>>         return await to_thread.run_sync(self._fp.readlines)
       
    1:     async def readinto(self: AsyncFile[bytes], b: WriteableBuffer) -> int:
>>>>>>         return await to_thread.run_sync(self._fp.readinto, b)
       
    1:     async def readinto1(self: AsyncFile[bytes], b: WriteableBuffer) -> int:
>>>>>>         return await to_thread.run_sync(self._fp.readinto1, b)
       
    2:     @overload
    2:     async def write(self: AsyncFile[bytes], b: ReadableBuffer) -> int: ...
       
    2:     @overload
    2:     async def write(self: AsyncFile[str], b: str) -> int: ...
       
    1:     async def write(self, b: ReadableBuffer | str) -> int:
>>>>>>         return await to_thread.run_sync(self._fp.write, b)
       
    2:     @overload
    5:     async def writelines(
    2:         self: AsyncFile[bytes], lines: Iterable[ReadableBuffer]
    1:     ) -> None: ...
       
    2:     @overload
    2:     async def writelines(self: AsyncFile[str], lines: Iterable[str]) -> None: ...
       
    1:     async def writelines(self, lines: Iterable[ReadableBuffer] | Iterable[str]) -> None:
>>>>>>         return await to_thread.run_sync(self._fp.writelines, lines)
       
    1:     async def truncate(self, size: int | None = None) -> int:
>>>>>>         return await to_thread.run_sync(self._fp.truncate, size)
       
    1:     async def seek(self, offset: int, whence: int | None = os.SEEK_SET) -> int:
>>>>>>         return await to_thread.run_sync(self._fp.seek, offset, whence)
       
    1:     async def tell(self) -> int:
>>>>>>         return await to_thread.run_sync(self._fp.tell)
       
    1:     async def flush(self) -> None:
>>>>>>         return await to_thread.run_sync(self._fp.flush)
       
       
    2: @overload
   11: async def open_file(
    1:     file: str | PathLike[str] | int,
    1:     mode: OpenBinaryMode,
    2:     buffering: int = ...,
    2:     encoding: str | None = ...,
    2:     errors: str | None = ...,
    2:     newline: str | None = ...,
    2:     closefd: bool = ...,
    2:     opener: Callable[[str, int], int] | None = ...,
    1: ) -> AsyncFile[bytes]: ...
       
       
    2: @overload
   11: async def open_file(
    1:     file: str | PathLike[str] | int,
    2:     mode: OpenTextMode = ...,
    2:     buffering: int = ...,
    2:     encoding: str | None = ...,
    2:     errors: str | None = ...,
    2:     newline: str | None = ...,
    2:     closefd: bool = ...,
    2:     opener: Callable[[str, int], int] | None = ...,
    1: ) -> AsyncFile[str]: ...
       
       
   10: async def open_file(
    1:     file: str | PathLike[str] | int,
    2:     mode: str = "r",
    2:     buffering: int = -1,
    2:     encoding: str | None = None,
    2:     errors: str | None = None,
    2:     newline: str | None = None,
    2:     closefd: bool = True,
    2:     opener: Callable[[str, int], int] | None = None,
    1: ) -> AsyncFile[Any]:
           """
           Open a file asynchronously.
       
           The arguments are exactly the same as for the builtin :func:`open`.
       
           :return: an asynchronous file object
       
           """
>>>>>>     fp = await to_thread.run_sync(
>>>>>>         open, file, mode, buffering, encoding, errors, newline, closefd, opener
           )
>>>>>>     return AsyncFile(fp)
       
       
    1: def wrap_file(file: IO[AnyStr]) -> AsyncFile[AnyStr]:
           """
           Wrap an existing file as an asynchronous file.
       
           :param file: an existing file-like object
           :return: an asynchronous file object
       
           """
>>>>>>     return AsyncFile(file)
       
       
    3: @dataclass(eq=False)
    2: class _PathIterator(AsyncIterator["Path"]):
    1:     iterator: Iterator[PathLike[str]]
       
    1:     async def __anext__(self) -> Path:
>>>>>>         nextval = await to_thread.run_sync(
>>>>>>             next, self.iterator, None, abandon_on_cancel=True
               )
>>>>>>         if nextval is None:
>>>>>>             raise StopAsyncIteration from None
       
>>>>>>         return Path(nextval)
       
       
    2: class Path:
    1:     """
           An asynchronous version of :class:`pathlib.Path`.
       
           This class cannot be substituted for :class:`pathlib.Path` or
           :class:`pathlib.PurePath`, but it is compatible with the :class:`os.PathLike`
           interface.
       
           It implements the Python 3.10 version of :class:`pathlib.Path` interface, except for
           the deprecated :meth:`~pathlib.Path.link_to` method.
       
           Some methods may be unavailable or have limited functionality, based on the Python
           version:
       
           * :meth:`~pathlib.Path.copy` (available on Python 3.14 or later)
           * :meth:`~pathlib.Path.copy_into` (available on Python 3.14 or later)
           * :meth:`~pathlib.Path.from_uri` (available on Python 3.13 or later)
           * :meth:`~pathlib.PurePath.full_match` (available on Python 3.13 or later)
           * :attr:`~pathlib.Path.info` (available on Python 3.14 or later)
           * :meth:`~pathlib.Path.is_junction` (available on Python 3.12 or later)
           * :meth:`~pathlib.PurePath.match` (the ``case_sensitive`` parameter is only
             available on Python 3.13 or later)
           * :meth:`~pathlib.Path.move` (available on Python 3.14 or later)
           * :meth:`~pathlib.Path.move_into` (available on Python 3.14 or later)
           * :meth:`~pathlib.PurePath.relative_to` (the ``walk_up`` parameter is only available
             on Python 3.12 or later)
           * :meth:`~pathlib.Path.walk` (available on Python 3.12 or later)
       
           Any methods that do disk I/O need to be awaited on. These methods are:
       
           * :meth:`~pathlib.Path.absolute`
           * :meth:`~pathlib.Path.chmod`
           * :meth:`~pathlib.Path.cwd`
           * :meth:`~pathlib.Path.exists`
           * :meth:`~pathlib.Path.expanduser`
           * :meth:`~pathlib.Path.group`
           * :meth:`~pathlib.Path.hardlink_to`
           * :meth:`~pathlib.Path.home`
           * :meth:`~pathlib.Path.is_block_device`
           * :meth:`~pathlib.Path.is_char_device`
           * :meth:`~pathlib.Path.is_dir`
           * :meth:`~pathlib.Path.is_fifo`
           * :meth:`~pathlib.Path.is_file`
           * :meth:`~pathlib.Path.is_junction`
           * :meth:`~pathlib.Path.is_mount`
           * :meth:`~pathlib.Path.is_socket`
           * :meth:`~pathlib.Path.is_symlink`
           * :meth:`~pathlib.Path.lchmod`
           * :meth:`~pathlib.Path.lstat`
           * :meth:`~pathlib.Path.mkdir`
           * :meth:`~pathlib.Path.open`
           * :meth:`~pathlib.Path.owner`
           * :meth:`~pathlib.Path.read_bytes`
           * :meth:`~pathlib.Path.read_text`
           * :meth:`~pathlib.Path.readlink`
           * :meth:`~pathlib.Path.rename`
           * :meth:`~pathlib.Path.replace`
           * :meth:`~pathlib.Path.resolve`
           * :meth:`~pathlib.Path.rmdir`
           * :meth:`~pathlib.Path.samefile`
           * :meth:`~pathlib.Path.stat`
           * :meth:`~pathlib.Path.symlink_to`
           * :meth:`~pathlib.Path.touch`
           * :meth:`~pathlib.Path.unlink`
           * :meth:`~pathlib.Path.walk`
           * :meth:`~pathlib.Path.write_bytes`
           * :meth:`~pathlib.Path.write_text`
       
           Additionally, the following methods return an async iterator yielding
           :class:`~.Path` objects:
       
           * :meth:`~pathlib.Path.glob`
           * :meth:`~pathlib.Path.iterdir`
           * :meth:`~pathlib.Path.rglob`
           """
       
    1:     __slots__ = "_path", "__weakref__"
       
    1:     __weakref__: Any
       
    1:     def __init__(self, *args: str | PathLike[str]) -> None:
>>>>>>         self._path: Final[pathlib.Path] = pathlib.Path(*args)
       
    1:     def __fspath__(self) -> str:
>>>>>>         return self._path.__fspath__()
       
    1:     def __str__(self) -> str:
>>>>>>         return self._path.__str__()
       
    1:     def __repr__(self) -> str:
>>>>>>         return f"{self.__class__.__name__}({self.as_posix()!r})"
       
    1:     def __bytes__(self) -> bytes:
>>>>>>         return self._path.__bytes__()
       
    1:     def __hash__(self) -> int:
>>>>>>         return self._path.__hash__()
       
    1:     def __eq__(self, other: object) -> bool:
>>>>>>         target = other._path if isinstance(other, Path) else other
>>>>>>         return self._path.__eq__(target)
       
    1:     def __lt__(self, other: pathlib.PurePath | Path) -> bool:
>>>>>>         target = other._path if isinstance(other, Path) else other
>>>>>>         return self._path.__lt__(target)
       
    1:     def __le__(self, other: pathlib.PurePath | Path) -> bool:
>>>>>>         target = other._path if isinstance(other, Path) else other
>>>>>>         return self._path.__le__(target)
       
    1:     def __gt__(self, other: pathlib.PurePath | Path) -> bool:
>>>>>>         target = other._path if isinstance(other, Path) else other
>>>>>>         return self._path.__gt__(target)
       
    1:     def __ge__(self, other: pathlib.PurePath | Path) -> bool:
>>>>>>         target = other._path if isinstance(other, Path) else other
>>>>>>         return self._path.__ge__(target)
       
    1:     def __truediv__(self, other: str | PathLike[str]) -> Path:
>>>>>>         return Path(self._path / other)
       
    1:     def __rtruediv__(self, other: str | PathLike[str]) -> Path:
>>>>>>         return Path(other) / self
       
    2:     @property
    2:     def parts(self) -> tuple[str, ...]:
>>>>>>         return self._path.parts
       
    2:     @property
    2:     def drive(self) -> str:
>>>>>>         return self._path.drive
       
    2:     @property
    2:     def root(self) -> str:
>>>>>>         return self._path.root
       
    2:     @property
    2:     def anchor(self) -> str:
>>>>>>         return self._path.anchor
       
    2:     @property
    2:     def parents(self) -> Sequence[Path]:
>>>>>>         return tuple(Path(p) for p in self._path.parents)
       
    2:     @property
    2:     def parent(self) -> Path:
>>>>>>         return Path(self._path.parent)
       
    2:     @property
    2:     def name(self) -> str:
>>>>>>         return self._path.name
       
    2:     @property
    2:     def suffix(self) -> str:
>>>>>>         return self._path.suffix
       
    2:     @property
    2:     def suffixes(self) -> list[str]:
>>>>>>         return self._path.suffixes
       
    2:     @property
    2:     def stem(self) -> str:
>>>>>>         return self._path.stem
       
    1:     async def absolute(self) -> Path:
>>>>>>         path = await to_thread.run_sync(self._path.absolute)
>>>>>>         return Path(path)
       
    1:     def as_posix(self) -> str:
>>>>>>         return self._path.as_posix()
       
    1:     def as_uri(self) -> str:
>>>>>>         return self._path.as_uri()
       
    1:     if sys.version_info >= (3, 13):
    1:         parser: ClassVar[ModuleType] = pathlib.Path.parser
       
    2:         @classmethod
    2:         def from_uri(cls, uri: str) -> Path:
>>>>>>             return Path(pathlib.Path.from_uri(uri))
       
    4:         def full_match(
    3:             self, path_pattern: str, *, case_sensitive: bool | None = None
    1:         ) -> bool:
>>>>>>             return self._path.full_match(path_pattern, case_sensitive=case_sensitive)
       
    4:         def match(
    3:             self, path_pattern: str, *, case_sensitive: bool | None = None
    1:         ) -> bool:
>>>>>>             return self._path.match(path_pattern, case_sensitive=case_sensitive)
           else:
       
>>>>>>         def match(self, path_pattern: str) -> bool:
>>>>>>             return self._path.match(path_pattern)
       
    1:     if sys.version_info >= (3, 14):
       
>>>>>>         @property
>>>>>>         def info(self) -> Any:  # TODO: add return type annotation when Typeshed gets it
>>>>>>             return self._path.info
       
>>>>>>         async def copy(
                   self,
>>>>>>             target: str | os.PathLike[str],
                   *,
>>>>>>             follow_symlinks: bool = True,
>>>>>>             preserve_metadata: bool = False,
>>>>>>         ) -> Path:
>>>>>>             func = partial(
>>>>>>                 self._path.copy,
>>>>>>                 follow_symlinks=follow_symlinks,
>>>>>>                 preserve_metadata=preserve_metadata,
                   )
>>>>>>             return Path(await to_thread.run_sync(func, pathlib.Path(target)))
       
>>>>>>         async def copy_into(
                   self,
>>>>>>             target_dir: str | os.PathLike[str],
                   *,
>>>>>>             follow_symlinks: bool = True,
>>>>>>             preserve_metadata: bool = False,
>>>>>>         ) -> Path:
>>>>>>             func = partial(
>>>>>>                 self._path.copy_into,
>>>>>>                 follow_symlinks=follow_symlinks,
>>>>>>                 preserve_metadata=preserve_metadata,
                   )
>>>>>>             return Path(await to_thread.run_sync(func, pathlib.Path(target_dir)))
       
>>>>>>         async def move(self, target: str | os.PathLike[str]) -> Path:
                   # Upstream does not handle anyio.Path properly as a PathLike
>>>>>>             target = pathlib.Path(target)
>>>>>>             return Path(await to_thread.run_sync(self._path.move, target))
       
>>>>>>         async def move_into(
                   self,
>>>>>>             target_dir: str | os.PathLike[str],
>>>>>>         ) -> Path:
>>>>>>             return Path(await to_thread.run_sync(self._path.move_into, target_dir))
       
    1:     def is_relative_to(self, other: str | PathLike[str]) -> bool:
>>>>>>         try:
>>>>>>             self.relative_to(other)
>>>>>>             return True
>>>>>>         except ValueError:
>>>>>>             return False
       
    1:     async def chmod(self, mode: int, *, follow_symlinks: bool = True) -> None:
>>>>>>         func = partial(os.chmod, follow_symlinks=follow_symlinks)
>>>>>>         return await to_thread.run_sync(func, self._path, mode)
       
    2:     @classmethod
    2:     async def cwd(cls) -> Path:
>>>>>>         path = await to_thread.run_sync(pathlib.Path.cwd)
>>>>>>         return cls(path)
       
    1:     async def exists(self) -> bool:
>>>>>>         return await to_thread.run_sync(self._path.exists, abandon_on_cancel=True)
       
    1:     async def expanduser(self) -> Path:
>>>>>>         return Path(
>>>>>>             await to_thread.run_sync(self._path.expanduser, abandon_on_cancel=True)
               )
       
    1:     if sys.version_info < (3, 12):
               # Python 3.11 and earlier
>>>>>>         def glob(self, pattern: str) -> AsyncIterator[Path]:
>>>>>>             gen = self._path.glob(pattern)
>>>>>>             return _PathIterator(gen)
    1:     elif (3, 12) <= sys.version_info < (3, 13):
               # changed in Python 3.12:
               # - The case_sensitive parameter was added.
>>>>>>         def glob(
                   self,
>>>>>>             pattern: str,
                   *,
>>>>>>             case_sensitive: bool | None = None,
>>>>>>         ) -> AsyncIterator[Path]:
>>>>>>             gen = self._path.glob(pattern, case_sensitive=case_sensitive)
>>>>>>             return _PathIterator(gen)
    1:     elif sys.version_info >= (3, 13):
               # Changed in Python 3.13:
               # - The recurse_symlinks parameter was added.
               # - The pattern parameter accepts a path-like object.
    5:         def glob(  # type: ignore[misc] # mypy doesn't allow for differing signatures in a conditional block
                   self,
    1:             pattern: str | PathLike[str],
                   *,
    2:             case_sensitive: bool | None = None,
    2:             recurse_symlinks: bool = False,
    1:         ) -> AsyncIterator[Path]:
>>>>>>             gen = self._path.glob(
>>>>>>                 pattern,  # type: ignore[arg-type]
>>>>>>                 case_sensitive=case_sensitive,
>>>>>>                 recurse_symlinks=recurse_symlinks,
                   )
>>>>>>             return _PathIterator(gen)
       
    1:     async def group(self) -> str:
>>>>>>         return await to_thread.run_sync(self._path.group, abandon_on_cancel=True)
       
    3:     async def hardlink_to(
    1:         self, target: str | bytes | PathLike[str] | PathLike[bytes]
    1:     ) -> None:
>>>>>>         if isinstance(target, Path):
>>>>>>             target = target._path
       
>>>>>>         await to_thread.run_sync(os.link, target, self)
       
    2:     @classmethod
    2:     async def home(cls) -> Path:
>>>>>>         home_path = await to_thread.run_sync(pathlib.Path.home)
>>>>>>         return cls(home_path)
       
    1:     def is_absolute(self) -> bool:
>>>>>>         return self._path.is_absolute()
       
    1:     async def is_block_device(self) -> bool:
>>>>>>         return await to_thread.run_sync(
>>>>>>             self._path.is_block_device, abandon_on_cancel=True
               )
       
    1:     async def is_char_device(self) -> bool:
>>>>>>         return await to_thread.run_sync(
>>>>>>             self._path.is_char_device, abandon_on_cancel=True
               )
       
    1:     async def is_dir(self) -> bool:
>>>>>>         return await to_thread.run_sync(self._path.is_dir, abandon_on_cancel=True)
       
    1:     async def is_fifo(self) -> bool:
>>>>>>         return await to_thread.run_sync(self._path.is_fifo, abandon_on_cancel=True)
       
    1:     async def is_file(self) -> bool:
>>>>>>         return await to_thread.run_sync(self._path.is_file, abandon_on_cancel=True)
       
    1:     if sys.version_info >= (3, 12):
       
    1:         async def is_junction(self) -> bool:
>>>>>>             return await to_thread.run_sync(self._path.is_junction)
       
    1:     async def is_mount(self) -> bool:
>>>>>>         return await to_thread.run_sync(
>>>>>>             os.path.ismount, self._path, abandon_on_cancel=True
               )
       
    1:     def is_reserved(self) -> bool:
>>>>>>         return self._path.is_reserved()
       
    1:     async def is_socket(self) -> bool:
>>>>>>         return await to_thread.run_sync(self._path.is_socket, abandon_on_cancel=True)
       
    1:     async def is_symlink(self) -> bool:
>>>>>>         return await to_thread.run_sync(self._path.is_symlink, abandon_on_cancel=True)
       
    1:     async def iterdir(self) -> AsyncIterator[Path]:
>>>>>>         gen = (
>>>>>>             self._path.iterdir()
>>>>>>             if sys.version_info < (3, 13)
>>>>>>             else await to_thread.run_sync(self._path.iterdir, abandon_on_cancel=True)
               )
>>>>>>         async for path in _PathIterator(gen):
>>>>>>             yield path
       
    1:     def joinpath(self, *args: str | PathLike[str]) -> Path:
>>>>>>         return Path(self._path.joinpath(*args))
       
    1:     async def lchmod(self, mode: int) -> None:
>>>>>>         await to_thread.run_sync(self._path.lchmod, mode)
       
    1:     async def lstat(self) -> os.stat_result:
>>>>>>         return await to_thread.run_sync(self._path.lstat, abandon_on_cancel=True)
       
    5:     async def mkdir(
    4:         self, mode: int = 0o777, parents: bool = False, exist_ok: bool = False
    1:     ) -> None:
>>>>>>         await to_thread.run_sync(self._path.mkdir, mode, parents, exist_ok)
       
    2:     @overload
    8:     async def open(
               self,
    1:         mode: OpenBinaryMode,
    2:         buffering: int = ...,
    2:         encoding: str | None = ...,
    2:         errors: str | None = ...,
    2:         newline: str | None = ...,
    1:     ) -> AsyncFile[bytes]: ...
       
    2:     @overload
    8:     async def open(
               self,
    2:         mode: OpenTextMode = ...,
    2:         buffering: int = ...,
    2:         encoding: str | None = ...,
    2:         errors: str | None = ...,
    2:         newline: str | None = ...,
    1:     ) -> AsyncFile[str]: ...
       
    7:     async def open(
               self,
    2:         mode: str = "r",
    2:         buffering: int = -1,
    2:         encoding: str | None = None,
    2:         errors: str | None = None,
    2:         newline: str | None = None,
    1:     ) -> AsyncFile[Any]:
>>>>>>         fp = await to_thread.run_sync(
>>>>>>             self._path.open, mode, buffering, encoding, errors, newline
               )
>>>>>>         return AsyncFile(fp)
       
    1:     async def owner(self) -> str:
>>>>>>         return await to_thread.run_sync(self._path.owner, abandon_on_cancel=True)
       
    1:     async def read_bytes(self) -> bytes:
>>>>>>         return await to_thread.run_sync(self._path.read_bytes)
       
    4:     async def read_text(
    3:         self, encoding: str | None = None, errors: str | None = None
    1:     ) -> str:
>>>>>>         return await to_thread.run_sync(self._path.read_text, encoding, errors)
       
    1:     if sys.version_info >= (3, 12):
       
    4:         def relative_to(
    3:             self, *other: str | PathLike[str], walk_up: bool = False
    1:         ) -> Path:
                   # relative_to() should work with any PathLike but it doesn't
>>>>>>             others = [pathlib.Path(other) for other in other]
>>>>>>             return Path(self._path.relative_to(*others, walk_up=walk_up))
       
           else:
       
>>>>>>         def relative_to(self, *other: str | PathLike[str]) -> Path:
>>>>>>             return Path(self._path.relative_to(*other))
       
    1:     async def readlink(self) -> Path:
>>>>>>         target = await to_thread.run_sync(os.readlink, self._path)
>>>>>>         return Path(target)
       
    1:     async def rename(self, target: str | pathlib.PurePath | Path) -> Path:
>>>>>>         if isinstance(target, Path):
>>>>>>             target = target._path
       
>>>>>>         await to_thread.run_sync(self._path.rename, target)
>>>>>>         return Path(target)
       
    1:     async def replace(self, target: str | pathlib.PurePath | Path) -> Path:
>>>>>>         if isinstance(target, Path):
>>>>>>             target = target._path
       
>>>>>>         await to_thread.run_sync(self._path.replace, target)
>>>>>>         return Path(target)
       
    1:     async def resolve(self, strict: bool = False) -> Path:
>>>>>>         func = partial(self._path.resolve, strict=strict)
>>>>>>         return Path(await to_thread.run_sync(func, abandon_on_cancel=True))
       
    1:     if sys.version_info < (3, 12):
               # Pre Python 3.12
>>>>>>         def rglob(self, pattern: str) -> AsyncIterator[Path]:
>>>>>>             gen = self._path.rglob(pattern)
>>>>>>             return _PathIterator(gen)
    1:     elif (3, 12) <= sys.version_info < (3, 13):
               # Changed in Python 3.12:
               # - The case_sensitive parameter was added.
>>>>>>         def rglob(
>>>>>>             self, pattern: str, *, case_sensitive: bool | None = None
>>>>>>         ) -> AsyncIterator[Path]:
>>>>>>             gen = self._path.rglob(pattern, case_sensitive=case_sensitive)
>>>>>>             return _PathIterator(gen)
    1:     elif sys.version_info >= (3, 13):
               # Changed in Python 3.13:
               # - The recurse_symlinks parameter was added.
               # - The pattern parameter accepts a path-like object.
    5:         def rglob(  # type: ignore[misc] # mypy doesn't allow for differing signatures in a conditional block
                   self,
    1:             pattern: str | PathLike[str],
                   *,
    2:             case_sensitive: bool | None = None,
    2:             recurse_symlinks: bool = False,
    1:         ) -> AsyncIterator[Path]:
>>>>>>             gen = self._path.rglob(
>>>>>>                 pattern,  # type: ignore[arg-type]
>>>>>>                 case_sensitive=case_sensitive,
>>>>>>                 recurse_symlinks=recurse_symlinks,
                   )
>>>>>>             return _PathIterator(gen)
       
    1:     async def rmdir(self) -> None:
>>>>>>         await to_thread.run_sync(self._path.rmdir)
       
    1:     async def samefile(self, other_path: str | PathLike[str]) -> bool:
>>>>>>         if isinstance(other_path, Path):
>>>>>>             other_path = other_path._path
       
>>>>>>         return await to_thread.run_sync(
>>>>>>             self._path.samefile, other_path, abandon_on_cancel=True
               )
       
    1:     async def stat(self, *, follow_symlinks: bool = True) -> os.stat_result:
>>>>>>         func = partial(os.stat, follow_symlinks=follow_symlinks)
>>>>>>         return await to_thread.run_sync(func, self._path, abandon_on_cancel=True)
       
    4:     async def symlink_to(
               self,
    1:         target: str | bytes | PathLike[str] | PathLike[bytes],
    2:         target_is_directory: bool = False,
    1:     ) -> None:
>>>>>>         if isinstance(target, Path):
>>>>>>             target = target._path
       
>>>>>>         await to_thread.run_sync(self._path.symlink_to, target, target_is_directory)
       
    1:     async def touch(self, mode: int = 0o666, exist_ok: bool = True) -> None:
>>>>>>         await to_thread.run_sync(self._path.touch, mode, exist_ok)
       
    1:     async def unlink(self, missing_ok: bool = False) -> None:
>>>>>>         try:
>>>>>>             await to_thread.run_sync(self._path.unlink)
>>>>>>         except FileNotFoundError:
>>>>>>             if not missing_ok:
>>>>>>                 raise
       
    1:     if sys.version_info >= (3, 12):
       
    5:         async def walk(
                   self,
    2:             top_down: bool = True,
    2:             on_error: Callable[[OSError], object] | None = None,
    2:             follow_symlinks: bool = False,
    1:         ) -> AsyncIterator[tuple[Path, list[str], list[str]]]:
>>>>>>             def get_next_value() -> tuple[pathlib.Path, list[str], list[str]] | None:
>>>>>>                 try:
>>>>>>                     return next(gen)
>>>>>>                 except StopIteration:
>>>>>>                     return None
       
>>>>>>             gen = self._path.walk(top_down, on_error, follow_symlinks)
>>>>>>             while True:
>>>>>>                 value = await to_thread.run_sync(get_next_value)
>>>>>>                 if value is None:
>>>>>>                     return
       
>>>>>>                 root, dirs, paths = value
>>>>>>                 yield Path(root), dirs, paths
       
    1:     def with_name(self, name: str) -> Path:
>>>>>>         return Path(self._path.with_name(name))
       
    1:     def with_stem(self, stem: str) -> Path:
>>>>>>         return Path(self._path.with_name(stem + self._path.suffix))
       
    1:     def with_suffix(self, suffix: str) -> Path:
>>>>>>         return Path(self._path.with_suffix(suffix))
       
    1:     def with_segments(self, *pathsegments: str | PathLike[str]) -> Path:
>>>>>>         return Path(*pathsegments)
       
    1:     async def write_bytes(self, data: bytes) -> int:
>>>>>>         return await to_thread.run_sync(self._path.write_bytes, data)
       
    6:     async def write_text(
               self,
    1:         data: str,
    2:         encoding: str | None = None,
    2:         errors: str | None = None,
    2:         newline: str | None = None,
    1:     ) -> int:
               # Path.write_text() does not support the "newline" parameter before Python 3.10
>>>>>>         def sync_write_text() -> int:
>>>>>>             with self._path.open(
>>>>>>                 "w", encoding=encoding, errors=errors, newline=newline
>>>>>>             ) as fp:
>>>>>>                 return fp.write(data)
       
>>>>>>         return await to_thread.run_sync(sync_write_text)
       
       
    1: PathLike.register(Path)
