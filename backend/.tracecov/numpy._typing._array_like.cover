    1: from __future__ import annotations
       
    1: import sys
    1: from collections.abc import Collection, Callable, Sequence
    1: from typing import Any, Protocol, TypeAlias, TypeVar, runtime_checkable, TYPE_CHECKING
       
    1: import numpy as np
    1: from numpy import (
           ndarray,
           dtype,
           generic,
           unsignedinteger,
           integer,
           floating,
           complexfloating,
           number,
           timedelta64,
           datetime64,
           object_,
           void,
           str_,
           bytes_,
       )
    1: from ._nbit_base import _32Bit, _64Bit
    1: from ._nested_sequence import _NestedSequence
    1: from ._shape import _Shape
       
    1: if TYPE_CHECKING:
>>>>>>     StringDType = np.dtypes.StringDType
       else:
           # at runtime outside of type checking importing this from numpy.dtypes
           # would lead to a circular import
    1:     from numpy._core.multiarray import StringDType
       
    1: _T = TypeVar("_T")
    1: _ScalarType = TypeVar("_ScalarType", bound=generic)
    1: _ScalarType_co = TypeVar("_ScalarType_co", bound=generic, covariant=True)
    1: _DType = TypeVar("_DType", bound=dtype[Any])
    1: _DType_co = TypeVar("_DType_co", covariant=True, bound=dtype[Any])
       
    1: NDArray: TypeAlias = ndarray[_Shape, dtype[_ScalarType_co]]
       
       # The `_SupportsArray` protocol only cares about the default dtype
       # (i.e. `dtype=None` or no `dtype` parameter at all) of the to-be returned
       # array.
       # Concrete implementations of the protocol are responsible for adding
       # any and all remaining overloads
    3: @runtime_checkable
    2: class _SupportsArray(Protocol[_DType_co]):
    1:     def __array__(self) -> ndarray[Any, _DType_co]: ...
       
       
    3: @runtime_checkable
    2: class _SupportsArrayFunc(Protocol):
    1:     """A protocol class representing `~class.__array_function__`."""
    6:     def __array_function__(
               self,
    1:         func: Callable[..., Any],
    1:         types: Collection[type[Any]],
    1:         args: tuple[Any, ...],
    1:         kwargs: dict[str, Any],
    1:     ) -> object: ...
       
       
       # TODO: Wait until mypy supports recursive objects in combination with typevars
    1: _FiniteNestedSequence: TypeAlias = (
    5:     _T
    1:     | Sequence[_T]
    1:     | Sequence[Sequence[_T]]
    1:     | Sequence[Sequence[Sequence[_T]]]
    1:     | Sequence[Sequence[Sequence[Sequence[_T]]]]
       )
       
       # A subset of `npt.ArrayLike` that can be parametrized w.r.t. `np.generic`
    1: _ArrayLike: TypeAlias = (
    2:     _SupportsArray[dtype[_ScalarType]]
    1:     | _NestedSequence[_SupportsArray[dtype[_ScalarType]]]
       )
       
       # A union representing array-like objects; consists of two typevars:
       # One representing types that can be parametrized w.r.t. `np.dtype`
       # and another one for the rest
    1: _DualArrayLike: TypeAlias = (
    4:     _SupportsArray[_DType]
    1:     | _NestedSequence[_SupportsArray[_DType]]
    1:     | _T
    1:     | _NestedSequence[_T]
       )
       
    1: if sys.version_info >= (3, 12):
    1:     from collections.abc import Buffer as _Buffer
       else:
>>>>>>     @runtime_checkable
>>>>>>     class _Buffer(Protocol):
>>>>>>         def __buffer__(self, flags: int, /) -> memoryview: ...
       
    2: ArrayLike: TypeAlias = _Buffer | _DualArrayLike[
    2:     dtype[Any],
    1:     bool | int | float | complex | str | bytes,
       ]
       
       # `ArrayLike<X>_co`: array-like objects that can be coerced into `X`
       # given the casting rules `same_kind`
    2: _ArrayLikeBool_co: TypeAlias = _DualArrayLike[
    2:     dtype[np.bool],
    1:     bool,
       ]
    2: _ArrayLikeUInt_co: TypeAlias = _DualArrayLike[
    2:     dtype[np.bool] | dtype[unsignedinteger[Any]],
    1:     bool,
       ]
    2: _ArrayLikeInt_co: TypeAlias = _DualArrayLike[
    2:     dtype[np.bool] | dtype[integer[Any]],
    1:     bool | int,
       ]
    2: _ArrayLikeFloat_co: TypeAlias = _DualArrayLike[
    2:     dtype[np.bool] | dtype[integer[Any]] | dtype[floating[Any]],
    1:     bool | int | float,
       ]
    2: _ArrayLikeComplex_co: TypeAlias = _DualArrayLike[
    1:     (
    4:         dtype[np.bool]
    1:         | dtype[integer[Any]]
    1:         | dtype[floating[Any]]
    1:         | dtype[complexfloating[Any, Any]]
           ),
    1:     bool | int | float | complex,
       ]
    2: _ArrayLikeNumber_co: TypeAlias = _DualArrayLike[
    2:     dtype[np.bool] | dtype[number[Any]],
    1:     bool | int | float | complex,
       ]
    2: _ArrayLikeTD64_co: TypeAlias = _DualArrayLike[
    2:     dtype[np.bool] | dtype[integer[Any]] | dtype[timedelta64],
    1:     bool | int,
       ]
    1: _ArrayLikeDT64_co: TypeAlias = (
    2:     _SupportsArray[dtype[datetime64]]
    1:     | _NestedSequence[_SupportsArray[dtype[datetime64]]]
       )
    1: _ArrayLikeObject_co: TypeAlias = (
    2:     _SupportsArray[dtype[object_]]
    1:     | _NestedSequence[_SupportsArray[dtype[object_]]]
       )
       
    1: _ArrayLikeVoid_co: TypeAlias = (
    2:     _SupportsArray[dtype[void]]
    1:     | _NestedSequence[_SupportsArray[dtype[void]]]
       )
    2: _ArrayLikeStr_co: TypeAlias = _DualArrayLike[
    2:     dtype[str_],
    1:     str,
       ]
    2: _ArrayLikeBytes_co: TypeAlias = _DualArrayLike[
    2:     dtype[bytes_],
    1:     bytes,
       ]
    2: _ArrayLikeString_co: TypeAlias = _DualArrayLike[
    2:     StringDType,
    1:     str
       ]
    1: _ArrayLikeAnyString_co: TypeAlias = (
    3:     _ArrayLikeStr_co |
    1:     _ArrayLikeBytes_co |
    1:     _ArrayLikeString_co
       )
       
    1: __Float64_co: TypeAlias = np.floating[_64Bit] | np.float32 | np.float16 | np.integer | np.bool
    1: __Complex128_co: TypeAlias = np.number[_64Bit] | np.number[_32Bit] | np.float16 | np.integer | np.bool
    1: _ArrayLikeFloat64_co: TypeAlias = _DualArrayLike[dtype[__Float64_co], float | int]
    1: _ArrayLikeComplex128_co: TypeAlias = _DualArrayLike[dtype[__Complex128_co], complex | float | int]
       
       # NOTE: This includes `builtins.bool`, but not `numpy.bool`.
    2: _ArrayLikeInt: TypeAlias = _DualArrayLike[
    2:     dtype[integer[Any]],
    1:     int,
       ]
       
       # Extra ArrayLike type so that pyright can deal with NDArray[Any]
       # Used as the first overload, should only match NDArray[Any],
       # not any actual types.
       # https://github.com/numpy/numpy/pull/22193
    1: if sys.version_info >= (3, 11):
    1:     from typing import Never as _UnknownType
       else:
>>>>>>     from typing import NoReturn as _UnknownType
       
       
    2: _ArrayLikeUnknown: TypeAlias = _DualArrayLike[
    2:     dtype[_UnknownType],
    1:     _UnknownType,
       ]
