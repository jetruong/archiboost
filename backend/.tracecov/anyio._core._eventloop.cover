    1: from __future__ import annotations
       
    1: import math
    1: import sys
    1: import threading
    1: from collections.abc import Awaitable, Callable, Generator
    1: from contextlib import contextmanager
    1: from contextvars import Token
    1: from importlib import import_module
    1: from typing import TYPE_CHECKING, Any, TypeVar
       
    1: from ._exceptions import NoEventLoopError
       
    1: if sys.version_info >= (3, 11):
    1:     from typing import TypeVarTuple, Unpack
       else:
>>>>>>     from typing_extensions import TypeVarTuple, Unpack
       
    1: sniffio: Any
    1: try:
    1:     import sniffio
    1: except ModuleNotFoundError:
    1:     sniffio = None
       
    1: if TYPE_CHECKING:
>>>>>>     from ..abc import AsyncBackend
       
       # This must be updated when new backends are introduced
    1: BACKENDS = "asyncio", "trio"
       
    1: T_Retval = TypeVar("T_Retval")
    1: PosArgsT = TypeVarTuple("PosArgsT")
       
    1: threadlocals = threading.local()
    1: loaded_backends: dict[str, type[AsyncBackend]] = {}
       
       
    6: def run(
    1:     func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval]],
    1:     *args: Unpack[PosArgsT],
    2:     backend: str = "asyncio",
    2:     backend_options: dict[str, Any] | None = None,
    1: ) -> T_Retval:
           """
           Run the given coroutine function in an asynchronous event loop.
       
           The current thread must not be already running an event loop.
       
           :param func: a coroutine function
           :param args: positional arguments to ``func``
           :param backend: name of the asynchronous event loop implementation â€“ currently
               either ``asyncio`` or ``trio``
           :param backend_options: keyword arguments to call the backend ``run()``
               implementation with (documented :ref:`here <backend options>`)
           :return: the return value of the coroutine function
           :raises RuntimeError: if an asynchronous event loop is already running in this
               thread
           :raises LookupError: if the named backend is not found
       
           """
    9:     if asynclib_name := current_async_library():
>>>>>>         raise RuntimeError(f"Already running {asynclib_name} in this thread")
       
    9:     try:
    9:         async_backend = get_async_backend(backend)
>>>>>>     except ImportError as exc:
>>>>>>         raise LookupError(f"No such backend: {backend}") from exc
       
    9:     token = None
    9:     if asynclib_name is None:
               # Since we're in control of the event loop, we can cache the name of the async
               # library
    9:         token = set_current_async_library(backend)
       
    9:     try:
    9:         backend_options = backend_options or {}
    9:         return async_backend.run(func, args, {}, backend_options)
           finally:
    9:         reset_current_async_library(token)
       
       
    1: async def sleep(delay: float) -> None:
           """
           Pause the current task for the specified duration.
       
           :param delay: the duration, in seconds
       
           """
>>>>>>     return await get_async_backend().sleep(delay)
       
       
    1: async def sleep_forever() -> None:
           """
           Pause the current task until it's cancelled.
       
           This is a shortcut for ``sleep(math.inf)``.
       
           .. versionadded:: 3.1
       
           """
>>>>>>     await sleep(math.inf)
       
       
    1: async def sleep_until(deadline: float) -> None:
           """
           Pause the current task until the given time.
       
           :param deadline: the absolute time to wake up at (according to the internal
               monotonic clock of the event loop)
       
           .. versionadded:: 3.1
       
           """
>>>>>>     now = current_time()
>>>>>>     await sleep(max(deadline - now, 0))
       
       
    1: def current_time() -> float:
           """
           Return the current value of the event loop's internal clock.
       
           :return: the clock value (seconds)
           :raises NoEventLoopError: if no supported asynchronous event loop is running in the
               current thread
       
           """
>>>>>>     return get_async_backend().current_time()
       
       
    1: def get_all_backends() -> tuple[str, ...]:
           """Return a tuple of the names of all built-in backends."""
    1:     return BACKENDS
       
       
    1: def get_available_backends() -> tuple[str, ...]:
           """
           Test for the availability of built-in backends.
       
           :return a tuple of the built-in backend names that were successfully imported
       
           .. versionadded:: 4.12
       
           """
    1:     available_backends: list[str] = []
    3:     for backend_name in get_all_backends():
    2:         try:
    2:             get_async_backend(backend_name)
    1:         except ImportError:
    1:             continue
       
    1:         available_backends.append(backend_name)
       
    1:     return tuple(available_backends)
       
       
    1: def get_cancelled_exc_class() -> type[BaseException]:
           """
           Return the current async library's cancellation exception class.
       
           :raises NoEventLoopError: if no supported asynchronous event loop is running in the
               current thread
       
           """
>>>>>>     return get_async_backend().cancelled_exception_class()
       
       
       #
       # Private API
       #
       
       
    2: @contextmanager
    5: def claim_worker_thread(
    2:     backend_class: type[AsyncBackend], token: object
    1: ) -> Generator[Any, None, None]:
>>>>>>     from ..lowlevel import EventLoopToken
       
>>>>>>     threadlocals.current_token = EventLoopToken(backend_class, token)
>>>>>>     try:
>>>>>>         yield
           finally:
>>>>>>         del threadlocals.current_token
       
       
    1: def get_async_backend(asynclib_name: str | None = None) -> type[AsyncBackend]:
   65:     if asynclib_name is None:
   54:         asynclib_name = current_async_library()
   54:         if not asynclib_name:
>>>>>>             raise NoEventLoopError(
>>>>>>                 f"Not currently running on any asynchronous event loop. "
>>>>>>                 f"Available async backends: {', '.join(get_all_backends())}"
                   )
       
           # We use our own dict instead of sys.modules to get the already imported back-end
           # class because the appropriate modules in sys.modules could potentially be only
           # partially initialized
   65:     try:
   65:         return loaded_backends[asynclib_name]
    2:     except KeyError:
    2:         module = import_module(f"anyio._backends._{asynclib_name}")
    1:         loaded_backends[asynclib_name] = module.backend_class
    1:         return module.backend_class
       
       
    1: def current_async_library() -> str | None:
   63:     if sniffio is None:
               # If sniffio is not installed, we assume we're either running asyncio or nothing
   63:         import asyncio
       
   63:         try:
   63:             asyncio.get_running_loop()
   54:             return "asyncio"
    9:         except RuntimeError:
    9:             pass
           else:
>>>>>>         try:
>>>>>>             return sniffio.current_async_library()
>>>>>>         except sniffio.AsyncLibraryNotFoundError:
>>>>>>             pass
       
    9:     return None
       
       
    1: def set_current_async_library(asynclib_name: str | None) -> Token | None:
           # no-op if sniffio is not installed
   36:     if sniffio is None:
   36:         return None
       
>>>>>>     return sniffio.current_async_library_cvar.set(asynclib_name)
       
       
    1: def reset_current_async_library(token: Token | None) -> None:
    9:     if token is not None:
>>>>>>         sniffio.current_async_library_cvar.reset(token)
