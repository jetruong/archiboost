    1: from __future__ import annotations
       
    1: import math
    1: from collections import deque
    1: from collections.abc import Callable
    1: from dataclasses import dataclass
    1: from types import TracebackType
    1: from typing import TypeVar
       
    1: from ..lowlevel import checkpoint_if_cancelled
    1: from ._eventloop import get_async_backend
    1: from ._exceptions import BusyResourceError, NoEventLoopError
    1: from ._tasks import CancelScope
    1: from ._testing import TaskInfo, get_current_task
       
    1: T = TypeVar("T")
       
       
    3: @dataclass(frozen=True)
    2: class EventStatistics:
    1:     """
           :ivar int tasks_waiting: number of tasks waiting on :meth:`~.Event.wait`
           """
       
    1:     tasks_waiting: int
       
       
    3: @dataclass(frozen=True)
    2: class CapacityLimiterStatistics:
    1:     """
           :ivar int borrowed_tokens: number of tokens currently borrowed by tasks
           :ivar float total_tokens: total number of available tokens
           :ivar tuple borrowers: tasks or other objects currently holding tokens borrowed from
               this limiter
           :ivar int tasks_waiting: number of tasks waiting on
               :meth:`~.CapacityLimiter.acquire` or
               :meth:`~.CapacityLimiter.acquire_on_behalf_of`
           """
       
    1:     borrowed_tokens: int
    1:     total_tokens: float
    1:     borrowers: tuple[object, ...]
    1:     tasks_waiting: int
       
       
    3: @dataclass(frozen=True)
    2: class LockStatistics:
    1:     """
           :ivar bool locked: flag indicating if this lock is locked or not
           :ivar ~anyio.TaskInfo owner: task currently holding the lock (or ``None`` if the
               lock is not held by any task)
           :ivar int tasks_waiting: number of tasks waiting on :meth:`~.Lock.acquire`
           """
       
    1:     locked: bool
    1:     owner: TaskInfo | None
    1:     tasks_waiting: int
       
       
    3: @dataclass(frozen=True)
    2: class ConditionStatistics:
    1:     """
           :ivar int tasks_waiting: number of tasks blocked on :meth:`~.Condition.wait`
           :ivar ~anyio.LockStatistics lock_statistics: statistics of the underlying
               :class:`~.Lock`
           """
       
    1:     tasks_waiting: int
    1:     lock_statistics: LockStatistics
       
       
    3: @dataclass(frozen=True)
    2: class SemaphoreStatistics:
    1:     """
           :ivar int tasks_waiting: number of tasks waiting on :meth:`~.Semaphore.acquire`
       
           """
       
    1:     tasks_waiting: int
       
       
    2: class Event:
    1:     def __new__(cls) -> Event:
   18:         try:
   18:             return get_async_backend().create_event()
>>>>>>         except NoEventLoopError:
>>>>>>             return EventAdapter()
       
    1:     def set(self) -> None:
               """Set the flag, notifying all listeners."""
>>>>>>         raise NotImplementedError
       
    1:     def is_set(self) -> bool:
               """Return ``True`` if the flag is set, ``False`` if not."""
>>>>>>         raise NotImplementedError
       
    1:     async def wait(self) -> None:
               """
               Wait until the flag has been set.
       
               If the flag has already been set when this method is called, it returns
               immediately.
       
               """
>>>>>>         raise NotImplementedError
       
    1:     def statistics(self) -> EventStatistics:
               """Return statistics about the current state of this event."""
>>>>>>         raise NotImplementedError
       
       
    2: class EventAdapter(Event):
    1:     _internal_event: Event | None = None
    1:     _is_set: bool = False
       
    1:     def __new__(cls) -> EventAdapter:
>>>>>>         return object.__new__(cls)
       
    2:     @property
    2:     def _event(self) -> Event:
>>>>>>         if self._internal_event is None:
>>>>>>             self._internal_event = get_async_backend().create_event()
>>>>>>             if self._is_set:
>>>>>>                 self._internal_event.set()
       
>>>>>>         return self._internal_event
       
    1:     def set(self) -> None:
>>>>>>         if self._internal_event is None:
>>>>>>             self._is_set = True
               else:
>>>>>>             self._event.set()
       
    1:     def is_set(self) -> bool:
>>>>>>         if self._internal_event is None:
>>>>>>             return self._is_set
       
>>>>>>         return self._internal_event.is_set()
       
    1:     async def wait(self) -> None:
>>>>>>         await self._event.wait()
       
    1:     def statistics(self) -> EventStatistics:
>>>>>>         if self._internal_event is None:
>>>>>>             return EventStatistics(tasks_waiting=0)
       
>>>>>>         return self._internal_event.statistics()
       
       
    2: class Lock:
    1:     def __new__(cls, *, fast_acquire: bool = False) -> Lock:
>>>>>>         try:
>>>>>>             return get_async_backend().create_lock(fast_acquire=fast_acquire)
>>>>>>         except NoEventLoopError:
>>>>>>             return LockAdapter(fast_acquire=fast_acquire)
       
    1:     async def __aenter__(self) -> None:
>>>>>>         await self.acquire()
       
    5:     async def __aexit__(
               self,
    1:         exc_type: type[BaseException] | None,
    1:         exc_val: BaseException | None,
    1:         exc_tb: TracebackType | None,
    1:     ) -> None:
>>>>>>         self.release()
       
    1:     async def acquire(self) -> None:
               """Acquire the lock."""
>>>>>>         raise NotImplementedError
       
    1:     def acquire_nowait(self) -> None:
               """
               Acquire the lock, without blocking.
       
               :raises ~anyio.WouldBlock: if the operation would block
       
               """
>>>>>>         raise NotImplementedError
       
    1:     def release(self) -> None:
               """Release the lock."""
>>>>>>         raise NotImplementedError
       
    1:     def locked(self) -> bool:
               """Return True if the lock is currently held."""
>>>>>>         raise NotImplementedError
       
    1:     def statistics(self) -> LockStatistics:
               """
               Return statistics about the current state of this lock.
       
               .. versionadded:: 3.0
               """
>>>>>>         raise NotImplementedError
       
       
    2: class LockAdapter(Lock):
    1:     _internal_lock: Lock | None = None
       
    1:     def __new__(cls, *, fast_acquire: bool = False) -> LockAdapter:
>>>>>>         return object.__new__(cls)
       
    1:     def __init__(self, *, fast_acquire: bool = False):
>>>>>>         self._fast_acquire = fast_acquire
       
    2:     @property
    2:     def _lock(self) -> Lock:
>>>>>>         if self._internal_lock is None:
>>>>>>             self._internal_lock = get_async_backend().create_lock(
>>>>>>                 fast_acquire=self._fast_acquire
                   )
       
>>>>>>         return self._internal_lock
       
    1:     async def __aenter__(self) -> None:
>>>>>>         await self._lock.acquire()
       
    5:     async def __aexit__(
               self,
    1:         exc_type: type[BaseException] | None,
    1:         exc_val: BaseException | None,
    1:         exc_tb: TracebackType | None,
    1:     ) -> None:
>>>>>>         if self._internal_lock is not None:
>>>>>>             self._internal_lock.release()
       
    1:     async def acquire(self) -> None:
               """Acquire the lock."""
>>>>>>         await self._lock.acquire()
       
    1:     def acquire_nowait(self) -> None:
               """
               Acquire the lock, without blocking.
       
               :raises ~anyio.WouldBlock: if the operation would block
       
               """
>>>>>>         self._lock.acquire_nowait()
       
    1:     def release(self) -> None:
               """Release the lock."""
>>>>>>         self._lock.release()
       
    1:     def locked(self) -> bool:
               """Return True if the lock is currently held."""
>>>>>>         return self._lock.locked()
       
    1:     def statistics(self) -> LockStatistics:
               """
               Return statistics about the current state of this lock.
       
               .. versionadded:: 3.0
       
               """
>>>>>>         if self._internal_lock is None:
>>>>>>             return LockStatistics(False, None, 0)
       
>>>>>>         return self._internal_lock.statistics()
       
       
    2: class Condition:
    1:     _owner_task: TaskInfo | None = None
       
    1:     def __init__(self, lock: Lock | None = None):
>>>>>>         self._lock = lock or Lock()
>>>>>>         self._waiters: deque[Event] = deque()
       
    1:     async def __aenter__(self) -> None:
>>>>>>         await self.acquire()
       
    5:     async def __aexit__(
               self,
    1:         exc_type: type[BaseException] | None,
    1:         exc_val: BaseException | None,
    1:         exc_tb: TracebackType | None,
    1:     ) -> None:
>>>>>>         self.release()
       
    1:     def _check_acquired(self) -> None:
>>>>>>         if self._owner_task != get_current_task():
>>>>>>             raise RuntimeError("The current task is not holding the underlying lock")
       
    1:     async def acquire(self) -> None:
               """Acquire the underlying lock."""
>>>>>>         await self._lock.acquire()
>>>>>>         self._owner_task = get_current_task()
       
    1:     def acquire_nowait(self) -> None:
               """
               Acquire the underlying lock, without blocking.
       
               :raises ~anyio.WouldBlock: if the operation would block
       
               """
>>>>>>         self._lock.acquire_nowait()
>>>>>>         self._owner_task = get_current_task()
       
    1:     def release(self) -> None:
               """Release the underlying lock."""
>>>>>>         self._lock.release()
       
    1:     def locked(self) -> bool:
               """Return True if the lock is set."""
>>>>>>         return self._lock.locked()
       
    1:     def notify(self, n: int = 1) -> None:
               """Notify exactly n listeners."""
>>>>>>         self._check_acquired()
>>>>>>         for _ in range(n):
>>>>>>             try:
>>>>>>                 event = self._waiters.popleft()
>>>>>>             except IndexError:
>>>>>>                 break
       
>>>>>>             event.set()
       
    1:     def notify_all(self) -> None:
               """Notify all the listeners."""
>>>>>>         self._check_acquired()
>>>>>>         for event in self._waiters:
>>>>>>             event.set()
       
>>>>>>         self._waiters.clear()
       
    1:     async def wait(self) -> None:
               """Wait for a notification."""
>>>>>>         await checkpoint_if_cancelled()
>>>>>>         self._check_acquired()
>>>>>>         event = Event()
>>>>>>         self._waiters.append(event)
>>>>>>         self.release()
>>>>>>         try:
>>>>>>             await event.wait()
>>>>>>         except BaseException:
>>>>>>             if not event.is_set():
>>>>>>                 self._waiters.remove(event)
       
>>>>>>             raise
               finally:
>>>>>>             with CancelScope(shield=True):
>>>>>>                 await self.acquire()
       
    1:     async def wait_for(self, predicate: Callable[[], T]) -> T:
               """
               Wait until a predicate becomes true.
       
               :param predicate: a callable that returns a truthy value when the condition is
                   met
               :return: the result of the predicate
       
               .. versionadded:: 4.11.0
       
               """
>>>>>>         while not (result := predicate()):
>>>>>>             await self.wait()
       
>>>>>>         return result
       
    1:     def statistics(self) -> ConditionStatistics:
               """
               Return statistics about the current state of this condition.
       
               .. versionadded:: 3.0
               """
>>>>>>         return ConditionStatistics(len(self._waiters), self._lock.statistics())
       
       
    2: class Semaphore:
    5:     def __new__(
               cls,
    1:         initial_value: int,
               *,
    2:         max_value: int | None = None,
    2:         fast_acquire: bool = False,
    1:     ) -> Semaphore:
>>>>>>         try:
>>>>>>             return get_async_backend().create_semaphore(
>>>>>>                 initial_value, max_value=max_value, fast_acquire=fast_acquire
                   )
>>>>>>         except NoEventLoopError:
>>>>>>             return SemaphoreAdapter(initial_value, max_value=max_value)
       
    4:     def __init__(
               self,
    1:         initial_value: int,
               *,
    2:         max_value: int | None = None,
    2:         fast_acquire: bool = False,
           ):
>>>>>>         if not isinstance(initial_value, int):
>>>>>>             raise TypeError("initial_value must be an integer")
>>>>>>         if initial_value < 0:
>>>>>>             raise ValueError("initial_value must be >= 0")
>>>>>>         if max_value is not None:
>>>>>>             if not isinstance(max_value, int):
>>>>>>                 raise TypeError("max_value must be an integer or None")
>>>>>>             if max_value < initial_value:
>>>>>>                 raise ValueError(
>>>>>>                     "max_value must be equal to or higher than initial_value"
                       )
       
>>>>>>         self._fast_acquire = fast_acquire
       
    1:     async def __aenter__(self) -> Semaphore:
>>>>>>         await self.acquire()
>>>>>>         return self
       
    5:     async def __aexit__(
               self,
    1:         exc_type: type[BaseException] | None,
    1:         exc_val: BaseException | None,
    1:         exc_tb: TracebackType | None,
    1:     ) -> None:
>>>>>>         self.release()
       
    1:     async def acquire(self) -> None:
               """Decrement the semaphore value, blocking if necessary."""
>>>>>>         raise NotImplementedError
       
    1:     def acquire_nowait(self) -> None:
               """
               Acquire the underlying lock, without blocking.
       
               :raises ~anyio.WouldBlock: if the operation would block
       
               """
>>>>>>         raise NotImplementedError
       
    1:     def release(self) -> None:
               """Increment the semaphore value."""
>>>>>>         raise NotImplementedError
       
    2:     @property
    2:     def value(self) -> int:
               """The current value of the semaphore."""
>>>>>>         raise NotImplementedError
       
    2:     @property
    2:     def max_value(self) -> int | None:
               """The maximum value of the semaphore."""
>>>>>>         raise NotImplementedError
       
    1:     def statistics(self) -> SemaphoreStatistics:
               """
               Return statistics about the current state of this semaphore.
       
               .. versionadded:: 3.0
               """
>>>>>>         raise NotImplementedError
       
       
    2: class SemaphoreAdapter(Semaphore):
    1:     _internal_semaphore: Semaphore | None = None
       
    5:     def __new__(
               cls,
    1:         initial_value: int,
               *,
    2:         max_value: int | None = None,
    2:         fast_acquire: bool = False,
    1:     ) -> SemaphoreAdapter:
>>>>>>         return object.__new__(cls)
       
    5:     def __init__(
               self,
    1:         initial_value: int,
               *,
    2:         max_value: int | None = None,
    2:         fast_acquire: bool = False,
    1:     ) -> None:
>>>>>>         super().__init__(initial_value, max_value=max_value, fast_acquire=fast_acquire)
>>>>>>         self._initial_value = initial_value
>>>>>>         self._max_value = max_value
       
    2:     @property
    2:     def _semaphore(self) -> Semaphore:
>>>>>>         if self._internal_semaphore is None:
>>>>>>             self._internal_semaphore = get_async_backend().create_semaphore(
>>>>>>                 self._initial_value, max_value=self._max_value
                   )
       
>>>>>>         return self._internal_semaphore
       
    1:     async def acquire(self) -> None:
>>>>>>         await self._semaphore.acquire()
       
    1:     def acquire_nowait(self) -> None:
>>>>>>         self._semaphore.acquire_nowait()
       
    1:     def release(self) -> None:
>>>>>>         self._semaphore.release()
       
    2:     @property
    2:     def value(self) -> int:
>>>>>>         if self._internal_semaphore is None:
>>>>>>             return self._initial_value
       
>>>>>>         return self._semaphore.value
       
    2:     @property
    2:     def max_value(self) -> int | None:
>>>>>>         return self._max_value
       
    1:     def statistics(self) -> SemaphoreStatistics:
>>>>>>         if self._internal_semaphore is None:
>>>>>>             return SemaphoreStatistics(tasks_waiting=0)
       
>>>>>>         return self._semaphore.statistics()
       
       
    2: class CapacityLimiter:
    1:     def __new__(cls, total_tokens: float) -> CapacityLimiter:
>>>>>>         try:
>>>>>>             return get_async_backend().create_capacity_limiter(total_tokens)
>>>>>>         except NoEventLoopError:
>>>>>>             return CapacityLimiterAdapter(total_tokens)
       
    1:     async def __aenter__(self) -> None:
>>>>>>         raise NotImplementedError
       
    5:     async def __aexit__(
               self,
    1:         exc_type: type[BaseException] | None,
    1:         exc_val: BaseException | None,
    1:         exc_tb: TracebackType | None,
    1:     ) -> None:
>>>>>>         raise NotImplementedError
       
    2:     @property
    2:     def total_tokens(self) -> float:
               """
               The total number of tokens available for borrowing.
       
               This is a read-write property. If the total number of tokens is increased, the
               proportionate number of tasks waiting on this limiter will be granted their
               tokens.
       
               .. versionchanged:: 3.0
                   The property is now writable.
               .. versionchanged:: 4.12
                   The value can now be set to 0.
       
               """
>>>>>>         raise NotImplementedError
       
    2:     @total_tokens.setter
    2:     def total_tokens(self, value: float) -> None:
>>>>>>         raise NotImplementedError
       
    2:     @property
    2:     def borrowed_tokens(self) -> int:
               """The number of tokens that have currently been borrowed."""
>>>>>>         raise NotImplementedError
       
    2:     @property
    2:     def available_tokens(self) -> float:
               """The number of tokens currently available to be borrowed"""
>>>>>>         raise NotImplementedError
       
    1:     def acquire_nowait(self) -> None:
               """
               Acquire a token for the current task without waiting for one to become
               available.
       
               :raises ~anyio.WouldBlock: if there are no tokens available for borrowing
       
               """
>>>>>>         raise NotImplementedError
       
    1:     def acquire_on_behalf_of_nowait(self, borrower: object) -> None:
               """
               Acquire a token without waiting for one to become available.
       
               :param borrower: the entity borrowing a token
               :raises ~anyio.WouldBlock: if there are no tokens available for borrowing
       
               """
>>>>>>         raise NotImplementedError
       
    1:     async def acquire(self) -> None:
               """
               Acquire a token for the current task, waiting if necessary for one to become
               available.
       
               """
>>>>>>         raise NotImplementedError
       
    1:     async def acquire_on_behalf_of(self, borrower: object) -> None:
               """
               Acquire a token, waiting if necessary for one to become available.
       
               :param borrower: the entity borrowing a token
       
               """
>>>>>>         raise NotImplementedError
       
    1:     def release(self) -> None:
               """
               Release the token held by the current task.
       
               :raises RuntimeError: if the current task has not borrowed a token from this
                   limiter.
       
               """
>>>>>>         raise NotImplementedError
       
    1:     def release_on_behalf_of(self, borrower: object) -> None:
               """
               Release the token held by the given borrower.
       
               :raises RuntimeError: if the borrower has not borrowed a token from this
                   limiter.
       
               """
>>>>>>         raise NotImplementedError
       
    1:     def statistics(self) -> CapacityLimiterStatistics:
               """
               Return statistics about the current state of this limiter.
       
               .. versionadded:: 3.0
       
               """
>>>>>>         raise NotImplementedError
       
       
    2: class CapacityLimiterAdapter(CapacityLimiter):
    1:     _internal_limiter: CapacityLimiter | None = None
       
    1:     def __new__(cls, total_tokens: float) -> CapacityLimiterAdapter:
>>>>>>         return object.__new__(cls)
       
    1:     def __init__(self, total_tokens: float) -> None:
>>>>>>         self.total_tokens = total_tokens
       
    2:     @property
    2:     def _limiter(self) -> CapacityLimiter:
>>>>>>         if self._internal_limiter is None:
>>>>>>             self._internal_limiter = get_async_backend().create_capacity_limiter(
>>>>>>                 self._total_tokens
                   )
       
>>>>>>         return self._internal_limiter
       
    1:     async def __aenter__(self) -> None:
>>>>>>         await self._limiter.__aenter__()
       
    5:     async def __aexit__(
               self,
    1:         exc_type: type[BaseException] | None,
    1:         exc_val: BaseException | None,
    1:         exc_tb: TracebackType | None,
    1:     ) -> None:
>>>>>>         return await self._limiter.__aexit__(exc_type, exc_val, exc_tb)
       
    2:     @property
    2:     def total_tokens(self) -> float:
>>>>>>         if self._internal_limiter is None:
>>>>>>             return self._total_tokens
       
>>>>>>         return self._internal_limiter.total_tokens
       
    2:     @total_tokens.setter
    2:     def total_tokens(self, value: float) -> None:
>>>>>>         if not isinstance(value, int) and value is not math.inf:
>>>>>>             raise TypeError("total_tokens must be an int or math.inf")
>>>>>>         elif value < 1:
>>>>>>             raise ValueError("total_tokens must be >= 1")
       
>>>>>>         if self._internal_limiter is None:
>>>>>>             self._total_tokens = value
>>>>>>             return
       
>>>>>>         self._limiter.total_tokens = value
       
    2:     @property
    2:     def borrowed_tokens(self) -> int:
>>>>>>         if self._internal_limiter is None:
>>>>>>             return 0
       
>>>>>>         return self._internal_limiter.borrowed_tokens
       
    2:     @property
    2:     def available_tokens(self) -> float:
>>>>>>         if self._internal_limiter is None:
>>>>>>             return self._total_tokens
       
>>>>>>         return self._internal_limiter.available_tokens
       
    1:     def acquire_nowait(self) -> None:
>>>>>>         self._limiter.acquire_nowait()
       
    1:     def acquire_on_behalf_of_nowait(self, borrower: object) -> None:
>>>>>>         self._limiter.acquire_on_behalf_of_nowait(borrower)
       
    1:     async def acquire(self) -> None:
>>>>>>         await self._limiter.acquire()
       
    1:     async def acquire_on_behalf_of(self, borrower: object) -> None:
>>>>>>         await self._limiter.acquire_on_behalf_of(borrower)
       
    1:     def release(self) -> None:
>>>>>>         self._limiter.release()
       
    1:     def release_on_behalf_of(self, borrower: object) -> None:
>>>>>>         self._limiter.release_on_behalf_of(borrower)
       
    1:     def statistics(self) -> CapacityLimiterStatistics:
>>>>>>         if self._internal_limiter is None:
>>>>>>             return CapacityLimiterStatistics(
>>>>>>                 borrowed_tokens=0,
>>>>>>                 total_tokens=self.total_tokens,
>>>>>>                 borrowers=(),
>>>>>>                 tasks_waiting=0,
                   )
       
>>>>>>         return self._internal_limiter.statistics()
       
       
    2: class ResourceGuard:
    1:     """
           A context manager for ensuring that a resource is only used by a single task at a
           time.
       
           Entering this context manager while the previous has not exited it yet will trigger
           :exc:`BusyResourceError`.
       
           :param action: the action to guard against (visible in the :exc:`BusyResourceError`
               when triggered, e.g. "Another task is already {action} this resource")
       
           .. versionadded:: 4.1
           """
       
    1:     __slots__ = "action", "_guarded"
       
    1:     def __init__(self, action: str = "using"):
>>>>>>         self.action: str = action
>>>>>>         self._guarded = False
       
    1:     def __enter__(self) -> None:
>>>>>>         if self._guarded:
>>>>>>             raise BusyResourceError(self.action)
       
>>>>>>         self._guarded = True
       
    5:     def __exit__(
               self,
    1:         exc_type: type[BaseException] | None,
    1:         exc_val: BaseException | None,
    1:         exc_tb: TracebackType | None,
    1:     ) -> None:
>>>>>>         self._guarded = False
