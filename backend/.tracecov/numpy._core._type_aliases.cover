    1: """
       Due to compatibility, numpy has a very large number of different naming
       conventions for the scalar types (those subclassing from `numpy.generic`).
       This file produces a convoluted set of dictionaries mapping names to types,
       and sometimes other mappings too.
       
       .. data:: allTypes
           A dictionary of names to types that will be exposed as attributes through
           ``np._core.numerictypes.*``
       
       .. data:: sctypeDict
           Similar to `allTypes`, but maps a broader set of aliases to their types.
       
       .. data:: sctypes
           A dictionary keyed by a "type group" string, providing a list of types
           under that group.
       
       """
       
    1: import numpy._core.multiarray as ma
    1: from numpy._core.multiarray import typeinfo, dtype
       
       ######################################
       # Building `sctypeDict` and `allTypes`
       ######################################
       
    1: sctypeDict = {}
    1: allTypes = {}
    1: c_names_dict = {}
       
    1: _abstract_type_names = {
           "generic", "integer", "inexact", "floating", "number",
           "flexible", "character", "complexfloating", "unsignedinteger",
           "signedinteger"
       }
       
   11: for _abstract_type_name in _abstract_type_names:
   10:     allTypes[_abstract_type_name] = getattr(ma, _abstract_type_name)
       
   59: for k, v in typeinfo.items():
   58:     if k.startswith("NPY_") and v not in c_names_dict:
   24:         c_names_dict[k[4:]] = v
           else:
   34:         concrete_type = v.type
   34:         allTypes[k] = concrete_type
   34:         sctypeDict[k] = concrete_type
       
    1: _aliases = {
    1:     "double": "float64",
    1:     "cdouble": "complex128",
    1:     "single": "float32",
    1:     "csingle": "complex64",
    1:     "half": "float16",
    1:     "bool_": "bool",
           # Default integer:
    1:     "int_": "intp",
    1:     "uint": "uintp",
       }
       
    9: for k, v in _aliases.items():
    8:     sctypeDict[k] = allTypes[v]
    8:     allTypes[k] = allTypes[v]
       
       # extra aliases are added only to `sctypeDict`
       # to support dtype name access, such as`np.dtype("float")`
    1: _extra_aliases = {
    1:     "float": "float64",
    1:     "complex": "complex128",
    1:     "object": "object_",
    1:     "bytes": "bytes_",
    1:     "a": "bytes_",
    1:     "int": "int_",
    1:     "str": "str_",
    1:     "unicode": "str_",
       }
       
    9: for k, v in _extra_aliases.items():
    8:     sctypeDict[k] = allTypes[v]
       
       # include extended precision sized aliases
    3: for is_complex, full_name in [(False, "longdouble"), (True, "clongdouble")]:
    2:     longdouble_type: type = allTypes[full_name]
       
    2:     bits: int = dtype(longdouble_type).itemsize * 8
    2:     base_name: str = "complex" if is_complex else "float"
    2:     extended_prec_name: str = f"{base_name}{bits}"
    2:     if extended_prec_name not in allTypes:
>>>>>>         sctypeDict[extended_prec_name] = longdouble_type
>>>>>>         allTypes[extended_prec_name] = longdouble_type
       
       
       ####################
       # Building `sctypes`
       ####################
       
    2: sctypes = {"int": set(), "uint": set(), "float": set(),
    1:            "complex": set(), "others": set()}
       
   59: for type_info in typeinfo.values():
   58:     if type_info.kind in ["M", "m"]:  # exclude timedelta and datetime
    4:         continue
       
   54:     concrete_type = type_info.type
       
           # find proper group for each concrete type
  143:     for type_group, abstract_type in [
   54:         ("int", ma.signedinteger), ("uint", ma.unsignedinteger),
   54:         ("float", ma.floating), ("complex", ma.complexfloating),
   54:         ("others", ma.generic)
           ]:
  143:         if issubclass(concrete_type, abstract_type):
   54:             sctypes[type_group].add(concrete_type)
   54:             break
       
       # sort sctype groups by bitsize
    6: for sctype_key in sctypes.keys():
    5:     sctype_list = list(sctypes[sctype_key])
   27:     sctype_list.sort(key=lambda x: dtype(x).itemsize)
    5:     sctypes[sctype_key] = sctype_list
