    1: """High-level introspection utilities, used to inspect type annotations."""
       
    1: from __future__ import annotations
       
    1: import sys
    1: import types
    1: from collections.abc import Generator
    1: from dataclasses import InitVar
    1: from enum import Enum, IntEnum, auto
    1: from typing import Any, Literal, NamedTuple, cast
       
    1: from typing_extensions import TypeAlias, assert_never, get_args, get_origin
       
    1: from . import typing_objects
       
    1: __all__ = (
           'AnnotationSource',
           'ForbiddenQualifier',
           'InspectedAnnotation',
           'Qualifier',
           'get_literal_values',
           'inspect_annotation',
           'is_union_origin',
       )
       
    1: if sys.version_info >= (3, 14) or sys.version_info < (3, 10):
       
>>>>>>     def is_union_origin(obj: Any, /) -> bool:
               """Return whether the provided origin is the union form.
       
               ```pycon
               >>> is_union_origin(typing.Union)
               True
               >>> is_union_origin(get_origin(int | str))
               True
               >>> is_union_origin(types.UnionType)
               True
               ```
       
               !!! note
                   Since Python 3.14, both `Union[<t1>, <t2>, ...]` and `<t1> | <t2> | ...` forms create instances
                   of the same [`typing.Union`][] class. As such, it is recommended to not use this function
                   anymore (provided that you only support Python 3.14 or greater), and instead use the
                   [`typing_objects.is_union()`][typing_inspection.typing_objects.is_union] function directly:
       
                   ```python
                   from typing import Union, get_origin
       
                   from typing_inspection import typing_objects
       
                   typ = int | str  # Or Union[int, str]
                   origin = get_origin(typ)
                   if typing_objects.is_union(origin):
                       ...
                   ```
               """
>>>>>>         return typing_objects.is_union(obj)
       
       
       else:
       
    1:     def is_union_origin(obj: Any, /) -> bool:
               """Return whether the provided origin is the union form.
       
               ```pycon
               >>> is_union_origin(typing.Union)
               True
               >>> is_union_origin(get_origin(int | str))
               True
               >>> is_union_origin(types.UnionType)
               True
               ```
       
               !!! note
                   Since Python 3.14, both `Union[<t1>, <t2>, ...]` and `<t1> | <t2> | ...` forms create instances
                   of the same [`typing.Union`][] class. As such, it is recommended to not use this function
                   anymore (provided that you only support Python 3.14 or greater), and instead use the
                   [`typing_objects.is_union()`][typing_inspection.typing_objects.is_union] function directly:
       
                   ```python
                   from typing import Union, get_origin
       
                   from typing_inspection import typing_objects
       
                   typ = int | str  # Or Union[int, str]
                   origin = get_origin(typ)
                   if typing_objects.is_union(origin):
                       ...
                   ```
               """
 1980:         return typing_objects.is_union(obj) or obj is types.UnionType
       
       
    1: def _literal_type_check(value: Any, /) -> None:
           """Type check the provided literal value against the legal parameters."""
           if (
>>>>>>         not isinstance(value, (int, bytes, str, bool, Enum, typing_objects.NoneType))
>>>>>>         and value is not typing_objects.NoneType
           ):
>>>>>>         raise TypeError(f'{value} is not a valid literal value, must be one of: int, bytes, str, Enum, None.')
       
       
    5: def get_literal_values(
    1:     annotation: Any,
           /,
           *,
    2:     type_check: bool = False,
    2:     unpack_type_aliases: Literal['skip', 'lenient', 'eager'] = 'eager',
    1: ) -> Generator[Any]:
           """Yield the values contained in the provided [`Literal`][typing.Literal] [special form][].
       
           Args:
               annotation: The [`Literal`][typing.Literal] [special form][] to unpack.
               type_check: Whether to check if the literal values are [legal parameters][literal-legal-parameters].
                   Raises a [`TypeError`][] otherwise.
               unpack_type_aliases: What to do when encountering [PEP 695](https://peps.python.org/pep-0695/)
                   [type aliases][type-aliases]. Can be one of:
       
                   - `'skip'`: Do not try to parse type aliases. Note that this can lead to incorrect results:
                     ```pycon
                     >>> type MyAlias = Literal[1, 2]
                     >>> list(get_literal_values(Literal[MyAlias, 3], unpack_type_aliases="skip"))
                     [MyAlias, 3]
                     ```
       
                   - `'lenient'`: Try to parse type aliases, and fallback to `'skip'` if the type alias can't be inspected
                     (because of an undefined forward reference).
       
                   - `'eager'`: Parse type aliases and raise any encountered [`NameError`][] exceptions (the default):
                     ```pycon
                     >>> type MyAlias = Literal[1, 2]
                     >>> list(get_literal_values(Literal[MyAlias, 3], unpack_type_aliases="eager"))
                     [1, 2, 3]
                     ```
       
           Note:
               While `None` is [equivalent to][none] `type(None)`, the runtime implementation of [`Literal`][typing.Literal]
               does not de-duplicate them. This function makes sure this de-duplication is applied:
       
               ```pycon
               >>> list(get_literal_values(Literal[NoneType, None]))
               [None]
               ```
       
           Example:
               ```pycon
               >>> type Ints = Literal[1, 2]
               >>> list(get_literal_values(Literal[1, Ints], unpack_type_alias="skip"))
               ["a", Ints]
               >>> list(get_literal_values(Literal[1, Ints]))
               [1, 2]
               >>> list(get_literal_values(Literal[1.0], type_check=True))
               Traceback (most recent call last):
               ...
               TypeError: 1.0 is not a valid literal value, must be one of: int, bytes, str, Enum, None.
               ```
           """
           # `literal` is guaranteed to be a `Literal[...]` special form, so use
           # `__args__` directly instead of calling `get_args()`.
       
   20:     if unpack_type_aliases == 'skip':
>>>>>>         _has_none = False
               # `Literal` parameters are already deduplicated, no need to do it ourselves.
               # (we only check for `None` and `NoneType`, which should be considered as duplicates).
>>>>>>         for arg in annotation.__args__:
>>>>>>             if type_check:
>>>>>>                 _literal_type_check(arg)
>>>>>>             if arg is None or arg is typing_objects.NoneType:
>>>>>>                 if not _has_none:
>>>>>>                     yield None
>>>>>>                 _has_none = True
                   else:
>>>>>>                 yield arg
           else:
               # We'll need to manually deduplicate parameters, see the `Literal` implementation in `typing`.
   20:         values_and_type: list[tuple[Any, type[Any]]] = []
       
  139:         for arg in annotation.__args__:
                   # Note: we could also check for generic aliases with a type alias as an origin.
                   # However, it is very unlikely that this happens as type variables can't appear in
                   # `Literal` forms, so the only valid (but unnecessary) use case would be something like:
                   # `type Test[T] = Literal['a']` (and then use `Test[SomeType]`).
  119:             if typing_objects.is_typealiastype(arg):
>>>>>>                 try:
>>>>>>                     alias_value = arg.__value__
>>>>>>                 except NameError:
>>>>>>                     if unpack_type_aliases == 'eager':
>>>>>>                         raise
                           # unpack_type_aliases == "lenient":
>>>>>>                     if type_check:
>>>>>>                         _literal_type_check(arg)
>>>>>>                     values_and_type.append((arg, type(arg)))
                       else:
>>>>>>                     sub_args = get_literal_values(
>>>>>>                         alias_value, type_check=type_check, unpack_type_aliases=unpack_type_aliases
                           )
>>>>>>                     values_and_type.extend((a, type(a)) for a in sub_args)  # pyright: ignore[reportUnknownArgumentType]
                   else:
  119:                 if type_check:
>>>>>>                     _literal_type_check(arg)
  119:                 if arg is typing_objects.NoneType:
>>>>>>                     values_and_type.append((None, typing_objects.NoneType))
                       else:
  119:                     values_and_type.append((arg, type(arg)))  # pyright: ignore[reportUnknownArgumentType]
       
   20:         try:
   20:             dct = dict.fromkeys(values_and_type)
>>>>>>         except TypeError:
                   # Unhashable parameters, the Python implementation allows them
>>>>>>             yield from (p for p, _ in values_and_type)
               else:
  159:             yield from (p for p, _ in dct)
       
       
    1: Qualifier: TypeAlias = Literal['required', 'not_required', 'read_only', 'class_var', 'init_var', 'final']
    1: """A [type qualifier][]."""
       
    1: _all_qualifiers: set[Qualifier] = set(get_args(Qualifier))
       
       
       # TODO at some point, we could switch to an enum flag, so that multiple sources
       # can be combined. However, is there a need for this?
    2: class AnnotationSource(IntEnum):
           # TODO if/when https://peps.python.org/pep-0767/ is accepted, add 'read_only'
           # to CLASS and NAMED_TUPLE (even though for named tuples it is redundant).
       
    1:     """The source of an annotation, e.g. a class or a function.
       
           Depending on the source, different [type qualifiers][type qualifier] may be (dis)allowed.
           """
       
    1:     ASSIGNMENT_OR_VARIABLE = auto()
    1:     """An annotation used in an assignment or variable annotation:
       
           ```python
           x: Final[int] = 1
           y: Final[str]
           ```
       
           **Allowed type qualifiers:** [`Final`][typing.Final].
           """
       
    1:     CLASS = auto()
    1:     """An annotation used in the body of a class:
       
           ```python
           class Test:
               x: Final[int] = 1
               y: ClassVar[str]
           ```
       
           **Allowed type qualifiers:** [`ClassVar`][typing.ClassVar], [`Final`][typing.Final].
           """
       
    1:     DATACLASS = auto()
    1:     """An annotation used in the body of a dataclass:
       
           ```python
           @dataclass
           class Test:
               x: Final[int] = 1
               y: InitVar[str] = 'test'
           ```
       
           **Allowed type qualifiers:** [`ClassVar`][typing.ClassVar], [`Final`][typing.Final], [`InitVar`][dataclasses.InitVar].
           """  # noqa: E501
       
    1:     TYPED_DICT = auto()
    1:     """An annotation used in the body of a [`TypedDict`][typing.TypedDict]:
       
           ```python
           class TD(TypedDict):
               x: Required[ReadOnly[int]]
               y: ReadOnly[NotRequired[str]]
           ```
       
           **Allowed type qualifiers:** [`ReadOnly`][typing.ReadOnly], [`Required`][typing.Required],
           [`NotRequired`][typing.NotRequired].
           """
       
    1:     NAMED_TUPLE = auto()
    1:     """An annotation used in the body of a [`NamedTuple`][typing.NamedTuple].
       
           ```python
           class NT(NamedTuple):
               x: int
               y: str
           ```
       
           **Allowed type qualifiers:** none.
           """
       
    1:     FUNCTION = auto()
    1:     """An annotation used in a function, either for a parameter or the return value.
       
           ```python
           def func(a: int) -> str:
               ...
           ```
       
           **Allowed type qualifiers:** none.
           """
       
    1:     ANY = auto()
    1:     """An annotation that might come from any source.
       
           **Allowed type qualifiers:** all.
           """
       
    1:     BARE = auto()
    1:     """An annotation that is inspected as is.
       
           **Allowed type qualifiers:** none.
           """
       
    2:     @property
    2:     def allowed_qualifiers(self) -> set[Qualifier]:
               """The allowed [type qualifiers][type qualifier] for this annotation source."""
               # TODO use a match statement when Python 3.9 support is dropped.
  773:         if self is AnnotationSource.ASSIGNMENT_OR_VARIABLE:
>>>>>>             return {'final'}
  773:         elif self is AnnotationSource.CLASS:
  745:             return {'final', 'class_var'}
   28:         elif self is AnnotationSource.DATACLASS:
>>>>>>             return {'final', 'class_var', 'init_var'}
   28:         elif self is AnnotationSource.TYPED_DICT:
   28:             return {'required', 'not_required', 'read_only'}
>>>>>>         elif self in (AnnotationSource.NAMED_TUPLE, AnnotationSource.FUNCTION, AnnotationSource.BARE):
>>>>>>             return set()
>>>>>>         elif self is AnnotationSource.ANY:
>>>>>>             return _all_qualifiers
               else:  # pragma: no cover
>>>>>>             assert_never(self)
       
       
    2: class ForbiddenQualifier(Exception):
    1:     """The provided [type qualifier][] is forbidden."""
       
    1:     qualifier: Qualifier
    1:     """The forbidden qualifier."""
       
    1:     def __init__(self, qualifier: Qualifier, /) -> None:
>>>>>>         self.qualifier = qualifier
       
       
    2: class _UnknownTypeEnum(Enum):
    1:     UNKNOWN = auto()
       
    1:     def __str__(self) -> str:
>>>>>>         return 'UNKNOWN'
       
    1:     def __repr__(self) -> str:
>>>>>>         return '<UNKNOWN>'
       
       
    1: UNKNOWN = _UnknownTypeEnum.UNKNOWN
    1: """A sentinel value used when no [type expression][] is present."""
       
    1: _UnkownType: TypeAlias = Literal[_UnknownTypeEnum.UNKNOWN]
    1: """The type of the [`UNKNOWN`][typing_inspection.introspection.UNKNOWN] sentinel value."""
       
       
    2: class InspectedAnnotation(NamedTuple):
    1:     """The result of the inspected annotation."""
       
    1:     type: Any | _UnkownType
    1:     """The final [type expression][], with [type qualifiers][type qualifier] and annotated metadata stripped.
       
           If no type expression is available, the [`UNKNOWN`][typing_inspection.introspection.UNKNOWN] sentinel
           value is used instead. This is the case when a [type qualifier][] is used with no type annotation:
       
           ```python
           ID: Final = 1
       
           class C:
               x: ClassVar = 'test'
           ```
           """
       
    1:     qualifiers: set[Qualifier]
    1:     """The [type qualifiers][type qualifier] present on the annotation."""
       
    1:     metadata: list[Any]
    1:     """The annotated metadata."""
       
       
    5: def inspect_annotation(  # noqa: PLR0915
    1:     annotation: Any,
           /,
           *,
    1:     annotation_source: AnnotationSource,
    2:     unpack_type_aliases: Literal['skip', 'lenient', 'eager'] = 'skip',
    1: ) -> InspectedAnnotation:
           """Inspect an [annotation expression][], extracting any [type qualifier][] and metadata.
       
           An [annotation expression][] is a [type expression][] optionally surrounded by one or more
           [type qualifiers][type qualifier] or by [`Annotated`][typing.Annotated]. This function will:
       
           - Unwrap the type expression, keeping track of the type qualifiers.
           - Unwrap [`Annotated`][typing.Annotated] forms, keeping track of the annotated metadata.
       
           Args:
               annotation: The annotation expression to be inspected.
               annotation_source: The source of the annotation. Depending on the source (e.g. a class), different type
                   qualifiers may be (dis)allowed. To allow any type qualifier, use
                   [`AnnotationSource.ANY`][typing_inspection.introspection.AnnotationSource.ANY].
               unpack_type_aliases: What to do when encountering [PEP 695](https://peps.python.org/pep-0695/)
                   [type aliases][type-aliases]. Can be one of:
       
                   - `'skip'`: Do not try to parse type aliases (the default):
                     ```pycon
                     >>> type MyInt = Annotated[int, 'meta']
                     >>> inspect_annotation(MyInt, annotation_source=AnnotationSource.BARE, unpack_type_aliases='skip')
                     InspectedAnnotation(type=MyInt, qualifiers={}, metadata=[])
                     ```
       
                   - `'lenient'`: Try to parse type aliases, and fallback to `'skip'` if the type alias
                     can't be inspected (because of an undefined forward reference):
                     ```pycon
                     >>> type MyInt = Annotated[Undefined, 'meta']
                     >>> inspect_annotation(MyInt, annotation_source=AnnotationSource.BARE, unpack_type_aliases='lenient')
                     InspectedAnnotation(type=MyInt, qualifiers={}, metadata=[])
                     >>> Undefined = int
                     >>> inspect_annotation(MyInt, annotation_source=AnnotationSource.BARE, unpack_type_aliases='lenient')
                     InspectedAnnotation(type=int, qualifiers={}, metadata=['meta'])
                     ```
       
                   - `'eager'`: Parse type aliases and raise any encountered [`NameError`][] exceptions.
       
           Returns:
               The result of the inspected annotation, where the type expression, used qualifiers and metadata is stored.
       
           Example:
               ```pycon
               >>> inspect_annotation(
               ...     Final[Annotated[ClassVar[Annotated[int, 'meta_1']], 'meta_2']],
               ...     annotation_source=AnnotationSource.CLASS,
               ... )
               ...
               InspectedAnnotation(type=int, qualifiers={'class_var', 'final'}, metadata=['meta_1', 'meta_2'])
               ```
           """
  773:     allowed_qualifiers = annotation_source.allowed_qualifiers
  773:     qualifiers: set[Qualifier] = set()
  773:     metadata: list[Any] = []
       
  779:     while True:
  779:         annotation, _meta = _unpack_annotated(annotation, unpack_type_aliases=unpack_type_aliases)
  779:         if _meta:
    6:             metadata = _meta + metadata
    6:             continue
       
  773:         origin = get_origin(annotation)
  773:         if origin is not None:
  432:             if typing_objects.is_classvar(origin):
>>>>>>                 if 'class_var' not in allowed_qualifiers:
>>>>>>                     raise ForbiddenQualifier('class_var')
>>>>>>                 qualifiers.add('class_var')
>>>>>>                 annotation = annotation.__args__[0]
  432:             elif typing_objects.is_final(origin):
>>>>>>                 if 'final' not in allowed_qualifiers:
>>>>>>                     raise ForbiddenQualifier('final')
>>>>>>                 qualifiers.add('final')
>>>>>>                 annotation = annotation.__args__[0]
  432:             elif typing_objects.is_required(origin):
>>>>>>                 if 'required' not in allowed_qualifiers:
>>>>>>                     raise ForbiddenQualifier('required')
>>>>>>                 qualifiers.add('required')
>>>>>>                 annotation = annotation.__args__[0]
  432:             elif typing_objects.is_notrequired(origin):
>>>>>>                 if 'not_required' not in allowed_qualifiers:
>>>>>>                     raise ForbiddenQualifier('not_required')
>>>>>>                 qualifiers.add('not_required')
>>>>>>                 annotation = annotation.__args__[0]
  432:             elif typing_objects.is_readonly(origin):
>>>>>>                 if 'read_only' not in allowed_qualifiers:
>>>>>>                     raise ForbiddenQualifier('not_required')
>>>>>>                 qualifiers.add('read_only')
>>>>>>                 annotation = annotation.__args__[0]
                   else:
                       # origin is not None but not a type qualifier nor `Annotated` (e.g. `list[int]`):
  432:                 break
  341:         elif isinstance(annotation, InitVar):
>>>>>>             if 'init_var' not in allowed_qualifiers:
>>>>>>                 raise ForbiddenQualifier('init_var')
>>>>>>             qualifiers.add('init_var')
>>>>>>             annotation = cast(Any, annotation.type)
               else:
  341:             break
       
           # `Final`, `ClassVar` and `InitVar` are type qualifiers allowed to be used as a bare annotation:
  773:     if typing_objects.is_final(annotation):
>>>>>>         if 'final' not in allowed_qualifiers:
>>>>>>             raise ForbiddenQualifier('final')
>>>>>>         qualifiers.add('final')
>>>>>>         annotation = UNKNOWN
  773:     elif typing_objects.is_classvar(annotation):
>>>>>>         if 'class_var' not in allowed_qualifiers:
>>>>>>             raise ForbiddenQualifier('class_var')
>>>>>>         qualifiers.add('class_var')
>>>>>>         annotation = UNKNOWN
  773:     elif annotation is InitVar:
>>>>>>         if 'init_var' not in allowed_qualifiers:
>>>>>>             raise ForbiddenQualifier('init_var')
>>>>>>         qualifiers.add('init_var')
>>>>>>         annotation = UNKNOWN
       
  773:     return InspectedAnnotation(annotation, qualifiers, metadata)
       
       
    5: def _unpack_annotated_inner(
    3:     annotation: Any, unpack_type_aliases: Literal['lenient', 'eager'], check_annotated: bool
    1: ) -> tuple[Any, list[Any]]:
>>>>>>     origin = get_origin(annotation)
>>>>>>     if check_annotated and typing_objects.is_annotated(origin):
>>>>>>         annotated_type = annotation.__origin__
>>>>>>         metadata = list(annotation.__metadata__)
       
               # The annotated type might be a PEP 695 type alias, so we need to recursively
               # unpack it. Because Python already flattens `Annotated[Annotated[<type>, ...], ...]` forms,
               # we can skip the `is_annotated()` check in the next call:
>>>>>>         annotated_type, sub_meta = _unpack_annotated_inner(
>>>>>>             annotated_type, unpack_type_aliases=unpack_type_aliases, check_annotated=False
               )
>>>>>>         metadata = sub_meta + metadata
>>>>>>         return annotated_type, metadata
>>>>>>     elif typing_objects.is_typealiastype(annotation):
>>>>>>         try:
>>>>>>             value = annotation.__value__
>>>>>>         except NameError:
>>>>>>             if unpack_type_aliases == 'eager':
>>>>>>                 raise
               else:
>>>>>>             typ, metadata = _unpack_annotated_inner(
>>>>>>                 value, unpack_type_aliases=unpack_type_aliases, check_annotated=True
                   )
>>>>>>             if metadata:
                       # Having metadata means the type alias' `__value__` was an `Annotated` form
                       # (or, recursively, a type alias to an `Annotated` form). It is important to check
                       # for this, as we don't want to unpack other type aliases (e.g. `type MyInt = int`).
>>>>>>                 return typ, metadata
>>>>>>             return annotation, []
>>>>>>     elif typing_objects.is_typealiastype(origin):
               # When parameterized, PEP 695 type aliases become generic aliases
               # (e.g. with `type MyList[T] = Annotated[list[T], ...]`, `MyList[int]`
               # is a generic alias).
>>>>>>         try:
>>>>>>             value = origin.__value__
>>>>>>         except NameError:
>>>>>>             if unpack_type_aliases == 'eager':
>>>>>>                 raise
               else:
                   # While Python already handles type variable replacement for simple `Annotated` forms,
                   # we need to manually apply the same logic for PEP 695 type aliases:
                   # - With `MyList = Annotated[list[T], ...]`, `MyList[int] == Annotated[list[int], ...]`
                   # - With `type MyList[T] = Annotated[list[T], ...]`, `MyList[int].__value__ == Annotated[list[T], ...]`.
       
>>>>>>             try:
                       # To do so, we emulate the parameterization of the value with the arguments:
                       # with `type MyList[T] = Annotated[list[T], ...]`, to emulate `MyList[int]`,
                       # we do `Annotated[list[T], ...][int]` (which gives `Annotated[list[T], ...]`):
>>>>>>                 value = value[annotation.__args__]
>>>>>>             except TypeError:
                       # Might happen if the type alias is parameterized, but its value doesn't have any
                       # type variables, e.g. `type MyInt[T] = int`.
>>>>>>                 pass
>>>>>>             typ, metadata = _unpack_annotated_inner(
>>>>>>                 value, unpack_type_aliases=unpack_type_aliases, check_annotated=True
                   )
>>>>>>             if metadata:
>>>>>>                 return typ, metadata
>>>>>>             return annotation, []
       
>>>>>>     return annotation, []
       
       
       # This could eventually be made public:
    4: def _unpack_annotated(
    3:     annotation: Any, /, *, unpack_type_aliases: Literal['skip', 'lenient', 'eager'] = 'eager'
    1: ) -> tuple[Any, list[Any]]:
  779:     if unpack_type_aliases == 'skip':
  779:         if typing_objects.is_annotated(get_origin(annotation)):
    6:             return annotation.__origin__, list(annotation.__metadata__)
               else:
  773:             return annotation, []
       
>>>>>>     return _unpack_annotated_inner(annotation, unpack_type_aliases=unpack_type_aliases, check_annotated=True)
