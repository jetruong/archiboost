    1: from __future__ import annotations
       
    1: import dataclasses
    1: from datetime import datetime
    1: from datetime import timedelta
    1: from typing import Any
    1: from typing import TYPE_CHECKING
       
    1: from _pytest import nodes
    1: from _pytest.cacheprovider import Cache
    1: from _pytest.config import Config
    1: from _pytest.config.argparsing import Parser
    1: from _pytest.main import Session
    1: from _pytest.reports import TestReport
       
       
    1: if TYPE_CHECKING:
>>>>>>     from typing_extensions import Self
       
    1: STEPWISE_CACHE_DIR = "cache/stepwise"
       
       
    1: def pytest_addoption(parser: Parser) -> None:
    1:     group = parser.getgroup("general")
    2:     group.addoption(
    1:         "--sw",
    1:         "--stepwise",
    1:         action="store_true",
    1:         default=False,
    1:         dest="stepwise",
    1:         help="Exit on test failure and continue from last failing test next time",
           )
    2:     group.addoption(
    1:         "--sw-skip",
    1:         "--stepwise-skip",
    1:         action="store_true",
    1:         default=False,
    1:         dest="stepwise_skip",
    1:         help="Ignore the first failing test but stop on the next failing test. "
               "Implicitly enables --stepwise.",
           )
    2:     group.addoption(
    1:         "--sw-reset",
    1:         "--stepwise-reset",
    1:         action="store_true",
    1:         default=False,
    1:         dest="stepwise_reset",
    1:         help="Resets stepwise state, restarting the stepwise workflow. "
               "Implicitly enables --stepwise.",
           )
       
       
    1: def pytest_configure(config: Config) -> None:
           # --stepwise-skip/--stepwise-reset implies stepwise.
    1:     if config.option.stepwise_skip or config.option.stepwise_reset:
>>>>>>         config.option.stepwise = True
    1:     if config.getoption("stepwise"):
>>>>>>         config.pluginmanager.register(StepwisePlugin(config), "stepwiseplugin")
       
       
    1: def pytest_sessionfinish(session: Session) -> None:
    1:     if not session.config.getoption("stepwise"):
    1:         assert session.config.cache is not None
    1:         if hasattr(session.config, "workerinput"):
                   # Do not update cache if this process is a xdist worker to prevent
                   # race conditions (#10641).
>>>>>>             return
       
       
    3: @dataclasses.dataclass
    2: class StepwiseCacheInfo:
           # The nodeid of the last failed test.
    1:     last_failed: str | None
       
           # The number of tests in the last time --stepwise was run.
           # We use this information as a simple way to invalidate the cache information, avoiding
           # confusing behavior in case the cache is stale.
    1:     last_test_count: int | None
       
           # The date when the cache was last updated, for information purposes only.
    1:     last_cache_date_str: str
       
    2:     @property
    2:     def last_cache_date(self) -> datetime:
>>>>>>         return datetime.fromisoformat(self.last_cache_date_str)
       
    2:     @classmethod
    2:     def empty(cls) -> Self:
>>>>>>         return cls(
>>>>>>             last_failed=None,
>>>>>>             last_test_count=None,
>>>>>>             last_cache_date_str=datetime.now().isoformat(),
               )
       
    1:     def update_date_to_now(self) -> None:
>>>>>>         self.last_cache_date_str = datetime.now().isoformat()
       
       
    2: class StepwisePlugin:
    1:     def __init__(self, config: Config) -> None:
>>>>>>         self.config = config
>>>>>>         self.session: Session | None = None
>>>>>>         self.report_status: list[str] = []
>>>>>>         assert config.cache is not None
>>>>>>         self.cache: Cache = config.cache
>>>>>>         self.skip: bool = config.getoption("stepwise_skip")
>>>>>>         self.reset: bool = config.getoption("stepwise_reset")
>>>>>>         self.cached_info = self._load_cached_info()
       
    1:     def _load_cached_info(self) -> StepwiseCacheInfo:
>>>>>>         cached_dict: dict[str, Any] | None = self.cache.get(STEPWISE_CACHE_DIR, None)
>>>>>>         if cached_dict:
>>>>>>             try:
>>>>>>                 return StepwiseCacheInfo(
>>>>>>                     cached_dict["last_failed"],
>>>>>>                     cached_dict["last_test_count"],
>>>>>>                     cached_dict["last_cache_date_str"],
                       )
>>>>>>             except (KeyError, TypeError) as e:
>>>>>>                 error = f"{type(e).__name__}: {e}"
>>>>>>                 self.report_status.append(f"error reading cache, discarding ({error})")
       
               # Cache not found or error during load, return a new cache.
>>>>>>         return StepwiseCacheInfo.empty()
       
    1:     def pytest_sessionstart(self, session: Session) -> None:
>>>>>>         self.session = session
       
    4:     def pytest_collection_modifyitems(
    2:         self, config: Config, items: list[nodes.Item]
    1:     ) -> None:
>>>>>>         last_test_count = self.cached_info.last_test_count
>>>>>>         self.cached_info.last_test_count = len(items)
       
>>>>>>         if self.reset:
>>>>>>             self.report_status.append("resetting state, not skipping.")
>>>>>>             self.cached_info.last_failed = None
>>>>>>             return
       
>>>>>>         if not self.cached_info.last_failed:
>>>>>>             self.report_status.append("no previously failed tests, not skipping.")
>>>>>>             return
       
>>>>>>         if last_test_count is not None and last_test_count != len(items):
>>>>>>             self.report_status.append(
>>>>>>                 f"test count changed, not skipping (now {len(items)} tests, previously {last_test_count})."
                   )
>>>>>>             self.cached_info.last_failed = None
>>>>>>             return
       
               # Check all item nodes until we find a match on last failed.
>>>>>>         failed_index = None
>>>>>>         for index, item in enumerate(items):
>>>>>>             if item.nodeid == self.cached_info.last_failed:
>>>>>>                 failed_index = index
>>>>>>                 break
       
               # If the previously failed test was not found among the test items,
               # do not skip any tests.
>>>>>>         if failed_index is None:
>>>>>>             self.report_status.append("previously failed test not found, not skipping.")
               else:
>>>>>>             cache_age = datetime.now() - self.cached_info.last_cache_date
                   # Round up to avoid showing microseconds.
>>>>>>             cache_age = timedelta(seconds=int(cache_age.total_seconds()))
>>>>>>             self.report_status.append(
>>>>>>                 f"skipping {failed_index} already passed items (cache from {cache_age} ago,"
                       f" use --sw-reset to discard)."
                   )
>>>>>>             deselected = items[:failed_index]
>>>>>>             del items[:failed_index]
>>>>>>             config.hook.pytest_deselected(items=deselected)
       
    1:     def pytest_runtest_logreport(self, report: TestReport) -> None:
>>>>>>         if report.failed:
>>>>>>             if self.skip:
                       # Remove test from the failed ones (if it exists) and unset the skip option
                       # to make sure the following tests will not be skipped.
>>>>>>                 if report.nodeid == self.cached_info.last_failed:
>>>>>>                     self.cached_info.last_failed = None
       
>>>>>>                 self.skip = False
                   else:
                       # Mark test as the last failing and interrupt the test session.
>>>>>>                 self.cached_info.last_failed = report.nodeid
>>>>>>                 assert self.session is not None
>>>>>>                 self.session.shouldstop = (
>>>>>>                     "Test failed, continuing from this test next run."
                       )
       
               else:
                   # If the test was actually run and did pass.
>>>>>>             if report.when == "call":
                       # Remove test from the failed ones, if exists.
>>>>>>                 if report.nodeid == self.cached_info.last_failed:
>>>>>>                     self.cached_info.last_failed = None
       
    1:     def pytest_report_collectionfinish(self) -> list[str] | None:
>>>>>>         if self.config.get_verbosity() >= 0 and self.report_status:
>>>>>>             return [f"stepwise: {x}" for x in self.report_status]
>>>>>>         return None
       
    1:     def pytest_sessionfinish(self) -> None:
>>>>>>         if hasattr(self.config, "workerinput"):
                   # Do not update cache if this process is a xdist worker to prevent
                   # race conditions (#10641).
>>>>>>             return
>>>>>>         self.cached_info.update_date_to_now()
>>>>>>         self.cache.set(STEPWISE_CACHE_DIR, dataclasses.asdict(self.cached_info))
