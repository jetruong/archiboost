    1: from __future__ import annotations
       
    1: import dataclasses
    1: from inspect import Parameter, Signature, signature
    1: from typing import TYPE_CHECKING, Any, Callable
       
    1: from pydantic_core import PydanticUndefined
       
    1: from ._utils import is_valid_identifier
       
    1: if TYPE_CHECKING:
>>>>>>     from ..config import ExtraValues
>>>>>>     from ..fields import FieldInfo
       
       
       # Copied over from stdlib dataclasses
    2: class _HAS_DEFAULT_FACTORY_CLASS:
    1:     def __repr__(self):
>>>>>>         return '<factory>'
       
       
    1: _HAS_DEFAULT_FACTORY = _HAS_DEFAULT_FACTORY_CLASS()
       
       
    1: def _field_name_for_signature(field_name: str, field_info: FieldInfo) -> str:
           """Extract the correct name to use for the field when generating a signature.
       
           Assuming the field has a valid alias, this will return the alias. Otherwise, it will return the field name.
           First priority is given to the alias, then the validation_alias, then the field name.
       
           Args:
               field_name: The name of the field
               field_info: The corresponding FieldInfo object.
       
           Returns:
               The correct name to use when generating a signature.
           """
   18:     if isinstance(field_info.alias, str) and is_valid_identifier(field_info.alias):
>>>>>>         return field_info.alias
   18:     if isinstance(field_info.validation_alias, str) and is_valid_identifier(field_info.validation_alias):
>>>>>>         return field_info.validation_alias
       
   18:     return field_name
       
       
    1: def _process_param_defaults(param: Parameter) -> Parameter:
           """Modify the signature for a parameter in a dataclass where the default value is a FieldInfo instance.
       
           Args:
               param (Parameter): The parameter
       
           Returns:
               Parameter: The custom processed parameter
           """
>>>>>>     from ..fields import FieldInfo
       
>>>>>>     param_default = param.default
>>>>>>     if isinstance(param_default, FieldInfo):
>>>>>>         annotation = param.annotation
               # Replace the annotation if appropriate
               # inspect does "clever" things to show annotations as strings because we have
               # `from __future__ import annotations` in main, we don't want that
>>>>>>         if annotation == 'Any':
>>>>>>             annotation = Any
       
               # Replace the field default
>>>>>>         default = param_default.default
>>>>>>         if default is PydanticUndefined:
>>>>>>             if param_default.default_factory is PydanticUndefined:
>>>>>>                 default = Signature.empty
                   else:
                       # this is used by dataclasses to indicate a factory exists:
>>>>>>                 default = dataclasses._HAS_DEFAULT_FACTORY  # type: ignore
>>>>>>         return param.replace(
>>>>>>             annotation=annotation, name=_field_name_for_signature(param.name, param_default), default=default
               )
>>>>>>     return param
       
       
    6: def _generate_signature_parameters(  # noqa: C901 (ignore complexity, could use a refactor)
    1:     init: Callable[..., None],
    1:     fields: dict[str, FieldInfo],
    1:     validate_by_name: bool,
    1:     extra: ExtraValues | None,
    1: ) -> dict[str, Parameter]:
           """Generate a mapping of parameter names to Parameter objects for a pydantic BaseModel or dataclass."""
    3:     from itertools import islice
       
    3:     present_params = signature(init).parameters.values()
    3:     merged_params: dict[str, Parameter] = {}
    3:     var_kw = None
    3:     use_var_kw = False
       
    6:     for param in islice(present_params, 1, None):  # skip self arg
               # inspect does "clever" things to show annotations as strings because we have
               # `from __future__ import annotations` in main, we don't want that
    3:         if fields.get(param.name):
                   # exclude params with init=False
>>>>>>             if getattr(fields[param.name], 'init', True) is False:
>>>>>>                 continue
>>>>>>             param = param.replace(name=_field_name_for_signature(param.name, fields[param.name]))
    3:         if param.annotation == 'Any':
    3:             param = param.replace(annotation=Any)
    3:         if param.kind is param.VAR_KEYWORD:
    3:             var_kw = param
    3:             continue
>>>>>>         merged_params[param.name] = param
       
    3:     if var_kw:  # if custom init has no var_kw, fields which are not declared in it cannot be passed through
    3:         allow_names = validate_by_name
   21:         for field_name, field in fields.items():
                   # when alias is a str it should be used for signature generation
   18:             param_name = _field_name_for_signature(field_name, field)
       
   18:             if field_name in merged_params or param_name in merged_params:
>>>>>>                 continue
       
   18:             if not is_valid_identifier(param_name):
>>>>>>                 if allow_names:
>>>>>>                     param_name = field_name
                       else:
>>>>>>                     use_var_kw = True
>>>>>>                     continue
       
   18:             if field.is_required():
>>>>>>                 default = Parameter.empty
   18:             elif field.default_factory is not None:
                       # Mimics stdlib dataclasses:
    3:                 default = _HAS_DEFAULT_FACTORY
                   else:
   15:                 default = field.default
   36:             merged_params[param_name] = Parameter(
   18:                 param_name,
   18:                 Parameter.KEYWORD_ONLY,
   18:                 annotation=field.rebuild_annotation(),
   18:                 default=default,
                   )
       
    3:     if extra == 'allow':
>>>>>>         use_var_kw = True
       
    3:     if var_kw and use_var_kw:
               # Make sure the parameter for extra kwargs
               # does not have the same name as a field
>>>>>>         default_model_signature = [
>>>>>>             ('self', Parameter.POSITIONAL_ONLY),
>>>>>>             ('data', Parameter.VAR_KEYWORD),
               ]
>>>>>>         if [(p.name, p.kind) for p in present_params] == default_model_signature:
                   # if this is the standard model signature, use extra_data as the extra args name
>>>>>>             var_kw_name = 'extra_data'
               else:
                   # else start from var_kw
>>>>>>             var_kw_name = var_kw.name
       
               # generate a name that's definitely unique
>>>>>>         while var_kw_name in fields:
>>>>>>             var_kw_name += '_'
>>>>>>         merged_params[var_kw_name] = var_kw.replace(name=var_kw_name)
       
    3:     return merged_params
       
       
    7: def generate_pydantic_signature(
    1:     init: Callable[..., None],
    1:     fields: dict[str, FieldInfo],
    1:     validate_by_name: bool,
    1:     extra: ExtraValues | None,
    2:     is_dataclass: bool = False,
    1: ) -> Signature:
           """Generate signature for a pydantic BaseModel or dataclass.
       
           Args:
               init: The class init.
               fields: The model fields.
               validate_by_name: The `validate_by_name` value of the config.
               extra: The `extra` value of the config.
               is_dataclass: Whether the model is a dataclass.
       
           Returns:
               The dataclass/BaseModel subclass signature.
           """
    3:     merged_params = _generate_signature_parameters(init, fields, validate_by_name, extra)
       
    3:     if is_dataclass:
>>>>>>         merged_params = {k: _process_param_defaults(v) for k, v in merged_params.items()}
       
    3:     return Signature(parameters=list(merged_params.values()), return_annotation=None)
