    1: import re
    1: from abc import ABCMeta, abstractmethod
    1: from typing import Iterator, Mapping, Optional, Pattern
       
    2: _posix_variable: Pattern[str] = re.compile(
    1:     r"""
           \$\{
               (?P<name>[^\}:]*)
               (?::-
                   (?P<default>[^\}]*)
               )?
           \}
           """,
    1:     re.VERBOSE,
       )
       
       
    2: class Atom(metaclass=ABCMeta):
    1:     def __ne__(self, other: object) -> bool:
>>>>>>         result = self.__eq__(other)
>>>>>>         if result is NotImplemented:
>>>>>>             return NotImplemented
>>>>>>         return not result
       
    2:     @abstractmethod
    2:     def resolve(self, env: Mapping[str, Optional[str]]) -> str: ...
       
       
    2: class Literal(Atom):
    1:     def __init__(self, value: str) -> None:
    3:         self.value = value
       
    1:     def __repr__(self) -> str:
>>>>>>         return f"Literal(value={self.value})"
       
    1:     def __eq__(self, other: object) -> bool:
>>>>>>         if not isinstance(other, self.__class__):
>>>>>>             return NotImplemented
>>>>>>         return self.value == other.value
       
    1:     def __hash__(self) -> int:
>>>>>>         return hash((self.__class__, self.value))
       
    1:     def resolve(self, env: Mapping[str, Optional[str]]) -> str:
    3:         return self.value
       
       
    2: class Variable(Atom):
    1:     def __init__(self, name: str, default: Optional[str]) -> None:
>>>>>>         self.name = name
>>>>>>         self.default = default
       
    1:     def __repr__(self) -> str:
>>>>>>         return f"Variable(name={self.name}, default={self.default})"
       
    1:     def __eq__(self, other: object) -> bool:
>>>>>>         if not isinstance(other, self.__class__):
>>>>>>             return NotImplemented
>>>>>>         return (self.name, self.default) == (other.name, other.default)
       
    1:     def __hash__(self) -> int:
>>>>>>         return hash((self.__class__, self.name, self.default))
       
    1:     def resolve(self, env: Mapping[str, Optional[str]]) -> str:
>>>>>>         default = self.default if self.default is not None else ""
>>>>>>         result = env.get(self.name, default)
>>>>>>         return result if result is not None else ""
       
       
    1: def parse_variables(value: str) -> Iterator[Atom]:
    3:     cursor = 0
       
    3:     for match in _posix_variable.finditer(value):
>>>>>>         (start, end) = match.span()
>>>>>>         name = match["name"]
>>>>>>         default = match["default"]
       
>>>>>>         if start > cursor:
>>>>>>             yield Literal(value=value[cursor:start])
       
>>>>>>         yield Variable(name=name, default=default)
>>>>>>         cursor = end
       
    3:     length = len(value)
    3:     if cursor < length:
    3:         yield Literal(value=value[cursor:length])
