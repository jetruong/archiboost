>>>>>> from collections.abc import Mapping
>>>>>> from typing import NamedTuple
       
>>>>>> from .exceptions import ParseError
       
>>>>>> COMMENTCHARS = "#;"
       
       
>>>>>> class ParsedLine(NamedTuple):
>>>>>>     lineno: int
>>>>>>     section: str | None
>>>>>>     name: str | None
>>>>>>     value: str | None
       
       
>>>>>> def parse_ini_data(
>>>>>>     path: str,
>>>>>>     data: str,
           *,
>>>>>>     strip_inline_comments: bool,
>>>>>>     strip_section_whitespace: bool = False,
>>>>>> ) -> tuple[Mapping[str, Mapping[str, str]], Mapping[tuple[str, str | None], int]]:
           """Parse INI data and return sections and sources mappings.
       
           Args:
               path: Path for error messages
               data: INI content as string
               strip_inline_comments: Whether to strip inline comments from values
               strip_section_whitespace: Whether to strip whitespace from section and key names
                   (default: False). When True, addresses issue #4 by stripping Unicode whitespace.
       
           Returns:
               Tuple of (sections_data, sources) where:
               - sections_data: mapping of section -> {name -> value}
               - sources: mapping of (section, name) -> line number
           """
    2:     tokens = parse_lines(
    1:         path,
    1:         data.splitlines(True),
    1:         strip_inline_comments=strip_inline_comments,
    1:         strip_section_whitespace=strip_section_whitespace,
           )
       
    1:     sources: dict[tuple[str, str | None], int] = {}
    1:     sections_data: dict[str, dict[str, str]] = {}
       
    8:     for lineno, section, name, value in tokens:
    7:         if section is None:
>>>>>>             raise ParseError(path, lineno, "no section header defined")
    7:         sources[section, name] = lineno
    7:         if name is None:
    1:             if section in sections_data:
>>>>>>                 raise ParseError(path, lineno, f"duplicate section {section!r}")
    1:             sections_data[section] = {}
               else:
    6:             if name in sections_data[section]:
>>>>>>                 raise ParseError(path, lineno, f"duplicate name {name!r}")
    6:             assert value is not None
    6:             sections_data[section][name] = value
       
    1:     return sections_data, sources
       
       
>>>>>> def parse_lines(
>>>>>>     path: str,
>>>>>>     line_iter: list[str],
           *,
>>>>>>     strip_inline_comments: bool = False,
>>>>>>     strip_section_whitespace: bool = False,
>>>>>> ) -> list[ParsedLine]:
    1:     result: list[ParsedLine] = []
    1:     section = None
    8:     for lineno, line in enumerate(line_iter):
   14:         name, data = _parseline(
    7:             path, line, lineno, strip_inline_comments, strip_section_whitespace
               )
               # new value
    7:         if name is not None and data is not None:
    6:             result.append(ParsedLine(lineno, section, name, data))
               # new section
    1:         elif name is not None and data is None:
    1:             if not name:
>>>>>>                 raise ParseError(path, lineno, "empty section name")
    1:             section = name
    1:             result.append(ParsedLine(lineno, section, None, None))
               # continuation
>>>>>>         elif name is None and data is not None:
>>>>>>             if not result:
>>>>>>                 raise ParseError(path, lineno, "unexpected value continuation")
>>>>>>             last = result.pop()
>>>>>>             if last.name is None:
>>>>>>                 raise ParseError(path, lineno, "unexpected value continuation")
       
>>>>>>             if last.value:
>>>>>>                 last = last._replace(value=f"{last.value}\n{data}")
                   else:
>>>>>>                 last = last._replace(value=data)
>>>>>>             result.append(last)
    1:     return result
       
       
>>>>>> def _parseline(
>>>>>>     path: str,
>>>>>>     line: str,
>>>>>>     lineno: int,
>>>>>>     strip_inline_comments: bool,
>>>>>>     strip_section_whitespace: bool,
>>>>>> ) -> tuple[str | None, str | None]:
           # blank lines
    7:     if iscommentline(line):
>>>>>>         line = ""
           else:
    7:         line = line.rstrip()
    7:     if not line:
>>>>>>         return None, None
           # section
    7:     if line[0] == "[":
    1:         realline = line
    3:         for c in COMMENTCHARS:
    2:             line = line.split(c)[0].rstrip()
    1:         if line[-1] == "]":
    1:             section_name = line[1:-1]
                   # Optionally strip whitespace from section name (issue #4)
    1:             if strip_section_whitespace:
>>>>>>                 section_name = section_name.strip()
    1:             return section_name, None
>>>>>>         return None, realline.strip()
           # value
    6:     elif not line[0].isspace():
    6:         try:
    6:             name, value = line.split("=", 1)
    6:             if ":" in name:
>>>>>>                 raise ValueError()
>>>>>>         except ValueError:
>>>>>>             try:
>>>>>>                 name, value = line.split(":", 1)
>>>>>>             except ValueError:
>>>>>>                 raise ParseError(path, lineno, f"unexpected line: {line!r}") from None
       
               # Strip key name (always for backward compatibility, optionally with unicode awareness)
    6:         key_name = name.strip()
       
               # Strip value
    6:         value = value.strip()
               # Strip inline comments from values if requested (issue #55)
    6:         if strip_inline_comments:
>>>>>>             for c in COMMENTCHARS:
>>>>>>                 value = value.split(c)[0].rstrip()
       
    6:         return key_name, value
           # continuation
           else:
>>>>>>         line = line.strip()
               # Strip inline comments from continuations if requested (issue #55)
>>>>>>         if strip_inline_comments:
>>>>>>             for c in COMMENTCHARS:
>>>>>>                 line = line.split(c)[0].rstrip()
>>>>>>         return None, line
       
       
>>>>>> def iscommentline(line: str) -> bool:
    7:     c = line.lstrip()[:1]
    7:     return c in COMMENTCHARS
