    1: from __future__ import annotations
       
    1: import socket
    1: import sys
    1: from collections.abc import Callable, Generator, Iterator
    1: from contextlib import ExitStack, contextmanager
    1: from inspect import isasyncgenfunction, iscoroutinefunction, ismethod
    1: from typing import Any, cast
       
    1: import pytest
    1: from _pytest.fixtures import SubRequest
    1: from _pytest.outcomes import Exit
       
    1: from . import get_available_backends
    1: from ._core._eventloop import (
           current_async_library,
           get_async_backend,
           reset_current_async_library,
           set_current_async_library,
       )
    1: from ._core._exceptions import iterate_exceptions
    1: from .abc import TestRunner
       
    1: if sys.version_info < (3, 11):
>>>>>>     from exceptiongroup import ExceptionGroup
       
    1: _current_runner: TestRunner | None = None
    1: _runner_stack: ExitStack | None = None
    1: _runner_leases = 0
       
       
    1: def extract_backend_and_options(backend: object) -> tuple[str, dict[str, Any]]:
>>>>>>     if isinstance(backend, str):
>>>>>>         return backend, {}
>>>>>>     elif isinstance(backend, tuple) and len(backend) == 2:
>>>>>>         if isinstance(backend[0], str) and isinstance(backend[1], dict):
>>>>>>             return cast(tuple[str, dict[str, Any]], backend)
       
>>>>>>     raise TypeError("anyio_backend must be either a string or tuple of (string, dict)")
       
       
    2: @contextmanager
    5: def get_runner(
    2:     backend_name: str, backend_options: dict[str, Any]
    1: ) -> Iterator[TestRunner]:
           global _current_runner, _runner_leases, _runner_stack
>>>>>>     if _current_runner is None:
>>>>>>         asynclib = get_async_backend(backend_name)
>>>>>>         _runner_stack = ExitStack()
>>>>>>         if current_async_library() is None:
                   # Since we're in control of the event loop, we can cache the name of the
                   # async library
>>>>>>             token = set_current_async_library(backend_name)
>>>>>>             _runner_stack.callback(reset_current_async_library, token)
       
>>>>>>         backend_options = backend_options or {}
>>>>>>         _current_runner = _runner_stack.enter_context(
>>>>>>             asynclib.create_test_runner(backend_options)
               )
       
>>>>>>     _runner_leases += 1
>>>>>>     try:
>>>>>>         yield _current_runner
           finally:
>>>>>>         _runner_leases -= 1
>>>>>>         if not _runner_leases:
>>>>>>             assert _runner_stack is not None
>>>>>>             _runner_stack.close()
>>>>>>             _runner_stack = _current_runner = None
       
       
    1: def pytest_addoption(parser: pytest.Parser) -> None:
    2:     parser.addini(
    1:         "anyio_mode",
    1:         default="strict",
    1:         help='AnyIO plugin mode (either "strict" or "auto")',
           )
       
       
    1: def pytest_configure(config: pytest.Config) -> None:
    2:     config.addinivalue_line(
    1:         "markers",
    1:         "anyio: mark the (coroutine function) test to be run asynchronously via anyio.",
           )
           if (
    1:         config.getini("anyio_mode") == "auto"
>>>>>>         and config.pluginmanager.has_plugin("asyncio")
>>>>>>         and config.getini("asyncio_mode") == "auto"
           ):
>>>>>>         config.issue_config_time_warning(
>>>>>>             pytest.PytestConfigWarning(
>>>>>>                 "AnyIO auto mode has been enabled together with pytest-asyncio auto "
                       "mode. This may cause unexpected behavior."
                   ),
>>>>>>             1,
               )
       
       
    2: @pytest.hookimpl(hookwrapper=True)
    2: def pytest_fixture_setup(fixturedef: Any, request: Any) -> Generator[Any]:
   61:     def wrapper(anyio_backend: Any, request: SubRequest, **kwargs: Any) -> Any:
               # Rebind any fixture methods to the request instance
               if (
>>>>>>             request.instance
>>>>>>             and ismethod(func)
>>>>>>             and type(func.__self__) is type(request.instance)
               ):
>>>>>>             local_func = func.__func__.__get__(request.instance)
               else:
>>>>>>             local_func = func
       
>>>>>>         backend_name, backend_options = extract_backend_and_options(anyio_backend)
>>>>>>         if has_backend_arg:
>>>>>>             kwargs["anyio_backend"] = anyio_backend
       
>>>>>>         if has_request_arg:
>>>>>>             kwargs["request"] = request
       
>>>>>>         with get_runner(backend_name, backend_options) as runner:
>>>>>>             if isasyncgenfunction(local_func):
>>>>>>                 yield from runner.run_asyncgen_fixture(local_func, kwargs)
                   else:
>>>>>>                 yield runner.run_fixture(local_func, kwargs)
       
           # Only apply this to coroutine functions and async generator functions in requests
           # that involve the anyio_backend fixture
   61:     func = fixturedef.func
   61:     if isasyncgenfunction(func) or iscoroutinefunction(func):
>>>>>>         if "anyio_backend" in request.fixturenames:
>>>>>>             fixturedef.func = wrapper
>>>>>>             original_argname = fixturedef.argnames
       
>>>>>>             if not (has_backend_arg := "anyio_backend" in fixturedef.argnames):
>>>>>>                 fixturedef.argnames += ("anyio_backend",)
       
>>>>>>             if not (has_request_arg := "request" in fixturedef.argnames):
>>>>>>                 fixturedef.argnames += ("request",)
       
>>>>>>             try:
>>>>>>                 return (yield)
                   finally:
>>>>>>                 fixturedef.func = func
>>>>>>                 fixturedef.argnames = original_argname
       
   61:     return (yield)
       
       
    2: @pytest.hookimpl(tryfirst=True)
    6: def pytest_pycollect_makeitem(
    3:     collector: pytest.Module | pytest.Class, name: str, obj: object
    1: ) -> None:
  176:     if collector.istestfunction(obj, name):
   89:         inner_func = obj.hypothesis.inner_test if hasattr(obj, "hypothesis") else obj
   89:         if iscoroutinefunction(inner_func):
>>>>>>             anyio_auto_mode = collector.config.getini("anyio_mode") == "auto"
>>>>>>             marker = collector.get_closest_marker("anyio")
>>>>>>             own_markers = getattr(obj, "pytestmark", ())
                   if (
>>>>>>                 anyio_auto_mode
>>>>>>                 or marker
>>>>>>                 or any(marker.name == "anyio" for marker in own_markers)
                   ):
>>>>>>                 pytest.mark.usefixtures("anyio_backend")(obj)
       
       
    2: @pytest.hookimpl(tryfirst=True)
    2: def pytest_pyfunc_call(pyfuncitem: Any) -> bool | None:
   89:     def run_with_hypothesis(**kwargs: Any) -> None:
>>>>>>         with get_runner(backend_name, backend_options) as runner:
>>>>>>             runner.run_test(original_func, kwargs)
       
   89:     backend = pyfuncitem.funcargs.get("anyio_backend")
   89:     if backend:
>>>>>>         backend_name, backend_options = extract_backend_and_options(backend)
       
>>>>>>         if hasattr(pyfuncitem.obj, "hypothesis"):
                   # Wrap the inner test function unless it's already wrapped
>>>>>>             original_func = pyfuncitem.obj.hypothesis.inner_test
>>>>>>             if original_func.__qualname__ != run_with_hypothesis.__qualname__:
>>>>>>                 if iscoroutinefunction(original_func):
>>>>>>                     pyfuncitem.obj.hypothesis.inner_test = run_with_hypothesis
       
>>>>>>             return None
       
>>>>>>         if iscoroutinefunction(pyfuncitem.obj):
>>>>>>             funcargs = pyfuncitem.funcargs
>>>>>>             testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>>>>>>             with get_runner(backend_name, backend_options) as runner:
>>>>>>                 try:
>>>>>>                     runner.run_test(pyfuncitem.obj, testargs)
>>>>>>                 except ExceptionGroup as excgrp:
>>>>>>                     for exc in iterate_exceptions(excgrp):
>>>>>>                         if isinstance(exc, (Exit, KeyboardInterrupt, SystemExit)):
>>>>>>                             raise exc from excgrp
       
>>>>>>                     raise
       
>>>>>>             return True
       
   89:     return None
       
       
    2: @pytest.fixture(scope="module", params=get_available_backends())
    2: def anyio_backend(request: Any) -> Any:
>>>>>>     return request.param
       
       
    2: @pytest.fixture
    2: def anyio_backend_name(anyio_backend: Any) -> str:
>>>>>>     if isinstance(anyio_backend, str):
>>>>>>         return anyio_backend
           else:
>>>>>>         return anyio_backend[0]
       
       
    2: @pytest.fixture
    2: def anyio_backend_options(anyio_backend: Any) -> dict[str, Any]:
>>>>>>     if isinstance(anyio_backend, str):
>>>>>>         return {}
           else:
>>>>>>         return anyio_backend[1]
       
       
    2: class FreePortFactory:
    1:     """
           Manages port generation based on specified socket kind, ensuring no duplicate
           ports are generated.
       
           This class provides functionality for generating available free ports on the
           system. It is initialized with a specific socket kind and can generate ports
           for given address families while avoiding reuse of previously generated ports.
       
           Users should not instantiate this class directly, but use the
           ``free_tcp_port_factory`` and ``free_udp_port_factory`` fixtures instead. For simple
           uses cases, ``free_tcp_port`` and ``free_udp_port`` can be used instead.
           """
       
    1:     def __init__(self, kind: socket.SocketKind) -> None:
>>>>>>         self._kind = kind
>>>>>>         self._generated = set[int]()
       
    2:     @property
    2:     def kind(self) -> socket.SocketKind:
               """
               The type of socket connection (e.g., :data:`~socket.SOCK_STREAM` or
               :data:`~socket.SOCK_DGRAM`) used to bind for checking port availability
       
               """
>>>>>>         return self._kind
       
    1:     def __call__(self, family: socket.AddressFamily | None = None) -> int:
               """
               Return an unbound port for the given address family.
       
               :param family: if omitted, both IPv4 and IPv6 addresses will be tried
               :return: a port number
       
               """
>>>>>>         if family is not None:
>>>>>>             families = [family]
               else:
>>>>>>             families = [socket.AF_INET]
>>>>>>             if socket.has_ipv6:
>>>>>>                 families.append(socket.AF_INET6)
       
>>>>>>         while True:
>>>>>>             port = 0
>>>>>>             with ExitStack() as stack:
>>>>>>                 for family in families:
>>>>>>                     sock = stack.enter_context(socket.socket(family, self._kind))
>>>>>>                     addr = "::1" if family == socket.AF_INET6 else "127.0.0.1"
>>>>>>                     try:
>>>>>>                         sock.bind((addr, port))
>>>>>>                     except OSError:
>>>>>>                         break
       
>>>>>>                     if not port:
>>>>>>                         port = sock.getsockname()[1]
                       else:
>>>>>>                     if port not in self._generated:
>>>>>>                         self._generated.add(port)
>>>>>>                         return port
       
       
    2: @pytest.fixture(scope="session")
    2: def free_tcp_port_factory() -> FreePortFactory:
>>>>>>     return FreePortFactory(socket.SOCK_STREAM)
       
       
    2: @pytest.fixture(scope="session")
    2: def free_udp_port_factory() -> FreePortFactory:
>>>>>>     return FreePortFactory(socket.SOCK_DGRAM)
       
       
    2: @pytest.fixture
    2: def free_tcp_port(free_tcp_port_factory: Callable[[], int]) -> int:
>>>>>>     return free_tcp_port_factory()
       
       
    2: @pytest.fixture
    2: def free_udp_port(free_udp_port_factory: Callable[[], int]) -> int:
>>>>>>     return free_udp_port_factory()
