    1: from __future__ import annotations
       
    1: __all__ = (
           "BlockingPortal",
           "BlockingPortalProvider",
           "check_cancelled",
           "run",
           "run_sync",
           "start_blocking_portal",
       )
       
    1: import sys
    1: from collections.abc import Awaitable, Callable, Generator
    1: from concurrent.futures import Future
    1: from contextlib import (
           AbstractAsyncContextManager,
           AbstractContextManager,
           contextmanager,
       )
    1: from dataclasses import dataclass, field
    1: from functools import partial
    1: from inspect import isawaitable
    1: from threading import Lock, Thread, current_thread, get_ident
    1: from types import TracebackType
    1: from typing import (
           Any,
           Generic,
           TypeVar,
           cast,
           overload,
       )
       
    1: from ._core._eventloop import (
           get_cancelled_exc_class,
           threadlocals,
       )
    1: from ._core._eventloop import run as run_eventloop
    1: from ._core._exceptions import NoEventLoopError
    1: from ._core._synchronization import Event
    1: from ._core._tasks import CancelScope, create_task_group
    1: from .abc._tasks import TaskStatus
    1: from .lowlevel import EventLoopToken, current_token
       
    1: if sys.version_info >= (3, 11):
    1:     from typing import TypeVarTuple, Unpack
       else:
>>>>>>     from typing_extensions import TypeVarTuple, Unpack
       
    1: T_Retval = TypeVar("T_Retval")
    1: T_co = TypeVar("T_co", covariant=True)
    1: PosArgsT = TypeVarTuple("PosArgsT")
       
       
    1: def _token_or_error(token: EventLoopToken | None) -> EventLoopToken:
   27:     if token is not None:
   27:         return token
       
>>>>>>     try:
>>>>>>         return threadlocals.current_token
>>>>>>     except AttributeError:
>>>>>>         raise NoEventLoopError(
>>>>>>             "Not running inside an AnyIO worker thread, and no event loop token was "
                   "provided"
>>>>>>         ) from None
       
       
    5: def run(
    1:     func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval]],
    1:     *args: Unpack[PosArgsT],
    2:     token: EventLoopToken | None = None,
    1: ) -> T_Retval:
           """
           Call a coroutine function from a worker thread.
       
           :param func: a coroutine function
           :param args: positional arguments for the callable
           :param token: an event loop token to use to get back to the event loop thread
               (required if calling this function from outside an AnyIO worker thread)
           :return: the return value of the coroutine function
           :raises MissingTokenError: if no token was provided and called from outside an
               AnyIO worker thread
           :raises RunFinishedError: if the event loop tied to ``token`` is no longer running
       
           .. versionchanged:: 4.11.0
               Added the ``token`` parameter.
       
           """
>>>>>>     explicit_token = token is not None
>>>>>>     token = _token_or_error(token)
>>>>>>     return token.backend_class.run_async_from_thread(
>>>>>>         func, args, token=token.native_token if explicit_token else None
           )
       
       
    5: def run_sync(
    1:     func: Callable[[Unpack[PosArgsT]], T_Retval],
    1:     *args: Unpack[PosArgsT],
    2:     token: EventLoopToken | None = None,
    1: ) -> T_Retval:
           """
           Call a function in the event loop thread from a worker thread.
       
           :param func: a callable
           :param args: positional arguments for the callable
           :param token: an event loop token to use to get back to the event loop thread
               (required if calling this function from outside an AnyIO worker thread)
           :return: the return value of the callable
           :raises MissingTokenError: if no token was provided and called from outside an
               AnyIO worker thread
           :raises RunFinishedError: if the event loop tied to ``token`` is no longer running
       
           .. versionchanged:: 4.11.0
               Added the ``token`` parameter.
       
           """
   27:     explicit_token = token is not None
   27:     token = _token_or_error(token)
   54:     return token.backend_class.run_sync_from_thread(
   27:         func, args, token=token.native_token if explicit_token else None
           )
       
       
    2: class _BlockingAsyncContextManager(Generic[T_co], AbstractContextManager):
    1:     _enter_future: Future[T_co]
    1:     _exit_future: Future[bool | None]
    1:     _exit_event: Event
    1:     _exit_exc_info: tuple[
               type[BaseException] | None, BaseException | None, TracebackType | None
    1:     ] = (None, None, None)
       
    3:     def __init__(
    2:         self, async_cm: AbstractAsyncContextManager[T_co], portal: BlockingPortal
           ):
>>>>>>         self._async_cm = async_cm
>>>>>>         self._portal = portal
       
    1:     async def run_async_cm(self) -> bool | None:
>>>>>>         try:
>>>>>>             self._exit_event = Event()
>>>>>>             value = await self._async_cm.__aenter__()
>>>>>>         except BaseException as exc:
>>>>>>             self._enter_future.set_exception(exc)
>>>>>>             raise
               else:
>>>>>>             self._enter_future.set_result(value)
       
>>>>>>         try:
                   # Wait for the sync context manager to exit.
                   # This next statement can raise `get_cancelled_exc_class()` if
                   # something went wrong in a task group in this async context
                   # manager.
>>>>>>             await self._exit_event.wait()
               finally:
                   # In case of cancellation, it could be that we end up here before
                   # `_BlockingAsyncContextManager.__exit__` is called, and an
                   # `_exit_exc_info` has been set.
>>>>>>             result = await self._async_cm.__aexit__(*self._exit_exc_info)
       
>>>>>>         return result
       
    1:     def __enter__(self) -> T_co:
>>>>>>         self._enter_future = Future()
>>>>>>         self._exit_future = self._portal.start_task_soon(self.run_async_cm)
>>>>>>         return self._enter_future.result()
       
    5:     def __exit__(
               self,
    1:         __exc_type: type[BaseException] | None,
    1:         __exc_value: BaseException | None,
    1:         __traceback: TracebackType | None,
    1:     ) -> bool | None:
>>>>>>         self._exit_exc_info = __exc_type, __exc_value, __traceback
>>>>>>         self._portal.call(self._exit_event.set)
>>>>>>         return self._exit_future.result()
       
       
    2: class _BlockingPortalTaskStatus(TaskStatus):
    1:     def __init__(self, future: Future):
>>>>>>         self._future = future
       
    1:     def started(self, value: object = None) -> None:
>>>>>>         self._future.set_result(value)
       
       
    2: class BlockingPortal:
    1:     """
           An object that lets external threads run code in an asynchronous event loop.
       
           :raises NoEventLoopError: if no supported asynchronous event loop is running in the
               current thread
           """
       
    1:     def __init__(self) -> None:
    9:         self._token = current_token()
    9:         self._event_loop_thread_id: int | None = get_ident()
    9:         self._stop_event = Event()
    9:         self._task_group = create_task_group()
       
    1:     async def __aenter__(self) -> BlockingPortal:
    9:         await self._task_group.__aenter__()
    9:         return self
       
    5:     async def __aexit__(
               self,
    1:         exc_type: type[BaseException] | None,
    1:         exc_val: BaseException | None,
    1:         exc_tb: TracebackType | None,
    1:     ) -> bool:
    9:         await self.stop()
    9:         return await self._task_group.__aexit__(exc_type, exc_val, exc_tb)
       
    1:     def _check_running(self) -> None:
   27:         if self._event_loop_thread_id is None:
>>>>>>             raise RuntimeError("This portal is not running")
   27:         if self._event_loop_thread_id == get_ident():
>>>>>>             raise RuntimeError(
>>>>>>                 "This method cannot be called from the event loop thread"
                   )
       
    1:     async def sleep_until_stopped(self) -> None:
               """Sleep until :meth:`stop` is called."""
    9:         await self._stop_event.wait()
       
    1:     async def stop(self, cancel_remaining: bool = False) -> None:
               """
               Signal the portal to shut down.
       
               This marks the portal as no longer accepting new calls and exits from
               :meth:`sleep_until_stopped`.
       
               :param cancel_remaining: ``True`` to cancel all the remaining tasks, ``False``
                   to let them finish before returning
       
               """
   18:         self._event_loop_thread_id = None
   18:         self._stop_event.set()
   18:         if cancel_remaining:
>>>>>>             self._task_group.cancel_scope.cancel("the blocking portal is shutting down")
       
    6:     async def _call_func(
               self,
    1:         func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
    1:         args: tuple[Unpack[PosArgsT]],
    1:         kwargs: dict[str, Any],
    1:         future: Future[T_Retval],
    1:     ) -> None:
   27:         def callback(f: Future[T_Retval]) -> None:
   18:             if f.cancelled():
>>>>>>                 if self._event_loop_thread_id == get_ident():
>>>>>>                     scope.cancel("the future was cancelled")
>>>>>>                 elif self._event_loop_thread_id is not None:
>>>>>>                     self.call(scope.cancel, "the future was cancelled")
       
   27:         try:
   27:             retval_or_awaitable = func(*args, **kwargs)
   27:             if isawaitable(retval_or_awaitable):
   36:                 with CancelScope() as scope:
   18:                     future.add_done_callback(callback)
   18:                     retval = await retval_or_awaitable
                   else:
    9:                 retval = retval_or_awaitable
>>>>>>         except get_cancelled_exc_class():
>>>>>>             future.cancel()
>>>>>>             future.set_running_or_notify_cancel()
>>>>>>         except BaseException as exc:
>>>>>>             if not future.cancelled():
>>>>>>                 future.set_exception(exc)
       
                   # Let base exceptions fall through
>>>>>>             if not isinstance(exc, Exception):
>>>>>>                 raise
               else:
   27:             if not future.cancelled():
   27:                 future.set_result(retval)
               finally:
   27:             scope = None  # type: ignore[assignment]
       
    7:     def _spawn_task_from_thread(
               self,
    1:         func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
    1:         args: tuple[Unpack[PosArgsT]],
    1:         kwargs: dict[str, Any],
    1:         name: object,
    1:         future: Future[T_Retval],
    1:     ) -> None:
               """
               Spawn a new task using the given callable.
       
               :param func: a callable
               :param args: positional arguments to be passed to the callable
               :param kwargs: keyword arguments to be passed to the callable
               :param name: name of the task (will be coerced to a string if not ``None``)
               :param future: a future that will resolve to the return value of the callable,
                   or the exception raised during its execution
       
               """
   54:         run_sync(
   27:             partial(self._task_group.start_soon, name=name),
   27:             self._call_func,
   27:             func,
   27:             args,
   27:             kwargs,
   27:             future,
   27:             token=self._token,
               )
       
    2:     @overload
    5:     def call(
               self,
    1:         func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval]],
    1:         *args: Unpack[PosArgsT],
    1:     ) -> T_Retval: ...
       
    2:     @overload
    5:     def call(
    2:         self, func: Callable[[Unpack[PosArgsT]], T_Retval], *args: Unpack[PosArgsT]
    1:     ) -> T_Retval: ...
       
    4:     def call(
               self,
    1:         func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
    1:         *args: Unpack[PosArgsT],
    1:     ) -> T_Retval:
               """
               Call the given function in the event loop thread.
       
               If the callable returns a coroutine object, it is awaited on.
       
               :param func: any callable
               :raises RuntimeError: if the portal is not running or if this method is called
                   from within the event loop thread
       
               """
   27:         return cast(T_Retval, self.start_task_soon(func, *args).result())
       
    2:     @overload
    6:     def start_task_soon(
               self,
    1:         func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval]],
    1:         *args: Unpack[PosArgsT],
    2:         name: object = None,
    1:     ) -> Future[T_Retval]: ...
       
    2:     @overload
    6:     def start_task_soon(
               self,
    1:         func: Callable[[Unpack[PosArgsT]], T_Retval],
    1:         *args: Unpack[PosArgsT],
    2:         name: object = None,
    1:     ) -> Future[T_Retval]: ...
       
    5:     def start_task_soon(
               self,
    1:         func: Callable[[Unpack[PosArgsT]], Awaitable[T_Retval] | T_Retval],
    1:         *args: Unpack[PosArgsT],
    2:         name: object = None,
    1:     ) -> Future[T_Retval]:
               """
               Start a task in the portal's task group.
       
               The task will be run inside a cancel scope which can be cancelled by cancelling
               the returned future.
       
               :param func: the target function
               :param args: positional arguments passed to ``func``
               :param name: name of the task (will be coerced to a string if not ``None``)
               :return: a future that resolves with the return value of the callable if the
                   task completes successfully, or with the exception raised in the task
               :raises RuntimeError: if the portal is not running or if this method is called
                   from within the event loop thread
               :rtype: concurrent.futures.Future[T_Retval]
       
               .. versionadded:: 3.0
       
               """
   27:         self._check_running()
   27:         f: Future[T_Retval] = Future()
   27:         self._spawn_task_from_thread(func, args, {}, name, f)
   27:         return f
       
    5:     def start_task(
               self,
    1:         func: Callable[..., Awaitable[T_Retval]],
    1:         *args: object,
    2:         name: object = None,
    1:     ) -> tuple[Future[T_Retval], Any]:
               """
               Start a task in the portal's task group and wait until it signals for readiness.
       
               This method works the same way as :meth:`.abc.TaskGroup.start`.
       
               :param func: the target function
               :param args: positional arguments passed to ``func``
               :param name: name of the task (will be coerced to a string if not ``None``)
               :return: a tuple of (future, task_status_value) where the ``task_status_value``
                   is the value passed to ``task_status.started()`` from within the target
                   function
               :rtype: tuple[concurrent.futures.Future[T_Retval], Any]
       
               .. versionadded:: 3.0
       
               """
       
>>>>>>         def task_done(future: Future[T_Retval]) -> None:
>>>>>>             if not task_status_future.done():
>>>>>>                 if future.cancelled():
>>>>>>                     task_status_future.cancel()
>>>>>>                 elif future.exception():
>>>>>>                     task_status_future.set_exception(future.exception())
                       else:
>>>>>>                     exc = RuntimeError(
>>>>>>                         "Task exited without calling task_status.started()"
                           )
>>>>>>                     task_status_future.set_exception(exc)
       
>>>>>>         self._check_running()
>>>>>>         task_status_future: Future = Future()
>>>>>>         task_status = _BlockingPortalTaskStatus(task_status_future)
>>>>>>         f: Future = Future()
>>>>>>         f.add_done_callback(task_done)
>>>>>>         self._spawn_task_from_thread(func, args, {"task_status": task_status}, name, f)
>>>>>>         return f, task_status_future.result()
       
    3:     def wrap_async_context_manager(
    1:         self, cm: AbstractAsyncContextManager[T_co]
    1:     ) -> AbstractContextManager[T_co]:
               """
               Wrap an async context manager as a synchronous context manager via this portal.
       
               Spawns a task that will call both ``__aenter__()`` and ``__aexit__()``, stopping
               in the middle until the synchronous context manager exits.
       
               :param cm: an asynchronous context manager
               :return: a synchronous context manager
       
               .. versionadded:: 2.1
       
               """
>>>>>>         return _BlockingAsyncContextManager(cm, self)
       
       
    3: @dataclass
    2: class BlockingPortalProvider:
    1:     """
           A manager for a blocking portal. Used as a context manager. The first thread to
           enter this context manager causes a blocking portal to be started with the specific
           parameters, and the last thread to exit causes the portal to be shut down. Thus,
           there will be exactly one blocking portal running in this context as long as at
           least one thread has entered this context manager.
       
           The parameters are the same as for :func:`~anyio.run`.
       
           :param backend: name of the backend
           :param backend_options: backend options
       
           .. versionadded:: 4.4
           """
       
    1:     backend: str = "asyncio"
    1:     backend_options: dict[str, Any] | None = None
    1:     _lock: Lock = field(init=False, default_factory=Lock)
    1:     _leases: int = field(init=False, default=0)
    1:     _portal: BlockingPortal = field(init=False)
    2:     _portal_cm: AbstractContextManager[BlockingPortal] | None = field(
    1:         init=False, default=None
           )
       
    1:     def __enter__(self) -> BlockingPortal:
>>>>>>         with self._lock:
>>>>>>             if self._portal_cm is None:
>>>>>>                 self._portal_cm = start_blocking_portal(
>>>>>>                     self.backend, self.backend_options
                       )
>>>>>>                 self._portal = self._portal_cm.__enter__()
       
>>>>>>             self._leases += 1
>>>>>>             return self._portal
       
    5:     def __exit__(
               self,
    1:         exc_type: type[BaseException] | None,
    1:         exc_val: BaseException | None,
    1:         exc_tb: TracebackType | None,
    1:     ) -> None:
>>>>>>         portal_cm: AbstractContextManager[BlockingPortal] | None = None
>>>>>>         with self._lock:
>>>>>>             assert self._portal_cm
>>>>>>             assert self._leases > 0
>>>>>>             self._leases -= 1
>>>>>>             if not self._leases:
>>>>>>                 portal_cm = self._portal_cm
>>>>>>                 self._portal_cm = None
>>>>>>                 del self._portal
       
>>>>>>         if portal_cm:
>>>>>>             portal_cm.__exit__(None, None, None)
       
       
    2: @contextmanager
    7: def start_blocking_portal(
    2:     backend: str = "asyncio",
    2:     backend_options: dict[str, Any] | None = None,
           *,
    2:     name: str | None = None,
    1: ) -> Generator[BlockingPortal, Any, None]:
           """
           Start a new event loop in a new thread and run a blocking portal in its main task.
       
           The parameters are the same as for :func:`~anyio.run`.
       
           :param backend: name of the backend
           :param backend_options: backend options
           :param name: name of the thread
           :return: a context manager that yields a blocking portal
       
           .. versionchanged:: 3.0
               Usage as a context manager is now required.
       
           """
       
    9:     async def run_portal() -> None:
   18:         async with BlockingPortal() as portal_:
    9:             if name is None:
    9:                 current_thread().name = f"{backend}-portal-{id(portal_):x}"
       
    9:             future.set_result(portal_)
    9:             await portal_.sleep_until_stopped()
       
    9:     def run_blocking_portal() -> None:
    9:         if future.set_running_or_notify_cancel():
    9:             try:
   18:                 run_eventloop(
    9:                     run_portal, backend=backend, backend_options=backend_options
                       )
>>>>>>             except BaseException as exc:
>>>>>>                 if not future.done():
>>>>>>                     future.set_exception(exc)
       
    9:     future: Future[BlockingPortal] = Future()
    9:     thread = Thread(target=run_blocking_portal, daemon=True, name=name)
    9:     thread.start()
    9:     try:
    9:         cancel_remaining_tasks = False
    9:         portal = future.result()
    9:         try:
    9:             yield portal
>>>>>>         except BaseException:
>>>>>>             cancel_remaining_tasks = True
>>>>>>             raise
               finally:
    9:             try:
    9:                 portal.call(portal.stop, cancel_remaining_tasks)
>>>>>>             except RuntimeError:
>>>>>>                 pass
           finally:
    9:         thread.join()
       
       
    1: def check_cancelled() -> None:
           """
           Check if the cancel scope of the host task's running the current worker thread has
           been cancelled.
       
           If the host task's current cancel scope has indeed been cancelled, the
           backend-specific cancellation exception will be raised.
       
           :raises RuntimeError: if the current thread was not spawned by
               :func:`.to_thread.run_sync`
       
           """
>>>>>>     try:
>>>>>>         token: EventLoopToken = threadlocals.current_token
>>>>>>     except AttributeError:
>>>>>>         raise NoEventLoopError(
>>>>>>             "This function can only be called inside an AnyIO worker thread"
>>>>>>         ) from None
       
>>>>>>     token.backend_class.check_cancelled()
