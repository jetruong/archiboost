    1: from __future__ import annotations
       
    1: __all__ = (
           "TLSAttribute",
           "TLSConnectable",
           "TLSListener",
           "TLSStream",
       )
       
    1: import logging
    1: import re
    1: import ssl
    1: import sys
    1: from collections.abc import Callable, Mapping
    1: from dataclasses import dataclass
    1: from functools import wraps
    1: from ssl import SSLContext
    1: from typing import Any, TypeVar
       
    1: from .. import (
           BrokenResourceError,
           EndOfStream,
           aclose_forcefully,
           get_cancelled_exc_class,
           to_thread,
       )
    1: from .._core._typedattr import TypedAttributeSet, typed_attribute
    1: from ..abc import (
           AnyByteStream,
           AnyByteStreamConnectable,
           ByteStream,
           ByteStreamConnectable,
           Listener,
           TaskGroup,
       )
       
    1: if sys.version_info >= (3, 10):
    1:     from typing import TypeAlias
       else:
>>>>>>     from typing_extensions import TypeAlias
       
    1: if sys.version_info >= (3, 11):
    1:     from typing import TypeVarTuple, Unpack
       else:
>>>>>>     from typing_extensions import TypeVarTuple, Unpack
       
    1: if sys.version_info >= (3, 12):
    1:     from typing import override
       else:
>>>>>>     from typing_extensions import override
       
    1: T_Retval = TypeVar("T_Retval")
    1: PosArgsT = TypeVarTuple("PosArgsT")
    1: _PCTRTT: TypeAlias = tuple[tuple[str, str], ...]
    1: _PCTRTTT: TypeAlias = tuple[_PCTRTT, ...]
       
       
    2: class TLSAttribute(TypedAttributeSet):
    1:     """Contains Transport Layer Security related attributes."""
       
           #: the selected ALPN protocol
    1:     alpn_protocol: str | None = typed_attribute()
           #: the channel binding for type ``tls-unique``
    1:     channel_binding_tls_unique: bytes = typed_attribute()
           #: the selected cipher
    1:     cipher: tuple[str, str, int] = typed_attribute()
           #: the peer certificate in dictionary form (see :meth:`ssl.SSLSocket.getpeercert`
           # for more information)
    1:     peer_certificate: None | (dict[str, str | _PCTRTTT | _PCTRTT]) = typed_attribute()
           #: the peer certificate in binary form
    1:     peer_certificate_binary: bytes | None = typed_attribute()
           #: ``True`` if this is the server side of the connection
    1:     server_side: bool = typed_attribute()
           #: ciphers shared by the client during the TLS handshake (``None`` if this is the
           #: client side)
    1:     shared_ciphers: list[tuple[str, str, int]] | None = typed_attribute()
           #: the :class:`~ssl.SSLObject` used for encryption
    1:     ssl_object: ssl.SSLObject = typed_attribute()
           #: ``True`` if this stream does (and expects) a closing TLS handshake when the
           #: stream is being closed
    1:     standard_compatible: bool = typed_attribute()
           #: the TLS protocol version (e.g. ``TLSv1.2``)
    1:     tls_version: str = typed_attribute()
       
       
    3: @dataclass(eq=False)
    2: class TLSStream(ByteStream):
    1:     """
           A stream wrapper that encrypts all sent data and decrypts received data.
       
           This class has no public initializer; use :meth:`wrap` instead.
           All extra attributes from :class:`~TLSAttribute` are supported.
       
           :var AnyByteStream transport_stream: the wrapped stream
       
           """
       
    1:     transport_stream: AnyByteStream
    1:     standard_compatible: bool
    1:     _ssl_object: ssl.SSLObject
    1:     _read_bio: ssl.MemoryBIO
    1:     _write_bio: ssl.MemoryBIO
       
    2:     @classmethod
    8:     async def wrap(
               cls,
    1:         transport_stream: AnyByteStream,
               *,
    2:         server_side: bool | None = None,
    2:         hostname: str | None = None,
    2:         ssl_context: ssl.SSLContext | None = None,
    2:         standard_compatible: bool = True,
    1:     ) -> TLSStream:
               """
               Wrap an existing stream with Transport Layer Security.
       
               This performs a TLS handshake with the peer.
       
               :param transport_stream: a bytes-transporting stream to wrap
               :param server_side: ``True`` if this is the server side of the connection,
                   ``False`` if this is the client side (if omitted, will be set to ``False``
                   if ``hostname`` has been provided, ``False`` otherwise). Used only to create
                   a default context when an explicit context has not been provided.
               :param hostname: host name of the peer (if host name checking is desired)
               :param ssl_context: the SSLContext object to use (if not provided, a secure
                   default will be created)
               :param standard_compatible: if ``False``, skip the closing handshake when
                   closing the connection, and don't raise an exception if the peer does the
                   same
               :raises ~ssl.SSLError: if the TLS handshake fails
       
               """
>>>>>>         if server_side is None:
>>>>>>             server_side = not hostname
       
>>>>>>         if not ssl_context:
>>>>>>             purpose = (
>>>>>>                 ssl.Purpose.CLIENT_AUTH if server_side else ssl.Purpose.SERVER_AUTH
                   )
>>>>>>             ssl_context = ssl.create_default_context(purpose)
       
                   # Re-enable detection of unexpected EOFs if it was disabled by Python
>>>>>>             if hasattr(ssl, "OP_IGNORE_UNEXPECTED_EOF"):
>>>>>>                 ssl_context.options &= ~ssl.OP_IGNORE_UNEXPECTED_EOF
       
>>>>>>         bio_in = ssl.MemoryBIO()
>>>>>>         bio_out = ssl.MemoryBIO()
       
               # External SSLContext implementations may do blocking I/O in wrap_bio(),
               # but the standard library implementation won't
>>>>>>         if type(ssl_context) is ssl.SSLContext:
>>>>>>             ssl_object = ssl_context.wrap_bio(
>>>>>>                 bio_in, bio_out, server_side=server_side, server_hostname=hostname
                   )
               else:
>>>>>>             ssl_object = await to_thread.run_sync(
>>>>>>                 ssl_context.wrap_bio,
>>>>>>                 bio_in,
>>>>>>                 bio_out,
>>>>>>                 server_side,
>>>>>>                 hostname,
>>>>>>                 None,
                   )
       
>>>>>>         wrapper = cls(
>>>>>>             transport_stream=transport_stream,
>>>>>>             standard_compatible=standard_compatible,
>>>>>>             _ssl_object=ssl_object,
>>>>>>             _read_bio=bio_in,
>>>>>>             _write_bio=bio_out,
               )
>>>>>>         await wrapper._call_sslobject_method(ssl_object.do_handshake)
>>>>>>         return wrapper
       
    4:     async def _call_sslobject_method(
    2:         self, func: Callable[[Unpack[PosArgsT]], T_Retval], *args: Unpack[PosArgsT]
    1:     ) -> T_Retval:
>>>>>>         while True:
>>>>>>             try:
>>>>>>                 result = func(*args)
>>>>>>             except ssl.SSLWantReadError:
>>>>>>                 try:
                           # Flush any pending writes first
>>>>>>                     if self._write_bio.pending:
>>>>>>                         await self.transport_stream.send(self._write_bio.read())
       
>>>>>>                     data = await self.transport_stream.receive()
>>>>>>                 except EndOfStream:
>>>>>>                     self._read_bio.write_eof()
>>>>>>                 except OSError as exc:
>>>>>>                     self._read_bio.write_eof()
>>>>>>                     self._write_bio.write_eof()
>>>>>>                     raise BrokenResourceError from exc
                       else:
>>>>>>                     self._read_bio.write(data)
>>>>>>             except ssl.SSLWantWriteError:
>>>>>>                 await self.transport_stream.send(self._write_bio.read())
>>>>>>             except ssl.SSLSyscallError as exc:
>>>>>>                 self._read_bio.write_eof()
>>>>>>                 self._write_bio.write_eof()
>>>>>>                 raise BrokenResourceError from exc
>>>>>>             except ssl.SSLError as exc:
>>>>>>                 self._read_bio.write_eof()
>>>>>>                 self._write_bio.write_eof()
>>>>>>                 if isinstance(exc, ssl.SSLEOFError) or (
>>>>>>                     exc.strerror and "UNEXPECTED_EOF_WHILE_READING" in exc.strerror
                       ):
>>>>>>                     if self.standard_compatible:
>>>>>>                         raise BrokenResourceError from exc
                           else:
>>>>>>                         raise EndOfStream from None
       
>>>>>>                 raise
                   else:
                       # Flush any pending writes first
>>>>>>                 if self._write_bio.pending:
>>>>>>                     await self.transport_stream.send(self._write_bio.read())
       
>>>>>>                 return result
       
    1:     async def unwrap(self) -> tuple[AnyByteStream, bytes]:
               """
               Does the TLS closing handshake.
       
               :return: a tuple of (wrapped byte stream, bytes left in the read buffer)
       
               """
>>>>>>         await self._call_sslobject_method(self._ssl_object.unwrap)
>>>>>>         self._read_bio.write_eof()
>>>>>>         self._write_bio.write_eof()
>>>>>>         return self.transport_stream, self._read_bio.read()
       
    1:     async def aclose(self) -> None:
>>>>>>         if self.standard_compatible:
>>>>>>             try:
>>>>>>                 await self.unwrap()
>>>>>>             except BaseException:
>>>>>>                 await aclose_forcefully(self.transport_stream)
>>>>>>                 raise
       
>>>>>>         await self.transport_stream.aclose()
       
    1:     async def receive(self, max_bytes: int = 65536) -> bytes:
>>>>>>         data = await self._call_sslobject_method(self._ssl_object.read, max_bytes)
>>>>>>         if not data:
>>>>>>             raise EndOfStream
       
>>>>>>         return data
       
    1:     async def send(self, item: bytes) -> None:
>>>>>>         await self._call_sslobject_method(self._ssl_object.write, item)
       
    1:     async def send_eof(self) -> None:
>>>>>>         tls_version = self.extra(TLSAttribute.tls_version)
>>>>>>         match = re.match(r"TLSv(\d+)(?:\.(\d+))?", tls_version)
>>>>>>         if match:
>>>>>>             major, minor = int(match.group(1)), int(match.group(2) or 0)
>>>>>>             if (major, minor) < (1, 3):
>>>>>>                 raise NotImplementedError(
>>>>>>                     f"send_eof() requires at least TLSv1.3; current "
>>>>>>                     f"session uses {tls_version}"
                       )
       
>>>>>>         raise NotImplementedError(
>>>>>>             "send_eof() has not yet been implemented for TLS streams"
               )
       
    2:     @property
    2:     def extra_attributes(self) -> Mapping[Any, Callable[[], Any]]:
>>>>>>         return {
>>>>>>             **self.transport_stream.extra_attributes,
>>>>>>             TLSAttribute.alpn_protocol: self._ssl_object.selected_alpn_protocol,
>>>>>>             TLSAttribute.channel_binding_tls_unique: (
>>>>>>                 self._ssl_object.get_channel_binding
                   ),
>>>>>>             TLSAttribute.cipher: self._ssl_object.cipher,
>>>>>>             TLSAttribute.peer_certificate: lambda: self._ssl_object.getpeercert(False),
>>>>>>             TLSAttribute.peer_certificate_binary: lambda: self._ssl_object.getpeercert(
>>>>>>                 True
                   ),
>>>>>>             TLSAttribute.server_side: lambda: self._ssl_object.server_side,
>>>>>>             TLSAttribute.shared_ciphers: lambda: self._ssl_object.shared_ciphers()
>>>>>>             if self._ssl_object.server_side
>>>>>>             else None,
>>>>>>             TLSAttribute.standard_compatible: lambda: self.standard_compatible,
>>>>>>             TLSAttribute.ssl_object: lambda: self._ssl_object,
>>>>>>             TLSAttribute.tls_version: self._ssl_object.version,
               }
       
       
    3: @dataclass(eq=False)
    2: class TLSListener(Listener[TLSStream]):
    1:     """
           A convenience listener that wraps another listener and auto-negotiates a TLS session
           on every accepted connection.
       
           If the TLS handshake times out or raises an exception,
           :meth:`handle_handshake_error` is called to do whatever post-mortem processing is
           deemed necessary.
       
           Supports only the :attr:`~TLSAttribute.standard_compatible` extra attribute.
       
           :param Listener listener: the listener to wrap
           :param ssl_context: the SSL context object
           :param standard_compatible: a flag passed through to :meth:`TLSStream.wrap`
           :param handshake_timeout: time limit for the TLS handshake
               (passed to :func:`~anyio.fail_after`)
           """
       
    1:     listener: Listener[Any]
    1:     ssl_context: ssl.SSLContext
    1:     standard_compatible: bool = True
    1:     handshake_timeout: float = 30
       
    2:     @staticmethod
    2:     async def handle_handshake_error(exc: BaseException, stream: AnyByteStream) -> None:
               """
               Handle an exception raised during the TLS handshake.
       
               This method does 3 things:
       
               #. Forcefully closes the original stream
               #. Logs the exception (unless it was a cancellation exception) using the
                  ``anyio.streams.tls`` logger
               #. Reraises the exception if it was a base exception or a cancellation exception
       
               :param exc: the exception
               :param stream: the original stream
       
               """
>>>>>>         await aclose_forcefully(stream)
       
               # Log all except cancellation exceptions
>>>>>>         if not isinstance(exc, get_cancelled_exc_class()):
                   # CPython (as of 3.11.5) returns incorrect `sys.exc_info()` here when using
                   # any asyncio implementation, so we explicitly pass the exception to log
                   # (https://github.com/python/cpython/issues/108668). Trio does not have this
                   # issue because it works around the CPython bug.
>>>>>>             logging.getLogger(__name__).exception(
>>>>>>                 "Error during TLS handshake", exc_info=exc
                   )
       
               # Only reraise base exceptions and cancellation exceptions
>>>>>>         if not isinstance(exc, Exception) or isinstance(exc, get_cancelled_exc_class()):
>>>>>>             raise
       
    4:     async def serve(
               self,
    1:         handler: Callable[[TLSStream], Any],
    2:         task_group: TaskGroup | None = None,
    1:     ) -> None:
>>>>>>         @wraps(handler)
>>>>>>         async def handler_wrapper(stream: AnyByteStream) -> None:
>>>>>>             from .. import fail_after
       
>>>>>>             try:
>>>>>>                 with fail_after(self.handshake_timeout):
>>>>>>                     wrapped_stream = await TLSStream.wrap(
>>>>>>                         stream,
>>>>>>                         ssl_context=self.ssl_context,
>>>>>>                         standard_compatible=self.standard_compatible,
                           )
>>>>>>             except BaseException as exc:
>>>>>>                 await self.handle_handshake_error(exc, stream)
                   else:
>>>>>>                 await handler(wrapped_stream)
       
>>>>>>         await self.listener.serve(handler_wrapper, task_group)
       
    1:     async def aclose(self) -> None:
>>>>>>         await self.listener.aclose()
       
    2:     @property
    2:     def extra_attributes(self) -> Mapping[Any, Callable[[], Any]]:
>>>>>>         return {
>>>>>>             TLSAttribute.standard_compatible: lambda: self.standard_compatible,
               }
       
       
    2: class TLSConnectable(ByteStreamConnectable):
    1:     """
           Wraps another connectable and does TLS negotiation after a successful connection.
       
           :param connectable: the connectable to wrap
           :param hostname: host name of the server (if host name checking is desired)
           :param ssl_context: the SSLContext object to use (if not provided, a secure default
               will be created)
           :param standard_compatible: if ``False``, skip the closing handshake when closing
               the connection, and don't raise an exception if the server does the same
           """
       
    6:     def __init__(
               self,
    1:         connectable: AnyByteStreamConnectable,
               *,
    2:         hostname: str | None = None,
    2:         ssl_context: ssl.SSLContext | None = None,
    2:         standard_compatible: bool = True,
    1:     ) -> None:
>>>>>>         self.connectable = connectable
>>>>>>         self.ssl_context: SSLContext = ssl_context or ssl.create_default_context(
>>>>>>             ssl.Purpose.SERVER_AUTH
               )
>>>>>>         if not isinstance(self.ssl_context, ssl.SSLContext):
>>>>>>             raise TypeError(
>>>>>>                 "ssl_context must be an instance of ssl.SSLContext, not "
>>>>>>                 f"{type(self.ssl_context).__name__}"
                   )
>>>>>>         self.hostname = hostname
>>>>>>         self.standard_compatible = standard_compatible
       
    2:     @override
    2:     async def connect(self) -> TLSStream:
>>>>>>         stream = await self.connectable.connect()
>>>>>>         try:
>>>>>>             return await TLSStream.wrap(
>>>>>>                 stream,
>>>>>>                 hostname=self.hostname,
>>>>>>                 ssl_context=self.ssl_context,
>>>>>>                 standard_compatible=self.standard_compatible,
                   )
>>>>>>         except BaseException:
>>>>>>             await aclose_forcefully(stream)
>>>>>>             raise
