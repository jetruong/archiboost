    1: from __future__ import annotations
       
    1: from collections.abc import Generator
    1: import os
    1: import sys
       
    1: from _pytest.config import Config
    1: from _pytest.config.argparsing import Parser
    1: from _pytest.nodes import Item
    1: from _pytest.stash import StashKey
    1: import pytest
       
       
    1: fault_handler_original_stderr_fd_key = StashKey[int]()
    1: fault_handler_stderr_fd_key = StashKey[int]()
       
       
    1: def pytest_addoption(parser: Parser) -> None:
    1:     help_timeout = (
    1:         "Dump the traceback of all threads if a test takes "
               "more than TIMEOUT seconds to finish"
           )
    1:     help_exit_on_timeout = (
    1:         "Exit the test process if a test takes more than "
               "faulthandler_timeout seconds to finish"
           )
    1:     parser.addini("faulthandler_timeout", help_timeout, default=0.0)
    2:     parser.addini(
    1:         "faulthandler_exit_on_timeout", help_exit_on_timeout, type="bool", default=False
           )
       
       
    1: def pytest_configure(config: Config) -> None:
    1:     import faulthandler
       
           # at teardown we want to restore the original faulthandler fileno
           # but faulthandler has no api to return the original fileno
           # so here we stash the stderr fileno to be used at teardown
           # sys.stderr and sys.__stderr__ may be closed or patched during the session
           # so we can't rely on their values being good at that point (#11572).
    1:     stderr_fileno = get_stderr_fileno()
    1:     if faulthandler.is_enabled():
>>>>>>         config.stash[fault_handler_original_stderr_fd_key] = stderr_fileno
    1:     config.stash[fault_handler_stderr_fd_key] = os.dup(stderr_fileno)
    1:     faulthandler.enable(file=config.stash[fault_handler_stderr_fd_key])
       
       
    1: def pytest_unconfigure(config: Config) -> None:
    1:     import faulthandler
       
    1:     faulthandler.disable()
           # Close the dup file installed during pytest_configure.
    1:     if fault_handler_stderr_fd_key in config.stash:
    1:         os.close(config.stash[fault_handler_stderr_fd_key])
    1:         del config.stash[fault_handler_stderr_fd_key]
           # Re-enable the faulthandler if it was originally enabled.
    1:     if fault_handler_original_stderr_fd_key in config.stash:
>>>>>>         faulthandler.enable(config.stash[fault_handler_original_stderr_fd_key])
>>>>>>         del config.stash[fault_handler_original_stderr_fd_key]
       
       
    1: def get_stderr_fileno() -> int:
    1:     try:
    1:         fileno = sys.stderr.fileno()
               # The Twisted Logger will return an invalid file descriptor since it is not backed
               # by an FD. So, let's also forward this to the same code path as with pytest-xdist.
    1:         if fileno == -1:
>>>>>>             raise AttributeError()
    1:         return fileno
>>>>>>     except (AttributeError, ValueError):
               # pytest-xdist monkeypatches sys.stderr with an object that is not an actual file.
               # https://docs.python.org/3/library/faulthandler.html#issue-with-file-descriptors
               # This is potentially dangerous, but the best we can do.
>>>>>>         assert sys.__stderr__ is not None
>>>>>>         return sys.__stderr__.fileno()
       
       
    1: def get_timeout_config_value(config: Config) -> float:
   89:     return float(config.getini("faulthandler_timeout") or 0.0)
       
       
    1: def get_exit_on_timeout_config_value(config: Config) -> bool:
   89:     exit_on_timeout = config.getini("faulthandler_exit_on_timeout")
   89:     assert isinstance(exit_on_timeout, bool)
   89:     return exit_on_timeout
       
       
    2: @pytest.hookimpl(wrapper=True, trylast=True)
    2: def pytest_runtest_protocol(item: Item) -> Generator[None, object, object]:
   89:     timeout = get_timeout_config_value(item.config)
   89:     exit_on_timeout = get_exit_on_timeout_config_value(item.config)
   89:     if timeout > 0:
>>>>>>         import faulthandler
       
>>>>>>         stderr = item.config.stash[fault_handler_stderr_fd_key]
>>>>>>         faulthandler.dump_traceback_later(timeout, file=stderr, exit=exit_on_timeout)
>>>>>>         try:
>>>>>>             return (yield)
               finally:
>>>>>>             faulthandler.cancel_dump_traceback_later()
           else:
   89:         return (yield)
       
       
    2: @pytest.hookimpl(tryfirst=True)
    2: def pytest_enter_pdb() -> None:
           """Cancel any traceback dumping due to timeout before entering pdb."""
>>>>>>     import faulthandler
       
>>>>>>     faulthandler.cancel_dump_traceback_later()
       
       
    2: @pytest.hookimpl(tryfirst=True)
    2: def pytest_exception_interact() -> None:
           """Cancel any traceback dumping due to an interactive exception being
           raised."""
>>>>>>     import faulthandler
       
>>>>>>     faulthandler.cancel_dump_traceback_later()
