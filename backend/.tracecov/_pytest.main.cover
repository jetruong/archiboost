       """Core implementation of the testing process: init, session, runtest loop."""
       
>>>>>> from __future__ import annotations
       
>>>>>> import argparse
>>>>>> from collections.abc import Callable
>>>>>> from collections.abc import Iterable
>>>>>> from collections.abc import Iterator
>>>>>> from collections.abc import Sequence
>>>>>> from collections.abc import Set as AbstractSet
>>>>>> import dataclasses
>>>>>> import fnmatch
>>>>>> import functools
>>>>>> import importlib
>>>>>> import importlib.util
>>>>>> import os
>>>>>> from pathlib import Path
>>>>>> import sys
>>>>>> from typing import final
>>>>>> from typing import Literal
>>>>>> from typing import overload
>>>>>> from typing import TYPE_CHECKING
>>>>>> import warnings
       
>>>>>> import pluggy
       
>>>>>> from _pytest import nodes
>>>>>> import _pytest._code
>>>>>> from _pytest.config import Config
>>>>>> from _pytest.config import directory_arg
>>>>>> from _pytest.config import ExitCode
>>>>>> from _pytest.config import hookimpl
>>>>>> from _pytest.config import PytestPluginManager
>>>>>> from _pytest.config import UsageError
>>>>>> from _pytest.config.argparsing import OverrideIniAction
>>>>>> from _pytest.config.argparsing import Parser
>>>>>> from _pytest.config.compat import PathAwareHookProxy
>>>>>> from _pytest.outcomes import exit
>>>>>> from _pytest.pathlib import absolutepath
>>>>>> from _pytest.pathlib import bestrelpath
>>>>>> from _pytest.pathlib import fnmatch_ex
>>>>>> from _pytest.pathlib import safe_exists
>>>>>> from _pytest.pathlib import samefile_nofollow
>>>>>> from _pytest.pathlib import scandir
>>>>>> from _pytest.reports import CollectReport
>>>>>> from _pytest.reports import TestReport
>>>>>> from _pytest.runner import collect_one_node
>>>>>> from _pytest.runner import SetupState
>>>>>> from _pytest.warning_types import PytestWarning
       
       
>>>>>> if TYPE_CHECKING:
>>>>>>     from typing_extensions import Self
       
>>>>>>     from _pytest.fixtures import FixtureManager
       
       
>>>>>> def pytest_addoption(parser: Parser) -> None:
    1:     group = parser.getgroup("general")
    2:     group._addoption(  # private to use reserved lower-case short option
    1:         "-x",
    1:         "--exitfirst",
    1:         action="store_const",
    1:         dest="maxfail",
    1:         const=1,
    1:         help="Exit instantly on first error or failed test",
           )
    2:     group.addoption(
    1:         "--maxfail",
    1:         metavar="num",
    1:         action="store",
    1:         type=int,
    1:         dest="maxfail",
    1:         default=0,
    1:         help="Exit after first num failures or errors",
           )
    2:     group.addoption(
    1:         "--strict-config",
    1:         action=OverrideIniAction,
    1:         ini_option="strict_config",
    1:         ini_value="true",
    1:         help="Enables the strict_config option",
           )
    2:     group.addoption(
    1:         "--strict-markers",
    1:         action=OverrideIniAction,
    1:         ini_option="strict_markers",
    1:         ini_value="true",
    1:         help="Enables the strict_markers option",
           )
    2:     group.addoption(
    1:         "--strict",
    1:         action=OverrideIniAction,
    1:         ini_option="strict",
    1:         ini_value="true",
    1:         help="Enables the strict option",
           )
    2:     parser.addini(
    1:         "strict_config",
    1:         "Any warnings encountered while parsing the `pytest` section of the "
               "configuration file raise errors",
    1:         type="bool",
               # None => fallback to `strict`.
    1:         default=None,
           )
    2:     parser.addini(
    1:         "strict_markers",
    1:         "Markers not registered in the `markers` section of the configuration "
               "file raise errors",
    1:         type="bool",
               # None => fallback to `strict`.
    1:         default=None,
           )
    2:     parser.addini(
    1:         "strict",
    1:         "Enables all strictness options, currently: "
               "strict_config, strict_markers, strict_xfail, strict_parametrization_ids",
    1:         type="bool",
    1:         default=False,
           )
       
    1:     group = parser.getgroup("pytest-warnings")
    2:     group.addoption(
    1:         "-W",
    1:         "--pythonwarnings",
    1:         action="append",
    1:         help="Set which warnings to report, see -W option of Python itself",
           )
    2:     parser.addini(
    1:         "filterwarnings",
    1:         type="linelist",
    1:         help="Each line specifies a pattern for "
               "warnings.filterwarnings. "
               "Processed after -W/--pythonwarnings.",
           )
       
    1:     group = parser.getgroup("collect", "collection")
    2:     group.addoption(
    1:         "--collectonly",
    1:         "--collect-only",
    1:         "--co",
    1:         action="store_true",
    1:         help="Only collect tests, don't execute them",
           )
    2:     group.addoption(
    1:         "--pyargs",
    1:         action="store_true",
    1:         help="Try to interpret all arguments as Python packages",
           )
    2:     group.addoption(
    1:         "--ignore",
    1:         action="append",
    1:         metavar="path",
    1:         help="Ignore path during collection (multi-allowed)",
           )
    2:     group.addoption(
    1:         "--ignore-glob",
    1:         action="append",
    1:         metavar="path",
    1:         help="Ignore path pattern during collection (multi-allowed)",
           )
    2:     group.addoption(
    1:         "--deselect",
    1:         action="append",
    1:         metavar="nodeid_prefix",
    1:         help="Deselect item (via node id prefix) during collection (multi-allowed)",
           )
    2:     group.addoption(
    1:         "--confcutdir",
    1:         dest="confcutdir",
    1:         default=None,
    1:         metavar="dir",
    1:         type=functools.partial(directory_arg, optname="--confcutdir"),
    1:         help="Only load conftest.py's relative to specified dir",
           )
    2:     group.addoption(
    1:         "--noconftest",
    1:         action="store_true",
    1:         dest="noconftest",
    1:         default=False,
    1:         help="Don't load any conftest.py files",
           )
    2:     group.addoption(
    1:         "--keepduplicates",
    1:         "--keep-duplicates",
    1:         action="store_true",
    1:         dest="keepduplicates",
    1:         default=False,
    1:         help="Keep duplicate tests",
           )
    2:     group.addoption(
    1:         "--collect-in-virtualenv",
    1:         action="store_true",
    1:         dest="collect_in_virtualenv",
    1:         default=False,
    1:         help="Don't ignore tests in a local virtualenv directory",
           )
    2:     group.addoption(
    1:         "--continue-on-collection-errors",
    1:         action="store_true",
    1:         default=False,
    1:         dest="continue_on_collection_errors",
    1:         help="Force test execution even if collection errors occur",
           )
    2:     group.addoption(
    1:         "--import-mode",
    1:         default="prepend",
    1:         choices=["prepend", "append", "importlib"],
    1:         dest="importmode",
    1:         help="Prepend/append to sys.path when importing test modules and conftest "
               "files. Default: prepend.",
           )
    2:     parser.addini(
    1:         "norecursedirs",
    1:         "Directory patterns to avoid for recursion",
    1:         type="args",
    1:         default=[
                   "*.egg",
                   ".*",
                   "_darcs",
                   "build",
                   "CVS",
                   "dist",
                   "node_modules",
                   "venv",
                   "{arch}",
               ],
           )
    2:     parser.addini(
    1:         "testpaths",
    1:         "Directories to search for tests when no files or directories are given on the "
               "command line",
    1:         type="args",
    1:         default=[],
           )
    2:     parser.addini(
    1:         "collect_imported_tests",
    1:         "Whether to collect tests in imported modules outside `testpaths`",
    1:         type="bool",
    1:         default=True,
           )
    2:     parser.addini(
    1:         "consider_namespace_packages",
    1:         type="bool",
    1:         default=False,
    1:         help="Consider namespace packages when resolving module names during import",
           )
       
    1:     group = parser.getgroup("debugconfig", "test session debugging and configuration")
    2:     group._addoption(  # private to use reserved lower-case short option
    1:         "-c",
    1:         "--config-file",
    1:         metavar="FILE",
    1:         type=str,
    1:         dest="inifilename",
    1:         help="Load configuration from `FILE` instead of trying to locate one of the "
               "implicit configuration files.",
           )
    2:     group.addoption(
    1:         "--rootdir",
    1:         action="store",
    1:         dest="rootdir",
    1:         help="Define root directory for tests. Can be relative path: 'root_dir', './root_dir', "
               "'root_dir/another_dir/'; absolute path: '/home/user/root_dir'; path with variables: "
               "'$HOME/root_dir'.",
           )
    2:     group.addoption(
    1:         "--basetemp",
    1:         dest="basetemp",
    1:         default=None,
    1:         type=validate_basetemp,
    1:         metavar="dir",
               help=(
    1:             "Base temporary directory for this test run. "
                   "(Warning: this directory is removed if it exists.)"
               ),
           )
       
       
>>>>>> def validate_basetemp(path: str) -> str:
           # GH 7119
>>>>>>     msg = "basetemp must not be empty, the current working directory or any parent directory of it"
       
           # empty path
>>>>>>     if not path:
>>>>>>         raise argparse.ArgumentTypeError(msg)
       
>>>>>>     def is_ancestor(base: Path, query: Path) -> bool:
               """Return whether query is an ancestor of base."""
>>>>>>         if base == query:
>>>>>>             return True
>>>>>>         return query in base.parents
       
           # check if path is an ancestor of cwd
>>>>>>     if is_ancestor(Path.cwd(), Path(path).absolute()):
>>>>>>         raise argparse.ArgumentTypeError(msg)
       
           # check symlinks for ancestors
>>>>>>     if is_ancestor(Path.cwd().resolve(), Path(path).resolve()):
>>>>>>         raise argparse.ArgumentTypeError(msg)
       
>>>>>>     return path
       
       
>>>>>> def wrap_session(
>>>>>>     config: Config, doit: Callable[[Config, Session], int | ExitCode | None]
>>>>>> ) -> int | ExitCode:
           """Skeleton command line program."""
    1:     session = Session.from_config(config)
    1:     session.exitstatus = ExitCode.OK
    1:     initstate = 0
    1:     try:
    1:         try:
    1:             config._do_configure()
    1:             initstate = 1
    1:             config.hook.pytest_sessionstart(session=session)
    1:             initstate = 2
    1:             session.exitstatus = doit(config, session) or 0
>>>>>>         except UsageError:
>>>>>>             session.exitstatus = ExitCode.USAGE_ERROR
>>>>>>             raise
>>>>>>         except Failed:
>>>>>>             session.exitstatus = ExitCode.TESTS_FAILED
>>>>>>         except (KeyboardInterrupt, exit.Exception):
>>>>>>             excinfo = _pytest._code.ExceptionInfo.from_current()
>>>>>>             exitstatus: int | ExitCode = ExitCode.INTERRUPTED
>>>>>>             if isinstance(excinfo.value, exit.Exception):
>>>>>>                 if excinfo.value.returncode is not None:
>>>>>>                     exitstatus = excinfo.value.returncode
>>>>>>                 if initstate < 2:
>>>>>>                     sys.stderr.write(f"{excinfo.typename}: {excinfo.value.msg}\n")
>>>>>>             config.hook.pytest_keyboard_interrupt(excinfo=excinfo)
>>>>>>             session.exitstatus = exitstatus
>>>>>>         except BaseException:
>>>>>>             session.exitstatus = ExitCode.INTERNAL_ERROR
>>>>>>             excinfo = _pytest._code.ExceptionInfo.from_current()
>>>>>>             try:
>>>>>>                 config.notify_exception(excinfo, config.option)
>>>>>>             except exit.Exception as exc:
>>>>>>                 if exc.returncode is not None:
>>>>>>                     session.exitstatus = exc.returncode
>>>>>>                 sys.stderr.write(f"{type(exc).__name__}: {exc}\n")
                   else:
>>>>>>                 if isinstance(excinfo.value, SystemExit):
>>>>>>                     sys.stderr.write("mainloop: caught unexpected SystemExit!\n")
       
           finally:
               # Explicitly break reference cycle.
    1:         excinfo = None  # type: ignore
    1:         os.chdir(session.startpath)
    1:         if initstate >= 2:
    1:             try:
    2:                 config.hook.pytest_sessionfinish(
    1:                     session=session, exitstatus=session.exitstatus
                       )
>>>>>>             except exit.Exception as exc:
>>>>>>                 if exc.returncode is not None:
>>>>>>                     session.exitstatus = exc.returncode
>>>>>>                 sys.stderr.write(f"{type(exc).__name__}: {exc}\n")
    1:         config._ensure_unconfigure()
    1:     return session.exitstatus
       
       
>>>>>> def pytest_cmdline_main(config: Config) -> int | ExitCode:
    1:     return wrap_session(config, _main)
       
       
>>>>>> def _main(config: Config, session: Session) -> int | ExitCode | None:
           """Default command line protocol for initialization, session,
           running tests and reporting."""
    1:     config.hook.pytest_collection(session=session)
    1:     config.hook.pytest_runtestloop(session=session)
       
    1:     if session.testsfailed:
>>>>>>         return ExitCode.TESTS_FAILED
    1:     elif session.testscollected == 0:
>>>>>>         return ExitCode.NO_TESTS_COLLECTED
    1:     return None
       
       
>>>>>> def pytest_collection(session: Session) -> None:
    1:     session.perform_collect()
       
       
>>>>>> def pytest_runtestloop(session: Session) -> bool:
    1:     if session.testsfailed and not session.config.option.continue_on_collection_errors:
>>>>>>         raise session.Interrupted(
>>>>>>             f"{session.testsfailed} error{'s' if session.testsfailed != 1 else ''} during collection"
               )
       
    1:     if session.config.option.collectonly:
>>>>>>         return True
       
   90:     for i, item in enumerate(session.items):
   89:         nextitem = session.items[i + 1] if i + 1 < len(session.items) else None
   89:         item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)
   89:         if session.shouldfail:
>>>>>>             raise session.Failed(session.shouldfail)
   89:         if session.shouldstop:
>>>>>>             raise session.Interrupted(session.shouldstop)
    1:     return True
       
       
>>>>>> def _in_venv(path: Path) -> bool:
           """Attempt to detect if ``path`` is the root of a Virtual Environment by
           checking for the existence of the pyvenv.cfg file.
       
           [https://peps.python.org/pep-0405/]
       
           For regression protection we also check for conda environments that do not include pyenv.cfg yet --
           https://github.com/conda/conda/issues/13337 is the conda issue tracking adding pyenv.cfg.
       
           Checking for the `conda-meta/history` file per https://github.com/pytest-dev/pytest/issues/12652#issuecomment-2246336902.
       
           """
   17:     try:
   17:         return (
   17:             path.joinpath("pyvenv.cfg").is_file()
   16:             or path.joinpath("conda-meta", "history").is_file()
               )
>>>>>>     except OSError:
>>>>>>         return False
       
       
>>>>>> def pytest_ignore_collect(collection_path: Path, config: Config) -> bool | None:
   18:     if collection_path.name == "__pycache__":
    1:         return True
       
   34:     ignore_paths = config._getconftest_pathlist(
   17:         "collect_ignore", path=collection_path.parent
           )
   17:     ignore_paths = ignore_paths or []
   17:     excludeopt = config.getoption("ignore")
   17:     if excludeopt:
>>>>>>         ignore_paths.extend(absolutepath(x) for x in excludeopt)
       
   17:     if collection_path in ignore_paths:
>>>>>>         return True
       
   34:     ignore_globs = config._getconftest_pathlist(
   17:         "collect_ignore_glob", path=collection_path.parent
           )
   17:     ignore_globs = ignore_globs or []
   17:     excludeglobopt = config.getoption("ignore_glob")
   17:     if excludeglobopt:
>>>>>>         ignore_globs.extend(absolutepath(x) for x in excludeglobopt)
       
   34:     if any(fnmatch.fnmatch(str(collection_path), str(glob)) for glob in ignore_globs):
>>>>>>         return True
       
   17:     allow_in_venv = config.getoption("collect_in_virtualenv")
   17:     if not allow_in_venv and _in_venv(collection_path):
    1:         return True
       
   16:     if collection_path.is_dir():
    5:         norecursepatterns = config.getini("norecursedirs")
   47:         if any(fnmatch_ex(pat, collection_path) for pat in norecursepatterns):
    1:             return True
       
   15:     return None
       
       
>>>>>> def pytest_collect_directory(
>>>>>>     path: Path, parent: nodes.Collector
>>>>>> ) -> nodes.Collector | None:
    4:     return Dir.from_parent(parent, path=path)
       
       
>>>>>> def pytest_collection_modifyitems(items: list[nodes.Item], config: Config) -> None:
    1:     deselect_prefixes = tuple(config.getoption("deselect") or [])
    1:     if not deselect_prefixes:
    1:         return
       
>>>>>>     remaining = []
>>>>>>     deselected = []
>>>>>>     for colitem in items:
>>>>>>         if colitem.nodeid.startswith(deselect_prefixes):
>>>>>>             deselected.append(colitem)
               else:
>>>>>>             remaining.append(colitem)
       
>>>>>>     if deselected:
>>>>>>         config.hook.pytest_deselected(items=deselected)
>>>>>>         items[:] = remaining
       
       
>>>>>> class FSHookProxy:
>>>>>>     def __init__(
               self,
>>>>>>         pm: PytestPluginManager,
>>>>>>         remove_mods: AbstractSet[object],
>>>>>>     ) -> None:
>>>>>>         self.pm = pm
>>>>>>         self.remove_mods = remove_mods
       
>>>>>>     def __getattr__(self, name: str) -> pluggy.HookCaller:
>>>>>>         x = self.pm.subset_hook_caller(name, remove_plugins=self.remove_mods)
>>>>>>         self.__dict__[name] = x
>>>>>>         return x
       
       
>>>>>> class Interrupted(KeyboardInterrupt):
           """Signals that the test run was interrupted."""
       
>>>>>>     __module__ = "builtins"  # For py3.
       
       
>>>>>> class Failed(Exception):
           """Signals a stop as failed test run."""
       
       
>>>>>> @dataclasses.dataclass
>>>>>> class _bestrelpath_cache(dict[Path, str]):
>>>>>>     __slots__ = ("path",)
       
>>>>>>     path: Path
       
>>>>>>     def __missing__(self, path: Path) -> str:
    5:         r = bestrelpath(self.path, path)
    5:         self[path] = r
    5:         return r
       
       
>>>>>> @final
>>>>>> class Dir(nodes.Directory):
           """Collector of files in a file system directory.
       
           .. versionadded:: 8.0
       
           .. note::
       
               Python directories with an `__init__.py` file are instead collected by
               :class:`~pytest.Package` by default. Both are :class:`~pytest.Directory`
               collectors.
           """
       
>>>>>>     @classmethod
>>>>>>     def from_parent(  # type: ignore[override]
               cls,
>>>>>>         parent: nodes.Collector,
               *,
>>>>>>         path: Path,
>>>>>>     ) -> Self:
               """The public constructor.
       
               :param parent: The parent collector of this Dir.
               :param path: The directory's path.
               :type path: pathlib.Path
               """
    4:         return super().from_parent(parent=parent, path=path)
       
>>>>>>     def collect(self) -> Iterable[nodes.Item | nodes.Collector]:
    1:         config = self.config
               col: nodes.Collector | None
               cols: Sequence[nodes.Collector]
    1:         ihook = self.ihook
   13:         for direntry in scandir(self.path):
   12:             if direntry.is_dir():
    7:                 path = Path(direntry.path)
    7:                 if not self.session.isinitpath(path, with_parents=True):
    6:                     if ihook.pytest_ignore_collect(collection_path=path, config=config):
    2:                         continue
    5:                 col = ihook.pytest_collect_directory(path=path, parent=self)
    5:                 if col is not None:
    5:                     yield col
       
    5:             elif direntry.is_file():
    5:                 path = Path(direntry.path)
    5:                 if not self.session.isinitpath(path):
    5:                     if ihook.pytest_ignore_collect(collection_path=path, config=config):
>>>>>>                         continue
    5:                 cols = ihook.pytest_collect_file(file_path=path, parent=self)
    5:                 yield from cols
       
       
>>>>>> @final
>>>>>> class Session(nodes.Collector):
           """The root of the collection tree.
       
           ``Session`` collects the initial paths given as arguments to pytest.
           """
       
>>>>>>     Interrupted = Interrupted
>>>>>>     Failed = Failed
           # Set on the session by runner.pytest_sessionstart.
>>>>>>     _setupstate: SetupState
           # Set on the session by fixtures.pytest_sessionstart.
>>>>>>     _fixturemanager: FixtureManager
>>>>>>     exitstatus: int | ExitCode
       
>>>>>>     def __init__(self, config: Config) -> None:
    2:         super().__init__(
    1:             name="",
    1:             path=config.rootpath,
    1:             fspath=None,
    1:             parent=None,
    1:             config=config,
    1:             session=self,
    1:             nodeid="",
               )
    1:         self.testsfailed = 0
    1:         self.testscollected = 0
    1:         self._shouldstop: bool | str = False
    1:         self._shouldfail: bool | str = False
    1:         self.trace = config.trace.root.get("collection")
    1:         self._initialpaths: frozenset[Path] = frozenset()
    1:         self._initialpaths_with_parents: frozenset[Path] = frozenset()
    1:         self._notfound: list[tuple[str, Sequence[nodes.Collector]]] = []
    1:         self._initial_parts: list[CollectionArgument] = []
    1:         self._collection_cache: dict[nodes.Collector, CollectReport] = {}
    1:         self.items: list[nodes.Item] = []
       
    1:         self._bestrelpathcache: dict[Path, str] = _bestrelpath_cache(config.rootpath)
       
    1:         self.config.pluginmanager.register(self, name="session")
       
>>>>>>     @classmethod
>>>>>>     def from_config(cls, config: Config) -> Session:
    1:         session: Session = cls._create(config=config)
    1:         return session
       
>>>>>>     def __repr__(self) -> str:
>>>>>>         return (
>>>>>>             f"<{self.__class__.__name__} {self.name} "
                   f"exitstatus=%r "
>>>>>>             f"testsfailed={self.testsfailed} "
>>>>>>             f"testscollected={self.testscollected}>"
>>>>>>         ) % getattr(self, "exitstatus", "<UNSET>")
       
>>>>>>     @property
>>>>>>     def shouldstop(self) -> bool | str:
  215:         return self._shouldstop
       
>>>>>>     @shouldstop.setter
>>>>>>     def shouldstop(self, value: bool | str) -> None:
               # The runner checks shouldfail and assumes that if it is set we are
               # definitely stopping, so prevent unsetting it.
>>>>>>         if value is False and self._shouldstop:
>>>>>>             warnings.warn(
>>>>>>                 PytestWarning(
>>>>>>                     "session.shouldstop cannot be unset after it has been set; ignoring."
                       ),
>>>>>>                 stacklevel=2,
                   )
>>>>>>             return
>>>>>>         self._shouldstop = value
       
>>>>>>     @property
>>>>>>     def shouldfail(self) -> bool | str:
  215:         return self._shouldfail
       
>>>>>>     @shouldfail.setter
>>>>>>     def shouldfail(self, value: bool | str) -> None:
               # The runner checks shouldfail and assumes that if it is set we are
               # definitely stopping, so prevent unsetting it.
>>>>>>         if value is False and self._shouldfail:
>>>>>>             warnings.warn(
>>>>>>                 PytestWarning(
>>>>>>                     "session.shouldfail cannot be unset after it has been set; ignoring."
                       ),
>>>>>>                 stacklevel=2,
                   )
>>>>>>             return
>>>>>>         self._shouldfail = value
       
>>>>>>     @property
>>>>>>     def startpath(self) -> Path:
               """The path from which pytest was invoked.
       
               .. versionadded:: 7.0.0
               """
    1:         return self.config.invocation_params.dir
       
>>>>>>     def _node_location_to_relpath(self, node_path: Path) -> str:
               # bestrelpath is a quite slow function.
   89:         return self._bestrelpathcache[node_path]
       
>>>>>>     @hookimpl(tryfirst=True)
>>>>>>     def pytest_collectstart(self) -> None:
   36:         if self.shouldfail:
>>>>>>             raise self.Failed(self.shouldfail)
   36:         if self.shouldstop:
>>>>>>             raise self.Interrupted(self.shouldstop)
       
>>>>>>     @hookimpl(tryfirst=True)
>>>>>>     def pytest_runtest_logreport(self, report: TestReport | CollectReport) -> None:
  302:         if report.failed and not hasattr(report, "wasxfail"):
>>>>>>             self.testsfailed += 1
>>>>>>             maxfail = self.config.getvalue("maxfail")
>>>>>>             if maxfail and self.testsfailed >= maxfail:
>>>>>>                 self.shouldfail = f"stopping after {self.testsfailed} failures"
       
>>>>>>     pytest_collectreport = pytest_runtest_logreport
       
>>>>>>     def isinitpath(
               self,
>>>>>>         path: str | os.PathLike[str],
               *,
>>>>>>         with_parents: bool = False,
>>>>>>     ) -> bool:
               """Is path an initial path?
       
               An initial path is a path explicitly given to pytest on the command
               line.
       
               :param with_parents:
                   If set, also return True if the path is a parent of an initial path.
       
               .. versionchanged:: 8.0
                   Added the ``with_parents`` parameter.
               """
               # Optimization: Path(Path(...)) is much slower than isinstance.
   32:         path_ = path if isinstance(path, Path) else Path(path)
   32:         if with_parents:
    8:             return path_ in self._initialpaths_with_parents
               else:
   24:             return path_ in self._initialpaths
       
>>>>>>     def gethookproxy(self, fspath: os.PathLike[str]) -> pluggy.HookRelay:
               # Optimization: Path(Path(...)) is much slower than isinstance.
 1034:         path = fspath if isinstance(fspath, Path) else Path(fspath)
 1034:         pm = self.config.pluginmanager
               # Check if we have the common case of running
               # hooks with all conftest.py files.
 1034:         my_conftestmodules = pm._getconftestmodules(path)
 1034:         remove_mods = pm._conftest_plugins.difference(my_conftestmodules)
               proxy: pluggy.HookRelay
 1034:         if remove_mods:
                   # One or more conftests are not in use at this path.
>>>>>>             proxy = PathAwareHookProxy(FSHookProxy(pm, remove_mods))  # type: ignore[arg-type,assignment]
               else:
                   # All plugins are active for this fspath.
 1034:             proxy = self.config.hook
 1034:         return proxy
       
>>>>>>     def _collect_path(
               self,
>>>>>>         path: Path,
>>>>>>         path_cache: dict[Path, Sequence[nodes.Collector]],
>>>>>>     ) -> Sequence[nodes.Collector]:
               """Create a Collector for the given path.
       
               `path_cache` makes it so the same Collectors are returned for the same
               path.
               """
    1:         if path in path_cache:
>>>>>>             return path_cache[path]
       
    1:         if path.is_dir():
    1:             ihook = self.gethookproxy(path.parent)
    2:             col: nodes.Collector | None = ihook.pytest_collect_directory(
    1:                 path=path, parent=self
                   )
    1:             cols: Sequence[nodes.Collector] = (col,) if col is not None else ()
       
>>>>>>         elif path.is_file():
>>>>>>             ihook = self.gethookproxy(path)
>>>>>>             cols = ihook.pytest_collect_file(file_path=path, parent=self)
       
               else:
                   # Broken symlink or invalid/missing file.
>>>>>>             cols = ()
       
    1:         path_cache[path] = cols
    1:         return cols
       
>>>>>>     @overload
>>>>>>     def perform_collect(
>>>>>>         self, args: Sequence[str] | None = ..., genitems: Literal[True] = ...
>>>>>>     ) -> Sequence[nodes.Item]: ...
       
>>>>>>     @overload
>>>>>>     def perform_collect(
>>>>>>         self, args: Sequence[str] | None = ..., genitems: bool = ...
>>>>>>     ) -> Sequence[nodes.Item | nodes.Collector]: ...
       
>>>>>>     def perform_collect(
>>>>>>         self, args: Sequence[str] | None = None, genitems: bool = True
>>>>>>     ) -> Sequence[nodes.Item | nodes.Collector]:
               """Perform the collection phase for this session.
       
               This is called by the default :hook:`pytest_collection` hook
               implementation; see the documentation of this hook for more details.
               For testing purposes, it may also be called directly on a fresh
               ``Session``.
       
               This function normally recursively expands any collectors collected
               from the session to their items, and only items are returned. For
               testing purposes, this may be suppressed by passing ``genitems=False``,
               in which case the return value contains these collectors unexpanded,
               and ``session.items`` is empty.
               """
    1:         if args is None:
    1:             args = self.config.args
       
    1:         self.trace("perform_collect", self, args)
    1:         self.trace.root.indent += 1
       
    1:         hook = self.config.hook
       
    1:         self._notfound = []
    1:         self._initial_parts = []
    1:         self._collection_cache = {}
    1:         self.items = []
    1:         items: Sequence[nodes.Item | nodes.Collector] = self.items
    2:         consider_namespace_packages: bool = self.config.getini(
    1:             "consider_namespace_packages"
               )
    1:         try:
    1:             initialpaths: list[Path] = []
    1:             initialpaths_with_parents: list[Path] = []
       
    2:             collection_args = [
    2:                 resolve_collection_argument(
    1:                     self.config.invocation_params.dir,
    1:                     arg,
    1:                     i,
    1:                     as_pypath=self.config.option.pyargs,
    1:                     consider_namespace_packages=consider_namespace_packages,
                       )
    3:                 for i, arg in enumerate(args)
                   ]
       
    1:             if not self.config.getoption("keepduplicates"):
                       # Normalize the collection arguments -- remove duplicates and overlaps.
    1:                 self._initial_parts = normalize_collection_arguments(collection_args)
                   else:
>>>>>>                 self._initial_parts = collection_args
       
    2:             for collection_argument in self._initial_parts:
    1:                 initialpaths.append(collection_argument.path)
    1:                 initialpaths_with_parents.append(collection_argument.path)
    1:                 initialpaths_with_parents.extend(collection_argument.path.parents)
    1:             self._initialpaths = frozenset(initialpaths)
    1:             self._initialpaths_with_parents = frozenset(initialpaths_with_parents)
       
    1:             rep = collect_one_node(self)
    1:             self.ihook.pytest_collectreport(report=rep)
    1:             self.trace.root.indent -= 1
    1:             if self._notfound:
>>>>>>                 errors = []
>>>>>>                 for arg, collectors in self._notfound:
>>>>>>                     if collectors:
>>>>>>                         errors.append(
>>>>>>                             f"not found: {arg}\n(no match in any of {collectors!r})"
                               )
                           else:
>>>>>>                         errors.append(f"found no collectors for {arg}")
       
>>>>>>                 raise UsageError(*errors)
       
    1:             if not genitems:
>>>>>>                 items = rep.result
                   else:
    1:                 if rep.passed:
    2:                     for node in rep.result:
    1:                         self.items.extend(self.genitems(node))
       
    1:             self.config.pluginmanager.check_pending()
    2:             hook.pytest_collection_modifyitems(
    1:                 session=self, config=self.config, items=items
                   )
               finally:
    1:             self._notfound = []
    1:             self._initial_parts = []
    1:             self._collection_cache = {}
    1:             hook.pytest_collection_finish(session=self)
       
    1:         if genitems:
    1:             self.testscollected = len(items)
       
    1:         return items
       
>>>>>>     def _collect_one_node(
               self,
>>>>>>         node: nodes.Collector,
>>>>>>         handle_dupes: bool = True,
>>>>>>     ) -> tuple[CollectReport, bool]:
   35:         if node in self._collection_cache and handle_dupes:
>>>>>>             rep = self._collection_cache[node]
>>>>>>             return rep, True
               else:
   35:             rep = collect_one_node(node)
   35:             self._collection_cache[node] = rep
   35:             return rep, False
       
>>>>>>     def collect(self) -> Iterator[nodes.Item | nodes.Collector]:
               # This is a cache for the root directories of the initial paths.
               # We can't use collection_cache for Session because of its special
               # role as the bootstrapping collector.
    1:         path_cache: dict[Path, Sequence[nodes.Collector]] = {}
       
    1:         pm = self.config.pluginmanager
       
    2:         for collection_argument in self._initial_parts:
    1:             self.trace("processing argument", collection_argument)
    1:             self.trace.root.indent += 1
       
    1:             argpath = collection_argument.path
    1:             names = collection_argument.parts
    1:             parametrization = collection_argument.parametrization
    1:             module_name = collection_argument.module_name
       
                   # resolve_collection_argument() ensures this.
    1:             if argpath.is_dir():
    1:                 assert not names, f"invalid arg {(argpath, names)!r}"
       
    1:             paths = [argpath]
                   # Add relevant parents of the path, from the root, e.g.
                   #   /a/b/c.py -> [/, /a, /a/b, /a/b/c.py]
    1:             if module_name is None:
                       # Paths outside of the confcutdir should not be considered.
    2:                 for path in argpath.parents:
    2:                     if not pm._is_in_confcutdir(path):
    1:                         break
    1:                     paths.insert(0, path)
                   else:
                       # For --pyargs arguments, only consider paths matching the module
                       # name. Paths beyond the package hierarchy are not included.
>>>>>>                 module_name_parts = module_name.split(".")
>>>>>>                 for i, path in enumerate(argpath.parents, 2):
>>>>>>                     if i > len(module_name_parts) or path.stem != module_name_parts[-i]:
>>>>>>                         break
>>>>>>                     paths.insert(0, path)
       
                   # Start going over the parts from the root, collecting each level
                   # and discarding all nodes which don't match the level's part.
    1:             any_matched_in_initial_part = False
    1:             notfound_collectors = []
    1:             work: list[tuple[nodes.Collector | nodes.Item, list[Path | str]]] = [
    1:                 (self, [*paths, *names])
                   ]
    4:             while work:
    3:                 matchnode, matchparts = work.pop()
       
                       # Pop'd all of the parts, this is a match.
    3:                 if not matchparts:
    1:                     yield matchnode
    1:                     any_matched_in_initial_part = True
    1:                     continue
       
                       # Should have been matched by now, discard.
    2:                 if not isinstance(matchnode, nodes.Collector):
>>>>>>                     continue
       
                       # Collect this level of matching.
                       # Collecting Session (self) is done directly to avoid endless
                       # recursion to this function.
                       subnodes: Sequence[nodes.Collector | nodes.Item]
    2:                 if isinstance(matchnode, Session):
    1:                     assert isinstance(matchparts[0], Path)
    1:                     subnodes = matchnode._collect_path(matchparts[0], path_cache)
                       else:
                           # For backward compat, files given directly multiple
                           # times on the command line should not be deduplicated.
    1:                     handle_dupes = not (
    2:                         len(matchparts) == 1
    1:                         and isinstance(matchparts[0], Path)
    1:                         and matchparts[0].is_file()
                           )
    1:                     rep, duplicate = self._collect_one_node(matchnode, handle_dupes)
    1:                     if not duplicate and not rep.passed:
                               # Report collection failures here to avoid failing to
                               # run some test specified in the command line because
                               # the module could not be imported (#134).
>>>>>>                         matchnode.ihook.pytest_collectreport(report=rep)
    1:                     if not rep.passed:
>>>>>>                         continue
    1:                     subnodes = rep.result
       
                       # Prune this level.
    2:                 any_matched_in_collector = False
    8:                 for node in reversed(subnodes):
                           # Path part e.g. `/a/b/` in `/a/b/test_file.py::TestIt::test_it`.
    6:                     if isinstance(matchparts[0], Path):
    6:                         is_match = node.path == matchparts[0]
    6:                         if sys.platform == "win32" and not is_match:
                                   # In case the file paths do not match, fallback to samefile() to
                                   # account for short-paths on Windows (#11895). But use a version
                                   # which doesn't resolve symlinks, otherwise we might match the
                                   # same file more than once (#12039).
>>>>>>                             is_match = samefile_nofollow(node.path, matchparts[0])
       
                           # Name part e.g. `TestIt` in `/a/b/test_file.py::TestIt::test_it`.
                           else:
>>>>>>                         if len(matchparts) == 1:
                                   # This the last part, one parametrization goes.
>>>>>>                             if parametrization is not None:
                                       # A parametrized arg must match exactly.
>>>>>>                                 is_match = node.name == matchparts[0] + parametrization
                                   else:
                                       # A non-parameterized arg matches all parametrizations (if any).
                                       # TODO: Remove the hacky split once the collection structure
                                       # contains parametrization.
>>>>>>                                 is_match = node.name.split("[")[0] == matchparts[0]
                               else:
>>>>>>                             is_match = node.name == matchparts[0]
    6:                     if is_match:
    2:                         work.append((node, matchparts[1:]))
    2:                         any_matched_in_collector = True
       
    2:                 if not any_matched_in_collector:
>>>>>>                     notfound_collectors.append(matchnode)
       
    1:             if not any_matched_in_initial_part:
>>>>>>                 report_arg = "::".join((str(argpath), *names))
>>>>>>                 self._notfound.append((report_arg, notfound_collectors))
       
    1:             self.trace.root.indent -= 1
       
>>>>>>     def genitems(self, node: nodes.Item | nodes.Collector) -> Iterator[nodes.Item]:
  123:         self.trace("genitems", node)
  123:         if isinstance(node, nodes.Item):
   89:             node.ihook.pytest_itemcollected(item=node)
   89:             yield node
               else:
   34:             assert isinstance(node, nodes.Collector)
                   # For backward compat, dedup only applies to files.
   34:             handle_dupes = not isinstance(node, nodes.File)
   34:             rep, duplicate = self._collect_one_node(node, handle_dupes)
   34:             if rep.passed:
  156:                 for subnode in rep.result:
  122:                     yield from self.genitems(subnode)
   34:             if not duplicate:
   34:                 node.ihook.pytest_collectreport(report=rep)
       
       
>>>>>> def search_pypath(
>>>>>>     module_name: str, *, consider_namespace_packages: bool = False
>>>>>> ) -> str | None:
           """Search sys.path for the given a dotted module name, and return its file
           system path if found."""
>>>>>>     try:
>>>>>>         spec = importlib.util.find_spec(module_name)
           # AttributeError: looks like package module, but actually filename
           # ImportError: module does not exist
           # ValueError: not a module name
>>>>>>     except (AttributeError, ImportError, ValueError):
>>>>>>         return None
       
>>>>>>     if spec is None:
>>>>>>         return None
       
           if (
>>>>>>         spec.submodule_search_locations is None
>>>>>>         or len(spec.submodule_search_locations) == 0
           ):
               # Must be a simple module.
>>>>>>         return spec.origin
       
>>>>>>     if consider_namespace_packages:
               # If submodule_search_locations is set, it's a package (regular or namespace).
               # Typically there is a single entry, but documentation claims it can be empty too
               #  (e.g. if the package has no physical location).
>>>>>>         return spec.submodule_search_locations[0]
       
>>>>>>     if spec.origin is None:
               # This is only the case for namespace packages
>>>>>>         return None
       
>>>>>>     return os.path.dirname(spec.origin)
       
       
>>>>>> @dataclasses.dataclass(frozen=True)
>>>>>> class CollectionArgument:
           """A resolved collection argument."""
       
>>>>>>     path: Path
>>>>>>     parts: Sequence[str]
>>>>>>     parametrization: str | None
>>>>>>     module_name: str | None
>>>>>>     original_index: int
       
       
>>>>>> def resolve_collection_argument(
>>>>>>     invocation_path: Path,
>>>>>>     arg: str,
>>>>>>     arg_index: int,
           *,
>>>>>>     as_pypath: bool = False,
>>>>>>     consider_namespace_packages: bool = False,
>>>>>> ) -> CollectionArgument:
           """Parse path arguments optionally containing selection parts and return (fspath, names).
       
           Command-line arguments can point to files and/or directories, and optionally contain
           parts for specific tests selection, for example:
       
               "pkg/tests/test_foo.py::TestClass::test_foo"
       
           This function ensures the path exists, and returns a resolved `CollectionArgument`:
       
               CollectionArgument(
                   path=Path("/full/path/to/pkg/tests/test_foo.py"),
                   parts=["TestClass", "test_foo"],
                   module_name=None,
               )
       
           When as_pypath is True, expects that the command-line argument actually contains
           module paths instead of file-system paths:
       
               "pkg.tests.test_foo::TestClass::test_foo[a,b]"
       
           In which case we search sys.path for a matching module, and then return the *path* to the
           found module, which may look like this:
       
               CollectionArgument(
                   path=Path("/home/u/myvenv/lib/site-packages/pkg/tests/test_foo.py"),
                   parts=["TestClass", "test_foo"],
                   parametrization="[a,b]",
                   module_name="pkg.tests.test_foo",
               )
       
           If the path doesn't exist, raise UsageError.
           If the path is a directory and selection parts are present, raise UsageError.
           """
    1:     base, squacket, rest = arg.partition("[")
    1:     strpath, *parts = base.split("::")
    1:     if squacket and not parts:
>>>>>>         raise UsageError(f"path cannot contain [] parametrization: {arg}")
    1:     parametrization = f"{squacket}{rest}" if squacket else None
    1:     module_name = None
    1:     if as_pypath:
>>>>>>         pyarg_strpath = search_pypath(
>>>>>>             strpath, consider_namespace_packages=consider_namespace_packages
               )
>>>>>>         if pyarg_strpath is not None:
>>>>>>             module_name = strpath
>>>>>>             strpath = pyarg_strpath
    1:     fspath = invocation_path / strpath
    1:     fspath = absolutepath(fspath)
    1:     if not safe_exists(fspath):
>>>>>>         msg = (
>>>>>>             "module or package not found: {arg} (missing __init__.py?)"
>>>>>>             if as_pypath
>>>>>>             else "file or directory not found: {arg}"
               )
>>>>>>         raise UsageError(msg.format(arg=arg))
    1:     if parts and fspath.is_dir():
>>>>>>         msg = (
>>>>>>             "package argument cannot contain :: selection parts: {arg}"
>>>>>>             if as_pypath
>>>>>>             else "directory argument cannot contain :: selection parts: {arg}"
               )
>>>>>>         raise UsageError(msg.format(arg=arg))
    2:     return CollectionArgument(
    1:         path=fspath,
    1:         parts=parts,
    1:         parametrization=parametrization,
    1:         module_name=module_name,
    1:         original_index=arg_index,
           )
       
       
>>>>>> def is_collection_argument_subsumed_by(
>>>>>>     arg: CollectionArgument, by: CollectionArgument
>>>>>> ) -> bool:
           """Check if `arg` is subsumed (contained) by `by`."""
           # First check path subsumption.
>>>>>>     if by.path != arg.path:
               # `by` subsumes `arg` if `by` is a parent directory of `arg` and has no
               # parts (collects everything in that directory).
>>>>>>         if not by.parts:
>>>>>>             return arg.path.is_relative_to(by.path)
>>>>>>         return False
           # Paths are equal, check parts.
           # For example: ("TestClass",) is a prefix of ("TestClass", "test_method").
>>>>>>     if len(by.parts) > len(arg.parts) or arg.parts[: len(by.parts)] != by.parts:
>>>>>>         return False
           # Paths and parts are equal, check parametrization.
           # A `by` without parametrization (None) matches everything, e.g.
           # `pytest x.py::test_it` matches `x.py::test_it[0]`. Otherwise must be
           # exactly equal.
>>>>>>     if by.parametrization is not None and by.parametrization != arg.parametrization:
>>>>>>         return False
>>>>>>     return True
       
       
>>>>>> def normalize_collection_arguments(
>>>>>>     collection_args: Sequence[CollectionArgument],
>>>>>> ) -> list[CollectionArgument]:
           """Normalize collection arguments to eliminate overlapping paths and parts.
       
           Detects when collection arguments overlap in either paths or parts and only
           keeps the shorter prefix, or the earliest argument if duplicate, preserving
           order. The result is prefix-free.
           """
           # A quadratic algorithm is not acceptable since large inputs are possible.
           # So this uses an O(n*log(n)) algorithm which takes advantage of the
           # property that after sorting, a collection argument will immediately
           # precede collection arguments it subsumes. An O(n) algorithm is not worth
           # it.
    2:     collection_args_sorted = sorted(
    1:         collection_args,
    2:         key=lambda arg: (arg.path, arg.parts, arg.parametrization or ""),
           )
    1:     normalized: list[CollectionArgument] = []
    1:     last_kept = None
    2:     for arg in collection_args_sorted:
    1:         if last_kept is None or not is_collection_argument_subsumed_by(arg, last_kept):
    1:             normalized.append(arg)
    1:             last_kept = arg
    2:     normalized.sort(key=lambda arg: arg.original_index)
    1:     return normalized
